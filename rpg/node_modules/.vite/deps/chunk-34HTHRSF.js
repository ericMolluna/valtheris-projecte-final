import {
  axios_default
} from "./chunk-JLYFZH6S.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-2GTGKKMZ.js";

// node_modules/sat/SAT.js
var require_SAT = __commonJS({
  "node_modules/sat/SAT.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof define === "function" && define["amd"]) {
        define(factory);
      } else if (typeof exports === "object") {
        module["exports"] = factory();
      } else {
        root["SAT"] = factory();
      }
    })(exports, function() {
      "use strict";
      var SAT3 = {};
      function Vector(x, y) {
        this["x"] = x || 0;
        this["y"] = y || 0;
      }
      SAT3["Vector"] = Vector;
      SAT3["V"] = Vector;
      Vector.prototype["copy"] = Vector.prototype.copy = function(other) {
        this["x"] = other["x"];
        this["y"] = other["y"];
        return this;
      };
      Vector.prototype["clone"] = Vector.prototype.clone = function() {
        return new Vector(this["x"], this["y"]);
      };
      Vector.prototype["perp"] = Vector.prototype.perp = function() {
        var x = this["x"];
        this["x"] = this["y"];
        this["y"] = -x;
        return this;
      };
      Vector.prototype["rotate"] = Vector.prototype.rotate = function(angle) {
        var x = this["x"];
        var y = this["y"];
        this["x"] = x * Math.cos(angle) - y * Math.sin(angle);
        this["y"] = x * Math.sin(angle) + y * Math.cos(angle);
        return this;
      };
      Vector.prototype["reverse"] = Vector.prototype.reverse = function() {
        this["x"] = -this["x"];
        this["y"] = -this["y"];
        return this;
      };
      Vector.prototype["normalize"] = Vector.prototype.normalize = function() {
        var d = this.len();
        if (d > 0) {
          this["x"] = this["x"] / d;
          this["y"] = this["y"] / d;
        }
        return this;
      };
      Vector.prototype["add"] = Vector.prototype.add = function(other) {
        this["x"] += other["x"];
        this["y"] += other["y"];
        return this;
      };
      Vector.prototype["sub"] = Vector.prototype.sub = function(other) {
        this["x"] -= other["x"];
        this["y"] -= other["y"];
        return this;
      };
      Vector.prototype["scale"] = Vector.prototype.scale = function(x, y) {
        this["x"] *= x;
        this["y"] *= typeof y != "undefined" ? y : x;
        return this;
      };
      Vector.prototype["project"] = Vector.prototype.project = function(other) {
        var amt = this.dot(other) / other.len2();
        this["x"] = amt * other["x"];
        this["y"] = amt * other["y"];
        return this;
      };
      Vector.prototype["projectN"] = Vector.prototype.projectN = function(other) {
        var amt = this.dot(other);
        this["x"] = amt * other["x"];
        this["y"] = amt * other["y"];
        return this;
      };
      Vector.prototype["reflect"] = Vector.prototype.reflect = function(axis) {
        var x = this["x"];
        var y = this["y"];
        this.project(axis).scale(2);
        this["x"] -= x;
        this["y"] -= y;
        return this;
      };
      Vector.prototype["reflectN"] = Vector.prototype.reflectN = function(axis) {
        var x = this["x"];
        var y = this["y"];
        this.projectN(axis).scale(2);
        this["x"] -= x;
        this["y"] -= y;
        return this;
      };
      Vector.prototype["dot"] = Vector.prototype.dot = function(other) {
        return this["x"] * other["x"] + this["y"] * other["y"];
      };
      Vector.prototype["len2"] = Vector.prototype.len2 = function() {
        return this.dot(this);
      };
      Vector.prototype["len"] = Vector.prototype.len = function() {
        return Math.sqrt(this.len2());
      };
      function Circle(pos, r) {
        this["pos"] = pos || new Vector();
        this["r"] = r || 0;
        this["offset"] = new Vector();
      }
      SAT3["Circle"] = Circle;
      Circle.prototype["getAABBAsBox"] = Circle.prototype.getAABBAsBox = function() {
        var r = this["r"];
        var corner = this["pos"].clone().add(this["offset"]).sub(new Vector(r, r));
        return new Box(corner, r * 2, r * 2);
      };
      Circle.prototype["getAABB"] = Circle.prototype.getAABB = function() {
        return this.getAABBAsBox().toPolygon();
      };
      Circle.prototype["setOffset"] = Circle.prototype.setOffset = function(offset) {
        this["offset"] = offset;
        return this;
      };
      function Polygon(pos, points) {
        this["pos"] = pos || new Vector();
        this["angle"] = 0;
        this["offset"] = new Vector();
        this.setPoints(points || []);
      }
      SAT3["Polygon"] = Polygon;
      Polygon.prototype["setPoints"] = Polygon.prototype.setPoints = function(points) {
        var lengthChanged = !this["points"] || this["points"].length !== points.length;
        if (lengthChanged) {
          var i2;
          var calcPoints = this["calcPoints"] = [];
          var edges = this["edges"] = [];
          var normals = this["normals"] = [];
          for (i2 = 0; i2 < points.length; i2++) {
            var p1 = points[i2];
            var p2 = i2 < points.length - 1 ? points[i2 + 1] : points[0];
            if (p1 !== p2 && p1.x === p2.x && p1.y === p2.y) {
              points.splice(i2, 1);
              i2 -= 1;
              continue;
            }
            calcPoints.push(new Vector());
            edges.push(new Vector());
            normals.push(new Vector());
          }
        }
        this["points"] = points;
        this._recalc();
        return this;
      };
      Polygon.prototype["setAngle"] = Polygon.prototype.setAngle = function(angle) {
        this["angle"] = angle;
        this._recalc();
        return this;
      };
      Polygon.prototype["setOffset"] = Polygon.prototype.setOffset = function(offset) {
        this["offset"] = offset;
        this._recalc();
        return this;
      };
      Polygon.prototype["rotate"] = Polygon.prototype.rotate = function(angle) {
        var points = this["points"];
        var len = points.length;
        for (var i2 = 0; i2 < len; i2++) {
          points[i2].rotate(angle);
        }
        this._recalc();
        return this;
      };
      Polygon.prototype["translate"] = Polygon.prototype.translate = function(x, y) {
        var points = this["points"];
        var len = points.length;
        for (var i2 = 0; i2 < len; i2++) {
          points[i2]["x"] += x;
          points[i2]["y"] += y;
        }
        this._recalc();
        return this;
      };
      Polygon.prototype._recalc = function() {
        var calcPoints = this["calcPoints"];
        var edges = this["edges"];
        var normals = this["normals"];
        var points = this["points"];
        var offset = this["offset"];
        var angle = this["angle"];
        var len = points.length;
        var i2;
        for (i2 = 0; i2 < len; i2++) {
          var calcPoint = calcPoints[i2].copy(points[i2]);
          calcPoint["x"] += offset["x"];
          calcPoint["y"] += offset["y"];
          if (angle !== 0) {
            calcPoint.rotate(angle);
          }
        }
        for (i2 = 0; i2 < len; i2++) {
          var p1 = calcPoints[i2];
          var p2 = i2 < len - 1 ? calcPoints[i2 + 1] : calcPoints[0];
          var e = edges[i2].copy(p2).sub(p1);
          normals[i2].copy(e).perp().normalize();
        }
        return this;
      };
      Polygon.prototype["getAABBAsBox"] = Polygon.prototype.getAABBAsBox = function() {
        var points = this["calcPoints"];
        var len = points.length;
        var xMin = points[0]["x"];
        var yMin = points[0]["y"];
        var xMax = points[0]["x"];
        var yMax = points[0]["y"];
        for (var i2 = 1; i2 < len; i2++) {
          var point = points[i2];
          if (point["x"] < xMin) {
            xMin = point["x"];
          } else if (point["x"] > xMax) {
            xMax = point["x"];
          }
          if (point["y"] < yMin) {
            yMin = point["y"];
          } else if (point["y"] > yMax) {
            yMax = point["y"];
          }
        }
        return new Box(this["pos"].clone().add(new Vector(xMin, yMin)), xMax - xMin, yMax - yMin);
      };
      Polygon.prototype["getAABB"] = Polygon.prototype.getAABB = function() {
        return this.getAABBAsBox().toPolygon();
      };
      Polygon.prototype["getCentroid"] = Polygon.prototype.getCentroid = function() {
        var points = this["calcPoints"];
        var len = points.length;
        var cx = 0;
        var cy = 0;
        var ar = 0;
        for (var i2 = 0; i2 < len; i2++) {
          var p1 = points[i2];
          var p2 = i2 === len - 1 ? points[0] : points[i2 + 1];
          var a = p1["x"] * p2["y"] - p2["x"] * p1["y"];
          cx += (p1["x"] + p2["x"]) * a;
          cy += (p1["y"] + p2["y"]) * a;
          ar += a;
        }
        ar = ar * 3;
        cx = cx / ar;
        cy = cy / ar;
        return new Vector(cx, cy);
      };
      function Box(pos, w, h) {
        this["pos"] = pos || new Vector();
        this["w"] = w || 0;
        this["h"] = h || 0;
      }
      SAT3["Box"] = Box;
      Box.prototype["toPolygon"] = Box.prototype.toPolygon = function() {
        var pos = this["pos"];
        var w = this["w"];
        var h = this["h"];
        return new Polygon(new Vector(pos["x"], pos["y"]), [
          new Vector(),
          new Vector(w, 0),
          new Vector(w, h),
          new Vector(0, h)
        ]);
      };
      function Response() {
        this["a"] = null;
        this["b"] = null;
        this["overlapN"] = new Vector();
        this["overlapV"] = new Vector();
        this.clear();
      }
      SAT3["Response"] = Response;
      Response.prototype["clear"] = Response.prototype.clear = function() {
        this["aInB"] = true;
        this["bInA"] = true;
        this["overlap"] = Number.MAX_VALUE;
        return this;
      };
      var T_VECTORS = [];
      for (var i = 0; i < 10; i++) {
        T_VECTORS.push(new Vector());
      }
      var T_ARRAYS = [];
      for (var i = 0; i < 5; i++) {
        T_ARRAYS.push([]);
      }
      var T_RESPONSE = new Response();
      var TEST_POINT = new Box(new Vector(), 1e-6, 1e-6).toPolygon();
      function flattenPointsOn(points, normal, result) {
        var min2 = Number.MAX_VALUE;
        var max2 = -Number.MAX_VALUE;
        var len = points.length;
        for (var i2 = 0; i2 < len; i2++) {
          var dot = points[i2].dot(normal);
          if (dot < min2) {
            min2 = dot;
          }
          if (dot > max2) {
            max2 = dot;
          }
        }
        result[0] = min2;
        result[1] = max2;
      }
      function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {
        var rangeA = T_ARRAYS.pop();
        var rangeB = T_ARRAYS.pop();
        var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);
        var projectedOffset = offsetV.dot(axis);
        flattenPointsOn(aPoints, axis, rangeA);
        flattenPointsOn(bPoints, axis, rangeB);
        rangeB[0] += projectedOffset;
        rangeB[1] += projectedOffset;
        if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {
          T_VECTORS.push(offsetV);
          T_ARRAYS.push(rangeA);
          T_ARRAYS.push(rangeB);
          return true;
        }
        if (response) {
          var overlap = 0;
          if (rangeA[0] < rangeB[0]) {
            response["aInB"] = false;
            if (rangeA[1] < rangeB[1]) {
              overlap = rangeA[1] - rangeB[0];
              response["bInA"] = false;
            } else {
              var option1 = rangeA[1] - rangeB[0];
              var option2 = rangeB[1] - rangeA[0];
              overlap = option1 < option2 ? option1 : -option2;
            }
          } else {
            response["bInA"] = false;
            if (rangeA[1] > rangeB[1]) {
              overlap = rangeA[0] - rangeB[1];
              response["aInB"] = false;
            } else {
              var option1 = rangeA[1] - rangeB[0];
              var option2 = rangeB[1] - rangeA[0];
              overlap = option1 < option2 ? option1 : -option2;
            }
          }
          var absOverlap = Math.abs(overlap);
          if (absOverlap < response["overlap"]) {
            response["overlap"] = absOverlap;
            response["overlapN"].copy(axis);
            if (overlap < 0) {
              response["overlapN"].reverse();
            }
          }
        }
        T_VECTORS.push(offsetV);
        T_ARRAYS.push(rangeA);
        T_ARRAYS.push(rangeB);
        return false;
      }
      SAT3["isSeparatingAxis"] = isSeparatingAxis;
      function voronoiRegion(line, point) {
        var len2 = line.len2();
        var dp = point.dot(line);
        if (dp < 0) {
          return LEFT_VORONOI_REGION;
        } else if (dp > len2) {
          return RIGHT_VORONOI_REGION;
        } else {
          return MIDDLE_VORONOI_REGION;
        }
      }
      var LEFT_VORONOI_REGION = -1;
      var MIDDLE_VORONOI_REGION = 0;
      var RIGHT_VORONOI_REGION = 1;
      function pointInCircle(p, c) {
        var differenceV = T_VECTORS.pop().copy(p).sub(c["pos"]).sub(c["offset"]);
        var radiusSq = c["r"] * c["r"];
        var distanceSq = differenceV.len2();
        T_VECTORS.push(differenceV);
        return distanceSq <= radiusSq;
      }
      SAT3["pointInCircle"] = pointInCircle;
      function pointInPolygon(p, poly) {
        TEST_POINT["pos"].copy(p);
        T_RESPONSE.clear();
        var result = testPolygonPolygon(TEST_POINT, poly, T_RESPONSE);
        if (result) {
          result = T_RESPONSE["aInB"];
        }
        return result;
      }
      SAT3["pointInPolygon"] = pointInPolygon;
      function testCircleCircle(a, b, response) {
        var differenceV = T_VECTORS.pop().copy(b["pos"]).add(b["offset"]).sub(a["pos"]).sub(a["offset"]);
        var totalRadius = a["r"] + b["r"];
        var totalRadiusSq = totalRadius * totalRadius;
        var distanceSq = differenceV.len2();
        if (distanceSq > totalRadiusSq) {
          T_VECTORS.push(differenceV);
          return false;
        }
        if (response) {
          var dist = Math.sqrt(distanceSq);
          response["a"] = a;
          response["b"] = b;
          response["overlap"] = totalRadius - dist;
          response["overlapN"].copy(differenceV.normalize());
          response["overlapV"].copy(differenceV).scale(response["overlap"]);
          response["aInB"] = a["r"] <= b["r"] && dist <= b["r"] - a["r"];
          response["bInA"] = b["r"] <= a["r"] && dist <= a["r"] - b["r"];
        }
        T_VECTORS.push(differenceV);
        return true;
      }
      SAT3["testCircleCircle"] = testCircleCircle;
      function testPolygonCircle(polygon, circle, response) {
        var circlePos = T_VECTORS.pop().copy(circle["pos"]).add(circle["offset"]).sub(polygon["pos"]);
        var radius = circle["r"];
        var radius2 = radius * radius;
        var points = polygon["calcPoints"];
        var len = points.length;
        var edge = T_VECTORS.pop();
        var point = T_VECTORS.pop();
        for (var i2 = 0; i2 < len; i2++) {
          var next = i2 === len - 1 ? 0 : i2 + 1;
          var prev = i2 === 0 ? len - 1 : i2 - 1;
          var overlap = 0;
          var overlapN = null;
          edge.copy(polygon["edges"][i2]);
          point.copy(circlePos).sub(points[i2]);
          if (response && point.len2() > radius2) {
            response["aInB"] = false;
          }
          var region = voronoiRegion(edge, point);
          if (region === LEFT_VORONOI_REGION) {
            edge.copy(polygon["edges"][prev]);
            var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);
            region = voronoiRegion(edge, point2);
            if (region === RIGHT_VORONOI_REGION) {
              var dist = point.len();
              if (dist > radius) {
                T_VECTORS.push(circlePos);
                T_VECTORS.push(edge);
                T_VECTORS.push(point);
                T_VECTORS.push(point2);
                return false;
              } else if (response) {
                response["bInA"] = false;
                overlapN = point.normalize();
                overlap = radius - dist;
              }
            }
            T_VECTORS.push(point2);
          } else if (region === RIGHT_VORONOI_REGION) {
            edge.copy(polygon["edges"][next]);
            point.copy(circlePos).sub(points[next]);
            region = voronoiRegion(edge, point);
            if (region === LEFT_VORONOI_REGION) {
              var dist = point.len();
              if (dist > radius) {
                T_VECTORS.push(circlePos);
                T_VECTORS.push(edge);
                T_VECTORS.push(point);
                return false;
              } else if (response) {
                response["bInA"] = false;
                overlapN = point.normalize();
                overlap = radius - dist;
              }
            }
          } else {
            var normal = edge.perp().normalize();
            var dist = point.dot(normal);
            var distAbs = Math.abs(dist);
            if (dist > 0 && distAbs > radius) {
              T_VECTORS.push(circlePos);
              T_VECTORS.push(normal);
              T_VECTORS.push(point);
              return false;
            } else if (response) {
              overlapN = normal;
              overlap = radius - dist;
              if (dist >= 0 || overlap < 2 * radius) {
                response["bInA"] = false;
              }
            }
          }
          if (overlapN && response && Math.abs(overlap) < Math.abs(response["overlap"])) {
            response["overlap"] = overlap;
            response["overlapN"].copy(overlapN);
          }
        }
        if (response) {
          response["a"] = polygon;
          response["b"] = circle;
          response["overlapV"].copy(response["overlapN"]).scale(response["overlap"]);
        }
        T_VECTORS.push(circlePos);
        T_VECTORS.push(edge);
        T_VECTORS.push(point);
        return true;
      }
      SAT3["testPolygonCircle"] = testPolygonCircle;
      function testCirclePolygon(circle, polygon, response) {
        var result = testPolygonCircle(polygon, circle, response);
        if (result && response) {
          var a = response["a"];
          var aInB = response["aInB"];
          response["overlapN"].reverse();
          response["overlapV"].reverse();
          response["a"] = response["b"];
          response["b"] = a;
          response["aInB"] = response["bInA"];
          response["bInA"] = aInB;
        }
        return result;
      }
      SAT3["testCirclePolygon"] = testCirclePolygon;
      function testPolygonPolygon(a, b, response) {
        var aPoints = a["calcPoints"];
        var aLen = aPoints.length;
        var bPoints = b["calcPoints"];
        var bLen = bPoints.length;
        for (var i2 = 0; i2 < aLen; i2++) {
          if (isSeparatingAxis(a["pos"], b["pos"], aPoints, bPoints, a["normals"][i2], response)) {
            return false;
          }
        }
        for (var i2 = 0; i2 < bLen; i2++) {
          if (isSeparatingAxis(a["pos"], b["pos"], aPoints, bPoints, b["normals"][i2], response)) {
            return false;
          }
        }
        if (response) {
          response["a"] = a;
          response["b"] = b;
          response["overlapV"].copy(response["overlapN"]).scale(response["overlap"]);
        }
        return true;
      }
      SAT3["testPolygonPolygon"] = testPolygonPolygon;
      return SAT3;
    });
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/events.js
function EventHandlers() {
}
function EventEmitter() {
  EventEmitter.init.call(this);
}
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].apply(self, args);
  }
}
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events.newListener) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events = target._events;
    }
    existing = events[type];
  }
  if (!existing) {
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e) {
  typeof console.warn === "function" ? console.warn(e) : console.log(e);
}
function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
function listenerCount(type) {
  var events = this._events;
  if (events) {
    var evlistener = events[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}
function arrayClone(arr, i) {
  var copy2 = new Array(i);
  while (i--)
    copy2[i] = arr[i];
  return copy2;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
var domain, events_default;
var init_events = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/events.js"() {
    "use strict";
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
    events_default = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active && !(this instanceof domain.Domain)) {
          this.domain = domain.active;
        }
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain2;
      var needDomainExit = false;
      var doError = type === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain2 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain2) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain2;
          er.domainThrown = false;
          domain2.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      if (needDomainExit)
        domain2.exit();
      return true;
    };
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners2, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        for (var i = 0, key; i < keys2.length; ++i) {
          key = keys2[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type];
      if (typeof listeners2 === "function") {
        this.removeListener(type, listeners2);
      } else if (listeners2) {
        do {
          this.removeListener(type, listeners2[listeners2.length - 1]);
        } while (listeners2[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/process-es6.js
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout2 = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout2);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop() {
}
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance2) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener2, once2, off, removeListener2, removeAllListeners2, emit2, performance2, performanceNow, startTime, browser$1, process_es6_default;
var init_process_es6 = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/process-es6.js"() {
    cachedSetTimeout = defaultSetTimout;
    cachedClearTimeout = defaultClearTimeout;
    if (typeof global.setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    }
    if (typeof global.clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    }
    queue = [];
    draining = false;
    queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser";
    platform = "browser";
    browser = true;
    env = {};
    argv = [];
    version = "";
    versions = {};
    release = {};
    config = {};
    on = noop;
    addListener2 = noop;
    once2 = noop;
    off = noop;
    removeListener2 = noop;
    removeAllListeners2 = noop;
    emit2 = noop;
    performance2 = global.performance || {};
    performanceNow = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
    startTime = /* @__PURE__ */ new Date();
    browser$1 = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on,
      addListener: addListener2,
      once: once2,
      off,
      removeListener: removeListener2,
      removeAllListeners: removeAllListeners2,
      emit: emit2,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    };
    process_es6_default = browser$1;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
var inherits, inherits_default;
var init_inherits = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
    if (typeof Object.create === "function") {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    inherits_default = inherits;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/util.js
function format(f) {
  if (!isString2(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(" ");
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x2) {
    if (x2 === "%%")
      return "%";
    if (i >= len)
      return x2;
    switch (x2) {
      case "%s":
        return String(args[i++]);
      case "%d":
        return Number(args[i++]);
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject2(x)) {
      str += " " + x;
    } else {
      str += " " + inspect(x);
    }
  }
  return str;
}
function deprecate(fn, msg) {
  if (isUndefined(global.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (process_es6_default.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process_es6_default.throwDeprecation) {
        throw new Error(msg);
      } else if (process_es6_default.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function debuglog(set2) {
  if (isUndefined(debugEnviron))
    debugEnviron = process_es6_default.env.NODE_DEBUG || "";
  set2 = set2.toUpperCase();
  if (!debugs[set2]) {
    if (new RegExp("\\b" + set2 + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set2] = function() {
        var msg = format.apply(null, arguments);
        console.error("%s %d: %s", set2, pid, msg);
      };
    } else {
      debugs[set2] = function() {
      };
    }
  }
  return debugs[set2];
}
function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined(ctx.depth))
    ctx.depth = 2;
  if (isUndefined(ctx.colors))
    ctx.colors = false;
  if (isUndefined(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction2(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString2(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys2.length === 0) {
    if (isFunction2(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray2(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction2(value)) {
    var n = value.name ? ": " + value.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp(value)) {
    base = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base = " " + formatError(value);
  }
  if (keys2.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString2(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        String(i),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf("\n") >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray2(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString2(arg) {
  return typeof arg === "string";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject2(re) && objectToString(re) === "[object RegExp]";
}
function isObject2(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d) {
  return isObject2(d) && objectToString(d) === "[object Date]";
}
function isError(e) {
  return isObject2(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isFunction2(arg) {
  return typeof arg === "function";
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function _extend(origin, add) {
  if (!add || !isObject2(add))
    return origin;
  var keys2 = Object.keys(add);
  var i = keys2.length;
  while (i--) {
    origin[keys2[i]] = add[keys2[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var formatRegExp, debugs, debugEnviron;
var init_util = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/util.js"() {
    init_process_es6();
    init_inherits();
    formatRegExp = /%[sdj%]/g;
    debugs = {};
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/buffer-es6.js
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer3, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer3[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer3[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer3[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer3, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer3[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer3[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer3[offset + i - d] |= s * 128;
}
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill2, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill2 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
  }
  return createBuffer(that, size);
}
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray3(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length | 0;
}
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
function bidirectionalIndexOf(buffer3, val, byteOffset, encoding, dir) {
  if (buffer3.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer3.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer3.length + byteOffset;
  if (byteOffset >= buffer3.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer3.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer3, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer3, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer3, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer3, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max2, min2) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max2 || value < min2)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
function checkIEEE754(buf, value, offset, ext, max2, min2) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var lookup, revLookup, Arr, inited, toString, isArray3, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
var init_buffer_es6 = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/buffer-es6.js"() {
    lookup = [];
    revLookup = [];
    Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited = false;
    toString = {}.toString;
    isArray3 = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
    INSPECT_MAX_BYTES = 50;
    Buffer2.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== void 0 ? global.TYPED_ARRAY_SUPPORT : true;
    _kMaxLength = kMaxLength();
    Buffer2.poolSize = 8192;
    Buffer2._augment = function(arr) {
      arr.__proto__ = Buffer2.prototype;
      return arr;
    };
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      Buffer2.prototype.__proto__ = Uint8Array.prototype;
      Buffer2.__proto__ = Uint8Array;
    }
    Buffer2.alloc = function(size, fill2, encoding) {
      return alloc(null, size, fill2, encoding);
    };
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.isBuffer = isBuffer;
    Buffer2.compare = function compare(a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!isArray3(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer3 = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer3, pos);
        pos += buf.length;
      }
      return buffer3;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = true;
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.equals = function equals(b) {
      if (!internalIsBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect2() {
      var str = "";
      var max2 = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
        if (this.length > max2)
          str += " ... ";
      }
      return "<Buffer " + str + ">";
    };
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    Buffer2.prototype.write = function write2(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
            return asciiWrite(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH = 4096;
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer2.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }
      return newBuf;
    };
    Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8);
    };
    Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i;
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
var buffer_list_default;
var init_buffer_list = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
    init_buffer_es6();
    buffer_list_default = BufferList;
    BufferList.prototype.push = function(v) {
      var entry = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function(v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/string-decoder.js
var string_decoder_exports = {};
__export(string_decoder_exports, {
  StringDecoder: () => StringDecoder
});
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
function passThroughWrite(buffer3) {
  return buffer3.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer3) {
  this.charReceived = buffer3.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer3) {
  this.charReceived = buffer3.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var isBufferEncoding;
var init_string_decoder = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/string-decoder.js"() {
    init_buffer_es6();
    isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    StringDecoder.prototype.write = function(buffer3) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer3.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer3.length;
        buffer3.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer3 = buffer3.slice(available, buffer3.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer3.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer3);
      var end = buffer3.length;
      if (this.charLength) {
        buffer3.copy(this.charBuffer, 0, buffer3.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer3.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer3.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer3) {
      var i = buffer3.length >= 3 ? 3 : buffer3.length;
      for (; i > 0; i--) {
        var c = buffer3[buffer3.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer3) {
      var res = "";
      if (buffer3 && buffer3.length)
        res = this.write(buffer3);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount2(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options, stream) {
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new buffer_list_default();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);
  this._readableState = new ReadableState(options, this);
  this.readable = true;
  if (options && typeof options.read === "function")
    this._read = options.read;
  events_default.call(this);
}
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit("error", er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error("stream.push() after EOF");
      stream.emit("error", e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream.emit("error", _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront)
        state.reading = false;
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
      }
      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended)
    return 0;
  if (state.objectMode)
    return 1;
  if (n !== n) {
    if (state.flowing && state.length)
      return state.buffer.head.data.length;
    else
      return state.length;
  }
  if (n > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length)
    return n;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}
function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream, state) {
  if (state.ended)
    return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  emitReadable(stream);
}
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      nextTick(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}
function emitReadable_(stream) {
  debug("emit readable");
  stream.emit("readable");
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length)
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners("data").length) {
      state.flowing = true;
      flow(src);
    }
  };
}
function nReadingNextTick(self) {
  debug("readable nexttick read 0");
  self.read(0);
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  if (!state.reading) {
    debug("resume read 0");
    stream.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}
function flow(stream) {
  var state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null) {
  }
}
function fromList(n, state) {
  if (state.length === 0)
    return null;
  var ret;
  if (state.objectMode)
    ret = state.buffer.shift();
  else if (!n || n >= state.length) {
    if (state.decoder)
      ret = state.buffer.join("");
    else if (state.buffer.length === 1)
      ret = state.buffer.head.data;
    else
      ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
}
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length)
      ret += str;
    else
      ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit("end");
  }
}
function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
function indexOf2(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x)
      return i;
  }
  return -1;
}
var debug, MAX_HWM;
var init_readable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
    "use strict";
    init_events();
    init_util();
    init_buffer_list();
    init_string_decoder();
    init_duplex();
    init_process_es6();
    Readable.ReadableState = ReadableState;
    debug = debuglog("stream");
    inherits_default(Readable, events_default);
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (!state.objectMode && typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    MAX_HWM = 8388608;
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== false;
      var endFn = doEnd ? onend2 : cleanup;
      if (state.endEmitted)
        nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend2() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (listenerCount2(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit("unpipe", this);
        }
        return this;
      }
      var i = indexOf2(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = events_default.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
        self.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
      self._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self;
    };
    Readable._fromList = fromList;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options, stream) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
function Writable(options) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);
  this._writableState = new WritableState(options, this);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function")
      this._write = options.write;
    if (typeof options.writev === "function")
      this._writev = options.writev;
  }
  EventEmitter.call(this);
}
function writeAfterEnd(stream, cb) {
  var er = new Error("write after end");
  stream.emit("error", er);
  nextTick(cb, er);
}
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream.emit("error", er);
    nextTick(cb, er);
    valid = false;
  }
  return valid;
}
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer2.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer2.isBuffer(chunk))
    encoding = "buffer";
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (!ret)
    state.needDrain = true;
  if (state.writing || state.corked) {
    var last3 = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last3) {
      last3.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    nextTick(cb, er);
  else
    cb(er);
  stream._writableState.errorEmitted = true;
  stream.emit("error", er);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
}
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    var l = state.bufferedRequestCount;
    var buffer3 = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count2 = 0;
    while (entry) {
      buffer3[count2] = entry;
      entry = entry.next;
      count2 += 1;
    }
    doWrite(stream, state, true, state.length, buffer3, "", holder.finish);
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      if (state.writing) {
        break;
      }
    }
    if (entry === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit("prefinish");
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit("finish");
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      nextTick(cb);
    else
      stream.once("finish", cb);
  }
  state.ended = true;
  stream.writable = false;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
var init_writable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
    init_util();
    init_buffer_es6();
    init_events();
    init_duplex();
    init_process_es6();
    Writable.WritableState = WritableState;
    inherits_default(Writable, EventEmitter);
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false)
    this.readable = false;
  if (options && options.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
var keys, method, v;
var init_duplex = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
    init_util();
    init_process_es6();
    init_readable();
    init_writable();
    inherits_default(Duplex, Readable);
    keys = Object.keys(Writable.prototype);
    for (v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb)
    return stream.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data !== null && data !== void 0)
    stream.push(data);
  cb(er);
  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  var stream = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function")
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}
function done(stream, er) {
  if (er)
    return stream.emit("error", er);
  var ws = stream._writableState;
  var ts = stream._transformState;
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream.push(null);
}
var init_transform = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
    init_duplex();
    init_util();
    inherits_default(Transform, Duplex);
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("Not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform.call(this, options);
}
var init_passthrough = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
    init_transform();
    init_util();
    inherits_default(PassThrough, Transform);
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/stream.js
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform,
  Writable: () => Writable,
  default: () => stream_default
});
function Stream() {
  events_default.call(this);
}
var stream_default;
var init_stream = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/stream.js"() {
    init_events();
    init_util();
    init_duplex();
    init_readable();
    init_writable();
    init_transform();
    init_passthrough();
    inherits_default(Stream, events_default);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    stream_default = Stream;
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend2);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend2() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (events_default.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend2);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/sax/lib/sax.js"(exports) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit3(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o)
            if (o.hasOwnProperty(i))
              a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write: write3,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream2;
      try {
        Stream2 = (init_stream(), __toCommonJS(stream_exports)).Stream;
      } catch (ex) {
        Stream2 = function() {
        };
      }
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream2.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream2.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = (init_string_decoder(), __toCommonJS(string_decoder_exports)).StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream2.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s2;
      });
      for (var s in sax.STATE) {
        sax.STATE[sax.STATE[s]] = s;
      }
      S = sax.STATE;
      function emit3(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode)
          closeText(parser);
        emit3(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
          emit3(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim)
          text = text.trim();
        if (opt.normalize)
          text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit3(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit3(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict)
          parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0)
          parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write3(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) {
              } else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") {
                parser.state = S.DOCTYPE;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer3;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer3 = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer3 = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer3 = "attribValue";
                  break;
              }
              if (c === ";") {
                parser[buffer3] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer3] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(typeof exports === "undefined" ? exports.sax = {} : exports);
  }
});

// node_modules/xml-js/lib/array-helper.js
var require_array_helper = __commonJS({
  "node_modules/xml-js/lib/array-helper.js"(exports, module) {
    module.exports = {
      isArray: function(value) {
        if (Array.isArray) {
          return Array.isArray(value);
        }
        return Object.prototype.toString.call(value) === "[object Array]";
      }
    };
  }
});

// node_modules/xml-js/lib/options-helper.js
var require_options_helper = __commonJS({
  "node_modules/xml-js/lib/options-helper.js"(exports, module) {
    var isArray7 = require_array_helper().isArray;
    module.exports = {
      copyOptions: function(options) {
        var key, copy2 = {};
        for (key in options) {
          if (options.hasOwnProperty(key)) {
            copy2[key] = options[key];
          }
        }
        return copy2;
      },
      ensureFlagExists: function(item, options) {
        if (!(item in options) || typeof options[item] !== "boolean") {
          options[item] = false;
        }
      },
      ensureSpacesExists: function(options) {
        if (!("spaces" in options) || typeof options.spaces !== "number" && typeof options.spaces !== "string") {
          options.spaces = 0;
        }
      },
      ensureAlwaysArrayExists: function(options) {
        if (!("alwaysArray" in options) || typeof options.alwaysArray !== "boolean" && !isArray7(options.alwaysArray)) {
          options.alwaysArray = false;
        }
      },
      ensureKeyExists: function(key, options) {
        if (!(key + "Key" in options) || typeof options[key + "Key"] !== "string") {
          options[key + "Key"] = options.compact ? "_" + key : key;
        }
      },
      checkFnExists: function(key, options) {
        return key + "Fn" in options;
      }
    };
  }
});

// node_modules/xml-js/lib/xml2js.js
var require_xml2js = __commonJS({
  "node_modules/xml-js/lib/xml2js.js"(exports, module) {
    var sax = require_sax();
    var expat = { on: function() {
    }, parse: function() {
    } };
    var helper = require_options_helper();
    var isArray7 = require_array_helper().isArray;
    var options;
    var pureJsParser = true;
    var currentElement;
    function validateOptions(userOptions) {
      options = helper.copyOptions(userOptions);
      helper.ensureFlagExists("ignoreDeclaration", options);
      helper.ensureFlagExists("ignoreInstruction", options);
      helper.ensureFlagExists("ignoreAttributes", options);
      helper.ensureFlagExists("ignoreText", options);
      helper.ensureFlagExists("ignoreComment", options);
      helper.ensureFlagExists("ignoreCdata", options);
      helper.ensureFlagExists("ignoreDoctype", options);
      helper.ensureFlagExists("compact", options);
      helper.ensureFlagExists("alwaysChildren", options);
      helper.ensureFlagExists("addParent", options);
      helper.ensureFlagExists("trim", options);
      helper.ensureFlagExists("nativeType", options);
      helper.ensureFlagExists("nativeTypeAttributes", options);
      helper.ensureFlagExists("sanitize", options);
      helper.ensureFlagExists("instructionHasAttributes", options);
      helper.ensureFlagExists("captureSpacesBetweenElements", options);
      helper.ensureAlwaysArrayExists(options);
      helper.ensureKeyExists("declaration", options);
      helper.ensureKeyExists("instruction", options);
      helper.ensureKeyExists("attributes", options);
      helper.ensureKeyExists("text", options);
      helper.ensureKeyExists("comment", options);
      helper.ensureKeyExists("cdata", options);
      helper.ensureKeyExists("doctype", options);
      helper.ensureKeyExists("type", options);
      helper.ensureKeyExists("name", options);
      helper.ensureKeyExists("elements", options);
      helper.ensureKeyExists("parent", options);
      helper.checkFnExists("doctype", options);
      helper.checkFnExists("instruction", options);
      helper.checkFnExists("cdata", options);
      helper.checkFnExists("comment", options);
      helper.checkFnExists("text", options);
      helper.checkFnExists("instructionName", options);
      helper.checkFnExists("elementName", options);
      helper.checkFnExists("attributeName", options);
      helper.checkFnExists("attributeValue", options);
      helper.checkFnExists("attributes", options);
      return options;
    }
    function nativeType(value) {
      var nValue = Number(value);
      if (!isNaN(nValue)) {
        return nValue;
      }
      var bValue = value.toLowerCase();
      if (bValue === "true") {
        return true;
      } else if (bValue === "false") {
        return false;
      }
      return value;
    }
    function addField(type, value) {
      var key;
      if (options.compact) {
        if (!currentElement[options[type + "Key"]] && (isArray7(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + "Key"]) !== -1 : options.alwaysArray)) {
          currentElement[options[type + "Key"]] = [];
        }
        if (currentElement[options[type + "Key"]] && !isArray7(currentElement[options[type + "Key"]])) {
          currentElement[options[type + "Key"]] = [currentElement[options[type + "Key"]]];
        }
        if (type + "Fn" in options && typeof value === "string") {
          value = options[type + "Fn"](value, currentElement);
        }
        if (type === "instruction" && ("instructionFn" in options || "instructionNameFn" in options)) {
          for (key in value) {
            if (value.hasOwnProperty(key)) {
              if ("instructionFn" in options) {
                value[key] = options.instructionFn(value[key], key, currentElement);
              } else {
                var temp = value[key];
                delete value[key];
                value[options.instructionNameFn(key, temp, currentElement)] = temp;
              }
            }
          }
        }
        if (isArray7(currentElement[options[type + "Key"]])) {
          currentElement[options[type + "Key"]].push(value);
        } else {
          currentElement[options[type + "Key"]] = value;
        }
      } else {
        if (!currentElement[options.elementsKey]) {
          currentElement[options.elementsKey] = [];
        }
        var element = {};
        element[options.typeKey] = type;
        if (type === "instruction") {
          for (key in value) {
            if (value.hasOwnProperty(key)) {
              break;
            }
          }
          element[options.nameKey] = "instructionNameFn" in options ? options.instructionNameFn(key, value, currentElement) : key;
          if (options.instructionHasAttributes) {
            element[options.attributesKey] = value[key][options.attributesKey];
            if ("instructionFn" in options) {
              element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);
            }
          } else {
            if ("instructionFn" in options) {
              value[key] = options.instructionFn(value[key], key, currentElement);
            }
            element[options.instructionKey] = value[key];
          }
        } else {
          if (type + "Fn" in options) {
            value = options[type + "Fn"](value, currentElement);
          }
          element[options[type + "Key"]] = value;
        }
        if (options.addParent) {
          element[options.parentKey] = currentElement;
        }
        currentElement[options.elementsKey].push(element);
      }
    }
    function manipulateAttributes(attributes) {
      if ("attributesFn" in options && attributes) {
        attributes = options.attributesFn(attributes, currentElement);
      }
      if ((options.trim || "attributeValueFn" in options || "attributeNameFn" in options || options.nativeTypeAttributes) && attributes) {
        var key;
        for (key in attributes) {
          if (attributes.hasOwnProperty(key)) {
            if (options.trim)
              attributes[key] = attributes[key].trim();
            if (options.nativeTypeAttributes) {
              attributes[key] = nativeType(attributes[key]);
            }
            if ("attributeValueFn" in options)
              attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);
            if ("attributeNameFn" in options) {
              var temp = attributes[key];
              delete attributes[key];
              attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;
            }
          }
        }
      }
      return attributes;
    }
    function onInstruction(instruction) {
      var attributes = {};
      if (instruction.body && (instruction.name.toLowerCase() === "xml" || options.instructionHasAttributes)) {
        var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
        var match;
        while ((match = attrsRegExp.exec(instruction.body)) !== null) {
          attributes[match[1]] = match[2] || match[3] || match[4];
        }
        attributes = manipulateAttributes(attributes);
      }
      if (instruction.name.toLowerCase() === "xml") {
        if (options.ignoreDeclaration) {
          return;
        }
        currentElement[options.declarationKey] = {};
        if (Object.keys(attributes).length) {
          currentElement[options.declarationKey][options.attributesKey] = attributes;
        }
        if (options.addParent) {
          currentElement[options.declarationKey][options.parentKey] = currentElement;
        }
      } else {
        if (options.ignoreInstruction) {
          return;
        }
        if (options.trim) {
          instruction.body = instruction.body.trim();
        }
        var value = {};
        if (options.instructionHasAttributes && Object.keys(attributes).length) {
          value[instruction.name] = {};
          value[instruction.name][options.attributesKey] = attributes;
        } else {
          value[instruction.name] = instruction.body;
        }
        addField("instruction", value);
      }
    }
    function onStartElement(name, attributes) {
      var element;
      if (typeof name === "object") {
        attributes = name.attributes;
        name = name.name;
      }
      attributes = manipulateAttributes(attributes);
      if ("elementNameFn" in options) {
        name = options.elementNameFn(name, currentElement);
      }
      if (options.compact) {
        element = {};
        if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
          element[options.attributesKey] = {};
          var key;
          for (key in attributes) {
            if (attributes.hasOwnProperty(key)) {
              element[options.attributesKey][key] = attributes[key];
            }
          }
        }
        if (!(name in currentElement) && (isArray7(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) {
          currentElement[name] = [];
        }
        if (currentElement[name] && !isArray7(currentElement[name])) {
          currentElement[name] = [currentElement[name]];
        }
        if (isArray7(currentElement[name])) {
          currentElement[name].push(element);
        } else {
          currentElement[name] = element;
        }
      } else {
        if (!currentElement[options.elementsKey]) {
          currentElement[options.elementsKey] = [];
        }
        element = {};
        element[options.typeKey] = "element";
        element[options.nameKey] = name;
        if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
          element[options.attributesKey] = attributes;
        }
        if (options.alwaysChildren) {
          element[options.elementsKey] = [];
        }
        currentElement[options.elementsKey].push(element);
      }
      element[options.parentKey] = currentElement;
      currentElement = element;
    }
    function onText(text) {
      if (options.ignoreText) {
        return;
      }
      if (!text.trim() && !options.captureSpacesBetweenElements) {
        return;
      }
      if (options.trim) {
        text = text.trim();
      }
      if (options.nativeType) {
        text = nativeType(text);
      }
      if (options.sanitize) {
        text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
      addField("text", text);
    }
    function onComment(comment) {
      if (options.ignoreComment) {
        return;
      }
      if (options.trim) {
        comment = comment.trim();
      }
      addField("comment", comment);
    }
    function onEndElement(name) {
      var parentElement = currentElement[options.parentKey];
      if (!options.addParent) {
        delete currentElement[options.parentKey];
      }
      currentElement = parentElement;
    }
    function onCdata(cdata) {
      if (options.ignoreCdata) {
        return;
      }
      if (options.trim) {
        cdata = cdata.trim();
      }
      addField("cdata", cdata);
    }
    function onDoctype(doctype) {
      if (options.ignoreDoctype) {
        return;
      }
      doctype = doctype.replace(/^ /, "");
      if (options.trim) {
        doctype = doctype.trim();
      }
      addField("doctype", doctype);
    }
    function onError(error) {
      error.note = error;
    }
    module.exports = function(xml, userOptions) {
      var parser = pureJsParser ? sax.parser(true, {}) : parser = new expat.Parser("UTF-8");
      var result = {};
      currentElement = result;
      options = validateOptions(userOptions);
      if (pureJsParser) {
        parser.opt = { strictEntities: true };
        parser.onopentag = onStartElement;
        parser.ontext = onText;
        parser.oncomment = onComment;
        parser.onclosetag = onEndElement;
        parser.onerror = onError;
        parser.oncdata = onCdata;
        parser.ondoctype = onDoctype;
        parser.onprocessinginstruction = onInstruction;
      } else {
        parser.on("startElement", onStartElement);
        parser.on("text", onText);
        parser.on("comment", onComment);
        parser.on("endElement", onEndElement);
        parser.on("error", onError);
      }
      if (pureJsParser) {
        parser.write(xml).close();
      } else {
        if (!parser.parse(xml)) {
          throw new Error("XML parsing error: " + parser.getError());
        }
      }
      if (result[options.elementsKey]) {
        var temp = result[options.elementsKey];
        delete result[options.elementsKey];
        result[options.elementsKey] = temp;
        delete result.text;
      }
      return result;
    };
  }
});

// node_modules/xml-js/lib/xml2json.js
var require_xml2json = __commonJS({
  "node_modules/xml-js/lib/xml2json.js"(exports, module) {
    var helper = require_options_helper();
    var xml2js2 = require_xml2js();
    function validateOptions(userOptions) {
      var options = helper.copyOptions(userOptions);
      helper.ensureSpacesExists(options);
      return options;
    }
    module.exports = function(xml, userOptions) {
      var options, js, json, parentKey;
      options = validateOptions(userOptions);
      js = xml2js2(xml, options);
      parentKey = "compact" in options && options.compact ? "_parent" : "parent";
      if ("addParent" in options && options.addParent) {
        json = JSON.stringify(js, function(k, v) {
          return k === parentKey ? "_" : v;
        }, options.spaces);
      } else {
        json = JSON.stringify(js, null, options.spaces);
      }
      return json.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    };
  }
});

// node_modules/xml-js/lib/js2xml.js
var require_js2xml = __commonJS({
  "node_modules/xml-js/lib/js2xml.js"(exports, module) {
    var helper = require_options_helper();
    var isArray7 = require_array_helper().isArray;
    var currentElement;
    var currentElementName;
    function validateOptions(userOptions) {
      var options = helper.copyOptions(userOptions);
      helper.ensureFlagExists("ignoreDeclaration", options);
      helper.ensureFlagExists("ignoreInstruction", options);
      helper.ensureFlagExists("ignoreAttributes", options);
      helper.ensureFlagExists("ignoreText", options);
      helper.ensureFlagExists("ignoreComment", options);
      helper.ensureFlagExists("ignoreCdata", options);
      helper.ensureFlagExists("ignoreDoctype", options);
      helper.ensureFlagExists("compact", options);
      helper.ensureFlagExists("indentText", options);
      helper.ensureFlagExists("indentCdata", options);
      helper.ensureFlagExists("indentAttributes", options);
      helper.ensureFlagExists("indentInstruction", options);
      helper.ensureFlagExists("fullTagEmptyElement", options);
      helper.ensureFlagExists("noQuotesForNativeAttributes", options);
      helper.ensureSpacesExists(options);
      if (typeof options.spaces === "number") {
        options.spaces = Array(options.spaces + 1).join(" ");
      }
      helper.ensureKeyExists("declaration", options);
      helper.ensureKeyExists("instruction", options);
      helper.ensureKeyExists("attributes", options);
      helper.ensureKeyExists("text", options);
      helper.ensureKeyExists("comment", options);
      helper.ensureKeyExists("cdata", options);
      helper.ensureKeyExists("doctype", options);
      helper.ensureKeyExists("type", options);
      helper.ensureKeyExists("name", options);
      helper.ensureKeyExists("elements", options);
      helper.checkFnExists("doctype", options);
      helper.checkFnExists("instruction", options);
      helper.checkFnExists("cdata", options);
      helper.checkFnExists("comment", options);
      helper.checkFnExists("text", options);
      helper.checkFnExists("instructionName", options);
      helper.checkFnExists("elementName", options);
      helper.checkFnExists("attributeName", options);
      helper.checkFnExists("attributeValue", options);
      helper.checkFnExists("attributes", options);
      helper.checkFnExists("fullTagEmptyElement", options);
      return options;
    }
    function writeIndentation(options, depth, firstLine) {
      return (!firstLine && options.spaces ? "\n" : "") + Array(depth + 1).join(options.spaces);
    }
    function writeAttributes(attributes, options, depth) {
      if (options.ignoreAttributes) {
        return "";
      }
      if ("attributesFn" in options) {
        attributes = options.attributesFn(attributes, currentElementName, currentElement);
      }
      var key, attr, attrName, quote, result = [];
      for (key in attributes) {
        if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== void 0) {
          quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== "string" ? "" : '"';
          attr = "" + attributes[key];
          attr = attr.replace(/"/g, "&quot;");
          attrName = "attributeNameFn" in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;
          result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, false) : " ");
          result.push(attrName + "=" + quote + ("attributeValueFn" in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
        }
      }
      if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {
        result.push(writeIndentation(options, depth, false));
      }
      return result.join("");
    }
    function writeDeclaration(declaration, options, depth) {
      currentElement = declaration;
      currentElementName = "xml";
      return options.ignoreDeclaration ? "" : "<?xml" + writeAttributes(declaration[options.attributesKey], options, depth) + "?>";
    }
    function writeInstruction(instruction, options, depth) {
      if (options.ignoreInstruction) {
        return "";
      }
      var key;
      for (key in instruction) {
        if (instruction.hasOwnProperty(key)) {
          break;
        }
      }
      var instructionName = "instructionNameFn" in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
      if (typeof instruction[key] === "object") {
        currentElement = instruction;
        currentElementName = instructionName;
        return "<?" + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + "?>";
      } else {
        var instructionValue = instruction[key] ? instruction[key] : "";
        if ("instructionFn" in options)
          instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);
        return "<?" + instructionName + (instructionValue ? " " + instructionValue : "") + "?>";
      }
    }
    function writeComment(comment, options) {
      return options.ignoreComment ? "" : "<!--" + ("commentFn" in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + "-->";
    }
    function writeCdata(cdata, options) {
      return options.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
    }
    function writeDoctype(doctype, options) {
      return options.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + ">";
    }
    function writeText(text, options) {
      if (options.ignoreText)
        return "";
      text = "" + text;
      text = text.replace(/&amp;/g, "&");
      text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      return "textFn" in options ? options.textFn(text, currentElementName, currentElement) : text;
    }
    function hasContent(element, options) {
      var i;
      if (element.elements && element.elements.length) {
        for (i = 0; i < element.elements.length; ++i) {
          switch (element.elements[i][options.typeKey]) {
            case "text":
              if (options.indentText) {
                return true;
              }
              break;
            case "cdata":
              if (options.indentCdata) {
                return true;
              }
              break;
            case "instruction":
              if (options.indentInstruction) {
                return true;
              }
              break;
            case "doctype":
            case "comment":
            case "element":
              return true;
            default:
              return true;
          }
        }
      }
      return false;
    }
    function writeElement(element, options, depth) {
      currentElement = element;
      currentElementName = element.name;
      var xml = [], elementName = "elementNameFn" in options ? options.elementNameFn(element.name, element) : element.name;
      xml.push("<" + elementName);
      if (element[options.attributesKey]) {
        xml.push(writeAttributes(element[options.attributesKey], options, depth));
      }
      var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
      if (!withClosingTag) {
        if ("fullTagEmptyElementFn" in options) {
          withClosingTag = options.fullTagEmptyElementFn(element.name, element);
        } else {
          withClosingTag = options.fullTagEmptyElement;
        }
      }
      if (withClosingTag) {
        xml.push(">");
        if (element[options.elementsKey] && element[options.elementsKey].length) {
          xml.push(writeElements(element[options.elementsKey], options, depth + 1));
          currentElement = element;
          currentElementName = element.name;
        }
        xml.push(options.spaces && hasContent(element, options) ? "\n" + Array(depth + 1).join(options.spaces) : "");
        xml.push("</" + elementName + ">");
      } else {
        xml.push("/>");
      }
      return xml.join("");
    }
    function writeElements(elements, options, depth, firstLine) {
      return elements.reduce(function(xml, element) {
        var indent = writeIndentation(options, depth, firstLine && !xml);
        switch (element.type) {
          case "element":
            return xml + indent + writeElement(element, options, depth);
          case "comment":
            return xml + indent + writeComment(element[options.commentKey], options);
          case "doctype":
            return xml + indent + writeDoctype(element[options.doctypeKey], options);
          case "cdata":
            return xml + (options.indentCdata ? indent : "") + writeCdata(element[options.cdataKey], options);
          case "text":
            return xml + (options.indentText ? indent : "") + writeText(element[options.textKey], options);
          case "instruction":
            var instruction = {};
            instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];
            return xml + (options.indentInstruction ? indent : "") + writeInstruction(instruction, options, depth);
        }
      }, "");
    }
    function hasContentCompact(element, options, anyContent) {
      var key;
      for (key in element) {
        if (element.hasOwnProperty(key)) {
          switch (key) {
            case options.parentKey:
            case options.attributesKey:
              break;
            case options.textKey:
              if (options.indentText || anyContent) {
                return true;
              }
              break;
            case options.cdataKey:
              if (options.indentCdata || anyContent) {
                return true;
              }
              break;
            case options.instructionKey:
              if (options.indentInstruction || anyContent) {
                return true;
              }
              break;
            case options.doctypeKey:
            case options.commentKey:
              return true;
            default:
              return true;
          }
        }
      }
      return false;
    }
    function writeElementCompact(element, name, options, depth, indent) {
      currentElement = element;
      currentElementName = name;
      var elementName = "elementNameFn" in options ? options.elementNameFn(name, element) : name;
      if (typeof element === "undefined" || element === null || element === "") {
        return "fullTagEmptyElementFn" in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? "<" + elementName + "></" + elementName + ">" : "<" + elementName + "/>";
      }
      var xml = [];
      if (name) {
        xml.push("<" + elementName);
        if (typeof element !== "object") {
          xml.push(">" + writeText(element, options) + "</" + elementName + ">");
          return xml.join("");
        }
        if (element[options.attributesKey]) {
          xml.push(writeAttributes(element[options.attributesKey], options, depth));
        }
        var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
        if (!withClosingTag) {
          if ("fullTagEmptyElementFn" in options) {
            withClosingTag = options.fullTagEmptyElementFn(name, element);
          } else {
            withClosingTag = options.fullTagEmptyElement;
          }
        }
        if (withClosingTag) {
          xml.push(">");
        } else {
          xml.push("/>");
          return xml.join("");
        }
      }
      xml.push(writeElementsCompact(element, options, depth + 1, false));
      currentElement = element;
      currentElementName = name;
      if (name) {
        xml.push((indent ? writeIndentation(options, depth, false) : "") + "</" + elementName + ">");
      }
      return xml.join("");
    }
    function writeElementsCompact(element, options, depth, firstLine) {
      var i, key, nodes, xml = [];
      for (key in element) {
        if (element.hasOwnProperty(key)) {
          nodes = isArray7(element[key]) ? element[key] : [element[key]];
          for (i = 0; i < nodes.length; ++i) {
            switch (key) {
              case options.declarationKey:
                xml.push(writeDeclaration(nodes[i], options, depth));
                break;
              case options.instructionKey:
                xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : "") + writeInstruction(nodes[i], options, depth));
                break;
              case options.attributesKey:
              case options.parentKey:
                break;
              case options.textKey:
                xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : "") + writeText(nodes[i], options));
                break;
              case options.cdataKey:
                xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : "") + writeCdata(nodes[i], options));
                break;
              case options.doctypeKey:
                xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options));
                break;
              case options.commentKey:
                xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options));
                break;
              default:
                xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));
            }
            firstLine = firstLine && !xml.length;
          }
        }
      }
      return xml.join("");
    }
    module.exports = function(js, options) {
      options = validateOptions(options);
      var xml = [];
      currentElement = js;
      currentElementName = "_root_";
      if (options.compact) {
        xml.push(writeElementsCompact(js, options, 0, true));
      } else {
        if (js[options.declarationKey]) {
          xml.push(writeDeclaration(js[options.declarationKey], options, 0));
        }
        if (js[options.elementsKey] && js[options.elementsKey].length) {
          xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));
        }
      }
      return xml.join("");
    };
  }
});

// node_modules/xml-js/lib/json2xml.js
var require_json2xml = __commonJS({
  "node_modules/xml-js/lib/json2xml.js"(exports, module) {
    var js2xml = require_js2xml();
    module.exports = function(json, options) {
      if (json instanceof Buffer) {
        json = json.toString();
      }
      var js = null;
      if (typeof json === "string") {
        try {
          js = JSON.parse(json);
        } catch (e) {
          throw new Error("The JSON structure is invalid");
        }
      } else {
        js = json;
      }
      return js2xml(js, options);
    };
  }
});

// node_modules/xml-js/lib/index.js
var require_lib = __commonJS({
  "node_modules/xml-js/lib/index.js"(exports, module) {
    var xml2js2 = require_xml2js();
    var xml2json = require_xml2json();
    var js2xml = require_js2xml();
    var json2xml = require_json2xml();
    module.exports = {
      xml2js: xml2js2,
      xml2json,
      js2xml,
      json2xml
    };
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/msgpack-lite/lib/buffer-global.js
var require_buffer_global = __commonJS({
  "node_modules/msgpack-lite/lib/buffer-global.js"(exports, module) {
    module.exports = c("undefined" !== typeof Buffer && Buffer) || c(exports.Buffer) || c("undefined" !== typeof window && window.Buffer) || exports.Buffer;
    function c(B) {
      return B && B.isBuffer && B;
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports, module) {
    var toString3 = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString3.call(arr) == "[object Array]";
    };
  }
});

// node_modules/msgpack-lite/lib/bufferish-array.js
var require_bufferish_array = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-array.js"(exports, module) {
    var Bufferish = require_bufferish();
    var exports = module.exports = alloc2(0);
    exports.alloc = alloc2;
    exports.concat = Bufferish.concat;
    exports.from = from3;
    function alloc2(size) {
      return new Array(size);
    }
    function from3(value) {
      if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
        value = Bufferish.Uint8Array.from(value);
      } else if (Bufferish.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return Array.prototype.slice.call(value);
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish-buffer.js
var require_bufferish_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-buffer.js"(exports, module) {
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var exports = module.exports = Bufferish.hasBuffer ? alloc2(0) : [];
    exports.alloc = Bufferish.hasBuffer && Buffer3.alloc || alloc2;
    exports.concat = Bufferish.concat;
    exports.from = from3;
    function alloc2(size) {
      return new Buffer3(size);
    }
    function from3(value) {
      if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
        value = Bufferish.Uint8Array.from(value);
      } else if (Bufferish.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (Buffer3.from && Buffer3.from.length !== 1) {
        return Buffer3.from(value);
      } else {
        return new Buffer3(value);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish-uint8array.js
var require_bufferish_uint8array = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-uint8array.js"(exports, module) {
    var Bufferish = require_bufferish();
    var exports = module.exports = Bufferish.hasArrayBuffer ? alloc2(0) : [];
    exports.alloc = alloc2;
    exports.concat = Bufferish.concat;
    exports.from = from3;
    function alloc2(size) {
      return new Uint8Array(size);
    }
    function from3(value) {
      if (Bufferish.isView(value)) {
        var byteOffset = value.byteOffset;
        var byteLength2 = value.byteLength;
        value = value.buffer;
        if (value.byteLength !== byteLength2) {
          if (value.slice) {
            value = value.slice(byteOffset, byteOffset + byteLength2);
          } else {
            value = new Uint8Array(value);
            if (value.byteLength !== byteLength2) {
              value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength2);
            }
          }
        }
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return new Uint8Array(value);
    }
  }
});

// node_modules/msgpack-lite/lib/buffer-lite.js
var require_buffer_lite = __commonJS({
  "node_modules/msgpack-lite/lib/buffer-lite.js"(exports) {
    exports.copy = copy2;
    exports.toString = toString3;
    exports.write = write3;
    function write3(string, offset) {
      var buffer3 = this;
      var index = offset || (offset |= 0);
      var length = string.length;
      var chr = 0;
      var i = 0;
      while (i < length) {
        chr = string.charCodeAt(i++);
        if (chr < 128) {
          buffer3[index++] = chr;
        } else if (chr < 2048) {
          buffer3[index++] = 192 | chr >>> 6;
          buffer3[index++] = 128 | chr & 63;
        } else if (chr < 55296 || chr > 57343) {
          buffer3[index++] = 224 | chr >>> 12;
          buffer3[index++] = 128 | chr >>> 6 & 63;
          buffer3[index++] = 128 | chr & 63;
        } else {
          chr = (chr - 55296 << 10 | string.charCodeAt(i++) - 56320) + 65536;
          buffer3[index++] = 240 | chr >>> 18;
          buffer3[index++] = 128 | chr >>> 12 & 63;
          buffer3[index++] = 128 | chr >>> 6 & 63;
          buffer3[index++] = 128 | chr & 63;
        }
      }
      return index - offset;
    }
    function toString3(encoding, start, end) {
      var buffer3 = this;
      var index = start | 0;
      if (!end)
        end = buffer3.length;
      var string = "";
      var chr = 0;
      while (index < end) {
        chr = buffer3[index++];
        if (chr < 128) {
          string += String.fromCharCode(chr);
          continue;
        }
        if ((chr & 224) === 192) {
          chr = (chr & 31) << 6 | buffer3[index++] & 63;
        } else if ((chr & 240) === 224) {
          chr = (chr & 15) << 12 | (buffer3[index++] & 63) << 6 | buffer3[index++] & 63;
        } else if ((chr & 248) === 240) {
          chr = (chr & 7) << 18 | (buffer3[index++] & 63) << 12 | (buffer3[index++] & 63) << 6 | buffer3[index++] & 63;
        }
        if (chr >= 65536) {
          chr -= 65536;
          string += String.fromCharCode((chr >>> 10) + 55296, (chr & 1023) + 56320);
        } else {
          string += String.fromCharCode(chr);
        }
      }
      return string;
    }
    function copy2(target, targetStart, start, end) {
      var i;
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (!targetStart)
        targetStart = 0;
      var len = end - start;
      if (target === this && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; i--) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        for (i = 0; i < len; i++) {
          target[i + targetStart] = this[i + start];
        }
      }
      return len;
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish-proto.js
var require_bufferish_proto = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-proto.js"(exports) {
    var BufferLite = require_buffer_lite();
    exports.copy = copy2;
    exports.slice = slice2;
    exports.toString = toString3;
    exports.write = gen("write");
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var isBufferShim = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer3;
    var brokenTypedArray = isBufferShim && !Buffer3.TYPED_ARRAY_SUPPORT;
    function copy2(target, targetStart, start, end) {
      var thisIsBuffer = Bufferish.isBuffer(this);
      var targetIsBuffer = Bufferish.isBuffer(target);
      if (thisIsBuffer && targetIsBuffer) {
        return this.copy(target, targetStart, start, end);
      } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer && Bufferish.isView(this) && Bufferish.isView(target)) {
        var buffer3 = start || end != null ? slice2.call(this, start, end) : this;
        target.set(buffer3, targetStart);
        return buffer3.length;
      } else {
        return BufferLite.copy.call(this, target, targetStart, start, end);
      }
    }
    function slice2(start, end) {
      var f = this.slice || !brokenTypedArray && this.subarray;
      if (f)
        return f.call(this, start, end);
      var target = Bufferish.alloc.call(this, end - start);
      copy2.call(this, target, 0, start, end);
      return target;
    }
    function toString3(encoding, start, end) {
      var f = !isBufferShim && Bufferish.isBuffer(this) ? this.toString : BufferLite.toString;
      return f.apply(this, arguments);
    }
    function gen(method) {
      return wrap;
      function wrap() {
        var f = this[method] || BufferLite[method];
        return f.apply(this, arguments);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish.js
var require_bufferish = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish.js"(exports) {
    var Buffer3 = exports.global = require_buffer_global();
    var hasBuffer = exports.hasBuffer = Buffer3 && !!Buffer3.isBuffer;
    var hasArrayBuffer = exports.hasArrayBuffer = "undefined" !== typeof ArrayBuffer;
    var isArray7 = exports.isArray = require_isarray();
    exports.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;
    var isBuffer2 = exports.isBuffer = hasBuffer ? Buffer3.isBuffer : _false;
    var isView = exports.isView = hasArrayBuffer ? ArrayBuffer.isView || _is("ArrayBuffer", "buffer") : _false;
    exports.alloc = alloc2;
    exports.concat = concat4;
    exports.from = from3;
    var BufferArray = exports.Array = require_bufferish_array();
    var BufferBuffer = exports.Buffer = require_bufferish_buffer();
    var BufferUint8Array = exports.Uint8Array = require_bufferish_uint8array();
    var BufferProto = exports.prototype = require_bufferish_proto();
    function from3(value) {
      if (typeof value === "string") {
        return fromString2.call(this, value);
      } else {
        return auto(this).from(value);
      }
    }
    function alloc2(size) {
      return auto(this).alloc(size);
    }
    function concat4(list, length) {
      if (!length) {
        length = 0;
        Array.prototype.forEach.call(list, dryrun);
      }
      var ref = this !== exports && this || list[0];
      var result = alloc2.call(ref, length);
      var offset = 0;
      Array.prototype.forEach.call(list, append);
      return result;
      function dryrun(buffer3) {
        length += buffer3.length;
      }
      function append(buffer3) {
        offset += BufferProto.copy.call(buffer3, result, offset);
      }
    }
    var _isArrayBuffer = _is("ArrayBuffer");
    function isArrayBuffer(value) {
      return value instanceof ArrayBuffer || _isArrayBuffer(value);
    }
    function fromString2(value) {
      var expected = value.length * 3;
      var that = alloc2.call(this, expected);
      var actual = BufferProto.write.call(that, value);
      if (expected !== actual) {
        that = BufferProto.slice.call(that, 0, actual);
      }
      return that;
    }
    function auto(that) {
      return isBuffer2(that) ? BufferBuffer : isView(that) ? BufferUint8Array : isArray7(that) ? BufferArray : hasBuffer ? BufferBuffer : hasArrayBuffer ? BufferUint8Array : BufferArray;
    }
    function _false() {
      return false;
    }
    function _is(name, key) {
      name = "[object " + name + "]";
      return function(value) {
        return value != null && {}.toString.call(key ? value[key] : value) === name;
      };
    }
  }
});

// node_modules/msgpack-lite/lib/ext-buffer.js
var require_ext_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/ext-buffer.js"(exports) {
    exports.ExtBuffer = ExtBuffer;
    var Bufferish = require_bufferish();
    function ExtBuffer(buffer3, type) {
      if (!(this instanceof ExtBuffer))
        return new ExtBuffer(buffer3, type);
      this.buffer = Bufferish.from(buffer3);
      this.type = type;
    }
  }
});

// node_modules/msgpack-lite/lib/ext-packer.js
var require_ext_packer = __commonJS({
  "node_modules/msgpack-lite/lib/ext-packer.js"(exports) {
    exports.setExtPackers = setExtPackers;
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var packTypedArray = Bufferish.Uint8Array.from;
    var _encode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtPackers(codec) {
      codec.addExtPacker(14, Error, [packError, encode]);
      codec.addExtPacker(1, EvalError, [packError, encode]);
      codec.addExtPacker(2, RangeError, [packError, encode]);
      codec.addExtPacker(3, ReferenceError, [packError, encode]);
      codec.addExtPacker(4, SyntaxError, [packError, encode]);
      codec.addExtPacker(5, TypeError, [packError, encode]);
      codec.addExtPacker(6, URIError, [packError, encode]);
      codec.addExtPacker(10, RegExp, [packRegExp, encode]);
      codec.addExtPacker(11, Boolean, [packValueOf, encode]);
      codec.addExtPacker(12, String, [packValueOf, encode]);
      codec.addExtPacker(13, Date, [Number, encode]);
      codec.addExtPacker(15, Number, [packValueOf, encode]);
      if ("undefined" !== typeof Uint8Array) {
        codec.addExtPacker(17, Int8Array, packTypedArray);
        codec.addExtPacker(18, Uint8Array, packTypedArray);
        codec.addExtPacker(19, Int16Array, packTypedArray);
        codec.addExtPacker(20, Uint16Array, packTypedArray);
        codec.addExtPacker(21, Int32Array, packTypedArray);
        codec.addExtPacker(22, Uint32Array, packTypedArray);
        codec.addExtPacker(23, Float32Array, packTypedArray);
        if ("undefined" !== typeof Float64Array) {
          codec.addExtPacker(24, Float64Array, packTypedArray);
        }
        if ("undefined" !== typeof Uint8ClampedArray) {
          codec.addExtPacker(25, Uint8ClampedArray, packTypedArray);
        }
        codec.addExtPacker(26, ArrayBuffer, packTypedArray);
        codec.addExtPacker(29, DataView, packTypedArray);
      }
      if (Bufferish.hasBuffer) {
        codec.addExtPacker(27, Buffer3, Bufferish.from);
      }
    }
    function encode(input) {
      if (!_encode)
        _encode = require_encode().encode;
      return _encode(input);
    }
    function packValueOf(value) {
      return value.valueOf();
    }
    function packRegExp(value) {
      value = RegExp.prototype.toString.call(value).split("/");
      value.shift();
      var out = [value.pop()];
      out.unshift(value.join("/"));
      return out;
    }
    function packError(value) {
      var out = {};
      for (var key in ERROR_COLUMNS) {
        out[key] = value[key];
      }
      return out;
    }
  }
});

// node_modules/int64-buffer/int64-buffer.js
var require_int64_buffer = __commonJS({
  "node_modules/int64-buffer/int64-buffer.js"(exports) {
    var Uint64BE;
    var Int64BE;
    var Uint64LE;
    var Int64LE;
    !function(exports2) {
      var UNDEFINED = "undefined";
      var BUFFER = UNDEFINED !== typeof Buffer && Buffer;
      var UINT8ARRAY = UNDEFINED !== typeof Uint8Array && Uint8Array;
      var ARRAYBUFFER = UNDEFINED !== typeof ArrayBuffer && ArrayBuffer;
      var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
      var isArray7 = Array.isArray || _isArray;
      var BIT32 = 4294967296;
      var BIT24 = 16777216;
      var storage;
      Uint64BE = factory("Uint64BE", true, true);
      Int64BE = factory("Int64BE", true, false);
      Uint64LE = factory("Uint64LE", false, true);
      Int64LE = factory("Int64LE", false, false);
      function factory(name, bigendian, unsigned) {
        var posH = bigendian ? 0 : 4;
        var posL = bigendian ? 4 : 0;
        var pos0 = bigendian ? 0 : 3;
        var pos1 = bigendian ? 1 : 2;
        var pos2 = bigendian ? 2 : 1;
        var pos3 = bigendian ? 3 : 0;
        var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
        var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
        var proto = Int64.prototype;
        var isName = "is" + name;
        var _isInt64 = "_" + isName;
        proto.buffer = void 0;
        proto.offset = 0;
        proto[_isInt64] = true;
        proto.toNumber = toNumber;
        proto.toString = toString3;
        proto.toJSON = toNumber;
        proto.toArray = toArray2;
        if (BUFFER)
          proto.toBuffer = toBuffer;
        if (UINT8ARRAY)
          proto.toArrayBuffer = toArrayBuffer;
        Int64[isName] = isInt64;
        exports2[name] = Int64;
        return Int64;
        function Int64(buffer3, offset, value, raddix) {
          if (!(this instanceof Int64))
            return new Int64(buffer3, offset, value, raddix);
          return init2(this, buffer3, offset, value, raddix);
        }
        function isInt64(b) {
          return !!(b && b[_isInt64]);
        }
        function init2(that, buffer3, offset, value, raddix) {
          if (UINT8ARRAY && ARRAYBUFFER) {
            if (buffer3 instanceof ARRAYBUFFER)
              buffer3 = new UINT8ARRAY(buffer3);
            if (value instanceof ARRAYBUFFER)
              value = new UINT8ARRAY(value);
          }
          if (!buffer3 && !offset && !value && !storage) {
            that.buffer = newArray(ZERO, 0);
            return;
          }
          if (!isValidBuffer(buffer3, offset)) {
            var _storage = storage || Array;
            raddix = offset;
            value = buffer3;
            offset = 0;
            buffer3 = new _storage(8);
          }
          that.buffer = buffer3;
          that.offset = offset |= 0;
          if (UNDEFINED === typeof value)
            return;
          if ("string" === typeof value) {
            fromString2(buffer3, offset, value, raddix || 10);
          } else if (isValidBuffer(value, raddix)) {
            fromArray(buffer3, offset, value, raddix);
          } else if ("number" === typeof raddix) {
            writeInt32(buffer3, offset + posH, value);
            writeInt32(buffer3, offset + posL, raddix);
          } else if (value > 0) {
            fromPositive(buffer3, offset, value);
          } else if (value < 0) {
            fromNegative(buffer3, offset, value);
          } else {
            fromArray(buffer3, offset, ZERO, 0);
          }
        }
        function fromString2(buffer3, offset, str, raddix) {
          var pos = 0;
          var len = str.length;
          var high = 0;
          var low = 0;
          if (str[0] === "-")
            pos++;
          var sign = pos;
          while (pos < len) {
            var chr = parseInt(str[pos++], raddix);
            if (!(chr >= 0))
              break;
            low = low * raddix + chr;
            high = high * raddix + Math.floor(low / BIT32);
            low %= BIT32;
          }
          if (sign) {
            high = ~high;
            if (low) {
              low = BIT32 - low;
            } else {
              high++;
            }
          }
          writeInt32(buffer3, offset + posH, high);
          writeInt32(buffer3, offset + posL, low);
        }
        function toNumber() {
          var buffer3 = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer3, offset + posH);
          var low = readInt32(buffer3, offset + posL);
          if (!unsigned)
            high |= 0;
          return high ? high * BIT32 + low : low;
        }
        function toString3(radix) {
          var buffer3 = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer3, offset + posH);
          var low = readInt32(buffer3, offset + posL);
          var str = "";
          var sign = !unsigned && high & 2147483648;
          if (sign) {
            high = ~high;
            low = BIT32 - low;
          }
          radix = radix || 10;
          while (1) {
            var mod = high % radix * BIT32 + low;
            high = Math.floor(high / radix);
            low = Math.floor(mod / radix);
            str = (mod % radix).toString(radix) + str;
            if (!high && !low)
              break;
          }
          if (sign) {
            str = "-" + str;
          }
          return str;
        }
        function writeInt32(buffer3, offset, value) {
          buffer3[offset + pos3] = value & 255;
          value = value >> 8;
          buffer3[offset + pos2] = value & 255;
          value = value >> 8;
          buffer3[offset + pos1] = value & 255;
          value = value >> 8;
          buffer3[offset + pos0] = value & 255;
        }
        function readInt32(buffer3, offset) {
          return buffer3[offset + pos0] * BIT24 + (buffer3[offset + pos1] << 16) + (buffer3[offset + pos2] << 8) + buffer3[offset + pos3];
        }
      }
      function toArray2(raw) {
        var buffer3 = this.buffer;
        var offset = this.offset;
        storage = null;
        if (raw !== false && offset === 0 && buffer3.length === 8 && isArray7(buffer3))
          return buffer3;
        return newArray(buffer3, offset);
      }
      function toBuffer(raw) {
        var buffer3 = this.buffer;
        var offset = this.offset;
        storage = BUFFER;
        if (raw !== false && offset === 0 && buffer3.length === 8 && Buffer.isBuffer(buffer3))
          return buffer3;
        var dest = new BUFFER(8);
        fromArray(dest, 0, buffer3, offset);
        return dest;
      }
      function toArrayBuffer(raw) {
        var buffer3 = this.buffer;
        var offset = this.offset;
        var arrbuf = buffer3.buffer;
        storage = UINT8ARRAY;
        if (raw !== false && offset === 0 && arrbuf instanceof ARRAYBUFFER && arrbuf.byteLength === 8)
          return arrbuf;
        var dest = new UINT8ARRAY(8);
        fromArray(dest, 0, buffer3, offset);
        return dest.buffer;
      }
      function isValidBuffer(buffer3, offset) {
        var len = buffer3 && buffer3.length;
        offset |= 0;
        return len && offset + 8 <= len && "string" !== typeof buffer3[offset];
      }
      function fromArray(destbuf, destoff, srcbuf, srcoff) {
        destoff |= 0;
        srcoff |= 0;
        for (var i = 0; i < 8; i++) {
          destbuf[destoff++] = srcbuf[srcoff++] & 255;
        }
      }
      function newArray(buffer3, offset) {
        return Array.prototype.slice.call(buffer3, offset, offset + 8);
      }
      function fromPositiveBE(buffer3, offset, value) {
        var pos = offset + 8;
        while (pos > offset) {
          buffer3[--pos] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeBE(buffer3, offset, value) {
        var pos = offset + 8;
        value++;
        while (pos > offset) {
          buffer3[--pos] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function fromPositiveLE(buffer3, offset, value) {
        var end = offset + 8;
        while (offset < end) {
          buffer3[offset++] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeLE(buffer3, offset, value) {
        var end = offset + 8;
        value++;
        while (offset < end) {
          buffer3[offset++] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function _isArray(val) {
        return !!val && "[object Array]" == Object.prototype.toString.call(val);
      }
    }(typeof exports === "object" && typeof exports.nodeName !== "string" ? exports : exports || {});
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer3, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer3[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer3[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer3[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer3, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer3[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer3[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer3[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/msgpack-lite/lib/write-uint8.js
var require_write_uint8 = __commonJS({
  "node_modules/msgpack-lite/lib/write-uint8.js"(exports) {
    var constant = exports.uint8 = new Array(256);
    for (i = 0; i <= 255; i++) {
      constant[i] = write0(i);
    }
    var i;
    function write0(type) {
      return function(encoder) {
        var offset = encoder.reserve(1);
        encoder.buffer[offset] = type;
      };
    }
  }
});

// node_modules/msgpack-lite/lib/write-token.js
var require_write_token = __commonJS({
  "node_modules/msgpack-lite/lib/write-token.js"(exports) {
    var ieee754 = require_ieee754();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    var uint8 = require_write_uint8().uint8;
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var IS_BUFFER_SHIM = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer3;
    var NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer3.TYPED_ARRAY_SUPPORT;
    var Buffer_prototype = Bufferish.hasBuffer && Buffer3.prototype || {};
    exports.getWriteToken = getWriteToken;
    function getWriteToken(options) {
      if (options && options.uint8array) {
        return init_uint8array();
      } else if (NO_TYPED_ARRAY || Bufferish.hasBuffer && options && options.safe) {
        return init_safe();
      } else {
        return init_token();
      }
    }
    function init_uint8array() {
      var token = init_token();
      token[202] = writeN(202, 4, writeFloatBE2);
      token[203] = writeN(203, 8, writeDoubleBE2);
      return token;
    }
    function init_token() {
      var token = uint8.slice();
      token[196] = write1(196);
      token[197] = write22(197);
      token[198] = write4(198);
      token[199] = write1(199);
      token[200] = write22(200);
      token[201] = write4(201);
      token[202] = writeN(202, 4, Buffer_prototype.writeFloatBE || writeFloatBE2, true);
      token[203] = writeN(203, 8, Buffer_prototype.writeDoubleBE || writeDoubleBE2, true);
      token[204] = write1(204);
      token[205] = write22(205);
      token[206] = write4(206);
      token[207] = writeN(207, 8, writeUInt64BE);
      token[208] = write1(208);
      token[209] = write22(209);
      token[210] = write4(210);
      token[211] = writeN(211, 8, writeInt64BE);
      token[217] = write1(217);
      token[218] = write22(218);
      token[219] = write4(219);
      token[220] = write22(220);
      token[221] = write4(221);
      token[222] = write22(222);
      token[223] = write4(223);
      return token;
    }
    function init_safe() {
      var token = uint8.slice();
      token[196] = writeN(196, 1, Buffer3.prototype.writeUInt8);
      token[197] = writeN(197, 2, Buffer3.prototype.writeUInt16BE);
      token[198] = writeN(198, 4, Buffer3.prototype.writeUInt32BE);
      token[199] = writeN(199, 1, Buffer3.prototype.writeUInt8);
      token[200] = writeN(200, 2, Buffer3.prototype.writeUInt16BE);
      token[201] = writeN(201, 4, Buffer3.prototype.writeUInt32BE);
      token[202] = writeN(202, 4, Buffer3.prototype.writeFloatBE);
      token[203] = writeN(203, 8, Buffer3.prototype.writeDoubleBE);
      token[204] = writeN(204, 1, Buffer3.prototype.writeUInt8);
      token[205] = writeN(205, 2, Buffer3.prototype.writeUInt16BE);
      token[206] = writeN(206, 4, Buffer3.prototype.writeUInt32BE);
      token[207] = writeN(207, 8, writeUInt64BE);
      token[208] = writeN(208, 1, Buffer3.prototype.writeInt8);
      token[209] = writeN(209, 2, Buffer3.prototype.writeInt16BE);
      token[210] = writeN(210, 4, Buffer3.prototype.writeInt32BE);
      token[211] = writeN(211, 8, writeInt64BE);
      token[217] = writeN(217, 1, Buffer3.prototype.writeUInt8);
      token[218] = writeN(218, 2, Buffer3.prototype.writeUInt16BE);
      token[219] = writeN(219, 4, Buffer3.prototype.writeUInt32BE);
      token[220] = writeN(220, 2, Buffer3.prototype.writeUInt16BE);
      token[221] = writeN(221, 4, Buffer3.prototype.writeUInt32BE);
      token[222] = writeN(222, 2, Buffer3.prototype.writeUInt16BE);
      token[223] = writeN(223, 4, Buffer3.prototype.writeUInt32BE);
      return token;
    }
    function write1(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(2);
        var buffer3 = encoder.buffer;
        buffer3[offset++] = type;
        buffer3[offset] = value;
      };
    }
    function write22(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(3);
        var buffer3 = encoder.buffer;
        buffer3[offset++] = type;
        buffer3[offset++] = value >>> 8;
        buffer3[offset] = value;
      };
    }
    function write4(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(5);
        var buffer3 = encoder.buffer;
        buffer3[offset++] = type;
        buffer3[offset++] = value >>> 24;
        buffer3[offset++] = value >>> 16;
        buffer3[offset++] = value >>> 8;
        buffer3[offset] = value;
      };
    }
    function writeN(type, len, method, noAssert) {
      return function(encoder, value) {
        var offset = encoder.reserve(len + 1);
        encoder.buffer[offset++] = type;
        method.call(encoder.buffer, value, offset, noAssert);
      };
    }
    function writeUInt64BE(value, offset) {
      new Uint64BE(this, offset, value);
    }
    function writeInt64BE(value, offset) {
      new Int64BE(this, offset, value);
    }
    function writeFloatBE2(value, offset) {
      ieee754.write(this, value, offset, false, 23, 4);
    }
    function writeDoubleBE2(value, offset) {
      ieee754.write(this, value, offset, false, 52, 8);
    }
  }
});

// node_modules/msgpack-lite/lib/write-type.js
var require_write_type = __commonJS({
  "node_modules/msgpack-lite/lib/write-type.js"(exports) {
    var IS_ARRAY = require_isarray();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    var Bufferish = require_bufferish();
    var BufferProto = require_bufferish_proto();
    var WriteToken = require_write_token();
    var uint8 = require_write_uint8().uint8;
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var HAS_UINT8ARRAY = "undefined" !== typeof Uint8Array;
    var HAS_MAP = "undefined" !== typeof Map;
    var extmap = [];
    extmap[1] = 212;
    extmap[2] = 213;
    extmap[4] = 214;
    extmap[8] = 215;
    extmap[16] = 216;
    exports.getWriteType = getWriteType;
    function getWriteType(options) {
      var token = WriteToken.getWriteToken(options);
      var useraw = options && options.useraw;
      var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;
      var isBuffer2 = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;
      var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;
      var usemap = HAS_MAP && options && options.usemap;
      var map2 = usemap ? map_to_map : obj_to_map;
      var writeType = {
        "boolean": bool,
        "function": nil,
        "number": number,
        "object": useraw ? object_raw : object,
        "string": _string(useraw ? raw_head_size : str_head_size),
        "symbol": nil,
        "undefined": nil
      };
      return writeType;
      function bool(encoder, value) {
        var type = value ? 195 : 194;
        token[type](encoder, value);
      }
      function number(encoder, value) {
        var ivalue = value | 0;
        var type;
        if (value !== ivalue) {
          type = 203;
          token[type](encoder, value);
          return;
        } else if (-32 <= ivalue && ivalue <= 127) {
          type = ivalue & 255;
        } else if (0 <= ivalue) {
          type = ivalue <= 255 ? 204 : ivalue <= 65535 ? 205 : 206;
        } else {
          type = -128 <= ivalue ? 208 : -32768 <= ivalue ? 209 : 210;
        }
        token[type](encoder, ivalue);
      }
      function uint64(encoder, value) {
        var type = 207;
        token[type](encoder, value.toArray());
      }
      function int64(encoder, value) {
        var type = 211;
        token[type](encoder, value.toArray());
      }
      function str_head_size(length) {
        return length < 32 ? 1 : length <= 255 ? 2 : length <= 65535 ? 3 : 5;
      }
      function raw_head_size(length) {
        return length < 32 ? 1 : length <= 65535 ? 3 : 5;
      }
      function _string(head_size) {
        return string;
        function string(encoder, value) {
          var length = value.length;
          var maxsize = 5 + length * 3;
          encoder.offset = encoder.reserve(maxsize);
          var buffer3 = encoder.buffer;
          var expected = head_size(length);
          var start = encoder.offset + expected;
          length = BufferProto.write.call(buffer3, value, start);
          var actual = head_size(length);
          if (expected !== actual) {
            var targetStart = start + actual - expected;
            var end = start + length;
            BufferProto.copy.call(buffer3, buffer3, targetStart, start, end);
          }
          var type = actual === 1 ? 160 + length : actual <= 3 ? 215 + actual : 219;
          token[type](encoder, length);
          encoder.offset += length;
        }
      }
      function object(encoder, value) {
        if (value === null)
          return nil(encoder, value);
        if (isBuffer2(value))
          return bin(encoder, value);
        if (IS_ARRAY(value))
          return array(encoder, value);
        if (Uint64BE.isUint64BE(value))
          return uint64(encoder, value);
        if (Int64BE.isInt64BE(value))
          return int64(encoder, value);
        var packer = encoder.codec.getExtPacker(value);
        if (packer)
          value = packer(value);
        if (value instanceof ExtBuffer)
          return ext(encoder, value);
        map2(encoder, value);
      }
      function object_raw(encoder, value) {
        if (isBuffer2(value))
          return raw(encoder, value);
        object(encoder, value);
      }
      function nil(encoder, value) {
        var type = 192;
        token[type](encoder, value);
      }
      function array(encoder, value) {
        var length = value.length;
        var type = length < 16 ? 144 + length : length <= 65535 ? 220 : 221;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        for (var i = 0; i < length; i++) {
          encode(encoder, value[i]);
        }
      }
      function bin_buffer(encoder, value) {
        var length = value.length;
        var type = length < 255 ? 196 : length <= 65535 ? 197 : 198;
        token[type](encoder, length);
        encoder.send(value);
      }
      function bin_arraybuffer(encoder, value) {
        bin_buffer(encoder, new Uint8Array(value));
      }
      function ext(encoder, value) {
        var buffer3 = value.buffer;
        var length = buffer3.length;
        var type = extmap[length] || (length < 255 ? 199 : length <= 65535 ? 200 : 201);
        token[type](encoder, length);
        uint8[value.type](encoder);
        encoder.send(buffer3);
      }
      function obj_to_map(encoder, value) {
        var keys2 = Object.keys(value);
        var length = keys2.length;
        var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        keys2.forEach(function(key) {
          encode(encoder, key);
          encode(encoder, value[key]);
        });
      }
      function map_to_map(encoder, value) {
        if (!(value instanceof Map))
          return obj_to_map(encoder, value);
        var length = value.size;
        var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        value.forEach(function(val, key, m) {
          encode(encoder, key);
          encode(encoder, val);
        });
      }
      function raw(encoder, value) {
        var length = value.length;
        var type = length < 32 ? 160 + length : length <= 65535 ? 218 : 219;
        token[type](encoder, length);
        encoder.send(value);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/codec-base.js
var require_codec_base = __commonJS({
  "node_modules/msgpack-lite/lib/codec-base.js"(exports) {
    var IS_ARRAY = require_isarray();
    exports.createCodec = createCodec;
    exports.install = install;
    exports.filter = filter3;
    var Bufferish = require_bufferish();
    function Codec(options) {
      if (!(this instanceof Codec))
        return new Codec(options);
      this.options = options;
      this.init();
    }
    Codec.prototype.init = function() {
      var options = this.options;
      if (options && options.uint8array) {
        this.bufferish = Bufferish.Uint8Array;
      }
      return this;
    };
    function install(props) {
      for (var key in props) {
        Codec.prototype[key] = add(Codec.prototype[key], props[key]);
      }
    }
    function add(a, b) {
      return a && b ? ab : a || b;
      function ab() {
        a.apply(this, arguments);
        return b.apply(this, arguments);
      }
    }
    function join2(filters) {
      filters = filters.slice();
      return function(value) {
        return filters.reduce(iterator2, value);
      };
      function iterator2(value, filter4) {
        return filter4(value);
      }
    }
    function filter3(filter4) {
      return IS_ARRAY(filter4) ? join2(filter4) : filter4;
    }
    function createCodec(options) {
      return new Codec(options);
    }
    exports.preset = createCodec({ preset: true });
  }
});

// node_modules/msgpack-lite/lib/write-core.js
var require_write_core = __commonJS({
  "node_modules/msgpack-lite/lib/write-core.js"(exports) {
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var ExtPacker = require_ext_packer();
    var WriteType = require_write_type();
    var CodecBase = require_codec_base();
    CodecBase.install({
      addExtPacker,
      getExtPacker,
      init: init2
    });
    exports.preset = init2.call(CodecBase.preset);
    function getEncoder(options) {
      var writeType = WriteType.getWriteType(options);
      return encode;
      function encode(encoder, value) {
        var func = writeType[typeof value];
        if (!func)
          throw new Error('Unsupported type "' + typeof value + '": ' + value);
        func(encoder, value);
      }
    }
    function init2() {
      var options = this.options;
      this.encode = getEncoder(options);
      if (options && options.preset) {
        ExtPacker.setExtPackers(this);
      }
      return this;
    }
    function addExtPacker(etype, Class, packer) {
      packer = CodecBase.filter(packer);
      var name = Class.name;
      if (name && name !== "Object") {
        var packers = this.extPackers || (this.extPackers = {});
        packers[name] = extPacker;
      } else {
        var list = this.extEncoderList || (this.extEncoderList = []);
        list.unshift([Class, extPacker]);
      }
      function extPacker(value) {
        if (packer)
          value = packer(value);
        return new ExtBuffer(value, etype);
      }
    }
    function getExtPacker(value) {
      var packers = this.extPackers || (this.extPackers = {});
      var c = value.constructor;
      var e = c && c.name && packers[c.name];
      if (e)
        return e;
      var list = this.extEncoderList || (this.extEncoderList = []);
      var len = list.length;
      for (var i = 0; i < len; i++) {
        var pair = list[i];
        if (c === pair[0])
          return pair[1];
      }
    }
  }
});

// node_modules/msgpack-lite/lib/flex-buffer.js
var require_flex_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/flex-buffer.js"(exports) {
    exports.FlexDecoder = FlexDecoder;
    exports.FlexEncoder = FlexEncoder;
    var Bufferish = require_bufferish();
    var MIN_BUFFER_SIZE = 2048;
    var MAX_BUFFER_SIZE = 65536;
    var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";
    function FlexDecoder() {
      if (!(this instanceof FlexDecoder))
        return new FlexDecoder();
    }
    function FlexEncoder() {
      if (!(this instanceof FlexEncoder))
        return new FlexEncoder();
    }
    FlexDecoder.mixin = mixinFactory(getDecoderMethods());
    FlexDecoder.mixin(FlexDecoder.prototype);
    FlexEncoder.mixin = mixinFactory(getEncoderMethods());
    FlexEncoder.mixin(FlexEncoder.prototype);
    function getDecoderMethods() {
      return {
        bufferish: Bufferish,
        write: write4,
        fetch,
        flush,
        push,
        pull,
        read: read2,
        reserve,
        offset: 0
      };
      function write4(chunk) {
        var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;
        this.buffer = prev ? chunk ? this.bufferish.concat([prev, chunk]) : prev : chunk;
        this.offset = 0;
      }
      function flush() {
        while (this.offset < this.buffer.length) {
          var start = this.offset;
          var value;
          try {
            value = this.fetch();
          } catch (e) {
            if (e && e.message != BUFFER_SHORTAGE)
              throw e;
            this.offset = start;
            break;
          }
          this.push(value);
        }
      }
      function reserve(length) {
        var start = this.offset;
        var end = start + length;
        if (end > this.buffer.length)
          throw new Error(BUFFER_SHORTAGE);
        this.offset = end;
        return start;
      }
    }
    function getEncoderMethods() {
      return {
        bufferish: Bufferish,
        write: write3,
        fetch: fetch2,
        flush,
        push,
        pull: pull2,
        read: read2,
        reserve,
        send,
        maxBufferSize: MAX_BUFFER_SIZE,
        minBufferSize: MIN_BUFFER_SIZE,
        offset: 0,
        start: 0
      };
      function fetch2() {
        var start = this.start;
        if (start < this.offset) {
          var end = this.start = this.offset;
          return Bufferish.prototype.slice.call(this.buffer, start, end);
        }
      }
      function flush() {
        while (this.start < this.offset) {
          var value = this.fetch();
          if (value)
            this.push(value);
        }
      }
      function pull2() {
        var buffers = this.buffers || (this.buffers = []);
        var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];
        buffers.length = 0;
        return chunk;
      }
      function reserve(length) {
        var req = length | 0;
        if (this.buffer) {
          var size = this.buffer.length;
          var start = this.offset | 0;
          var end = start + req;
          if (end < size) {
            this.offset = end;
            return start;
          }
          this.flush();
          length = Math.max(length, Math.min(size * 2, this.maxBufferSize));
        }
        length = Math.max(length, this.minBufferSize);
        this.buffer = this.bufferish.alloc(length);
        this.start = 0;
        this.offset = req;
        return 0;
      }
      function send(buffer3) {
        var length = buffer3.length;
        if (length > this.minBufferSize) {
          this.flush();
          this.push(buffer3);
        } else {
          var offset = this.reserve(length);
          Bufferish.prototype.copy.call(buffer3, this.buffer, offset);
        }
      }
    }
    function write3() {
      throw new Error("method not implemented: write()");
    }
    function fetch() {
      throw new Error("method not implemented: fetch()");
    }
    function read2() {
      var length = this.buffers && this.buffers.length;
      if (!length)
        return this.fetch();
      this.flush();
      return this.pull();
    }
    function push(chunk) {
      var buffers = this.buffers || (this.buffers = []);
      buffers.push(chunk);
    }
    function pull() {
      var buffers = this.buffers || (this.buffers = []);
      return buffers.shift();
    }
    function mixinFactory(source) {
      return mixin;
      function mixin(target) {
        for (var key in source) {
          target[key] = source[key];
        }
        return target;
      }
    }
  }
});

// node_modules/msgpack-lite/lib/encode-buffer.js
var require_encode_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/encode-buffer.js"(exports) {
    exports.EncodeBuffer = EncodeBuffer;
    var preset = require_write_core().preset;
    var FlexEncoder = require_flex_buffer().FlexEncoder;
    FlexEncoder.mixin(EncodeBuffer.prototype);
    function EncodeBuffer(options) {
      if (!(this instanceof EncodeBuffer))
        return new EncodeBuffer(options);
      if (options) {
        this.options = options;
        if (options.codec) {
          var codec = this.codec = options.codec;
          if (codec.bufferish)
            this.bufferish = codec.bufferish;
        }
      }
    }
    EncodeBuffer.prototype.codec = preset;
    EncodeBuffer.prototype.write = function(input) {
      this.codec.encode(this, input);
    };
  }
});

// node_modules/msgpack-lite/lib/encode.js
var require_encode = __commonJS({
  "node_modules/msgpack-lite/lib/encode.js"(exports) {
    exports.encode = encode;
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    function encode(input, options) {
      var encoder = new EncodeBuffer(options);
      encoder.write(input);
      return encoder.read();
    }
  }
});

// node_modules/msgpack-lite/lib/ext-unpacker.js
var require_ext_unpacker = __commonJS({
  "node_modules/msgpack-lite/lib/ext-unpacker.js"(exports) {
    exports.setExtUnpackers = setExtUnpackers;
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var _decode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtUnpackers(codec) {
      codec.addExtUnpacker(14, [decode, unpackError(Error)]);
      codec.addExtUnpacker(1, [decode, unpackError(EvalError)]);
      codec.addExtUnpacker(2, [decode, unpackError(RangeError)]);
      codec.addExtUnpacker(3, [decode, unpackError(ReferenceError)]);
      codec.addExtUnpacker(4, [decode, unpackError(SyntaxError)]);
      codec.addExtUnpacker(5, [decode, unpackError(TypeError)]);
      codec.addExtUnpacker(6, [decode, unpackError(URIError)]);
      codec.addExtUnpacker(10, [decode, unpackRegExp]);
      codec.addExtUnpacker(11, [decode, unpackClass(Boolean)]);
      codec.addExtUnpacker(12, [decode, unpackClass(String)]);
      codec.addExtUnpacker(13, [decode, unpackClass(Date)]);
      codec.addExtUnpacker(15, [decode, unpackClass(Number)]);
      if ("undefined" !== typeof Uint8Array) {
        codec.addExtUnpacker(17, unpackClass(Int8Array));
        codec.addExtUnpacker(18, unpackClass(Uint8Array));
        codec.addExtUnpacker(19, [unpackArrayBuffer, unpackClass(Int16Array)]);
        codec.addExtUnpacker(20, [unpackArrayBuffer, unpackClass(Uint16Array)]);
        codec.addExtUnpacker(21, [unpackArrayBuffer, unpackClass(Int32Array)]);
        codec.addExtUnpacker(22, [unpackArrayBuffer, unpackClass(Uint32Array)]);
        codec.addExtUnpacker(23, [unpackArrayBuffer, unpackClass(Float32Array)]);
        if ("undefined" !== typeof Float64Array) {
          codec.addExtUnpacker(24, [unpackArrayBuffer, unpackClass(Float64Array)]);
        }
        if ("undefined" !== typeof Uint8ClampedArray) {
          codec.addExtUnpacker(25, unpackClass(Uint8ClampedArray));
        }
        codec.addExtUnpacker(26, unpackArrayBuffer);
        codec.addExtUnpacker(29, [unpackArrayBuffer, unpackClass(DataView)]);
      }
      if (Bufferish.hasBuffer) {
        codec.addExtUnpacker(27, unpackClass(Buffer3));
      }
    }
    function decode(input) {
      if (!_decode)
        _decode = require_decode().decode;
      return _decode(input);
    }
    function unpackRegExp(value) {
      return RegExp.apply(null, value);
    }
    function unpackError(Class) {
      return function(value) {
        var out = new Class();
        for (var key in ERROR_COLUMNS) {
          out[key] = value[key];
        }
        return out;
      };
    }
    function unpackClass(Class) {
      return function(value) {
        return new Class(value);
      };
    }
    function unpackArrayBuffer(value) {
      return new Uint8Array(value).buffer;
    }
  }
});

// node_modules/msgpack-lite/lib/read-format.js
var require_read_format = __commonJS({
  "node_modules/msgpack-lite/lib/read-format.js"(exports) {
    var ieee754 = require_ieee754();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    exports.getReadFormat = getReadFormat;
    exports.readUint8 = uint8;
    var Bufferish = require_bufferish();
    var BufferProto = require_bufferish_proto();
    var HAS_MAP = "undefined" !== typeof Map;
    var NO_ASSERT = true;
    function getReadFormat(options) {
      var binarraybuffer = Bufferish.hasArrayBuffer && options && options.binarraybuffer;
      var int64 = options && options.int64;
      var usemap = HAS_MAP && options && options.usemap;
      var readFormat = {
        map: usemap ? map_to_map : map_to_obj,
        array,
        str,
        bin: binarraybuffer ? bin_arraybuffer : bin_buffer,
        ext,
        uint8,
        uint16,
        uint32,
        uint64: read2(8, int64 ? readUInt64BE_int64 : readUInt64BE),
        int8,
        int16,
        int32,
        int64: read2(8, int64 ? readInt64BE_int64 : readInt64BE),
        float32: read2(4, readFloatBE2),
        float64: read2(8, readDoubleBE2)
      };
      return readFormat;
    }
    function map_to_obj(decoder, len) {
      var value = {};
      var i;
      var k = new Array(len);
      var v = new Array(len);
      var decode = decoder.codec.decode;
      for (i = 0; i < len; i++) {
        k[i] = decode(decoder);
        v[i] = decode(decoder);
      }
      for (i = 0; i < len; i++) {
        value[k[i]] = v[i];
      }
      return value;
    }
    function map_to_map(decoder, len) {
      var value = /* @__PURE__ */ new Map();
      var i;
      var k = new Array(len);
      var v = new Array(len);
      var decode = decoder.codec.decode;
      for (i = 0; i < len; i++) {
        k[i] = decode(decoder);
        v[i] = decode(decoder);
      }
      for (i = 0; i < len; i++) {
        value.set(k[i], v[i]);
      }
      return value;
    }
    function array(decoder, len) {
      var value = new Array(len);
      var decode = decoder.codec.decode;
      for (var i = 0; i < len; i++) {
        value[i] = decode(decoder);
      }
      return value;
    }
    function str(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      return BufferProto.toString.call(decoder.buffer, "utf-8", start, end);
    }
    function bin_buffer(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return Bufferish.from(buf);
    }
    function bin_arraybuffer(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return Bufferish.Uint8Array.from(buf).buffer;
    }
    function ext(decoder, len) {
      var start = decoder.reserve(len + 1);
      var type = decoder.buffer[start++];
      var end = start + len;
      var unpack = decoder.codec.getExtUnpacker(type);
      if (!unpack)
        throw new Error("Invalid ext type: " + (type ? "0x" + type.toString(16) : type));
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return unpack(buf);
    }
    function uint8(decoder) {
      var start = decoder.reserve(1);
      return decoder.buffer[start];
    }
    function int8(decoder) {
      var start = decoder.reserve(1);
      var value = decoder.buffer[start];
      return value & 128 ? value - 256 : value;
    }
    function uint16(decoder) {
      var start = decoder.reserve(2);
      var buffer3 = decoder.buffer;
      return buffer3[start++] << 8 | buffer3[start];
    }
    function int16(decoder) {
      var start = decoder.reserve(2);
      var buffer3 = decoder.buffer;
      var value = buffer3[start++] << 8 | buffer3[start];
      return value & 32768 ? value - 65536 : value;
    }
    function uint32(decoder) {
      var start = decoder.reserve(4);
      var buffer3 = decoder.buffer;
      return buffer3[start++] * 16777216 + (buffer3[start++] << 16) + (buffer3[start++] << 8) + buffer3[start];
    }
    function int32(decoder) {
      var start = decoder.reserve(4);
      var buffer3 = decoder.buffer;
      return buffer3[start++] << 24 | buffer3[start++] << 16 | buffer3[start++] << 8 | buffer3[start];
    }
    function read2(len, method) {
      return function(decoder) {
        var start = decoder.reserve(len);
        return method.call(decoder.buffer, start, NO_ASSERT);
      };
    }
    function readUInt64BE(start) {
      return new Uint64BE(this, start).toNumber();
    }
    function readInt64BE(start) {
      return new Int64BE(this, start).toNumber();
    }
    function readUInt64BE_int64(start) {
      return new Uint64BE(this, start);
    }
    function readInt64BE_int64(start) {
      return new Int64BE(this, start);
    }
    function readFloatBE2(start) {
      return ieee754.read(this, start, false, 23, 4);
    }
    function readDoubleBE2(start) {
      return ieee754.read(this, start, false, 52, 8);
    }
  }
});

// node_modules/msgpack-lite/lib/read-token.js
var require_read_token = __commonJS({
  "node_modules/msgpack-lite/lib/read-token.js"(exports) {
    var ReadFormat = require_read_format();
    exports.getReadToken = getReadToken;
    function getReadToken(options) {
      var format2 = ReadFormat.getReadFormat(options);
      if (options && options.useraw) {
        return init_useraw(format2);
      } else {
        return init_token(format2);
      }
    }
    function init_token(format2) {
      var i;
      var token = new Array(256);
      for (i = 0; i <= 127; i++) {
        token[i] = constant(i);
      }
      for (i = 128; i <= 143; i++) {
        token[i] = fix(i - 128, format2.map);
      }
      for (i = 144; i <= 159; i++) {
        token[i] = fix(i - 144, format2.array);
      }
      for (i = 160; i <= 191; i++) {
        token[i] = fix(i - 160, format2.str);
      }
      token[192] = constant(null);
      token[193] = null;
      token[194] = constant(false);
      token[195] = constant(true);
      token[196] = flex(format2.uint8, format2.bin);
      token[197] = flex(format2.uint16, format2.bin);
      token[198] = flex(format2.uint32, format2.bin);
      token[199] = flex(format2.uint8, format2.ext);
      token[200] = flex(format2.uint16, format2.ext);
      token[201] = flex(format2.uint32, format2.ext);
      token[202] = format2.float32;
      token[203] = format2.float64;
      token[204] = format2.uint8;
      token[205] = format2.uint16;
      token[206] = format2.uint32;
      token[207] = format2.uint64;
      token[208] = format2.int8;
      token[209] = format2.int16;
      token[210] = format2.int32;
      token[211] = format2.int64;
      token[212] = fix(1, format2.ext);
      token[213] = fix(2, format2.ext);
      token[214] = fix(4, format2.ext);
      token[215] = fix(8, format2.ext);
      token[216] = fix(16, format2.ext);
      token[217] = flex(format2.uint8, format2.str);
      token[218] = flex(format2.uint16, format2.str);
      token[219] = flex(format2.uint32, format2.str);
      token[220] = flex(format2.uint16, format2.array);
      token[221] = flex(format2.uint32, format2.array);
      token[222] = flex(format2.uint16, format2.map);
      token[223] = flex(format2.uint32, format2.map);
      for (i = 224; i <= 255; i++) {
        token[i] = constant(i - 256);
      }
      return token;
    }
    function init_useraw(format2) {
      var i;
      var token = init_token(format2).slice();
      token[217] = token[196];
      token[218] = token[197];
      token[219] = token[198];
      for (i = 160; i <= 191; i++) {
        token[i] = fix(i - 160, format2.bin);
      }
      return token;
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    function flex(lenFunc, decodeFunc) {
      return function(decoder) {
        var len = lenFunc(decoder);
        return decodeFunc(decoder, len);
      };
    }
    function fix(len, method) {
      return function(decoder) {
        return method(decoder, len);
      };
    }
  }
});

// node_modules/msgpack-lite/lib/read-core.js
var require_read_core = __commonJS({
  "node_modules/msgpack-lite/lib/read-core.js"(exports) {
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var ExtUnpacker = require_ext_unpacker();
    var readUint8 = require_read_format().readUint8;
    var ReadToken = require_read_token();
    var CodecBase = require_codec_base();
    CodecBase.install({
      addExtUnpacker,
      getExtUnpacker,
      init: init2
    });
    exports.preset = init2.call(CodecBase.preset);
    function getDecoder(options) {
      var readToken = ReadToken.getReadToken(options);
      return decode;
      function decode(decoder) {
        var type = readUint8(decoder);
        var func = readToken[type];
        if (!func)
          throw new Error("Invalid type: " + (type ? "0x" + type.toString(16) : type));
        return func(decoder);
      }
    }
    function init2() {
      var options = this.options;
      this.decode = getDecoder(options);
      if (options && options.preset) {
        ExtUnpacker.setExtUnpackers(this);
      }
      return this;
    }
    function addExtUnpacker(etype, unpacker) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      unpackers[etype] = CodecBase.filter(unpacker);
    }
    function getExtUnpacker(type) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      return unpackers[type] || extUnpacker;
      function extUnpacker(buffer3) {
        return new ExtBuffer(buffer3, type);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/decode-buffer.js
var require_decode_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/decode-buffer.js"(exports) {
    exports.DecodeBuffer = DecodeBuffer;
    var preset = require_read_core().preset;
    var FlexDecoder = require_flex_buffer().FlexDecoder;
    FlexDecoder.mixin(DecodeBuffer.prototype);
    function DecodeBuffer(options) {
      if (!(this instanceof DecodeBuffer))
        return new DecodeBuffer(options);
      if (options) {
        this.options = options;
        if (options.codec) {
          var codec = this.codec = options.codec;
          if (codec.bufferish)
            this.bufferish = codec.bufferish;
        }
      }
    }
    DecodeBuffer.prototype.codec = preset;
    DecodeBuffer.prototype.fetch = function() {
      return this.codec.decode(this);
    };
  }
});

// node_modules/msgpack-lite/lib/decode.js
var require_decode = __commonJS({
  "node_modules/msgpack-lite/lib/decode.js"(exports) {
    exports.decode = decode;
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    function decode(input, options) {
      var decoder = new DecodeBuffer(options);
      decoder.write(input);
      return decoder.read();
    }
  }
});

// node_modules/event-lite/event-lite.js
var require_event_lite = __commonJS({
  "node_modules/event-lite/event-lite.js"(exports, module) {
    function EventLite() {
      if (!(this instanceof EventLite))
        return new EventLite();
    }
    (function(EventLite2) {
      if ("undefined" !== typeof module)
        module.exports = EventLite2;
      var LISTENERS = "listeners";
      var methods = {
        on: on2,
        once: once3,
        off: off2,
        emit: emit3
      };
      mixin(EventLite2.prototype);
      EventLite2.mixin = mixin;
      function mixin(target) {
        for (var key in methods) {
          target[key] = methods[key];
        }
        return target;
      }
      function on2(type, func) {
        getListeners(this, type).push(func);
        return this;
      }
      function once3(type, func) {
        var that = this;
        wrap.originalListener = func;
        getListeners(that, type).push(wrap);
        return that;
        function wrap() {
          off2.call(that, type, wrap);
          func.apply(this, arguments);
        }
      }
      function off2(type, func) {
        var that = this;
        var listners;
        if (!arguments.length) {
          delete that[LISTENERS];
        } else if (!func) {
          listners = that[LISTENERS];
          if (listners) {
            delete listners[type];
            if (!Object.keys(listners).length)
              return off2.call(that);
          }
        } else {
          listners = getListeners(that, type, true);
          if (listners) {
            listners = listners.filter(ne);
            if (!listners.length)
              return off2.call(that, type);
            that[LISTENERS][type] = listners;
          }
        }
        return that;
        function ne(test) {
          return test !== func && test.originalListener !== func;
        }
      }
      function emit3(type, value) {
        var that = this;
        var listeners2 = getListeners(that, type, true);
        if (!listeners2)
          return false;
        var arglen = arguments.length;
        if (arglen === 1) {
          listeners2.forEach(zeroarg);
        } else if (arglen === 2) {
          listeners2.forEach(onearg);
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          listeners2.forEach(moreargs);
        }
        return !!listeners2.length;
        function zeroarg(func) {
          func.call(that);
        }
        function onearg(func) {
          func.call(that, value);
        }
        function moreargs(func) {
          func.apply(that, args);
        }
      }
      function getListeners(that, type, readonly) {
        if (readonly && !that[LISTENERS])
          return;
        var listeners2 = that[LISTENERS] || (that[LISTENERS] = {});
        return listeners2[type] || (listeners2[type] = []);
      }
    })(EventLite);
  }
});

// node_modules/msgpack-lite/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/msgpack-lite/lib/encoder.js"(exports) {
    exports.Encoder = Encoder;
    var EventLite = require_event_lite();
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    function Encoder(options) {
      if (!(this instanceof Encoder))
        return new Encoder(options);
      EncodeBuffer.call(this, options);
    }
    Encoder.prototype = new EncodeBuffer();
    EventLite.mixin(Encoder.prototype);
    Encoder.prototype.encode = function(chunk) {
      this.write(chunk);
      this.emit("data", this.read());
    };
    Encoder.prototype.end = function(chunk) {
      if (arguments.length)
        this.encode(chunk);
      this.flush();
      this.emit("end");
    };
  }
});

// node_modules/msgpack-lite/lib/decoder.js
var require_decoder = __commonJS({
  "node_modules/msgpack-lite/lib/decoder.js"(exports) {
    exports.Decoder = Decoder;
    var EventLite = require_event_lite();
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    function Decoder(options) {
      if (!(this instanceof Decoder))
        return new Decoder(options);
      DecodeBuffer.call(this, options);
    }
    Decoder.prototype = new DecodeBuffer();
    EventLite.mixin(Decoder.prototype);
    Decoder.prototype.decode = function(chunk) {
      if (arguments.length)
        this.write(chunk);
      this.flush();
    };
    Decoder.prototype.push = function(chunk) {
      this.emit("data", chunk);
    };
    Decoder.prototype.end = function(chunk) {
      this.decode(chunk);
      this.emit("end");
    };
  }
});

// node_modules/msgpack-lite/lib/ext.js
var require_ext = __commonJS({
  "node_modules/msgpack-lite/lib/ext.js"(exports) {
    require_read_core();
    require_write_core();
    exports.createCodec = require_codec_base().createCodec;
  }
});

// node_modules/msgpack-lite/lib/codec.js
var require_codec = __commonJS({
  "node_modules/msgpack-lite/lib/codec.js"(exports) {
    require_read_core();
    require_write_core();
    exports.codec = {
      preset: require_codec_base().preset
    };
  }
});

// node_modules/msgpack-lite/lib/browser.js
var require_browser = __commonJS({
  "node_modules/msgpack-lite/lib/browser.js"(exports) {
    exports.encode = require_encode().encode;
    exports.decode = require_decode().decode;
    exports.Encoder = require_encoder().Encoder;
    exports.Decoder = require_decoder().Decoder;
    exports.createCodec = require_ext().createCodec;
    exports.codec = require_codec().codec;
  }
});

// node_modules/@rpgjs/common/lib/Utils.js
var Utils_exports = {};
__export(Utils_exports, {
  applyMixins: () => applyMixins,
  arrayEquals: () => arrayEquals,
  arrayFlat: () => arrayFlat,
  arrayUniq: () => arrayUniq,
  basename: () => basename,
  camelToKebab: () => camelToKebab,
  capitalize: () => capitalize,
  createConstructor: () => createConstructor,
  default: () => Utils_default,
  elementToPositionAbsolute: () => elementToPositionAbsolute,
  extractId: () => extractId,
  fps2ms: () => fps2ms,
  generateUID: () => generateUID,
  hexaToNumber: () => hexaToNumber,
  intersection: () => intersection,
  isArray: () => isArray,
  isBrowser: () => isBrowser,
  isClass: () => isClass,
  isFunction: () => isFunction,
  isInstanceOf: () => isInstanceOf,
  isObject: () => isObject,
  isPromise: () => isPromise,
  isString: () => isString,
  preciseNow: () => preciseNow,
  random: () => random,
  round: () => round,
  set: () => set,
  sharedArrayBuffer: () => sharedArrayBuffer,
  toRadians: () => toRadians
});
function random(min2, max2) {
  return Math.floor(Math.random() * (max2 - min2 + 1) + min2);
}
function isBrowser() {
  return typeof window !== "undefined";
}
function isFunction(val) {
  return {}.toString.call(val) === "[object Function]";
}
function isClass(func) {
  return typeof func === "function";
}
function isPromise(val) {
  return isInstanceOf(val, Promise);
}
function isArray(val) {
  return isInstanceOf(val, Array);
}
function isObject(val) {
  return typeof val == "object" && val != null && !isArray(val);
}
function isString(val) {
  return typeof val == "string";
}
function isInstanceOf(val, _class) {
  return val instanceof _class;
}
function arrayUniq(array) {
  return [...new Set(array)];
}
function arrayFlat(array) {
  return array.reduce((acc, val) => acc.concat(val), []);
}
function intersection([start1, end1], [start2, end2]) {
  return start1 >= start2 && start1 <= end2 || start2 >= start1 && start2 < end1;
}
function capitalize(s) {
  if (typeof s !== "string")
    return "";
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function camelToKebab(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function arrayEquals(a, b) {
  return a.length === b.length && a.every((v, i) => v === b[i]);
}
function applyMixins(derivedCtor, baseCtors) {
  baseCtors.forEach((baseCtor) => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
      const baseCtorName = Object.getOwnPropertyDescriptor(baseCtor.prototype, name);
      if (!baseCtorName) {
        return;
      }
      Object.defineProperty(derivedCtor.prototype, name, baseCtorName);
    });
  });
}
function generateUID() {
  let firstPart = Math.random() * 46656 | 0;
  let secondPart = Math.random() * 46656 | 0;
  firstPart = ("000" + firstPart.toString(36)).slice(-3);
  secondPart = ("000" + secondPart.toString(36)).slice(-3);
  return firstPart + secondPart;
}
function createConstructor(...propNames) {
  return class {
    constructor(...propValues) {
      propNames.forEach((name, idx) => {
        this[name] = propValues[idx];
      });
    }
  };
}
function sharedArrayBuffer() {
  let buffer3;
  if (typeof SharedArrayBuffer != "undefined") {
    buffer3 = SharedArrayBuffer;
  } else {
    buffer3 = ArrayBuffer;
  }
  return buffer3;
}
function toRadians(angle) {
  return angle * (Math.PI / 180);
}
function hexaToNumber(hexa) {
  let val = hexa.replace("#", "");
  let alpha = 1;
  if (val.length === 3) {
    val = val.split("").map((v) => v + v).join("");
  }
  if (val.length === 8) {
    alpha = parseInt(val.substring(0, 2), 16) / 255;
    val = val.substring(2);
  }
  return {
    value: parseInt(val, 16),
    alpha
  };
}
function extractId(path) {
  const id = path.match(/([a-zA-Z0-9-_$!]+)\.[a-z0-9]+$/i);
  if (!id)
    return null;
  return id[1];
}
function basename(path) {
  return path.substring(path.lastIndexOf("/") + 1);
}
function fps2ms(fps) {
  return 1e3 / fps;
}
function preciseNow() {
  return typeof performance !== "undefined" ? performance.now() : Date.now();
}
function round(num, decimals = 100) {
  return Math.round(num * decimals) / decimals;
}
function set(obj, path, value, onlyPlainObject = false) {
  if (Object(obj) !== obj)
    return obj;
  if (!Array.isArray(path))
    path = path.toString().match(/[^.[\]]+/g) || [];
  path.slice(0, -1).reduce(
    (a, c, i) => (
      // Iterate all of them except the last one
      Object(a[c]) === a[c] ? a[c] : a[c] = Math.abs(path[i + 1]) >> 0 === +path[i + 1] ? onlyPlainObject ? {} : [] : {}
    ),
    // No: assign a new plain object
    obj
  )[path[path.length - 1]] = value;
  return obj;
}
function elementToPositionAbsolute(element) {
  element.style.position = "absolute";
  element.style.top = "0";
  element.style.left = "0";
  element.style.right = "0";
  element.style.bottom = "0";
  element.style.width = "100%";
  element.style.height = "100%";
}
var Utils_default = {
  random,
  isBrowser,
  isPromise,
  isArray,
  isObject,
  isString,
  isFunction,
  isClass,
  isInstanceOf,
  arrayUniq,
  arrayFlat,
  arrayEquals,
  intersection,
  applyMixins,
  capitalize,
  sharedArrayBuffer,
  generateUID,
  createConstructor,
  toRadians,
  extractId,
  basename,
  fps2ms,
  preciseNow,
  hexaToNumber,
  set,
  round,
  camelToKebab,
  elementToPositionAbsolute
};

// node_modules/@rpgjs/types/lib/Player.js
var MoveClientMode;
(function(MoveClientMode2) {
  MoveClientMode2[MoveClientMode2["Disabled"] = 0] = "Disabled";
  MoveClientMode2[MoveClientMode2["ByDirection"] = 1] = "ByDirection";
  MoveClientMode2[MoveClientMode2["Drag"] = 2] = "Drag";
})(MoveClientMode || (MoveClientMode = {}));
var Behavior;
(function(Behavior2) {
  Behavior2[Behavior2["Direction"] = 0] = "Direction";
  Behavior2[Behavior2["Target"] = 1] = "Target";
})(Behavior || (Behavior = {}));
var Direction;
(function(Direction2) {
  Direction2[Direction2["Up"] = 1] = "Up";
  Direction2[Direction2["Down"] = 3] = "Down";
  Direction2[Direction2["Left"] = 4] = "Left";
  Direction2[Direction2["Right"] = 2] = "Right";
  Direction2[Direction2["UpRight"] = 1.5] = "UpRight";
  Direction2[Direction2["DownRight"] = 2.5] = "DownRight";
  Direction2[Direction2["DownLeft"] = 3.5] = "DownLeft";
  Direction2[Direction2["UpLeft"] = 2.5] = "UpLeft";
})(Direction || (Direction = {}));
var PlayerType;
(function(PlayerType2) {
  PlayerType2["Player"] = "player";
  PlayerType2["Event"] = "event";
  PlayerType2["Shape"] = "shape";
})(PlayerType || (PlayerType = {}));

// node_modules/@rpgjs/types/lib/Input.js
var Control;
(function(Control2) {
  Control2["Action"] = "action";
  Control2["Attack"] = "attack";
  Control2["Defense"] = "defense";
  Control2["Skill"] = "skill";
  Control2["Back"] = "back";
  Control2[Control2["Up"] = 1] = "Up";
  Control2[Control2["Down"] = 3] = "Down";
  Control2[Control2["Right"] = 2] = "Right";
  Control2[Control2["Left"] = 4] = "Left";
})(Control || (Control = {}));
var Input;
(function(Input2) {
  Input2["Break"] = "break";
  Input2["Backspace"] = "backspace";
  Input2["Tab"] = "tab";
  Input2["Clear"] = "clear";
  Input2["Enter"] = "enter";
  Input2["Shift"] = "shift";
  Input2["Ctrl"] = "ctrl";
  Input2["Alt"] = "alt";
  Input2["Pause"] = "pause/break";
  Input2["CapsLock"] = "caps lock";
  Input2["Escape"] = "escape";
  Input2["Conversion"] = "conversion";
  Input2["NonConversion"] = "non-conversion";
  Input2["Space"] = "space";
  Input2["PageUp"] = "page up";
  Input2["PageDown"] = "page down";
  Input2["End"] = "end";
  Input2["Home"] = "home";
  Input2[Input2["Left"] = 4] = "Left";
  Input2[Input2["Up"] = 1] = "Up";
  Input2[Input2["Right"] = 2] = "Right";
  Input2[Input2["Down"] = 3] = "Down";
  Input2["Select"] = "select";
  Input2["Print"] = "print";
  Input2["Execute"] = "execute";
  Input2["PrintScreen"] = "Print Screen";
  Input2["Insert"] = "insert";
  Input2["Delete"] = "delete";
  Input2["Zero"] = "0";
  Input2["One"] = "1";
  Input2["Two"] = "2";
  Input2["Three"] = "3";
  Input2["Four"] = "4";
  Input2["Five"] = "5";
  Input2["Six"] = "6";
  Input2["Seven"] = "7";
  Input2["Height"] = "8";
  Input2["Nine"] = "9";
  Input2["Equal"] = "=";
  Input2["Semicolon"] = "semicolon (firefox), equals";
  Input2["LessThan"] = "<";
  Input2["Equals"] = "equals (firefox)";
  Input2["Beta"] = "ß";
  Input2["At"] = "@";
  Input2["A"] = "a";
  Input2["B"] = "b";
  Input2["C"] = "c";
  Input2["D"] = "d";
  Input2["E"] = "e";
  Input2["F"] = "f";
  Input2["G"] = "g";
  Input2["H"] = "h";
  Input2["I"] = "i";
  Input2["J"] = "j";
  Input2["K"] = "k";
  Input2["L"] = "l";
  Input2["M"] = "m";
  Input2["N"] = "n";
  Input2["O"] = "o";
  Input2["P"] = "p";
  Input2["Q"] = "q";
  Input2["R"] = "r";
  Input2["S"] = "s";
  Input2["T"] = "t";
  Input2["U"] = "u";
  Input2["V"] = "v";
  Input2["W"] = "w";
  Input2["X"] = "x";
  Input2["Y"] = "y";
  Input2["Z"] = "z";
  Input2["SearchKey"] = "Windows Key / Left ⌘ / Chromebook Search key";
  Input2["NumPad0"] = "numpad 0";
  Input2["NumPad1"] = "numpad 1";
  Input2["NumPad2"] = "numpad 2";
  Input2["NumPad3"] = "numpad 3";
  Input2["NumPad4"] = "numpad 4";
  Input2["NumPad5"] = "numpad 5";
  Input2["NumPad6"] = "numpad 6";
  Input2["NumPad7"] = "numpad 7";
  Input2["NumPad8"] = "numpad 8";
  Input2["NumPad9"] = "numpad 9";
  Input2["Multiply"] = "multiply";
  Input2["Add"] = "add";
  Input2["Subtract"] = "subtract";
  Input2["DecimalPoint"] = "decimal point";
  Input2["Divide"] = "divide";
  Input2["F1"] = "f1";
  Input2["F2"] = "f2";
  Input2["F3"] = "f3";
  Input2["F4"] = "f4";
  Input2["F5"] = "f5";
  Input2["F6"] = "f6";
  Input2["F7"] = "f7";
  Input2["F8"] = "f8";
  Input2["F9"] = "f9";
  Input2["F10"] = "f10";
  Input2["F11"] = "f11";
  Input2["F12"] = "f12";
  Input2["F13"] = "f13";
  Input2["F14"] = "f14";
  Input2["F15"] = "f15";
  Input2["F16"] = "f16";
  Input2["F17"] = "f17";
  Input2["F18"] = "f18";
  Input2["F19"] = "f19";
  Input2["F20"] = "f20";
  Input2["F21"] = "f21";
  Input2["F22"] = "f22";
  Input2["F23"] = "f23";
  Input2["F24"] = "f24";
  Input2["NumLock"] = "num lock";
  Input2["ScrollLock"] = "scroll lock";
  Input2["CircumflexAccent"] = "^";
  Input2["ExclamationMark"] = "!";
  Input2["Hash"] = "#";
  Input2["Dollar"] = "$";
  Input2["AccentU"] = "ù";
  Input2["PageBackward"] = "page backward";
  Input2["PageForWard"] = "page forward";
  Input2["Star"] = "*";
  Input2["DecreaseVolume"] = "decrease volume level";
  Input2["IncreaseVolume"] = "increase volume level";
  Input2["Next"] = "next";
  Input2["Previous"] = "previous";
  Input2["Stop"] = "stop";
  Input2["PlayPause"] = "play/pause";
  Input2["Email"] = "e-mail";
  Input2["SemiColon"] = "semi-colon / ñ";
  Input2["EqualSign"] = "equal sign";
  Input2["Comma"] = "comma";
  Input2["Dash"] = "dash";
  Input2["FowardSlach"] = "forward slash / ç";
  Input2["GraveAccent"] = "grave accent / ñ / æ";
  Input2["OpenBracket"] = "open bracket";
  Input2["BackSlach"] = "back slash";
  Input2["CloseBracket"] = "close bracket / å";
  Input2["SingleQuote"] = "single quote / ø";
  Input2["BackQuote"] = "`";
  Input2["Altgr"] = "altgr";
})(Input || (Input = {}));

// node_modules/@rpgjs/types/lib/Hitbox.js
var HitType;
(function(HitType2) {
  HitType2["Box"] = "box";
  HitType2["Circle"] = "circle";
  HitType2["Polygon"] = "polygon";
})(HitType || (HitType = {}));

// node_modules/@rpgjs/types/lib/Socket.js
var SocketMethods;
(function(SocketMethods2) {
  SocketMethods2["CameraFollow"] = "cameraFollow";
  SocketMethods2["ShowAnimation"] = "showAnimation";
  SocketMethods2["PlaySound"] = "playSound";
  SocketMethods2["ModeMove"] = "modeMove";
})(SocketMethods || (SocketMethods = {}));
var SocketEvents;
(function(SocketEvents2) {
  SocketEvents2["CallMethod"] = "callMethod";
  SocketEvents2["GameReload"] = "gameReload";
  SocketEvents2["ChangeServer"] = "changeServer";
  SocketEvents2["LoadScene"] = "loadScene";
})(SocketEvents || (SocketEvents = {}));

// node_modules/@rpgjs/common/lib/Hit.js
var import_sat = __toESM(require_SAT(), 1);
var HitClass = class {
  createObjectHitbox(x, y, z, w, h) {
    return new import_sat.default.Box(new import_sat.default.Vector(x, y - z), w, h);
  }
  getHitbox(obj, offset) {
    let hitbox, type;
    if (!offset)
      offset = { x: 0, y: 0 };
    const x = obj.x + offset.x;
    const y = obj.y + offset.y;
    if ("ellipse" in obj || obj.type == HitType.Circle) {
      type = HitType.Circle;
      const radius = obj.width / 2;
      hitbox = new import_sat.default.Circle(new import_sat.default.Vector(x + radius, y + radius), radius);
    } else if ("polygon" in obj) {
      type = HitType.Polygon;
      hitbox = new import_sat.default.Polygon(new import_sat.default.Vector(x, y), obj.polygon.map((pos) => new import_sat.default.Vector(+pos.x, +pos.y)));
    } else if (!("polygon" in obj) && "width" in obj && "height" in obj) {
      type = HitType.Box;
      hitbox = new import_sat.default.Box(new import_sat.default.Vector(x, y), obj.width, obj.height);
    } else {
      hitbox = new import_sat.default.Vector(x, y);
      type = obj.type;
    }
    return {
      hitbox,
      type,
      name: obj.name
    };
  }
  testPolyCollision(type, hit1, hit2) {
    let collided = false;
    if (type == HitType.Box) {
      if (hit1.pos.x <= hit2.pos.x + hit2.w && hit1.pos.x + hit1.w >= hit2.pos.x && hit1.pos.y <= hit2.pos.y + hit2.h && hit1.h + hit1.pos.y >= hit2.pos.y) {
        return true;
      }
      return false;
    }
    if (isInstanceOf(hit1, import_sat.default.Box))
      hit1 = hit1.toPolygon();
    if (isInstanceOf(hit2, import_sat.default.Box))
      hit2 = hit2.toPolygon();
    switch (type) {
      case HitType.Circle:
        collided = import_sat.default.testPolygonCircle(hit1, hit2);
        break;
      case HitType.Polygon:
        collided = import_sat.default.testPolygonPolygon(hit1, hit2);
        break;
    }
    return collided;
  }
};
var Hit = new HitClass();

// node_modules/@rpgjs/tiled/lib/types/Layer.js
var TiledLayerType;
(function(TiledLayerType2) {
  TiledLayerType2["Tile"] = "tilelayer";
  TiledLayerType2["ObjectGroup"] = "objectgroup";
  TiledLayerType2["Image"] = "imagelayer";
  TiledLayerType2["Group"] = "group";
})(TiledLayerType || (TiledLayerType = {}));

// node_modules/@rpgjs/tiled/lib/utils.js
function isTiledFormat(val) {
  return typeof val == "object" && val.version && val.orientation;
}

// node_modules/@rpgjs/tiled/lib/parser/parser.js
var import_xml_js = __toESM(require_lib(), 1);
init_buffer_es6();

// node_modules/rollup-plugin-node-polyfills/polyfills/path.js
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last3 = parts[i];
    if (last3 === ".") {
      parts.splice(i, 1);
    } else if (last3 === "..") {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift("..");
    }
  }
  return parts;
}
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};
function resolve() {
  var resolvedPath = "", resolvedAbsolute = false;
  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : "/";
    if (typeof path !== "string") {
      throw new TypeError("Arguments to path.resolve must be strings");
    } else if (!path) {
      continue;
    }
    resolvedPath = path + "/" + resolvedPath;
    resolvedAbsolute = path.charAt(0) === "/";
  }
  resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
    return !!p;
  }), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
}
function normalize(path) {
  var isPathAbsolute = isAbsolute(path), trailingSlash = substr(path, -1) === "/";
  path = normalizeArray(filter(path.split("/"), function(p) {
    return !!p;
  }), !isPathAbsolute).join("/");
  if (!path && !isPathAbsolute) {
    path = ".";
  }
  if (path && trailingSlash) {
    path += "/";
  }
  return (isPathAbsolute ? "/" : "") + path;
}
function isAbsolute(path) {
  return path.charAt(0) === "/";
}
function join() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize(filter(paths, function(p, index) {
    if (typeof p !== "string") {
      throw new TypeError("Arguments to path.join must be strings");
    }
    return p;
  }).join("/"));
}
function relative(from3, to) {
  from3 = resolve(from3).substr(1);
  to = resolve(to).substr(1);
  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== "")
        break;
    }
    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== "")
        break;
    }
    if (start > end)
      return [];
    return arr.slice(start, end - start + 1);
  }
  var fromParts = trim(from3.split("/"));
  var toParts = trim(to.split("/"));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }
  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push("..");
  }
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join("/");
}
var sep = "/";
var delimiter = ":";
function dirname(path) {
  var result = splitPath(path), root = result[0], dir = result[1];
  if (!root && !dir) {
    return ".";
  }
  if (dir) {
    dir = dir.substr(0, dir.length - 1);
  }
  return root + dir;
}
function basename2(path, ext) {
  var f = splitPath(path)[2];
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
}
function extname(path) {
  return splitPath(path)[3];
}
var path_default = {
  extname,
  basename: basename2,
  dirname,
  sep,
  delimiter,
  relative,
  join,
  isAbsolute,
  normalize,
  resolve
};
function filter(xs, f) {
  if (xs.filter)
    return xs.filter(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs))
      res.push(xs[i]);
  }
  return res;
}
var substr = "ab".substr(-1) === "b" ? function(str, start, len) {
  return str.substr(start, len);
} : function(str, start, len) {
  if (start < 0)
    start = str.length + start;
  return str.substr(start, len);
};

// node_modules/@rpgjs/tiled/lib/parser/parser.js
var TiledParser = class _TiledParser {
  constructor(xml, filePath = "") {
    this.xml = xml;
    this.filePath = filePath;
    this.layers = /* @__PURE__ */ new Map();
    this.transform = (obj) => {
      var _a, _b;
      if (!obj)
        return;
      const attr = obj.attributes || obj._attributes;
      if (!attr)
        return obj;
      let newObj = {
        ...obj,
        ...attr,
        ..._TiledParser.propToNumber(attr, [
          "version",
          "width",
          "height",
          "tilewidth",
          "tileheight",
          "nextlayerid",
          "nextobjectid",
          "hexsidelength",
          "opacity",
          "x",
          "y",
          "offsetx",
          "offsety",
          "startx",
          "starty",
          "id",
          "firstgid",
          "imageheight",
          "imagewidth",
          "margin",
          "columns",
          "rows",
          "tilecount",
          "rotation",
          "gid",
          "tileid",
          "duration",
          "parallaxx",
          "parallaxy",
          "repeatx",
          "repeaty",
          "pixelsize"
        ]),
        ..._TiledParser.propToBool(attr, [
          "visible",
          "infinite",
          "locked",
          "bold",
          "italic",
          "kerning",
          "strikeout",
          "underline",
          "wrap"
        ])
      };
      if (newObj.properties) {
        const properties = _TiledParser.toArray(newObj.properties.property);
        const propObj = {};
        for (let prop of properties) {
          const attr2 = prop._attributes;
          if (!attr2)
            continue;
          let val;
          switch (attr2.type) {
            case "file":
              val = this.getImagePath(attr2.value);
              break;
            case "object":
            case "float":
            case "int":
              val = +attr2.value;
              break;
            case "bool":
              val = attr2.value == "true" ? true : false;
              break;
            case "class":
              val = {
                ...((_a = this.transform(prop)) == null ? void 0 : _a.properties) ?? {},
                _classname: attr2.propertytype
              };
              break;
            default:
              val = attr2.value;
          }
          propObj[attr2.name] = val;
        }
        newObj.properties = propObj;
      }
      if (newObj.polygon) {
        newObj.polygon = this.transform(newObj.polygon);
      }
      if (newObj.polyline) {
        newObj.polyline = this.transform(newObj.polyline);
      }
      if (newObj.points) {
        newObj = newObj.points.split(" ").map((point) => {
          const pos = point.split(",");
          return { x: +pos[0], y: +pos[1] };
        });
      }
      if (newObj.point) {
        newObj.point = true;
      }
      if (newObj.ellipse) {
        newObj.ellipse = true;
      }
      if (newObj.text) {
        newObj.text = {
          text: newObj.text._text,
          ...this.transform(newObj.text)
        };
        delete newObj.text._text;
      }
      if (newObj.image) {
        newObj.image = this.transform(newObj.image);
      }
      if (newObj.source) {
        newObj.source = this.getImagePath(newObj.source);
      }
      const objectgroup = newObj.object || ((_b = newObj.objectgroup) == null ? void 0 : _b.object);
      if (objectgroup) {
        newObj.objects = _TiledParser.toArray(objectgroup).map((object) => {
          return this.transform(object);
        });
      }
      delete newObj._attributes;
      delete newObj.attributes;
      delete newObj.object;
      delete newObj.objectgroup;
      return newObj;
    };
  }
  static toArray(prop) {
    if (!prop)
      return [];
    if (!Array.isArray(prop))
      return [prop];
    return prop;
  }
  getImagePath(image) {
    const baseName = path_default.dirname(this.filePath);
    if (this.filePath.startsWith("http"))
      return new URL(image, this.filePath).href;
    return path_default.join(baseName, image);
  }
  static unpackTileBytes(buffer3, size) {
    const expectedCount = size * 4;
    if (buffer3.length !== expectedCount) {
      throw new Error("Expected " + expectedCount + " bytes of tile data; received " + buffer3.length);
    }
    let tileIndex = 0;
    const array = [];
    for (let i = 0; i < expectedCount; i += 4) {
      array[tileIndex] = buffer3.readUInt32LE(i);
      tileIndex++;
    }
    return array;
  }
  static decode(obj, size) {
    const { encoding, data } = obj;
    if (encoding == "base64") {
      return _TiledParser.unpackTileBytes(Buffer2.from(data.trim(), "base64"), size);
    } else if (encoding == "csv") {
      return data.trim().split(",").map((x) => +x);
    }
    return data;
  }
  parseMap() {
    const json = (0, import_xml_js.xml2js)(this.xml, { compact: true });
    const jsonNoCompact = (0, import_xml_js.xml2js)(this.xml);
    const tileset = json.map.tileset;
    const group = json.map.group;
    const recursiveObjectGroup = (obj) => {
      const { objectgroup, group: group2, layer, imagelayer } = obj;
      const setLayer = (type) => {
        if (!type)
          return;
        _TiledParser.toArray(type).forEach((val) => {
          if (this.layers.has(+val._attributes.id)) {
            throw new Error(`Tiled Parser Error: Layer with id ${val._attributes.id} already exists`);
          }
          this.layers.set(+val._attributes.id, val);
        });
      };
      setLayer(objectgroup);
      setLayer(layer);
      setLayer(group2);
      setLayer(imagelayer);
      if (group2) {
        recursiveObjectGroup(group2);
      }
    };
    recursiveObjectGroup(json.map);
    const recursiveLayer = (elements, array = []) => {
      var _a;
      if (!elements)
        return array;
      for (let element of elements) {
        const { name } = element;
        if (!["layer", "group", "imagelayer", "objectgroup"].includes(name))
          continue;
        const data = (_a = element.elements) == null ? void 0 : _a.find((el) => el.name == "data");
        element.layer = this.layers.get(+element.attributes.id);
        const obj = {
          ...this.transform(data) ?? {},
          ...this.transform(element),
          ...this.transform(element.layer),
          layers: recursiveLayer(element.elements),
          data: data ? data.elements[0].text : void 0,
          type: name == "layer" ? "tilelayer" : name
        };
        delete obj.elements;
        delete obj.layer;
        if (obj.data)
          obj.data = _TiledParser.decode(obj, obj.width * obj.height);
        array.push(obj);
      }
      return array;
    };
    const layers = recursiveLayer(jsonNoCompact.elements[0].elements);
    const tilesets = _TiledParser.toArray(tileset).map((tileset2) => {
      const obj = this.transform(tileset2);
      return obj;
    });
    const ret = {
      ...this.transform(json.map),
      layers,
      tilesets
    };
    delete ret.layer;
    delete ret.tileset;
    delete ret.group;
    delete ret.imagelayer;
    return ret;
  }
  parseTileset() {
    const json = (0, import_xml_js.xml2js)(this.xml, { compact: true });
    const { tileset } = json;
    const ret = {
      ...this.transform(tileset),
      image: this.transform(tileset.image),
      tiles: _TiledParser.toArray(tileset.tile).map((tile) => {
        const ret2 = this.transform(tile);
        if (tile.animation) {
          ret2.animations = _TiledParser.toArray(tile.animation.frame).map(this.transform);
        }
        delete ret2.animation;
        return ret2;
      })
    };
    delete ret.tile;
    return ret;
  }
};
TiledParser.propToNumber = (obj, props) => {
  for (let key of props) {
    if (obj[key] !== void 0) {
      obj[key] = +obj[key];
    }
  }
  return obj;
};
TiledParser.propToBool = (obj, props) => {
  for (let key of props) {
    if (obj[key] !== void 0) {
      obj[key] = obj[key] == "true" || obj[key] == "1";
    }
  }
  return obj;
};

// node_modules/@rpgjs/tiled/lib/classes/Properties.js
var TiledProperties = class {
  constructor(data) {
    this.properties = {};
    this.properties = (data == null ? void 0 : data.properties) ?? {};
  }
  getProperty(name, defaultValue) {
    const val = this.properties[name];
    if (val === void 0) {
      return defaultValue;
    }
    return val;
  }
  hasProperty(name) {
    return !!this.properties[name];
  }
  setProperty(name, value) {
    this.properties[name] = value;
  }
  getType() {
    return this.class || this["type"];
  }
};

// node_modules/@rpgjs/tiled/lib/classes/Gid.js
var FLIPPED_HORIZONTALLY_FLAG = 2147483648;
var FLIPPED_VERTICALLY_FLAG = 1073741824;
var FLIPPED_DIAGONALLY_FLAG = 536870912;
var ROTATED_HEXAGONAL_120_FLAG = 268435456;
var TileGid = class _TileGid extends TiledProperties {
  constructor(obj) {
    super(obj);
    this.obj = obj;
    this._gid = obj == null ? void 0 : obj.gid;
  }
  static getRealGid(gid) {
    return gid & ~(FLIPPED_HORIZONTALLY_FLAG | FLIPPED_VERTICALLY_FLAG | FLIPPED_DIAGONALLY_FLAG | ROTATED_HEXAGONAL_120_FLAG);
  }
  get horizontalFlip() {
    return !!(this._gid & FLIPPED_HORIZONTALLY_FLAG);
  }
  get verticalFlip() {
    return !!(this._gid & FLIPPED_VERTICALLY_FLAG);
  }
  get diagonalFlip() {
    return !!(this._gid & FLIPPED_DIAGONALLY_FLAG);
  }
  get rotatedHex120() {
    return !!(this._gid & ROTATED_HEXAGONAL_120_FLAG);
  }
  get gid() {
    return _TileGid.getRealGid(this._gid);
  }
  set gid(val) {
    this._gid = val;
  }
};

// node_modules/@rpgjs/tiled/lib/classes/Tile.js
var Tile = class extends TileGid {
  constructor(tile) {
    super(tile);
    this.tile = tile;
    Reflect.deleteProperty(tile, "gid");
    Object.assign(this, tile);
  }
};

// node_modules/@rpgjs/tiled/lib/classes/Object.js
var TiledObjectClass = class extends TileGid {
  constructor(object) {
    super(object);
    this.layerName = "";
    Object.assign(this, object);
    if (object == null ? void 0 : object.gid) {
      this.y -= this.height;
    }
  }
};

// node_modules/@rpgjs/tiled/lib/classes/Layer.js
var Layer = class _Layer extends TiledProperties {
  get size() {
    return this.data.length;
  }
  constructor(layer, tilesets, parent) {
    super(layer);
    this.tilesets = tilesets;
    this.parent = parent;
    this.cacheTiles = false;
    this.tiles = [];
    Object.assign(this, layer);
    this.mapObjects();
    this.mergePropertiesWithParent();
    this.cacheTiles = this.getProperty("cache-tiles", false);
    if (this.cacheTiles)
      this.propertiesTiles();
  }
  createTile(gid, tileIndex, layerIndex) {
    if (gid == 0) {
      return;
    }
    const realGid = TileGid.getRealGid(gid);
    const tileset = _Layer.findTileSet(realGid, this.tilesets);
    if (!tileset) {
      return void 0;
    }
    const tile = tileset.getTile(realGid - tileset.firstgid);
    if (tile) {
      return new Tile({
        ...tile.tile,
        gid,
        index: tileIndex,
        layerIndex
      });
    }
    return new Tile({
      gid,
      index: tileIndex,
      layerIndex
    });
  }
  mergePropertiesWithParent() {
    const parent = this.getLayerParent();
    if (!this.properties)
      this.properties = {};
    if (!parent)
      return;
    for (let key in parent.properties) {
      const val = parent.properties[key];
      const valChild = this.properties[key];
      if (valChild === void 0) {
        this.properties[key] = val;
      } else {
        if (key == "z") {
          this.properties[key] += val;
        } else {
          continue;
        }
      }
    }
    this.opacity = Math.round((parent.opacity ?? 1) * (this.opacity ?? 1) * 100) / 100;
    this.offsetx = (parent.offsetx ?? 0) + (this.offsetx ?? 0);
    this.offsety = (parent.offsety ?? 0) + (this.offsety ?? 0);
    this.locked = parent.locked ?? false;
  }
  propertiesTiles() {
    if (!this.data)
      return;
    const data = this.data;
    for (let i = 0; i < data.length; i++) {
      const id = data[i];
      this.tiles.push(this.createTile(id, i));
    }
  }
  mapObjects() {
    if (this.objects) {
      this.objects = this.objects.map((object) => {
        const obj = new TiledObjectClass(object);
        obj.layerName = this.name;
        return obj;
      });
    }
  }
  getTileByIndex(tileIndex) {
    if (this.cacheTiles) {
      return this.tiles[tileIndex];
    }
    return this.createTile(this.data[tileIndex], tileIndex);
  }
  static findTileSet(gid, tileSets) {
    let tileset;
    for (let i = tileSets.length - 1; i >= 0; i--) {
      tileset = tileSets[i];
      if (tileset.firstgid && tileset.firstgid <= gid) {
        break;
      }
    }
    return tileset;
  }
  getLayerParent() {
    return this.parent;
  }
  tilesForEach(cb) {
    for (let i = 0; i < this.data.length; i++) {
      if (this.cacheTiles) {
        cb(this.tiles[i], i);
        continue;
      }
      cb(this.createTile(this.data[i], i), i);
    }
  }
  setData(tileIndex, gid) {
    this.data[tileIndex] = gid;
  }
};

// node_modules/@rpgjs/tiled/lib/classes/Tileset.js
var Tileset = class extends TiledProperties {
  constructor(tileset) {
    super(tileset);
    this.tileset = tileset;
    this.cacheTileId = /* @__PURE__ */ new Map();
    Object.assign(this, tileset);
    this.margin = this.margin ?? 0;
    this.spacing = this.spacing ?? 0;
    for (let tile of tileset.tiles) {
      this.addTile(tile);
    }
    Reflect.deleteProperty(this, "tiles");
  }
  addTile(tileObj) {
    const tile = new Tile(tileObj);
    this.cacheTileId.set(tile.id, tile);
    return tile;
  }
  getTile(id) {
    return this.cacheTileId.get(+id);
  }
};

// node_modules/@rpgjs/tiled/lib/parser/open-file.js
var import_fs = __toESM(require_fs(), 1);
var TiledParserFile = class _TiledParserFile {
  constructor(file, { basePath = "", staticDir = "", relativePath = "" } = {}) {
    this.file = file;
    this.basePath = basePath;
    this.staticDir = staticDir;
    this.relativePath = relativePath;
  }
  static isBrowser() {
    return typeof window !== "undefined" && !window.useFileSystem;
  }
  static typeOfFile(file) {
    file = file.trim();
    const isString3 = typeof file == "string";
    const info = {
      isXml: isString3 && file.startsWith("<?xml"),
      isObject: !!file["version"],
      isHttp: isString3 && file.startsWith("http")
    };
    return {
      ...info,
      isPath: !info.isXml && !info.isObject && !info.isHttp
    };
  }
  _parseFile(file, type, cb) {
    const isXml = (content) => _TiledParserFile.typeOfFile(content).isXml;
    const loadContent = (content) => {
      if (!content) {
        return cb(null);
      }
      if (isXml(content)) {
        const parser = new TiledParser(content, this.staticDir ? "" : isXml(file) ? this.relativePath : file);
        if (type == "map") {
          const json = parser.parseMap();
          return cb(json);
        } else if (type == "tileset") {
          const json = parser.parseTileset();
          return cb(json);
        }
      }
      return cb(JSON.parse(content));
    };
    if (_TiledParserFile.typeOfFile(file).isObject) {
      return cb(file);
    }
    const { isHttp } = _TiledParserFile.typeOfFile(file);
    if (isXml(file)) {
      loadContent(file);
    } else if (isHttp || _TiledParserFile.isBrowser() && true) {
      let url = isHttp ? file : path_default.join(this.basePath, this.staticDir, file);
      if (_TiledParserFile.isBrowser() && window.urlCache) {
        url = window.urlCache[file];
      }
      axios_default.get(url).then((res) => res.data).then(loadContent);
    } else {
      let filepath = file;
      if (file.startsWith("/")) {
        filepath = path_default.join(this.basePath ? this.basePath : "", file);
      }
      if (this.staticDir) {
        filepath = path_default.join(this.staticDir, file);
      }
      import_fs.default.readFile(path_default.normalize(filepath), "utf-8", (err, data) => {
        if (err)
          return cb(null, err);
        loadContent(data);
      });
      return;
    }
  }
  parseFile(cb, options = {}) {
    const { getOnlyBasename } = options;
    const basename3 = (path) => path.substring(path.lastIndexOf("/") + 1);
    if (getOnlyBasename) {
      if (_TiledParserFile.typeOfFile(this.file).isPath) {
        this.file = basename3(this.file);
      }
    }
    this._parseFile(this.file, "map", (map2, err) => {
      let hasError = false;
      if (err)
        return cb(null, err);
      if (map2.tilesets) {
        const parseTileset = [];
        const finish = () => {
          loadAll++;
          if (loadAll == map2.tilesets.length && !hasError) {
            map2.tilesets = parseTileset;
            cb(map2);
          }
        };
        let loadAll = 0;
        for (let i = 0; i < map2.tilesets.length; i++) {
          const tileset = map2.tilesets[i];
          if (!tileset.source) {
            parseTileset[i] = tileset;
            finish();
            continue;
          }
          if (getOnlyBasename) {
            if (_TiledParserFile.typeOfFile(tileset.source).isPath) {
              tileset.source = basename3(tileset.source);
            }
          }
          this._parseFile(tileset.source, "tileset", (result, err2) => {
            if (err2) {
              hasError = true;
              return cb(null, err2);
            }
            parseTileset[i] = {
              ...result,
              firstgid: tileset.firstgid
            };
            finish();
          });
        }
      }
    });
  }
  parseFilePromise(options = {}) {
    return new Promise((resolve2, reject) => {
      this.parseFile((ret, err) => {
        if (ret)
          resolve2(ret);
        else
          reject(err);
      }, options);
    });
  }
};

// node_modules/@rpgjs/tiled/lib/classes/Map.js
var bufferTilesets = {};
var MapClass = class extends TiledProperties {
  constructor(map2) {
    super(map2 ?? {});
    this.tilesets = [];
    this.layers = [];
    this.tmpLayers = [];
    this.tilesIndex = {};
    this.allocateMemory = 0;
    this.lowMemory = false;
    if (map2)
      this.load(map2);
  }
  load(map2) {
    Object.assign(this, map2);
    if (this.hasProperty("low-memory")) {
      this.lowMemory = this.getProperty("low-memory", false);
    }
    this.tmpLayers = [];
    this.mapTilesets();
    this.mapLayers(this.layers);
    this.layers = [...this.tmpLayers];
    Reflect.deleteProperty(this, "tmpLayers");
    this.setTilesIndex();
    this.data = map2;
  }
  /**
   * @title Width of the map in pixels
   * @prop {number} [widthPx]
   * @readonly
   * @memberof Map
   * @memberof RpgSceneMap
   * */
  get widthPx() {
    return this.width * this.tilewidth;
  }
  /**
  * @title Height of the map in pixels
  * @prop {number} [heightPx]
  * @readonly
  * @memberof Map
  * @memberof RpgSceneMap
  * */
  get heightPx() {
    return this.height * this.tileheight;
  }
  /**
   * @title The depth of the map in pixels (this is the height of a tile ;))
   * @prop {number} map.zTileHeight
   * @readonly
   * @memberof Map
   * @memberof RpgSceneMap
   * */
  get zTileHeight() {
    return this.tileheight;
  }
  /**
       * Find a layer by name. Returns `undefined` is the layer is not found
  
       * @title Get Layer by name
       * @method map.getLayerByName(name)
       * @param {string} name layer name
       * @returns {LayerInfo | undefined}
       * @example
       *  ```ts
       *  const tiles = map.getLayerByName(0, 0)
       *  ```
       * @memberof Map
       * @memberof RpgSceneMap
       */
  getLayerByName(name) {
    return this.layers.find((layer) => layer.name == name);
  }
  /**
  * Get the tile index on the tileset
  *
  * @title Get index of tile
  * @method map.getTileIndex(x,y)
  * @param {number} x Position X
  * @param {number} x Position Y
  * @returns {number}
  * @memberof Map
  * @memberof RpgSceneMap
  */
  getTileIndex(x, y, [z] = [0]) {
    return this.width * Math.floor((y - z) / this.tileheight) + Math.floor(x / this.tilewidth);
  }
  getTilePosition(index) {
    return {
      y: Math.floor(index / this.width) * this.tileheight,
      x: index % this.width * this.tilewidth
    };
  }
  /**
       * Find the point of origin (top left) of a tile. Of course, its position depends on the size of the tile
  
       * @title Get origin position of tile
       * @method map.getTileOriginPosition(x,y)
       * @param {number} x Position X
       * @param {number} x Position Y
       * @returns { {x: number, y: number }}
       * @example
       *  ```ts
       *  // If the size of a tile is 32x32px
       *  const position = map.getTileOriginPosition(35, 12)
       *  console.log(position) // { x: 32, y: 0 }
       *  ```
       * @memberof Map
       * @memberof RpgSceneMap
       */
  getTileOriginPosition(x, y) {
    return {
      x: Math.floor(x / this.tilewidth) * this.tilewidth,
      y: Math.floor(y / this.tileheight) * this.tileheight
    };
  }
  /**
      * Recover tiles according to a position
  
      * @title Get tile by position
      * @method map.getTileByPosition(x,y)
      * @param {number} x Position X
      * @param {number} x Position Y
      * @returns {TileInfo}
      * @example
      *  ```ts
      *  const tiles = map.getTileByPosition(0, 0)
      *  ```
      * @memberof Map
      * @memberof RpgSceneMap
      */
  getTileByPosition(x, y, z = [0, 0], options = {}) {
    const tileIndex = this.getTileIndex(x, y, [z[0]]);
    return this.getTileByIndex(tileIndex, z, options);
  }
  /**
       * Retrieves tiles according to its index
  
       * @title Get tile by index
       * @method map.getTileByIndex(tileIndex)
       * @param {number} tileIndex tile index
       * @returns {TileInfo}
       * @example
       *  ```ts
       *  const index = map.getTileIndex(0, 0)
       *  const tiles = map.getTileByIndex(index)
       *  ```
       * @memberof Map
       * @memberof RpgSceneMap
       */
  getTileByIndex(tileIndex, zPlayer = [0, 0], options = {
    populateTiles: true
  }) {
    const zA = Math.floor(zPlayer[0] / this.zTileHeight);
    const zB = Math.floor(zPlayer[1] / this.zTileHeight);
    const level = this.tilesIndex[zA];
    const obj = {
      tiles: [],
      hasCollision: true,
      isOverlay: false,
      objectGroups: [],
      tileIndex
    };
    if (!level) {
      return obj;
    }
    const [layer] = this.layers;
    const getTileByPointer = (pointer = 0) => {
      const pos = tileIndex * this.realAllocateMemory + pointer;
      const gid = level[pos];
      if (gid === 0) {
        return obj;
      }
      const tile2 = layer.createTile(gid, tileIndex, level[pos + 1]);
      if (tile2)
        obj.tiles.push(tile2);
    };
    if (options.populateTiles) {
      for (let i = 0; i < this.realAllocateMemory; i += 2) {
        getTileByPointer(i);
      }
    } else {
      getTileByPointer();
    }
    const [tile] = obj.tiles;
    if (tile) {
      obj.hasCollision = tile.getProperty("collision", false);
      obj.objectGroups = tile.objects ?? [];
    }
    return obj;
  }
  getAllObjects() {
    return this.layers.reduce((prev, current) => {
      if (!current.objects)
        return prev;
      return prev.concat(...current.objects);
    }, []);
  }
  getData() {
    return {
      ...this.data,
      layers: this.layers
    };
  }
  setTile(x, y, layerFilter, tileInfo) {
    if (this.lowMemory) {
      throw "Impossible to change a tile with the lowMemory option";
    }
    const tileIndex = this.getTileIndex(x, y);
    let fnFilter;
    let tilesEdited = {};
    if (typeof layerFilter == "string") {
      fnFilter = (layer) => layer.name == layerFilter;
    } else {
      fnFilter = layerFilter;
    }
    for (let i = 0; i < this.layers.length; i++) {
      const layer = this.layers[i];
      if (!fnFilter(layer))
        continue;
      let tile;
      const oldTile = this.getTileByIndex(tileIndex);
      if (tileInfo.gid) {
        tile = layer.createTile(tileInfo.gid, tileIndex);
      }
      if (!tile)
        continue;
      for (let key in tileInfo) {
        if (key == "gid")
          continue;
        tile[key] = tileInfo[key];
      }
      tilesEdited[layer.name] = {
        gid: tile.gid,
        properties: tile.properties
      };
      this.setTileIndex(layer, oldTile.tiles[0], tile, tileIndex, i);
      layer.setData(tileIndex, tile.gid);
    }
    return {
      x,
      y,
      tiles: tilesEdited
    };
  }
  removeCacheTileset(name) {
    delete bufferTilesets[name];
  }
  clearCacheTilesets() {
    bufferTilesets = {};
  }
  mapTilesets() {
    this.tilesets = this.tilesets.map((tileset) => {
      if (bufferTilesets[tileset.name]) {
        const instance = bufferTilesets[tileset.name];
        instance.firstgid = tileset.firstgid;
        return instance;
      }
      const _tileset = new Tileset(tileset);
      bufferTilesets[_tileset.name] = _tileset;
      return _tileset;
    });
  }
  mapLayers(layers = [], parent) {
    for (let layer of layers) {
      const layerInstance = new Layer(layer, this.tilesets, parent);
      this.tmpLayers.push(layerInstance);
      if (layer.layers) {
        this.mapLayers(layer.layers, layerInstance);
      }
    }
    if (this.lowMemory)
      this.allocateMemory = 1;
    if (!this.allocateMemory)
      this.allocateMemory = this.layers.length;
  }
  setTileIndex(layer, oldTile, newTile, tileIndex, layerIndex) {
    const startPos = tileIndex * this.realAllocateMemory;
    let pointer = startPos + this.realAllocateMemory - 2;
    const zLayer = layer.getProperty("z", 0);
    const zTile = oldTile.getProperty("z", 0);
    let z = zLayer + zTile;
    while (pointer >= startPos) {
      const zlayer = this.tilesIndex[z];
      if (zlayer[pointer] === oldTile.gid && zlayer[pointer + 1] === layerIndex) {
        this.tilesIndex[z][pointer] = newTile.gid;
      }
      pointer -= 2;
    }
  }
  /**
   * We multiply by 2 because 2 entries are stored for a tile: its GID and the Layer Index
   *
   * Example If I have 3 layers, The array will have the following form
   *
   * [
   *  GID of Layer 3,
   *  Layer Index of Layer 3,
   *  GID of Layer 2,
   *  Layer Index of Layer 2,
   *  GID of Layer 1,
   *  Layer Index of Layer 1,
   * ... others tiles
   * ]
   *
   * The size in memory of the map is therefore:
   *
   * `(map width * map height * number of layers * 4) bytes`
   *
   * > We multiply by 4, because an element takes 2 bytes and has 2 elements for a tile is 4 bytes in all
   *
   * Example (a 100x100 map with 5 layers)
   *
   * `100 * 100 * 5 * 4 = 200000 bytes = ~195 Kb`
   *
   * If we define on lowMemory then the calculation is the following
   *
   * `(map width * map height * 4) bytes`
   *
   * Example
   *
   * `100 * 100 * 4 = 40000 bytes = ~39 Kb`
   */
  get realAllocateMemory() {
    return this.allocateMemory * 2;
  }
  /**
   * We keep each tile in memory classified by z value. The values are ordered from the end to the beginning so that the first element of the array (when retrieved with getTileByIndex() is the tile on the highest layer. This way, the tile search is very fast for collisions
   *
   */
  addTileIndex(layer, tile, tileIndex, layerIndex) {
    if (!tile || tile && tile.gid == 0) {
      return;
    }
    const zLayer = layer.getProperty("z", 0);
    const zTile = tile.getProperty("z", 0);
    let z = zLayer + zTile;
    if (!this.tilesIndex[z]) {
      const buffer3 = new ArrayBuffer(layer.size * this.realAllocateMemory * 2);
      this.tilesIndex[z] = new Uint16Array(buffer3);
    }
    const startPos = tileIndex * this.realAllocateMemory;
    let pointer = startPos + this.realAllocateMemory - 2;
    while (this.tilesIndex[z][pointer] !== 0 && pointer > startPos) {
      pointer -= 2;
    }
    this.tilesIndex[z][pointer] = tile.gid;
    this.tilesIndex[z][pointer + 1] = layerIndex;
    this.tilesIndex[z][startPos] = tile.gid;
    this.tilesIndex[z][startPos + 1] = layerIndex;
  }
  setTilesIndex() {
    for (let i = 0; i < this.layers.length; i++) {
      const layer = this.layers[i];
      if (layer.type != TiledLayerType.Tile) {
        continue;
      }
      layer.tilesForEach((tile, index) => {
        this.addTileIndex(layer, tile, index, i);
      });
    }
  }
};

// node_modules/@rpgjs/common/lib/Vector2d.js
var Vector2d = class _Vector2d {
  constructor(x, y, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  set(vector) {
    this.x = vector.x;
    this.y = vector.y;
    this.z = vector.z;
    return this;
  }
  add(vector) {
    this.x += vector.x;
    this.y += vector.y;
    return this;
  }
  subtract(vector) {
    this.x -= vector.x;
    this.y -= vector.y;
    return this;
  }
  multiply(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(scalar) {
    this.x /= scalar;
    this.y /= scalar;
    return this;
  }
  distanceWith(vector) {
    const dx = this.x - vector.x;
    const dy = this.y - vector.y;
    return Math.sqrt(dx ** 2 + dy ** 2);
  }
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  copy() {
    return new _Vector2d(this.x, this.y, this.z);
  }
  normalize() {
    return this.divide(this.magnitude());
  }
  isEqual(vector) {
    return this.x === vector.x && this.y === vector.y && this.z === vector.z;
  }
  hasDifferentValues(vector) {
    return this.x !== vector.x || this.y !== vector.y || this.z !== vector.z;
  }
};
var Vector2dZero = class extends Vector2d {
  constructor() {
    super(0, 0);
  }
};

// node_modules/@rpgjs/common/lib/Shape.js
var ShapePositioning;
(function(ShapePositioning2) {
  ShapePositioning2["Default"] = "default";
  ShapePositioning2["Center"] = "center";
})(ShapePositioning || (ShapePositioning = {}));
var RpgShape = class extends TiledObjectClass {
  constructor(obj) {
    super();
    this.type = HitType.Box;
    this.class = "";
    this.name = "";
    this.playersIn = {};
    this.clientContainer = null;
    this.positioning = ShapePositioning.Default;
    this.components = [];
    Reflect.deleteProperty(obj, "id");
    this.set(obj);
  }
  setPos(type, val) {
    if (!this.hitbox.pos)
      return;
    if (this.isShapePosition()) {
      this.hitbox[type] = val;
    } else {
      this.hitbox.pos[type] = val;
    }
  }
  get hasCollision() {
    return this.getProperty("collision", false);
  }
  // alias
  get id() {
    return this.name;
  }
  get hitbox() {
    if (this.fixEvent) {
      this._hitbox.pos.x = this.fixEvent.position.x;
      this._hitbox.pos.y = this.fixEvent.position.y;
      switch (this.positioning) {
        case ShapePositioning.Center:
          this._hitbox.pos.x -= this._hitbox.w / 2 - this.fixEvent.hitbox.w / 2;
          this._hitbox.pos.y -= this._hitbox.h / 2 - this.fixEvent.hitbox.h / 2;
          break;
      }
    }
    return this._hitbox;
  }
  set hitbox(val) {
    this._hitbox = val;
  }
  /**
  * Get/Set width
  * @title width
  * @prop { number } width
  * @since 3.0.0-beta.5
  * @memberof Shape
  */
  get width() {
    return this.hitbox.w || 0;
  }
  set width(val) {
    this.setPos("w", val);
  }
  /**
  * Get/Set height
  * @title height
  * @prop { number } height
  * @since 3.0.0-beta.5
  * @memberof Shape
  */
  get height() {
    return this.hitbox.h || 0;
  }
  set height(val) {
    this.setPos("h", val);
  }
  /**
  * Get/Set x
  * @title x
  * @prop { number } x
  * @memberof Shape
  */
  get x() {
    return this.hitbox.x || this.hitbox.pos.x;
  }
  set x(val) {
    this.setPos("x", val);
  }
  get z() {
    return this.getProperty("z");
  }
  /**
  * Get/Set y
  * @title y
  * @prop { number } y
  * @memberof Shape
  */
  get y() {
    return this.hitbox.y || this.hitbox.pos.y;
  }
  set y(val) {
    this.setPos("y", val);
  }
  get position() {
    return new Vector2d(this.x, this.y, this.z);
  }
  /**
      * Get/Set properties
  
      * @title Properties
      * @prop { object } Properties
      * @memberof Shape
      */
  isEvent() {
    return this.type == PlayerType.Event;
  }
  set(obj) {
    const hit = Hit.getHitbox(obj);
    Object.assign(this, hit);
    const objClone = { ...obj };
    ["width", "height", "x", "y"].forEach((prop) => Reflect.deleteProperty(objClone, prop));
    Object.assign(this, objClone);
    const findPoint = (prop, isMin) => {
      return this.hitbox.points.sort((a, b) => isMin ? a[prop] - b[prop] : b[prop] - a[prop])[0][prop];
    };
    if (this.type == HitType.Polygon) {
      this.hitbox.minX = findPoint("x", true);
      this.hitbox.maxX = findPoint("x", false);
      this.hitbox.minY = findPoint("y", true);
      this.hitbox.maxY = findPoint("y", false);
    }
    this.positioning = obj.positioning;
    this.fixEvent = obj.fixEvent;
    this.setComponent();
  }
  setComponent() {
    const color = this.getProperty("color");
    const image = this.getProperty("image");
    if (color) {
      this.components = [{
        id: "shape",
        value: {
          fill: color
        }
      }];
      return;
    }
    if (image) {
      this.components = [{ id: "image", value: image }];
      return;
    }
    if (this.text) {
      this.components = [{ id: "text", value: this.text.text }];
      return;
    }
    if (this.gid) {
      this.components = [{ id: "tile", value: this.gid }];
      return;
    }
  }
  getType() {
    return this.class || this.type;
  }
  async in(player) {
    var _a;
    if (!this.playerIsIn(player)) {
      this.playersIn[player.id] = true;
      player.inShapes[this.name] = this;
      await player.execMethod("onInShape", [this]);
      await ((_a = this.fixEvent) == null ? void 0 : _a.execMethod("onDetectInShape", [player, this], this.fixEvent));
      await player.execMethod("onIn", [player], this);
      return true;
    }
    return false;
  }
  async out(player) {
    var _a;
    if (this.playerIsIn(player)) {
      delete this.playersIn[player.id];
      delete player.inShapes[this.name];
      await player.execMethod("onOutShape", [this]);
      await ((_a = this.fixEvent) == null ? void 0 : _a.execMethod("onDetectOutShape", [player, this], this.fixEvent));
      await player.execMethod("onOut", [player], this);
      return true;
    }
    return false;
  }
  /**
   * Whether the player is in this shape
   *
   * @title Player is in this shape ?
   * @method shape.playerIsIn(player)
   * @returns {boolean}
   * @memberof Shape
   */
  playerIsIn(player) {
    return !!this.playersIn[player.id];
  }
  isShapePosition() {
    return this.type !== HitType.Box && this.type !== HitType.Circle && this.type !== HitType.Polygon;
  }
  /**
    * Recover the player with the shape. You must have used the `attachShape()` method on the player
    *
    * @title Get Player Owner
    * @method shape.getPlayerOwner()
    * @returns {RpgPlayer | undefined}
    * @memberof Shape
    */
  getPlayerOwner() {
    return this.fixEvent;
  }
  /**
   * We get the rectangle of a shape (box, circle and polygon). We use in the grid system to recover a shape.
   * Generally we add a margin (size of a tile) to detect if the player enters or leaves a shape
   * @param margin
   * @returns { minX: number, minY: number, maxX: number, maxY: number }
   */
  getSizeBox(margin = 0) {
    if (this.type == HitType.Circle) {
      const radius = this.hitbox.r;
      return {
        minX: this.x - radius - margin,
        maxX: this.x + radius + margin,
        minY: this.y - radius - margin,
        maxY: this.y + radius + margin
      };
    }
    if (this.type == HitType.Polygon) {
      return {
        minX: this.x + this.hitbox.minX - margin,
        maxX: this.x + this.hitbox.maxX + margin,
        minY: this.y + this.hitbox.minY - margin,
        maxY: this.y + this.hitbox.maxY + margin
      };
    }
    return {
      minX: this.x - margin,
      maxX: this.x + this.width + margin,
      minY: this.y - margin,
      maxY: this.y + this.height + margin
    };
  }
};

// node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from3, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from3.length, ar; i < l; i++) {
      if (ar || !(i in from3)) {
        if (!ar)
          ar = Array.prototype.slice.call(from3, 0, i);
        ar[i] = from3[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from3));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume2(n, v);
        });
      };
      if (f)
        i[n] = f(i[n]);
    }
  }
  function resume2(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume2("next", value);
  }
  function reject(value) {
    resume2("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume2(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve2, reject) {
        v = o[n](v), settle(resolve2, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve2, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve2({ value: v2, done: d });
    }, reject);
  }
}

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction3(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction3(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction3(value.remove) && isFunction3(value.add) && isFunction3(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction3(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config2 = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config2.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop2() {
}

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config2.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config2.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction3(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config2.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config2.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config2.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop2,
  error: defaultErrorHandler,
  complete: noop2
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve2
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve2(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config2.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction3(value.next) && isFunction3(value.error) && isFunction3(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction3(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init2) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init2(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction3(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}

// node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);

// node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id = 0;
    var run = function() {
      if (!subscriber.closed) {
        id = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id = 0;
          var now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id) {
        animationFrameProvider.cancelAnimationFrame(id);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy2 = _buffer.slice();
    for (var i = 0; i < copy2.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy2[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last3 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last3 = i;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      immediateProvider.clearImmediate(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = function() {
  function Scheduler3(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler3.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler3.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  };
  Scheduler3.now = dateTimestampProvider.now;
  return Scheduler3;
}();

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state, delay2);
    }
    this.delay = delay2;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      animationFrameProvider.cancelAnimationFrame(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay2);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay2);
    }
  };
  VirtualAction2.sortActions = function(a, b) {
    if (a.delay === b.delay) {
      if (a.index === b.index) {
        return 0;
      } else if (a.index > b.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a.delay > b.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction3(value.schedule);
}

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction3(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise2(value) {
  return isFunction3(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction3(input[observable]);
}

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction3(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction3(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done2;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false)
            return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done2 = _a.done;
          if (!done2)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction3(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike2(input);
    }
    if (isPromise2(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction3(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike2(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done2;
        try {
          _a = iterator2.next(), value = _a.value, done2 = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done2) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction3(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise2(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from2(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from2(args, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction3(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init2 = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init2, 0, subscriber);
  } : init2);
}

// node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a;
    return isFunction3((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
}();
function observeNotification(notification, observer) {
  var _a, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/rxjs/dist/esm5/internal/lastValueFrom.js
function lastValueFrom(source, config3) {
  var hasConfig = typeof config3 === "object";
  return new Promise(function(resolve2, reject) {
    var _hasValue = false;
    var _value;
    source.subscribe({
      next: function(value) {
        _value = value;
        _hasValue = true;
      },
      error: reject,
      complete: function() {
        if (_hasValue) {
          resolve2(_value);
        } else if (hasConfig) {
          resolve2(config3.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray4 = Array.isArray;
function callOrApply(fn, args) {
  return isArray4(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray5 = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf;
var objectProto = Object.prototype;
var getKeys = Object.keys;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray5(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys2 = getKeys(first_1);
      return {
        args: keys2.map(function(key) {
          return first_1[key];
        }),
        keys: keys2
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}

// node_modules/rxjs/dist/esm5/internal/util/createObject.js
function createObject(keys2, values) {
  return keys2.reduce(function(result, key, i) {
    return result[key] = values[i], result;
  }, {});
}

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
function combineLatest() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), observables = _a.args, keys2 = _a.keys;
  if (observables.length === 0) {
    return from2([], scheduler);
  }
  var result = new Observable(combineLatestInit(observables, scheduler, keys2 ? function(values) {
    return createObject(keys2, values);
  } : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i2) {
        maybeSchedule(scheduler, function() {
          var source = from2(observables[i2], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i2] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i = 0; i < length; i++) {
        _loop_1(i);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer3 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer3.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer3.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer3.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer3.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction3(resultSelector)) {
    return mergeMap(function(a, i) {
      return map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/forkJoin.js
function forkJoin() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), sources = _a.args, keys2 = _a.keys;
  var result = new Observable(function(subscriber) {
    var length = sources.length;
    if (!length) {
      subscriber.complete();
      return;
    }
    var values = new Array(length);
    var remainingCompletions = length;
    var remainingEmissions = length;
    var _loop_1 = function(sourceIndex2) {
      var hasValue = false;
      innerFrom(sources[sourceIndex2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (!hasValue) {
          hasValue = true;
          remainingEmissions--;
        }
        values[sourceIndex2] = value;
      }, function() {
        return remainingCompletions--;
      }, void 0, function() {
        if (!remainingCompletions || !hasValue) {
          if (!remainingEmissions) {
            subscriber.next(keys2 ? createObject(keys2, values) : values);
          }
          subscriber.complete();
        }
      }));
    };
    for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
      _loop_1(sourceIndex);
    }
  });
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}

// node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable(noop2);

// node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
var isArray6 = Array.isArray;

// node_modules/rxjs/dist/esm5/internal/operators/filter.js
function filter2(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first2 = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a, b) {
  return a === b;
}

// node_modules/rxjs/dist/esm5/internal/operators/finalize.js
function finalize(callback) {
  return operate(function(source, subscriber) {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop2));
    !subscriber.closed && source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/timeInterval.js
var TimeInterval = function() {
  function TimeInterval2(value, interval2) {
    this.value = value;
    this.interval = interval2;
  }
  return TimeInterval2;
}();

// node_modules/@rpgjs/common/lib/EventEmitter.js
var EventEmitter2 = class {
  constructor() {
    this.listeners = {};
    this.listenersOnce = {};
  }
  has(name) {
    return !!this.listeners[name] || !!this.listenersOnce[name];
  }
  once(name, cb) {
    this.listenersOnce[name] = cb;
    return this;
  }
  on(name, cb) {
    if (!this.listeners[name])
      this.listeners[name] = [];
    this.listeners[name].push(cb);
    return this;
  }
  emit(name, data, rest = false) {
    const ret = [];
    if (this.listeners[name]) {
      for (let listener of this.listeners[name]) {
        if (rest)
          ret.push(listener(...data));
        else
          ret.push(listener(data));
      }
    }
    if (this.listenersOnce[name]) {
      if (rest)
        ret.push(this.listenersOnce[name](...data));
      else
        ret.push(this.listenersOnce[name](data));
    }
    return Promise.all(ret.map((val) => {
      if (!isPromise(val)) {
        return Promise.resolve(val);
      }
      return val;
    }));
  }
  off(name, listener) {
    if (!listener) {
      delete this.listeners[name];
      delete this.listenersOnce[name];
      return;
    }
    if (this.listeners[name]) {
      const index = this.listeners[name].indexOf(listener);
      if (index !== -1) {
        this.listeners[name].splice(index, 1);
      }
    }
  }
  clear() {
    this.listeners = {};
    this.listenersOnce = {};
  }
};

// node_modules/@rpgjs/common/lib/Plugin.js
var HookServer;
(function(HookServer2) {
  HookServer2["Start"] = "Server.Start";
  HookServer2["Step"] = "Server.Step";
  HookServer2["Auth"] = "Server.Auth";
  HookServer2["PlayerConnected"] = "Server.onConnected";
  HookServer2["PlayerDisconnected"] = "Server.onDisconnected";
  HookServer2["AddMap"] = "Server.AddMap";
  HookServer2["AddEvent"] = "Server.AddEvent";
  HookServer2["AddWorldMaps"] = "Server.AddWorldMaps";
  HookServer2["AddDatabase"] = "Server.AddDatabase";
  HookServer2["PlayerInput"] = "Server.onInput";
  HookServer2["PlayerJoinMap"] = "Server.onJoinMap";
  HookServer2["PlayerLeaveMap"] = "Server.onLeaveMap";
  HookServer2["PlayerLevelUp"] = "Server.onLevelUp";
  HookServer2["PlayerDead"] = "Server.onDead";
  HookServer2["PlayerInShape"] = "Server.onInShape";
  HookServer2["PlayerOutShape"] = "Server.onOutShape";
  HookServer2["PlayerMove"] = "Server.PlayerMove";
  HookServer2["PlayerCanChangeMap"] = "Server.PlayerCanChangeMap";
  HookServer2["ScalabilityPlayerConnected"] = "Server.ScalabilityPlayerConnected";
  HookServer2["ScalabilityChangeServer"] = "Server.ScalabilityChangeServer";
})(HookServer || (HookServer = {}));
var HookClient;
(function(HookClient2) {
  HookClient2["Start"] = "Client.Start";
  HookClient2["Step"] = "Client.Step";
  HookClient2["Connected"] = "Client.Connected";
  HookClient2["Disconnect"] = "Client.Disconnect";
  HookClient2["ConnectedError"] = "Client.ConnectedError";
  HookClient2["AddSpriteSheet"] = "Client.AddSpriteSheet";
  HookClient2["AddGui"] = "Client.AddGui";
  HookClient2["AddSound"] = "Client.AddSound";
  HookClient2["SendInput"] = "Client.SendInput";
  HookClient2["BeforeSceneLoading"] = "Client.BeforeSceneLoading";
  HookClient2["AfterSceneLoading"] = "Client.AfterSceneLoading";
  HookClient2["SceneMapLoading"] = "Client.SceneMapLoading";
  HookClient2["SceneAddSprite"] = "Client.SceneAddSprite";
  HookClient2["SceneOnChanges"] = "Client.SceneOnChanges";
  HookClient2["SceneDraw"] = "Client.SceneDraw";
  HookClient2["SceneRemoveSprite"] = "Client.SceneRemoveSprite";
  HookClient2["AddSprite"] = "Client.AddSprite";
  HookClient2["RemoveSprite"] = "Client.RemoveSprite";
  HookClient2["UpdateSprite"] = "Client.UpdateSprite";
  HookClient2["ChangesSprite"] = "Client.ChangesSprite";
  HookClient2["WindowResize"] = "Client.WindowResize";
  HookClient2["SpriteMove"] = "Client.SpriteMove";
})(HookClient || (HookClient = {}));
var PluginSystem = class extends EventEmitter2 {
  constructor() {
    super(...arguments);
    this.customHooks = {};
  }
  customHookExists(name) {
    return this.customHooks[name];
  }
  loadPlugins(plugins, shared, type) {
    if (!plugins)
      return;
    for (let plugin of plugins) {
      if (!plugin)
        continue;
      let plug = [];
      if (!isArray(plugin)) {
        plug = [plugin];
      } else {
        plug = plugin;
      }
      const [side, options] = plug;
      if (!side[type])
        continue;
      side[type]({
        RpgPlugin,
        ...shared
      }, options);
    }
  }
  loadServerPlugins(plugins, shared) {
    this.loadPlugins(plugins, shared, "server");
  }
  loadClientPlugins(plugins, shared) {
    this.loadPlugins(plugins, shared, "client");
  }
};
var RpgPlugin = new PluginSystem();

// node_modules/@rpgjs/common/lib/AbstractObject.js
var import_sat2 = __toESM(require_SAT(), 1);

// node_modules/@rpgjs/common/lib/VirtualGrid.js
var VirtualGrid = class {
  constructor(nbCellWidth, cellWidth, cellHeight) {
    this.nbCellWidth = nbCellWidth;
    this.cellWidth = cellWidth;
    this.cellHeight = cellHeight;
    this.cells = /* @__PURE__ */ new Map();
    this.inverseCells = /* @__PURE__ */ new Map();
  }
  zoom(nbCell) {
    this.nbCellWidth = Math.ceil(this.nbCellWidth / nbCell);
    this.cellWidth *= nbCell;
    this.cellHeight *= nbCell;
    return this;
  }
  getCellIndex(x, y) {
    return this.nbCellWidth * Math.floor(y / this.cellHeight) + Math.floor(x / this.cellWidth);
  }
  getCells(box, cb) {
    const { minX, minY, maxX, maxY } = box;
    const topLeft = this.getCellIndex(minX, minY);
    const topRight = this.getCellIndex(maxX, minY);
    const bottomLeft = this.getCellIndex(minX, maxY);
    const nbLines = (bottomLeft - topLeft) / this.nbCellWidth + 1;
    for (let j = 0; j < nbLines; j++) {
      for (let i = topLeft; i <= topRight; i++) {
        const index = i + j * this.nbCellWidth;
        cb(index);
      }
    }
  }
  getObjectsByBox(box) {
    let objects = [];
    this.getCells(box, (index) => {
      objects = [...objects, ...this.cells.get(index) || []];
    });
    return new Set(objects);
  }
  getObjectsById(id) {
    let objects = [];
    const cells = this.inverseCells.get(id);
    cells == null ? void 0 : cells.forEach((index) => {
      objects = [...objects, ...this.cells.get(index) || []];
    });
    return new Set(objects);
  }
  clearObjectInCells(id) {
    var _a;
    if (this.inverseCells.has(id)) {
      (_a = this.inverseCells.get(id)) == null ? void 0 : _a.forEach((cellIndex) => {
        var _a2;
        (_a2 = this.cells.get(cellIndex)) == null ? void 0 : _a2.delete(id);
      });
      this.inverseCells.delete(id);
    }
  }
  insertInCells(id, box) {
    this.clearObjectInCells(id);
    const cells = /* @__PURE__ */ new Set();
    this.getCells(box, (index) => {
      var _a;
      cells.add(index);
      const memoryCells = this.cells.get(index);
      if (!memoryCells) {
        this.cells.set(index, /* @__PURE__ */ new Set());
      }
      (_a = this.cells.get(index)) == null ? void 0 : _a.add(id);
    });
    this.inverseCells.set(id, cells);
  }
};

// node_modules/@rpgjs/common/lib/Map.js
var buffer2 = /* @__PURE__ */ new Map();
var bufferClient = /* @__PURE__ */ new Map();
var RpgCommonMap = class extends MapClass {
  constructor() {
    super(...arguments);
    this.shapes = {};
  }
  get tileWidth() {
    return this.tilewidth;
  }
  get tileHeight() {
    return this.tileheight;
  }
  /**
   * Retrieves the X position of the map in the world (0 if no world assigned)
   *
   * @title World X Position
   * @prop {number} [worldX]
   * @readonly
   * @since 3.0.0-beta.8
   * @memberof Map
   * */
  get worldX() {
    var _a, _b;
    return ((_b = (_a = this.getInWorldMaps()) == null ? void 0 : _a.getMapInfo(this.id)) == null ? void 0 : _b.x) || 0;
  }
  /**
   * Retrieves the Y position of the map in the world (0 if no world assigned)
   *
   * @title World Y Position
   * @prop {number} [worldY]
   * @readonly
   * @since 3.0.0-beta.8
   * @memberof Map
   * */
  get worldY() {
    var _a, _b;
    return ((_b = (_a = this.getInWorldMaps()) == null ? void 0 : _a.getMapInfo(this.id)) == null ? void 0 : _b.y) || 0;
  }
  /**
   * Memorize the maps so you don't have to make a new request or open a file each time you load a map
   */
  static get buffer() {
    return buffer2;
  }
  /**
   * In RPG mode, to avoid confusion with buffer, we have a new variable to memorize the maps
   */
  static get bufferClient() {
    return bufferClient;
  }
  load(data) {
    super.load(data);
    this.gridTiles = new VirtualGrid(this.width, this.tileWidth, this.tileHeight);
    this.grid = new VirtualGrid(this.width, this.tileWidth, this.tileHeight).zoom(10);
    this.gridShapes = new VirtualGrid(this.width, this.tileWidth, this.tileHeight).zoom(20);
  }
  /**
   * Create a shape dynamically on the map
   *
   * Object:
   *  - (number) x: Position X
   *  - (number) y: Position Y
   *  - (number) width: Width
   *  - (number) height: Height
   *  - (object) properties (optionnal):
   *      - (number) z: Position Z
   *      - (hexadecimal) color: Color (shared with client)
   *      - (boolean) collision
   *      - You can your own properties
   *
   * @title Create Shape
   * @since 3.0.0-beta.3
   * @method map.createShape(obj)
   * @param {object} obj
   * @returns {RpgShape}
   * @memberof Map
   */
  createShape(obj) {
    const id = obj.name = obj.name || generateUID();
    const shape = new RpgShape(obj);
    this.shapes[id] = shape;
    if (!shape.isShapePosition()) {
      this.gridShapes.insertInCells(id, shape.getSizeBox(this.tileWidth));
    }
    return this.shapes[id];
  }
  /**
   * Delete a shape
   *
   * @title Delete Shape
   * @method map.removeShape(name)
   * @param {string} name Name of shape
   * @returns {void}
   * @memberof Map
   */
  removeShape(name) {
    delete this.shapes[name];
  }
  clearShapes() {
    this.shapes = {};
  }
  /**
   * Return all shapes on the map
   *
   * @title Get Shapes
   * @method map.getShapes()
   * @returns {RpgShape[]}
   * @memberof Map
   * @memberof RpgSceneMap
   */
  getShapes() {
    return Object.values(this.shapes);
  }
  /**
   * Returns a shape by its name. Returns undefined is nothing is found
   *
   * @title Get Shape by name
   * @method map.getShape(name)
   * @param {string} name Name of shape
   * @returns {RpgShape[] | undefined}
   * @memberof Map
   * @memberof RpgSceneMap
   */
  getShape(name) {
    return this.getShapes().find((shape) => shape.name == name);
  }
  getPositionByShape(filter3) {
    const startsFind = this.getShapes().filter(filter3);
    if (startsFind.length) {
      const start = startsFind[random(0, startsFind.length - 1)];
      return { x: start.hitbox.x, y: start.hitbox.y, z: start.properties.z * this.zTileHeight || 0 };
    }
    return null;
  }
  /**
   * Get tile and verify collision with hitbox
   * @param hitbox
   * @param x
   * @param y
   * @param z
   * @returns TileInfo
   */
  getTile(hitbox, x, y, z = [0, 0]) {
    const tile = { ...this.getTileByPosition(x, y, z) };
    const tilePos = this.getTileOriginPosition(x, y);
    if (tile.objectGroups) {
      for (let object of tile.objectGroups) {
        const hit = Hit.getHitbox(object, {
          x: tilePos.x,
          y: tilePos.y
        });
        if (hit.type) {
          const collided = Hit.testPolyCollision(hit.type, hit.hitbox, hitbox);
          if (collided) {
            tile.hasCollision = true;
          }
        }
      }
    }
    return tile;
  }
  /**
       * Assign the map to a world
  
       * @title Assign the map to a world
       * @method map.setInWorldMaps(name)
       * @param {RpgWorldMaps} worldMap world maps
       * @since 3.0.0-beta.8
       * @memberof Map
       */
  setInWorldMaps(worldMap) {
    this.worldMapParent = worldMap;
  }
  /**
   * Remove this map from the world
   * @title Remove this map from the world
   * @method map.removeFromWorldMaps()
   * @returns {boolean | undefined}
   * @since 3.0.0-beta.8
   * @memberof Map
   */
  removeFromWorldMaps() {
    var _a;
    return (_a = this.worldMapParent) == null ? void 0 : _a.removeMap(this.id);
  }
  /**
      * Recover the world attached to this map (`undefined` if no world attached)
  
      * @title Get attached World
      * @method map.getInWorldMaps()
      * @return {RpgCommonWorldMaps | undefined}
      * @since 3.0.0-beta.8
      * @memberof Map
      */
  getInWorldMaps() {
    return this.worldMapParent;
  }
  boundingMap(nextPosition, hitbox) {
    let bounding = false;
    if (nextPosition.x < 0) {
      nextPosition.x = 0;
      bounding = true;
    } else if (nextPosition.y < 0) {
      nextPosition.y = 0;
      bounding = true;
    } else if (nextPosition.x > this.widthPx - hitbox.w) {
      nextPosition.x = this.widthPx - hitbox.w;
      bounding = true;
    } else if (nextPosition.y > this.heightPx - hitbox.h) {
      nextPosition.y = this.heightPx - hitbox.h;
      bounding = true;
    }
    return {
      bounding,
      nextPosition
    };
  }
  _createMovingHitbox(gameEngine, tick$, mapId, hitboxes, options = {}) {
    const object = new AbstractObject(gameEngine, Utils_default.generateUID());
    object.disableVirtualGrid = true;
    object.map = mapId;
    object.speed = options.speed ?? 1;
    let i = 0;
    let frame = 0;
    const destroyHitbox$ = new Subject();
    return tick$.pipe(takeUntil(destroyHitbox$), filter2(() => {
      frame++;
      return frame % object.speed == 0;
    }), map(() => {
      const hitbox = hitboxes[i];
      if (!hitbox) {
        destroyHitbox$.next(object);
        destroyHitbox$.complete();
        return object;
      }
      object.position.x = hitbox.x;
      object.position.y = hitbox.y;
      object.setHitbox(hitbox.width, hitbox.height);
      i++;
      return object;
    }), mergeMap((object2) => from2(object2.isCollided(object2.position, { allSearch: true }))), map(() => object));
  }
};

// node_modules/@rpgjs/common/lib/Worker.js
var GameWorker = class {
  constructor(options = {}) {
    this.options = options;
  }
  load() {
    return this;
  }
  call(methodName, data) {
    return this.pool.exec(methodName, [data]);
  }
};

// node_modules/@rpgjs/common/lib/Game.js
var GameSide;
(function(GameSide2) {
  GameSide2["Server"] = "server";
  GameSide2["Client"] = "client";
  GameSide2["Worker"] = "worker";
})(GameSide || (GameSide = {}));
var RpgCommonGame = class extends EventEmitter2 {
  initialize(side) {
    this.side = side;
    this.events = {};
  }
  get isWorker() {
    return this.side == "worker";
  }
  start(world) {
    this.world = world;
  }
  createWorkers(options) {
    return new GameWorker(options);
  }
  addObject(_class, playerId) {
    let event;
    if (!playerId)
      playerId = generateUID();
    if (isClass(_class)) {
      if (this.side == GameSide.Client) {
        event = new _class(this, playerId);
      } else {
        event = new _class(playerId);
      }
    } else {
      event = _class;
    }
    return event;
  }
  addPlayer(playerClass, playerId) {
    const player = this.addObject(playerClass, playerId);
    return player;
  }
  addEvent(eventClass, eventId) {
    const event = this.addObject(eventClass, eventId);
    return event;
  }
  addShape(obj) {
    const id = obj.name = obj.name || generateUID();
    const shape = new RpgShape(obj);
    shape.name = id;
    return shape;
  }
  async processInput(playerId, controls) {
    const player = this.world.getObject(playerId);
    const inputs = [];
    if (!player)
      return {
        player,
        inputs
      };
    const routesMove = [];
    while (player.pendingMove.length > 0) {
      const inputData = player.pendingMove.shift();
      let { input, deltaTimeInt } = inputData;
      let moving = false;
      if (controls && controls[input]) {
        const control = controls[input];
        const now = Date.now();
        const inputTime = player.inputsTimestamp[input] || 0;
        if (inputTime >= now) {
          continue;
        }
        if (control.delay) {
          let duration;
          let otherControls = [];
          if (typeof control.delay == "number") {
            duration = control.delay;
          } else {
            duration = control.delay.duration;
            if (control.delay.otherControls) {
              otherControls = control.delay.otherControls;
            }
          }
          player.inputsTimestamp[input] = now + duration;
          for (let control2 of otherControls) {
            player.inputsTimestamp[control2] = now + duration;
          }
        }
      }
      if (input == Control.Action) {
        await player.triggerCollisionWith(RpgCommonPlayer.ACTIONS.ACTION);
      } else if (input == Direction.Left || input == Direction.Right || input == Direction.Up || input == Direction.Down) {
        player.moving = true;
        moving = true;
        const isMove = await player.moveByDirection(+input, deltaTimeInt || 1);
        if (isMove) {
          routesMove.push(inputData);
        }
      }
      if (this.side == GameSide.Server) {
        await RpgPlugin.emit("Server.onInput", [player, {
          ...inputData,
          moving
        }], true);
      }
      inputs.push(input);
    }
    return {
      player,
      inputs
    };
  }
};

// node_modules/@rpgjs/common/lib/AbstractObject.js
var ACTIONS = { IDLE: 0, RUN: 1, ACTION: 2 };
var AbstractObject = class _AbstractObject {
  static get ACTIONS() {
    return ACTIONS;
  }
  constructor(gameEngine, playerId) {
    this.gameEngine = gameEngine;
    this.playerId = playerId;
    this.map = "";
    this.height = 0;
    this.width = 0;
    this.direction = 3;
    this.moving = false;
    this.checkCollision = true;
    this.clientModeMove = MoveClientMode.ByDirection;
    this.behavior = Behavior.Direction;
    this.inShapes = {};
    this.disableVirtualGrid = false;
    this.shapes = [];
    this.collisionWith = [];
    this._collisionWithTiles = [];
    this._collisionWithShapes = [];
    this.destroyMove$ = new Subject();
    this._destroy$ = new Subject();
    this._hitboxPos = new import_sat2.default.Vector(0, 0);
    this.setHitbox(this.width, this.height);
    this.position = { x: 0, y: 0, z: 0 };
  }
  get id() {
    return this.playerId;
  }
  set id(str) {
    this.playerId = str;
  }
  updateInVirtualGrid() {
    const map2 = this.mapInstance;
    if (map2 && !this.disableVirtualGrid) {
      map2.grid.insertInCells(this.id, this.getSizeMaxShape());
    }
  }
  get canMove() {
    return this.clientModeMove == MoveClientMode.ByDirection;
  }
  set canMove(val) {
    this.clientModeMove = val ? MoveClientMode.ByDirection : MoveClientMode.Disabled;
  }
  /**
   * Get/Set position x, y and z of player
   *
   * z is the depth layer. By default, its value is 0. Collisions and overlays will be performed with other objects on the same z-position.
   *
   * @title Get/Set position
   * @prop { { x: number, y: number, z: number } } position
   * @memberof Player
   */
  set position(val) {
    if (this.isDestroyed)
      return;
    const { x, y, z } = val;
    if (!isInstanceOf(val, Vector2d)) {
      val = new Vector2d(x, y, z);
    }
    this._hitboxPos.x = x;
    this._hitboxPos.y = y;
    this._hitboxPos.z = z;
    this.updateInVirtualGrid();
    this._position = new Proxy(val, {
      get: (target, prop) => target[prop],
      set: (target, prop, value) => {
        this._hitboxPos[prop] = value;
        target[prop] = value;
        this.updateInVirtualGrid();
        return true;
      }
    });
  }
  get position() {
    return this._position;
  }
  get worldPositionX() {
    let x = this.position.x;
    if (this.mapInstance) {
      x += this.mapInstance.worldX;
    }
    return x;
  }
  get worldPositionY() {
    let y = this.position.y;
    if (this.mapInstance) {
      y += this.mapInstance.worldY;
    }
    return y;
  }
  set posX(val) {
    this.position.x = val;
  }
  set posY(val) {
    this.position.y = val;
  }
  set posZ(val) {
    this.position.z = val;
  }
  /** @internal */
  get mapInstance() {
    if (this.gameEngine.side == GameSide.Client) {
      return RpgCommonMap.bufferClient.get(this.map);
    }
    return RpgCommonMap.buffer.get(this.map);
  }
  /**
  *
  * Recovers all the colliding shapes of the current player
  *
  * @title Get Collision of shapes
  * @since 3.2.0
  * @readonly
  * @prop { RpgShape[] } shapes
  * @memberof Player
  * @memberof RpgSpriteLogic
  */
  get shapesCollision() {
    return this._collisionWithShapes;
  }
  /**
  *
  * Recovers all the colliding tiles of the current player
  *
  * @title Get Collision of tiles
  * @since 3.0.0-beta.4
  * @readonly
  * @prop { TileInfo[] } tiles
  * @memberof Player
  * @memberof RpgSpriteLogic
  */
  get tilesCollision() {
    return this._collisionWithTiles;
  }
  /**
   *
   * Recovers all other players and events colliding with the current player's hitbox
   *
   * @title Get Collision of other players/events
   * @since 3.0.0-beta.4
   * @readonly
   * @prop { (RpgPlayer | RpgEvent)[] } otherPlayersCollision
   * @memberof Player
   * @memberof RpgSpriteLogic
   */
  get otherPlayersCollision() {
    return this.collisionWith;
  }
  /**
   * Define the size of the player. You can set the hitbox for collisions
   *
   * ```ts
   * player.setSizes({
   *      width: 32,
   *      height: 32
   * })
   * ```
   *
   * and with hitbox:
   *
   *  ```ts
   * player.setSizes({
   *      width: 32,
   *      height: 32,
   *      hitbox: {
   *          width: 20,
   *          height: 20
   *      }
   * })
   * ```
   *
   * @title Set Sizes
   * @method player.setSizes(key,value)
   * @param { { width: number, height: number, hitbox?: { width: number, height: number } } } obj
   * @deprecated
   * @returns {void}
   * @memberof Player
   */
  setSizes(obj) {
    this.width = obj.width;
    this.height = obj.height;
    if (obj.hitbox) {
      this.hitbox = new import_sat2.default.Box(this._hitboxPos, obj.hitbox.width, obj.hitbox.height);
    }
  }
  /**
   * Define the hitbox of the player.
   *
   * ```ts
   * player.setHitbox(20, 20)
   * ```
   *
   * @title Set Hitbox
   * @method player.setHitbox(width,height)
   * @param {number} width
   * @param {number} height
   * @returns {void}
   * @memberof Player
   */
  setHitbox(width, height) {
    const map2 = this.mapInstance;
    if (map2) {
      this.width = map2.tileWidth;
      this.height = map2.tileHeight;
    }
    this.hitbox = new import_sat2.default.Box(this._hitboxPos, width, height);
    this.wHitbox = width;
    this.hHitbox = height;
    this.updateInVirtualGrid();
  }
  set wHitbox(val) {
    this.hitbox.w = val;
  }
  set hHitbox(val) {
    this.hitbox.h = val;
  }
  get wHitbox() {
    return this.hitbox.w;
  }
  get hHitbox() {
    return this.hitbox.h;
  }
  directionToAngle(direction) {
    const angle = (direction < 2 ? +direction + 2 : direction - 2) * 90;
    return toRadians(angle);
  }
  /** @internal */
  defineNextPosition(direction, deltaTimeInt) {
    const angle = this.directionToAngle(direction);
    const computePosition = (prop) => {
      return this.position[prop] + this.speed * deltaTimeInt * (Math.round(Math[prop == "x" ? "cos" : "sin"](angle) * 100) / 100);
    };
    const x = this.speed < 1 ? computePosition("x") : round(computePosition("x"));
    const y = this.speed < 1 ? computePosition("y") : round(computePosition("y"));
    return new Vector2d(x, y, ~~this.position.z);
  }
  /** @internal */
  setPosition({ x, y, tileX, tileY }, move = true) {
    const { tileWidth, tileHeight } = this.mapInstance;
    if (x !== void 0)
      this.posX = x;
    if (y !== void 0)
      this.posY = y;
    if (tileX !== void 0)
      this.posX = tileX * tileWidth;
    if (tileY !== void 0)
      this.posY = tileY * tileHeight;
  }
  /** @internal */
  async triggerCollisionWith(type) {
    let doChanges = false;
    for (let collisionWith of this.collisionWith) {
      if (collisionWith.isDestroyed)
        continue;
      if (collisionWith instanceof RpgShape) {
        const goMap = collisionWith.getProperty("go-map");
        if (goMap && "changeMap" in this)
          await this.changeMap(goMap);
      } else {
        if (type == _AbstractObject.ACTIONS.ACTION) {
          if ("onAction" in collisionWith) {
            await collisionWith.execMethod("onAction", [this]);
            doChanges = true;
          }
        } else if ("onPlayerTouch" in collisionWith) {
          await collisionWith.execMethod("onPlayerTouch", [this]);
          doChanges = true;
        }
      }
    }
    if (this.syncChanges && doChanges)
      this.syncChanges();
  }
  /** @internal */
  zCollision(other) {
    const z = this.position.z;
    const otherZ = other.position.z;
    return intersection([z, z + this.height], [otherZ, otherZ + other.height]);
  }
  /** @internal */
  moveByDirection(direction, deltaTimeInt) {
    const nextPosition = this.defineNextPosition(direction, deltaTimeInt);
    return this.move(nextPosition);
  }
  /**
   * Retrieves a tile and checks if the player has a collision
   *
   * ```ts
   * const tileInfo = player.getTile(20, 30)
   * console.log(tileInfo)
   * ```
   *
   * Example of returns:
   *
   * ```ts
   *   {
   *       tiles: [
   *           {
   *               id: 0,
   *               terrain: [],
   *               probability: null,
   *               properties: [Object],
   *               animations: [],
   *               objectGroups: [],
   *               image: null,
   *               gid: 1
   *           }
   *       ],
   *       hasCollision: false,
   *       isOverlay: undefined,
   *       objectGroups: [],
   *       isClimbable: undefined,
   *       tileIndex: 93
   *   }
   * ```
   *
   * @title Get Tile
   * @since 3.0.0-beta.4
   * @method player.getTile(x,y,z?)
   * @param {number} x
   * @param {number} y
   * @param {number} [z]
   * @returns {object}
   * @memberof Player
   * @memberof RpgSpriteLogic
   */
  getTile(x, y, z = 0, hitbox) {
    const map2 = this.mapInstance;
    return map2.getTile(hitbox || this.hitbox, x, y, [z, this.height]);
  }
  async collisionObjects(playerSizeBox, hitbox, triggers) {
    const map2 = this.mapInstance;
    if (!map2)
      return true;
    const events = this.gameEngine.world.getObjectsOfGroup(this.map, this);
    const objects = map2.grid.getObjectsByBox(playerSizeBox);
    let boolFound = false;
    for (let objectId of objects) {
      if (!events[objectId])
        continue;
      const event = events[objectId]["object"] || events[objectId];
      if (event.id == this.id)
        continue;
      if (!this.zCollision(event))
        continue;
      const collided = Hit.testPolyCollision(HitType.Box, hitbox, event.hitbox);
      for (let shape of this.shapes) {
        await this.collisionWithShape(shape, event);
      }
      for (let shape of event.shapes) {
        await event.collisionWithShape(shape, this);
      }
      if (triggers == null ? void 0 : triggers.near)
        triggers.near(event);
      if (collided) {
        this.collisionWith.push(event);
        this.triggerCollisionWith();
        let throughOtherPlayer = false;
        if (event.type == PlayerType.Player && this.type == PlayerType.Player) {
          if (!(event.throughOtherPlayer || this.throughOtherPlayer)) {
            boolFound = true;
            if (!(triggers == null ? void 0 : triggers.allSearch))
              return true;
          } else {
            throughOtherPlayer = true;
          }
        }
        if (!throughOtherPlayer && !(event.through || this.through)) {
          boolFound = true;
          if (!(triggers == null ? void 0 : triggers.allSearch))
            return true;
        }
      }
      if (boolFound) {
        if (triggers == null ? void 0 : triggers.collision)
          triggers.collision(event);
      }
    }
    return boolFound;
  }
  /** @internal */
  async collisionWithShape(shape, player, nextPosition) {
    const collision = shape.hasCollision;
    const z = shape.z;
    if (shape.isShapePosition())
      return false;
    if (z !== void 0 && !this.zCollision({
      position: { z },
      height: this.mapInstance.zTileHeight
    })) {
      return false;
    }
    let position;
    let { hitbox } = player;
    if (nextPosition) {
      position = nextPosition.copy();
    } else {
      position = player.position.copy();
    }
    const hitboxObj = Hit.createObjectHitbox(position.x, position.y, position.z, hitbox.w, hitbox.h);
    let collided = Hit.testPolyCollision(shape.type, hitboxObj, shape.hitbox);
    const playerPositionSaved = player.position.copy();
    const verifyIfPositionChanged = () => {
      if (this.position.z != playerPositionSaved.z && nextPosition) {
        nextPosition.z = this.position.z;
      }
      if (this.position.x != playerPositionSaved.x || this.position.y != playerPositionSaved.y) {
        return true;
      }
    };
    if (collided) {
      this._collisionWithShapes.push(shape);
      if (!collision)
        await shape.in(player);
      if (verifyIfPositionChanged() === true)
        return true;
      this.triggerCollisionWith();
      if (collision)
        return true;
    } else {
      await shape.out(player);
      if (verifyIfPositionChanged() === true)
        return true;
    }
    return false;
  }
  async collisionShapes(playerSizeBox, nextPosition, triggers) {
    const map2 = this.mapInstance;
    if (!map2)
      return false;
    const shapes = this.gameEngine.world.getShapesOfGroup(this.map);
    const shapesInGrid = this.gameEngine.side == GameSide.Client ? new Set(Object.keys(shapes)) : map2.gridShapes.getObjectsByBox(playerSizeBox);
    let boolFound = false;
    for (let shapeId of shapesInGrid) {
      const shape = shapes[shapeId]["object"] || shapes[shapeId];
      if (triggers == null ? void 0 : triggers.near)
        triggers.near(shape);
      const bool = await this.collisionWithShape(shape, this, nextPosition);
      if (bool) {
        if (triggers == null ? void 0 : triggers.collision)
          triggers.collision(shape);
        boolFound = true;
        if (!(triggers == null ? void 0 : triggers.allSearch))
          return true;
      }
    }
    return boolFound;
  }
  async computeNextPositionByTarget(nextPosition, target) {
    const pullDistance = target.distanceWith(nextPosition);
    if (pullDistance <= this.speed) {
      return nextPosition.set(target);
    }
    const pull = target.copy().subtract(nextPosition).multiply(1 / pullDistance);
    const totalPush = new Vector2dZero();
    let contenders = 0;
    const hitbox = Hit.createObjectHitbox(nextPosition.x, nextPosition.y, nextPosition.z, this.hitbox.w, this.hitbox.h);
    const createObstacle = function(x, y, radius) {
      const obstacle = new Vector2d(x, y);
      let push = nextPosition.copy().subtract(obstacle);
      let distance = nextPosition.distanceWith(obstacle) - radius - radius;
      if (distance < radius * 2 * 10) {
        ++contenders;
        if (distance < 1e-4)
          distance = 1e-4;
        let weight = 1 / distance;
        totalPush.add(push.multiply(weight));
      }
      return obstacle;
    };
    const area = this.mapInstance.tileheight * 2;
    this.mapInstance.gridTiles.getCells({
      minX: nextPosition.x - area,
      maxX: nextPosition.x + area,
      minY: nextPosition.y - area,
      maxY: nextPosition.y + area
    }, (index) => {
      if (index < 0)
        return;
      const pos = this.mapInstance.getTilePosition(index);
      const hitbox2 = Hit.createObjectHitbox(pos.x, pos.y, nextPosition.z, this.hitbox.w, this.hitbox.h);
      const radius = this.mapInstance.tilewidth / 2;
      const tile = this.getTile(pos.x, pos.y, nextPosition.z, hitbox2);
      if (tile.hasCollision) {
        createObstacle(pos.x, pos.y, radius);
      }
    });
    const playerSizeBox = this.getSizeMaxShape(nextPosition.x, nextPosition.y);
    await this.collisionObjects(playerSizeBox, hitbox, {
      collision: (event) => {
        const { x, y } = event.position;
        createObstacle(x, y, event.hitbox.w);
      },
      allSearch: true
    });
    await this.collisionShapes(playerSizeBox, nextPosition, {
      collision: (shape) => {
        const { x, y } = shape.position;
        createObstacle(x, y, shape.hitbox.w);
      },
      allSearch: true
    });
    pull.multiply(Math.max(1, 4 * contenders)).add(totalPush).normalize();
    return nextPosition.add(pull.multiply(this.speed));
  }
  async isCollided(nextPosition, options = {}) {
    var _a;
    this.collisionWith = [];
    this._collisionWithTiles = [];
    const prevMapId = this.map;
    const hitbox = Hit.createObjectHitbox(nextPosition.x, nextPosition.y, 0, this.hitbox.w, this.hitbox.h);
    const boundingMap = (_a = this.mapInstance) == null ? void 0 : _a.boundingMap(nextPosition, this.hitbox);
    let collided = false;
    if (boundingMap == null ? void 0 : boundingMap.bounding) {
      this.position.set(nextPosition);
      if (!options.allSearch)
        return true;
      else
        collided = true;
    }
    const tileCollision = (x, y) => {
      const tile = this.getTile(x, y, nextPosition.z, hitbox);
      if (tile.hasCollision) {
        this._collisionWithTiles.push(tile);
        return true;
      }
      return false;
    };
    if (tileCollision(nextPosition.x, nextPosition.y) || tileCollision(nextPosition.x + this.hitbox.w, nextPosition.y) || tileCollision(nextPosition.x, nextPosition.y + this.hitbox.h) || tileCollision(nextPosition.x + this.hitbox.w, nextPosition.y + this.hitbox.h)) {
      if (!options.allSearch)
        return true;
      else
        collided = true;
    }
    if (this.autoChangeMap && this.type == PlayerType.Player) {
      const changeMap = await this.autoChangeMap(nextPosition);
      if (changeMap) {
        return true;
      }
    }
    const playerSizeBox = this.getSizeMaxShape(nextPosition.x, nextPosition.y);
    if (await this.collisionObjects(playerSizeBox, hitbox, options)) {
      if (!options.allSearch)
        return true;
      else
        collided = true;
    }
    if (await this.collisionShapes(playerSizeBox, nextPosition, options)) {
      if (!options.allSearch)
        return true;
      else
        collided = true;
    }
    if (prevMapId != this.map) {
      return true;
    }
    return collided;
  }
  /**
   * Attach a shape to the player (and allow interaction with it)
   *
   * ```ts
   * import { ShapePositioning } from '@rpgjs/server'
   *
   * player.attachShape({
   *      width: 100,
   *      height: 100,
   *      positioning: ShapePositioning.Center
   * })
   * ```
   *
   * @title Attach Shape
   * @method player.attachShape(parameters)
   * @param { { width: number, height: number, positioning?, name?, properties?: object } } obj
   * - positioning: Indicate where the shape is placed.
   * - properties: An object in order to retrieve information when interacting with the shape
   * - name: The name of the shape
   * @since 3.0.0-beta.3
   * @returns {RpgShape}
   * @memberof Player
   */
  attachShape(obj) {
    obj.name = obj.name || generateUID();
    const shape = new RpgShape({
      ...obj,
      fixEvent: this
    });
    this.shapes.push(shape);
    return shape;
  }
  /**
   * Returns all shapes assigned to this player
   *
   * @title Get Shapes
   * @method player.getShapes()
   * @returns {RpgShape[]}
   * @since 3.0.0-beta.3
   * @memberof Player
   * @memberof RpgSpriteLogic
   */
  getShapes() {
    return this.shapes;
  }
  autoChangeDirection(nextPosition) {
    const { x, y } = this.position;
    const { x: nx, y: ny } = nextPosition;
    const diff = Math.abs(x - nx) > Math.abs(y - ny);
    if (diff) {
      if (nx > x) {
        this.changeDirection(Direction.Right);
      } else {
        this.changeDirection(Direction.Left);
      }
    } else {
      if (ny > y) {
        this.changeDirection(Direction.Down);
      } else {
        this.changeDirection(Direction.Up);
      }
    }
  }
  // @internal
  /**
   * We need to know if the event is deleted. Because when the event is deleted, you don't update the positions and you don't send the positions back to the client.
   */
  get isDestroyed() {
    return !!this._destroy$["_closed"];
  }
  /**
  * Stops the movement of the player who moves towards his target
  *
  * @title Stop Move To
  * @method player.stopMoveTo()
  * @returns {void}
  * @since 3.2.0
  * @memberof MoveManager
  */
  stopMoveTo() {
    if (this.destroyMove$.closed)
      return;
    this.moving = false;
    this.destroyMove$.next(true);
    this.destroyMove$.unsubscribe();
  }
  _lookToward(player, otherPlayer) {
    const { x, y } = player;
    const { x: ox, y: oy } = otherPlayer;
    const dx = ox - x;
    const dy = oy - y;
    if (Math.abs(dx) > Math.abs(dy)) {
      if (dx > 0) {
        return Direction.Right;
      } else {
        return Direction.Left;
      }
    } else {
      if (dy > 0) {
        return Direction.Down;
      } else {
        return Direction.Up;
      }
    }
  }
  _moveTo(tick$, positionTarget, options = {}) {
    let i = 0;
    let count2 = 0;
    const lastPositions = [];
    this.stopMoveTo();
    this.moving = true;
    this.destroyMove$ = new Subject();
    const { infinite, onStuck, onComplete } = options;
    const getPosition = () => {
      let pos;
      if ("x" in positionTarget) {
        pos = new Vector2d(positionTarget.x, positionTarget.y);
      } else {
        pos = positionTarget.position;
      }
      return pos;
    };
    return tick$.pipe(takeUntil(this.destroyMove$), takeUntil(this._destroy$), mergeMap(() => from2(this.computeNextPositionByTarget(this.position.copy(), getPosition()))), filter2(() => {
      return this.isDestroyed === false;
    }), map((position) => {
      this.autoChangeDirection(position);
      return this.position.set(position);
    }), tap((position) => {
      lastPositions[i] = position.copy();
      i++;
      count2++;
      if (i >= 3) {
        i = 0;
      }
      if (lastPositions[2] && (lastPositions[0].isEqual(lastPositions[2]) || lastPositions[1].isEqual(lastPositions[2]) || lastPositions[0].isEqual(lastPositions[1]))) {
        this.direction = this._lookToward(this.position, getPosition());
        onStuck == null ? void 0 : onStuck(count2);
        this.moving = false;
      } else if (this.position.isEqual(getPosition())) {
        onComplete == null ? void 0 : onComplete();
        if (!infinite) {
          this.stopMoveTo();
        }
      } else {
        count2 = 0;
        this.moving = true;
      }
    }));
  }
  /** @internal */
  async move(nextPosition) {
    this.autoChangeDirection(nextPosition);
    const notCollided = !await this.isCollided(nextPosition);
    if ((notCollided || !this.checkCollision) && !this.isDestroyed) {
      this.position = nextPosition.copy();
      await RpgPlugin.emit(HookServer.PlayerMove, this);
    }
    return true;
  }
  /**
   * Retrieves all shapes where the player is located
   *
   * @title Get In-Shapes
   * @method player.getInShapes()
   * @returns {RpgShape[]}
   * @since 3.0.0-beta.3
   * @memberof Player
   */
  getInShapes() {
    return Object.values(this.inShapes);
  }
  /**
  * Get the current direction.
  *
  * ```ts
  * player.getDirection()
  * ```
  *
  * @title Get Direction
  * @method player.getDirection()
  * @returns {Direction | number} direction
  * @memberof Player
  */
  getDirection(direction) {
    return direction || this.direction;
  }
  /**
  * Changes the player's direction
  *
  * ```ts
  * import { Direction } from '@rpgjs/server'
  *
  * player.changeDirection(Direction.Left)
  * ```
  *
  * @title Change direction
  * @method player.changeDirection(direction)
  * @param {Direction} direction
  * @enum {string}
  *
  * Direction.Left | left
  * Direction.Right | right
  * Direction.Up | up
  * Direction.Down | down
  * @returns {boolean} the direction has changed
  * @memberof Player
  */
  changeDirection(direction) {
    const dir = +this.getDirection(direction);
    if (dir === void 0)
      return false;
    this.direction = dir;
    return true;
  }
  /**
   * Gets the necessary number of pixels to allow the player to cross a tile.
   * This is the ratio between the height or width of the tile and the speed of the player.
   */
  get nbPixelInTile() {
    const direction = this.getDirection();
    switch (direction) {
      case Direction.Down:
      case Direction.Up:
        return Math.floor(this.mapInstance.tileHeight / this.speed);
      case Direction.Left:
      case Direction.Right:
        return Math.floor(this.mapInstance.tileWidth / this.speed);
      default:
        return NaN;
    }
  }
  getSizeMaxShape(x, y) {
    const _x = x || this.position.x;
    const _y = y || this.position.y;
    let minX = _x;
    let minY = _y;
    let maxX = _x + this.wHitbox;
    let maxY = _y + this.hHitbox;
    const shapes = this.getShapes();
    for (let shape of shapes) {
      if (shape.x < minX)
        minX = shape.x;
      if (shape.y < minY)
        minY = shape.y;
      const shapeMaxX = shape.x + shape.width;
      const shapeMaxY = shape.y + shape.height;
      if (shapeMaxX > maxX)
        maxX = shapeMaxX;
      if (shapeMaxY > maxY)
        maxY = shapeMaxY;
    }
    return {
      minX,
      minY,
      maxX,
      maxY
    };
  }
  /** @internal */
  async execMethod(methodName, methodData, instance) {
  }
};

// node_modules/@rpgjs/common/lib/Player.js
var LiteralDirection = {
  1: "up",
  2: "right",
  3: "down",
  4: "left"
};
var RpgCommonPlayer = class extends AbstractObject {
  constructor() {
    super(...arguments);
    this.events = [];
    this.layerName = "";
    this.data = {};
    this.pendingMove = [];
    this.inputsTimestamp = {};
  }
};
var Player_default = AbstractObject;

// node_modules/@rpgjs/common/lib/gui/PrebuiltGui.js
var PrebuiltGui;
(function(PrebuiltGui2) {
  PrebuiltGui2["Dialog"] = "rpg-dialog";
  PrebuiltGui2["MainMenu"] = "rpg-main-menu";
  PrebuiltGui2["Shop"] = "rpg-shop";
  PrebuiltGui2["Disconnect"] = "rpg-disconnect";
  PrebuiltGui2["Gameover"] = "rpg-gameover";
  PrebuiltGui2["Save"] = "rpg-save";
  PrebuiltGui2["Controls"] = "rpg-controls";
  PrebuiltGui2["Notification"] = "rpg-notification";
})(PrebuiltGui || (PrebuiltGui = {}));

// node_modules/@rpgjs/common/lib/Logger.js
var Logger_exports = {};
__export(Logger_exports, {
  log: () => log,
  warning: () => warning
});
function log(message) {
  return new Error(`[RPGJS] - ${message}`);
}
function warning(...message) {
  console.warn("[RPGJS Warning]", ...message);
}

// node_modules/@rpgjs/common/lib/Module.js
var Side;
(function(Side2) {
  Side2["Server"] = "server";
  Side2["Client"] = "client";
})(Side || (Side = {}));
function RpgModule(options) {
  return (target) => {
    if (options.hooks) {
      target.hooks = options.hooks;
    }
    for (let key in options) {
      target.prototype[key] = options[key];
    }
  };
}
async function loadModules(modules, obj, middleware) {
  const { side, relations } = obj;
  let playerProps = {};
  let hooks = {};
  const getModuleClass = (module) => {
    if (!module)
      return null;
    let plug = [];
    if (!isArray(module)) {
      plug = [module];
    } else {
      plug = module;
    }
    const [moduleClassSides, options] = plug;
    const moduleClass = moduleClassSides[side];
    if (!moduleClass)
      return null;
    return {
      moduleClass,
      options
    };
  };
  for (let module of modules) {
    const moduleObject = getModuleClass(module);
    if (!moduleObject)
      continue;
    const { moduleClass } = moduleObject;
    if (moduleClass.hooks) {
      for (let key in moduleClass.hooks) {
        if (!hooks[key])
          hooks[key] = [];
        hooks[key] = [
          ...hooks[key],
          ...moduleClass.hooks[key]
        ];
      }
    }
  }
  for (let module of modules) {
    const moduleObject = getModuleClass(module);
    if (!moduleObject)
      continue;
    const { moduleClass, options } = moduleObject;
    let mod;
    if (options && side == Side.Client && options[Side.Server]) {
      warning(`Data that may be sensitive (normally visible only on the server side) are made optional and visible on the client side.
Instead, import the configuration with the server! flag into an import. Example: 

import config from 'server!./config

'`, options[Side.Server]);
    }
    if (options && !isClass(moduleClass) && isFunction(moduleClass)) {
      mod = new (moduleClass(options[side]))();
    } else if (isClass(moduleClass)) {
      mod = new moduleClass();
    } else {
      mod = moduleClass;
    }
    if (middleware) {
      mod = middleware(mod);
      if (isPromise(mod)) {
        mod = await mod;
      }
    }
    const { imports, maps, spritesheets, sounds, gui, scenes, engine, database, worldMaps, scalability, events } = mod;
    if (imports) {
      await loadModules(imports, obj);
    }
    if (maps) {
      RpgPlugin.on(HookServer.AddMap, () => maps);
    }
    if (events) {
      RpgPlugin.on(HookServer.AddEvent, () => events);
    }
    if (worldMaps) {
      RpgPlugin.on(HookServer.AddWorldMaps, () => worldMaps);
    }
    if (database) {
      RpgPlugin.on(HookServer.AddDatabase, () => database);
    }
    if (spritesheets) {
      RpgPlugin.on(HookClient.AddSpriteSheet, () => spritesheets);
    }
    if (sounds) {
      RpgPlugin.on(HookClient.AddSound, () => sounds);
    }
    if (gui) {
      RpgPlugin.on(HookClient.AddGui, () => gui);
    }
    const player = side == Side.Server ? mod.player : mod.sprite;
    const loadRelations = (hook, relationName) => {
      if (!hook)
        return;
      for (let method in relations[relationName]) {
        const hookName = relations[relationName][method];
        if (hook[method])
          RpgPlugin.on(hookName, hook[method]);
      }
      if (hooks[relationName]) {
        for (let methodName of hooks[relationName]) {
          const hookName = side + "." + relationName + "." + methodName;
          RpgPlugin.customHooks[hookName] = true;
          if (hook[methodName])
            RpgPlugin.on(hookName, hook[methodName]);
        }
      }
    };
    loadRelations(player, "player");
    if (player && player.props) {
      playerProps = Object.assign(playerProps, player.props);
    }
    loadRelations(engine, "engine");
    if (scalability)
      loadRelations(scalability._hooks, "scalability");
    if (scenes)
      loadRelations(scenes.map, "sceneMap");
  }
  return {
    playerProps
  };
}

// node_modules/@rpgjs/common/lib/transports/io.js
var io_exports = {};
__export(io_exports, {
  ClientIo: () => ClientIo,
  serverIo: () => serverIo
});
var MockIo = class {
  constructor() {
    this.events = /* @__PURE__ */ new Map();
  }
  on(name, value) {
    this.events.set(name, value);
  }
  off(name) {
    this.events.delete(name);
  }
  once(name, value) {
    this.on(name, value);
  }
  _trigger(name, data, client) {
    const fn = this.events.get(name);
    if (fn)
      fn(data, client);
  }
};
var MockSocket = class {
  constructor(io, handshake) {
    this.io = io;
    this.handshake = handshake;
    this.id = "" + Math.random();
  }
  on(name, value) {
    this.io.on(name, value, this.id);
    return this;
  }
  once(name, value) {
    this.io.once(name, value, this.id);
    return this;
  }
  emit(name, data) {
    this.io.emit(name, data, this.id);
  }
  removeAllListeners(name) {
    return this.off(name);
  }
  off(name) {
    this.io.off(name, this.id);
  }
};
var MockClientIo = class extends MockIo {
  constructor() {
    super(...arguments);
    this.id = "";
  }
  connection(handshake) {
    serverIo.connection(this, handshake);
    this._trigger("connect", void 0);
    return this;
  }
  emit(name, data) {
    serverIo._trigger(name, data, this);
    return this;
  }
  disconnect() {
    this.emit("disconnect", void 0);
  }
};
var MockServerIo = class extends MockIo {
  constructor() {
    super(...arguments);
    this.clients = /* @__PURE__ */ new Map();
  }
  connection(client, handshake) {
    const socket = new MockSocket(this, handshake);
    this.clients.set(socket.id, client);
    client.id = socket.id;
    this._trigger("connection", socket);
  }
  emit(name, data, id) {
    var _a;
    (_a = this.clients.get(id)) == null ? void 0 : _a._trigger(name, data);
  }
  clear() {
    this.clients.clear();
  }
};
var serverIo = new MockServerIo();
var ClientIo = MockClientIo;

// node_modules/@rpgjs/common/lib/Scheduler.js
var Scheduler2 = class extends EventEmitter2 {
  constructor() {
    super(...arguments);
    this.fps = 60;
    this.deltaTime = 0;
    this.frame = 0;
    this.timestamp = 0;
    this.requestedDelay = 0;
    this.lastTimestamp = 0;
    this._tick = new BehaviorSubject({
      timestamp: 0,
      deltaTime: 0,
      frame: 0,
      deltaRatio: 0
    });
    this._stop = false;
  }
  get tick() {
    return this._tick.asObservable();
  }
  nextTick(timestamp2) {
    this.lastTimestamp = this.lastTimestamp || this.timestamp;
    this.deltaTime = Utils_default.preciseNow() - this.timestamp;
    this.timestamp = timestamp2;
    this._tick.next({
      timestamp: this.timestamp,
      deltaTime: this.deltaTime,
      frame: this.frame,
      deltaRatio: ~~this.deltaTime / ~~Utils_default.fps2ms(this.fps)
    });
    this.lastTimestamp = this.timestamp;
    this.frame++;
  }
  /**
   * start the schedule
   * @return {Scheduler} returns this scheduler instance
   */
  start(options) {
    if (options.maxFps)
      this.maxFps = options.maxFps;
    if (options.fps)
      this.fps = options.fps;
    if (options.delay)
      this.requestedDelay = options.delay;
    const requestAnimationFrame2 = (fn) => {
      if (Utils_default.isBrowser()) {
        window.requestAnimationFrame(fn.bind(this));
      } else {
        setTimeout(() => {
          this.requestedDelay = 0;
          fn(Utils_default.preciseNow());
        }, Utils_default.fps2ms(this.fps) + this.requestedDelay);
      }
    };
    if (!this.maxFps) {
      const loop = (timestamp2) => {
        requestAnimationFrame2(loop);
        this.nextTick(timestamp2);
      };
      requestAnimationFrame2(loop);
    } else {
      const msInterval = Utils_default.fps2ms(this.maxFps);
      let now = Utils_default.preciseNow();
      let then = Utils_default.preciseNow();
      const loop = (timestamp2) => {
        if (this._stop)
          return;
        requestAnimationFrame2(loop);
        now = Utils_default.preciseNow();
        const elapsed = now - then;
        if (elapsed > msInterval) {
          then = now - elapsed % msInterval;
          this.nextTick(timestamp2);
        }
      };
      requestAnimationFrame2(loop);
    }
    return this;
  }
  stop() {
    this._stop = true;
    this._tick.complete();
  }
};

// node_modules/quickselect/index.js
function quickselect(arr, k, left, right, compare3) {
  quickselectStep(arr, k, left || 0, right || arr.length - 1, compare3 || defaultCompare2);
}
function quickselectStep(arr, k, left, right, compare3) {
  while (right > left) {
    if (right - left > 600) {
      var n = right - left + 1;
      var m = k - left + 1;
      var z = Math.log(n);
      var s = 0.5 * Math.exp(2 * z / 3);
      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselectStep(arr, k, newLeft, newRight, compare3);
    }
    var t = arr[k];
    var i = left;
    var j = right;
    swap2(arr, left, k);
    if (compare3(arr[right], t) > 0)
      swap2(arr, left, right);
    while (i < j) {
      swap2(arr, i, j);
      i++;
      j--;
      while (compare3(arr[i], t) < 0)
        i++;
      while (compare3(arr[j], t) > 0)
        j--;
    }
    if (compare3(arr[left], t) === 0)
      swap2(arr, left, j);
    else {
      j++;
      swap2(arr, j, right);
    }
    if (j <= k)
      left = j + 1;
    if (k <= j)
      right = j - 1;
  }
}
function swap2(arr, i, j) {
  var tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultCompare2(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}

// node_modules/rbush/index.js
var RBush = class {
  constructor(maxEntries = 9) {
    this._maxEntries = Math.max(4, maxEntries);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(bbox) {
    let node = this.data;
    const result = [];
    if (!intersects(bbox, node))
      return result;
    const toBBox = this.toBBox;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? toBBox(child) : child;
        if (intersects(bbox, childBBox)) {
          if (node.leaf)
            result.push(child);
          else if (contains(bbox, childBBox))
            this._all(child, result);
          else
            nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return result;
  }
  collides(bbox) {
    let node = this.data;
    if (!intersects(bbox, node))
      return false;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? this.toBBox(child) : child;
        if (intersects(bbox, childBBox)) {
          if (node.leaf || contains(bbox, childBBox))
            return true;
          nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return false;
  }
  load(data) {
    if (!(data && data.length))
      return this;
    if (data.length < this._minEntries) {
      for (let i = 0; i < data.length; i++) {
        this.insert(data[i]);
      }
      return this;
    }
    let node = this._build(data.slice(), 0, data.length - 1, 0);
    if (!this.data.children.length) {
      this.data = node;
    } else if (this.data.height === node.height) {
      this._splitRoot(this.data, node);
    } else {
      if (this.data.height < node.height) {
        const tmpNode = this.data;
        this.data = node;
        node = tmpNode;
      }
      this._insert(node, this.data.height - node.height - 1, true);
    }
    return this;
  }
  insert(item) {
    if (item)
      this._insert(item, this.data.height - 1);
    return this;
  }
  clear() {
    this.data = createNode([]);
    return this;
  }
  remove(item, equalsFn) {
    if (!item)
      return this;
    let node = this.data;
    const bbox = this.toBBox(item);
    const path = [];
    const indexes = [];
    let i, parent, goingUp;
    while (node || path.length) {
      if (!node) {
        node = path.pop();
        parent = path[path.length - 1];
        i = indexes.pop();
        goingUp = true;
      }
      if (node.leaf) {
        const index = findItem(item, node.children, equalsFn);
        if (index !== -1) {
          node.children.splice(index, 1);
          path.push(node);
          this._condense(path);
          return this;
        }
      }
      if (!goingUp && !node.leaf && contains(node, bbox)) {
        path.push(node);
        indexes.push(i);
        i = 0;
        parent = node;
        node = node.children[0];
      } else if (parent) {
        i++;
        node = parent.children[i];
        goingUp = false;
      } else
        node = null;
    }
    return this;
  }
  toBBox(item) {
    return item;
  }
  compareMinX(a, b) {
    return a.minX - b.minX;
  }
  compareMinY(a, b) {
    return a.minY - b.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(data) {
    this.data = data;
    return this;
  }
  _all(node, result) {
    const nodesToSearch = [];
    while (node) {
      if (node.leaf)
        result.push(...node.children);
      else
        nodesToSearch.push(...node.children);
      node = nodesToSearch.pop();
    }
    return result;
  }
  _build(items, left, right, height) {
    const N = right - left + 1;
    let M = this._maxEntries;
    let node;
    if (N <= M) {
      node = createNode(items.slice(left, right + 1));
      calcBBox(node, this.toBBox);
      return node;
    }
    if (!height) {
      height = Math.ceil(Math.log(N) / Math.log(M));
      M = Math.ceil(N / Math.pow(M, height - 1));
    }
    node = createNode([]);
    node.leaf = false;
    node.height = height;
    const N2 = Math.ceil(N / M);
    const N1 = N2 * Math.ceil(Math.sqrt(M));
    multiSelect(items, left, right, N1, this.compareMinX);
    for (let i = left; i <= right; i += N1) {
      const right2 = Math.min(i + N1 - 1, right);
      multiSelect(items, i, right2, N2, this.compareMinY);
      for (let j = i; j <= right2; j += N2) {
        const right3 = Math.min(j + N2 - 1, right2);
        node.children.push(this._build(items, j, right3, height - 1));
      }
    }
    calcBBox(node, this.toBBox);
    return node;
  }
  _chooseSubtree(bbox, node, level, path) {
    while (true) {
      path.push(node);
      if (node.leaf || path.length - 1 === level)
        break;
      let minArea = Infinity;
      let minEnlargement = Infinity;
      let targetNode;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const area = bboxArea(child);
        const enlargement = enlargedArea(bbox, child) - area;
        if (enlargement < minEnlargement) {
          minEnlargement = enlargement;
          minArea = area < minArea ? area : minArea;
          targetNode = child;
        } else if (enlargement === minEnlargement) {
          if (area < minArea) {
            minArea = area;
            targetNode = child;
          }
        }
      }
      node = targetNode || node.children[0];
    }
    return node;
  }
  _insert(item, level, isNode) {
    const bbox = isNode ? item : this.toBBox(item);
    const insertPath = [];
    const node = this._chooseSubtree(bbox, this.data, level, insertPath);
    node.children.push(item);
    extend(node, bbox);
    while (level >= 0) {
      if (insertPath[level].children.length > this._maxEntries) {
        this._split(insertPath, level);
        level--;
      } else
        break;
    }
    this._adjustParentBBoxes(bbox, insertPath, level);
  }
  // split overflowed node into two
  _split(insertPath, level) {
    const node = insertPath[level];
    const M = node.children.length;
    const m = this._minEntries;
    this._chooseSplitAxis(node, m, M);
    const splitIndex = this._chooseSplitIndex(node, m, M);
    const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
    newNode.height = node.height;
    newNode.leaf = node.leaf;
    calcBBox(node, this.toBBox);
    calcBBox(newNode, this.toBBox);
    if (level)
      insertPath[level - 1].children.push(newNode);
    else
      this._splitRoot(node, newNode);
  }
  _splitRoot(node, newNode) {
    this.data = createNode([node, newNode]);
    this.data.height = node.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
  }
  _chooseSplitIndex(node, m, M) {
    let index;
    let minOverlap = Infinity;
    let minArea = Infinity;
    for (let i = m; i <= M - m; i++) {
      const bbox1 = distBBox(node, 0, i, this.toBBox);
      const bbox2 = distBBox(node, i, M, this.toBBox);
      const overlap = intersectionArea(bbox1, bbox2);
      const area = bboxArea(bbox1) + bboxArea(bbox2);
      if (overlap < minOverlap) {
        minOverlap = overlap;
        index = i;
        minArea = area < minArea ? area : minArea;
      } else if (overlap === minOverlap) {
        if (area < minArea) {
          minArea = area;
          index = i;
        }
      }
    }
    return index || M - m;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(node, m, M) {
    const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
    const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
    const xMargin = this._allDistMargin(node, m, M, compareMinX);
    const yMargin = this._allDistMargin(node, m, M, compareMinY);
    if (xMargin < yMargin)
      node.children.sort(compareMinX);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(node, m, M, compare3) {
    node.children.sort(compare3);
    const toBBox = this.toBBox;
    const leftBBox = distBBox(node, 0, m, toBBox);
    const rightBBox = distBBox(node, M - m, M, toBBox);
    let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
    for (let i = m; i < M - m; i++) {
      const child = node.children[i];
      extend(leftBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(leftBBox);
    }
    for (let i = M - m - 1; i >= m; i--) {
      const child = node.children[i];
      extend(rightBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(rightBBox);
    }
    return margin;
  }
  _adjustParentBBoxes(bbox, path, level) {
    for (let i = level; i >= 0; i--) {
      extend(path[i], bbox);
    }
  }
  _condense(path) {
    for (let i = path.length - 1, siblings; i >= 0; i--) {
      if (path[i].children.length === 0) {
        if (i > 0) {
          siblings = path[i - 1].children;
          siblings.splice(siblings.indexOf(path[i]), 1);
        } else
          this.clear();
      } else
        calcBBox(path[i], this.toBBox);
    }
  }
};
function findItem(item, items, equalsFn) {
  if (!equalsFn)
    return items.indexOf(item);
  for (let i = 0; i < items.length; i++) {
    if (equalsFn(item, items[i]))
      return i;
  }
  return -1;
}
function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
}
function distBBox(node, k, p, toBBox, destNode) {
  if (!destNode)
    destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i = k; i < p; i++) {
    const child = node.children[i];
    extend(destNode, node.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend(a, b) {
  a.minX = Math.min(a.minX, b.minX);
  a.minY = Math.min(a.minY, b.minY);
  a.maxX = Math.max(a.maxX, b.maxX);
  a.maxY = Math.max(a.maxY, b.maxY);
  return a;
}
function compareNodeMinX(a, b) {
  return a.minX - b.minX;
}
function compareNodeMinY(a, b) {
  return a.minY - b.minY;
}
function bboxArea(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function bboxMargin(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}
function enlargedArea(a, b) {
  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}
function intersectionArea(a, b) {
  const minX = Math.max(a.minX, b.minX);
  const minY = Math.max(a.minY, b.minY);
  const maxX = Math.min(a.maxX, b.maxX);
  const maxY = Math.min(a.maxY, b.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a, b) {
  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
}
function intersects(a, b) {
  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n, compare3) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n)
      continue;
    const mid = left + Math.ceil((right - left) / n / 2) * n;
    quickselect(arr, mid, left, right, compare3);
    stack.push(left, mid, mid, right);
  }
}

// node_modules/@rpgjs/common/lib/WorldMaps.js
var RpgCommonWorldMaps = class {
  constructor(id) {
    this.id = id;
    this.mapsTree = new RBush(500);
    this.maps = /* @__PURE__ */ new Map();
  }
  /**
   * Adding information from the map to the world
   *
   * > Maximum maps in world: 500
   *
   * @title Add Map in world
   * @method world.addMap(wordMapInfo,map)
   * @param {object} wordMapInfo
   * Object file:
   * ```ts
   * {
   *  fileName: string;
      height: number;
      width: number;
      x: number;
      y: number;
   * }
      ```
      `fileName` represents a file to the JSON file (TMX transformed) or directly the Tiled Map Editor object
   *
   * @param {class of RpgMap} map
   * @since 3.0.0-beta.8
   * @memberof RpgWorldMaps
   */
  addMap(wordMapInfo, map2) {
    const { x, y, height, width } = wordMapInfo;
    map2.prototype.worldMapParent = this;
    this.maps.set(map2.id, wordMapInfo);
    this.mapsTree.insert({
      minX: x,
      minY: y,
      maxX: x + width,
      maxY: y + height,
      map: map2
    });
  }
  updateMap(mapId, wordMapInfo) {
    const map2 = this.maps.get(mapId);
    if (map2) {
      const item = this.mapsTree.all().find((item2) => item2.map.id == mapId);
      if (!item)
        return false;
      this.maps.set(mapId, wordMapInfo);
      item.map.prototype.worldMapParent = this;
      item.minX = wordMapInfo.x;
      item.minY = wordMapInfo.y;
      item.maxX = wordMapInfo.x + wordMapInfo.width;
      item.maxY = wordMapInfo.y + wordMapInfo.height;
      return true;
    }
    return false;
  }
  /**
   * Remove map of the world
   * @title Remove map of the world
   * @method world.removeMap(mapId)
   * @param {string} mapId
   * @returns {boolean}
   * @since 3.0.0-beta.8
   * @memberof RpgWorldMaps
   */
  removeMap(mapId) {
    const map2 = this.maps.get(mapId);
    if (map2) {
      const item = this.mapsTree.all().find((item2) => item2.map.id == mapId);
      if (!item)
        return false;
      this.maps.delete(mapId);
      item.map.prototype.worldMapParent = void 0;
      this.mapsTree.remove(item);
      return true;
    }
    return false;
  }
  removeAllMaps() {
    this.maps.forEach((map2, id) => {
      this.removeMap(id);
    });
  }
  /**
   * Retrieve information from the world
   *
   * @title Retrieve information from the world
   * @method world.getMapInfo(id)
   * @param {string} id map id
   * @return {RpgTiledWorldMap | undefined}
   * {
   *  id?: string
   *  properties?: object
   *  fileName: string;
      height: number;
      width: number;
      x: number;
      y: number;
   * }
   * @since 3.0.0-beta.8
   * @memberof RpgWorldMaps
   */
  getMapInfo(id) {
    return this.maps.get(id);
  }
  /**
   * Retrieves neighboring maps according to positions or direction
   *
   * @title Retrieves neighboring maps
   * @method world.getAdjacentMaps(map,search)
   * @param {RpgMap} map The source map. We want to find the neighboring maps of the source map
   * @param { PositionBox | Direction | { x: number, y: number } } search Research method
   *  * PositionBox. An object of the following form:
   *  `{ minX: number, minY: number, maxX: number, maxY: number }`
   *  * Direction. Collect all the maps in the given direction (e.g. the maps at the top)
   *  * Point: { x: number, y: number }
   * @return { {class of RpgMap}[] }
   * @since 3.0.0-beta.8
   * @example
   * ```ts
   * world.getAdjacentMaps(mymap, Direction.Up) // returns [class of RpgMap]
   * ```
   * @memberof RpgWorldMaps
   */
  getAdjacentMaps(map2, search) {
    let position = {};
    const point = search;
    if (typeof search == "number") {
      const padding = 1;
      switch (search) {
        case Direction.Up:
          position = {
            minX: map2.worldX + padding,
            maxX: map2.worldX + map2.widthPx - padding,
            minY: map2.worldY - padding - 1,
            maxY: map2.worldY - padding
          };
          break;
        case Direction.Right:
          position = {
            minX: map2.worldX + map2.widthPx + padding,
            maxX: map2.worldX + map2.widthPx + padding + 1,
            minY: map2.worldY + padding,
            maxY: map2.worldY + map2.heightPx - padding
          };
          break;
        case Direction.Down:
          position = {
            minX: map2.worldX + padding,
            maxX: map2.worldX + map2.widthPx - padding,
            minY: map2.worldY + map2.heightPx + padding,
            maxY: map2.worldY + map2.heightPx + padding + 1
          };
          break;
        case Direction.Left:
          position = {
            minX: map2.worldX - padding,
            maxX: map2.worldX - padding - 1,
            minY: map2.worldY + padding,
            maxY: map2.worldY + map2.heightPx - padding
          };
          break;
      }
    } else if (point.x) {
      position = {
        minX: point.x,
        maxX: point.x,
        minY: point.y,
        maxY: point.y
      };
    } else {
      position = search;
    }
    const result = this.mapsTree.search(position);
    return result.map((ret) => ret.map);
  }
};

// node_modules/@rpgjs/common/lib/Color.js
function hexToRGB(hex) {
  let r = parseInt(hex.substring(0, 2), 16);
  let g = parseInt(hex.substring(2, 4), 16);
  let b = parseInt(hex.substring(4, 6), 16);
  return [r, g, b];
}
function RGBToHex(rgb) {
  let r = rgb[0].toString(16).padStart(2, "0");
  let g = rgb[1].toString(16).padStart(2, "0");
  let b = rgb[2].toString(16).padStart(2, "0");
  return r + g + b;
}
function transitionColor(startColor, endColor, steps) {
  let startRGB = hexToRGB(startColor.replace("#", ""));
  let endRGB = hexToRGB(endColor.replace("#", ""));
  let deltaRGB = [(endRGB[0] - startRGB[0]) / steps, (endRGB[1] - startRGB[1]) / steps, (endRGB[2] - startRGB[2]) / steps];
  let colors = [];
  for (let i = 0; i < steps; i++) {
    let color = [startRGB[0] + deltaRGB[0] * i, startRGB[1] + deltaRGB[1] * i, startRGB[2] + deltaRGB[2] * i];
    colors.push(RGBToHex(color));
  }
  colors.push(endColor.replace("#", ""));
  return colors;
}

// node_modules/@rpgjs/common/lib/DefaultInput.js
var DefaultInput = {
  [Control.Up]: {
    repeat: true,
    bind: Input.Up
  },
  [Control.Down]: {
    repeat: true,
    bind: Input.Down
  },
  [Control.Right]: {
    repeat: true,
    bind: Input.Right
  },
  [Control.Left]: {
    repeat: true,
    bind: Input.Left
  },
  [Control.Action]: {
    bind: [Input.Space, Input.Enter]
  },
  [Control.Back]: {
    bind: Input.Escape
  }
};

// node_modules/@rpgjs/common/lib/Inject.js
var InjectContext = class {
  constructor() {
    this.instances = /* @__PURE__ */ new Map();
  }
  inject(constructor, args = []) {
    const serviceName = constructor.name;
    if (!this.instances.has(serviceName)) {
      const instance = new constructor(this, ...args);
      if (instance["initialize"]) {
        instance["initialize"](...args);
      }
      this.instances.set(serviceName, instance);
    }
    return this.instances.get(serviceName);
  }
};

export {
  Utils_exports,
  Direction,
  PlayerType,
  SocketMethods,
  SocketEvents,
  Control,
  Input,
  TiledLayerType,
  isTiledFormat,
  isNull,
  isNullOrUndefined,
  isString2 as isString,
  isObject2 as isObject,
  init_util,
  path_default,
  TiledParser,
  Tileset,
  TiledParserFile,
  ShapePositioning,
  RpgShape,
  __extends,
  __assign,
  __awaiter,
  __generator,
  __values,
  __read,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncValues,
  createErrorClass,
  Observable,
  Subject,
  BehaviorSubject,
  from2 as from,
  of,
  lastValueFrom,
  map,
  combineLatest,
  forkJoin,
  filter2 as filter,
  distinctUntilChanged,
  finalize,
  switchMap,
  takeUntil,
  tap,
  RpgCommonMap,
  EventEmitter2 as EventEmitter,
  HookServer,
  HookClient,
  RpgPlugin,
  GameSide,
  RpgCommonGame,
  LiteralDirection,
  RpgCommonPlayer,
  Player_default,
  PrebuiltGui,
  Scheduler2 as Scheduler,
  RpgModule,
  loadModules,
  RpgCommonWorldMaps,
  transitionColor,
  DefaultInput,
  InjectContext,
  require_browser
};
/*! Bundled license information:

sat/SAT.js:
  (** @preserve SAT.js - Version 0.9.0 - Copyright 2012 - 2021 - Jim Riecken <jimr@jimr.ca> - released under the MIT License. https://github.com/jriecken/sat-js *)

rollup-plugin-node-polyfills/polyfills/buffer-es6.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

event-lite/event-lite.js:
  (**
   * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
   *
   * @copyright Yusuke Kawasaki
   * @license MIT
   * @constructor
   * @see https://github.com/kawanet/event-lite
   * @see http://kawanet.github.io/event-lite/EventLite.html
   * @example
   * var EventLite = require("event-lite");
   *
   * function MyClass() {...}             // your class
   *
   * EventLite.mixin(MyClass.prototype);  // import event methods
   *
   * var obj = new MyClass();
   * obj.on("foo", function() {...});     // add event listener
   * obj.once("bar", function() {...});   // add one-time event listener
   * obj.emit("foo");                     // dispatch event
   * obj.emit("bar");                     // dispatch another event
   * obj.off("foo");                      // remove event listener
   *)
*/
//# sourceMappingURL=chunk-34HTHRSF.js.map
