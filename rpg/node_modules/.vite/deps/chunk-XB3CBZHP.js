import {
  DefaultInput,
  Direction,
  EventEmitter,
  GameSide,
  HookServer,
  InjectContext,
  LiteralDirection,
  Observable,
  PlayerType,
  PrebuiltGui,
  RpgCommonGame,
  RpgCommonMap,
  RpgCommonPlayer,
  RpgCommonWorldMaps,
  RpgPlugin,
  Scheduler,
  SocketEvents,
  SocketMethods,
  TiledParser,
  TiledParserFile,
  Utils_exports,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __extends,
  __generator,
  __read,
  __spreadArray,
  __values,
  from,
  isTiledFormat,
  loadModules,
  of,
  path_default,
  require_browser,
  switchMap,
  takeUntil,
  tap
} from "./chunk-34HTHRSF.js";
import {
  axios_default
} from "./chunk-JLYFZH6S.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-2GTGKKMZ.js";

// node_modules/lodash.merge/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.merge/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto2 = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto2.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs2 = data.__data__;
        if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
          pairs2.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs2);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray5(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction3(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray5(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray5(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction3(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity2), func + "");
    }
    var baseSetToString = !defineProperty ? identity2 : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer2, isDeep) {
      if (isDeep) {
        return buffer2.slice();
      }
      var length = buffer2.length, result = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
      buffer2.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike2(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count2 = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count2 >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count2 = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray5 = Array.isArray;
    function isArrayLike2(value) {
      return value != null && isLength(value.length) && !isFunction3(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike2(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction3(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var merge5 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity2(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module.exports = merge5;
  }
});

// node_modules/simple-room/lib/utils.js
var GENERIC_KEY_SCHEMA = "@";
var Utils = class _Utils {
  static isObject(val) {
    return typeof val === "object" && !Array.isArray(val) && val != null;
  }
  static propertiesToArray(obj) {
    const addDelimiter = (a, b) => a ? `${a}.${b}` : b;
    const paths = (obj2 = {}, head = "") => {
      return Object.entries(obj2).reduce((product, array) => {
        const [key] = array;
        const value = array[1];
        const extraProp = Room.hasExtraProp(value);
        let fullPath = addDelimiter(head, key == "0" ? GENERIC_KEY_SCHEMA : key);
        if (extraProp) {
          if (value.$syncWithClient === false) {
            return product;
          }
        }
        if (key[0] != "_" && !extraProp && (_Utils.isObject(value) || Array.isArray(value))) {
          if (Object.keys(value).length == 0) {
            return product.concat(fullPath);
          }
          return product.concat(paths(value, fullPath));
        } else {
          return product.concat(fullPath);
        }
      }, []);
    };
    return paths(obj);
  }
  static generateId(n = 5) {
    return Math.random().toString(36).substring(n);
  }
  static async resolveValue(value) {
    if (value instanceof Promise) {
      return await value;
    }
    return value;
  }
  static set(obj, path, value, onlyPlainObject = false) {
    if (Object(obj) !== obj)
      return obj;
    if (typeof path === "string") {
      path = path.split(".");
    }
    let len = path.length;
    if (!len)
      return obj;
    let current = obj;
    for (let i = 0; i < len - 1; i++) {
      let segment = path[i];
      let nextSegment = path[i + 1];
      let isNextNumeric = !isNaN(nextSegment) && isFinite(nextSegment);
      if (!current[segment] || typeof current[segment] !== "object") {
        current[segment] = isNextNumeric && !onlyPlainObject ? [] : {};
      }
      current = current[segment];
    }
    current[path[len - 1]] = value;
    return obj;
  }
  static get(obj, path) {
    const keys = path.split(".");
    let current = obj;
    for (let key of keys) {
      if (current[key] === void 0) {
        return void 0;
      }
      current = current[key];
    }
    return current;
  }
  static bufferFrom(input) {
    if (typeof input === "string") {
      let encoder = new TextEncoder();
      return encoder.encode(input);
    } else if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
      return new Uint8Array(input);
    } else {
      throw new Error("Input type not supported");
    }
  }
};

// node_modules/simple-room/lib/packet.js
var import_msgpack_lite = __toESM(require_browser(), 1);
var Packet = class _Packet {
  constructor(data, roomId) {
    this.data = data;
    this.roomId = roomId;
  }
  get body() {
    return this.data;
  }
  message(otherData) {
    return [this.roomId, Date.now(), otherData ?? this.data];
  }
  clone(data) {
    return new _Packet(data, this.roomId);
  }
  encode(otherData) {
    return import_msgpack_lite.default.encode(this.message(otherData));
  }
};

// node_modules/simple-room/lib/transmitter.js
var { get, set } = Utils;
var TransmitterClass = class {
  constructor() {
    this.encode = true;
    this.packets = {};
  }
  addPacket(room, obj) {
    const { id } = room;
    if (!id)
      return;
    if (!this.packets[id])
      this.packets[id] = [];
    this.packets[id].push(new Packet(obj, id));
  }
  forEach(cb) {
    for (let roomId in this.packets) {
      cb(this.packets[roomId], roomId);
    }
  }
  getPackets(room) {
    if (!room.id)
      return;
    return this.packets[room.id];
  }
  clear(room) {
    if (room && room.id) {
      this.packets[room.id] = [];
    } else {
      this.packets = {};
    }
  }
  error(user, error) {
    const err = error instanceof Error ? error.toObject ? error.toObject() : error.message : error;
    user._socket.emit("error", err);
  }
  async emit(user, packet, room) {
    let data = packet.body;
    if (room.$additionalEmitProperties) {
      let additionalData = await Utils.resolveValue(room.$additionalEmitProperties(user, packet.body));
      if (additionalData !== void 0) {
        if (typeof additionalData === "string") {
          additionalData = [additionalData];
        }
        if (Array.isArray(additionalData)) {
          const newData = structuredClone(data);
          for (let path of additionalData) {
            set(newData, path, get(room, path));
          }
          data = newData;
        } else {
          data = { ...data, ...additionalData };
        }
      }
    }
    user._socket.emit("w", this.encode ? packet.encode(data) : packet.message(data));
  }
};
var Transmitter = new TransmitterClass();

// node_modules/simple-room/lib/rooms/default.js
var UserState;
(function(UserState2) {
  UserState2["Connected"] = "C";
  UserState2["Disconnected"] = "D";
})(UserState || (UserState = {}));
var User = class {
  constructor() {
    this.$state = UserState.Connected;
    this._secretSessionId = "";
    this._rooms = [];
  }
};
User.schema = {
  $state: String
};

// node_modules/simple-room/lib/errors/error.js
var CustomError = class extends Error {
  constructor(customMessage) {
    super(customMessage);
    this.customMessage = customMessage;
    this.status = 500;
    this.code = "INTERNAL_SERVER_ERROR";
    this.message = "Internal Server error";
  }
  toObject() {
    return {
      message: this.customMessage || this.message,
      status: this.status,
      code: this.code
    };
  }
};

// node_modules/simple-room/lib/errors/not-authorized.js
var NotAuthorized = class extends CustomError {
  constructor(customMessage) {
    super(customMessage);
    this.status = 401;
    this.code = "NOT_AUTHORIZED";
    this.message = "Not authorized";
  }
};

// node_modules/simple-room/lib/room.js
var { set: set2, get: get2 } = Utils;
var Room = class _Room {
  static hasExtraProp(obj) {
    return obj.$default !== void 0 || obj.$syncWithClient !== void 0 || obj.$permanent !== void 0 || obj.$validate !== void 0 || obj.$effects !== void 0 || obj.$type !== void 0;
  }
  static compileSchema(schema, room) {
    const dict = {};
    const masks = {};
    const permanentObject = [];
    function specialObject(val, p) {
      if (_Room.hasExtraProp(val)) {
        if (val.$permanent ?? true)
          permanentObject.push(p);
        if (room && val.$default !== void 0) {
        }
        if (val.$syncWithClient === false) {
          return;
        }
        dict[p] = {
          ...val
        };
      } else {
        dict[p] = val;
        masks[p] = Utils.propertiesToArray(val);
        compile(val, p);
      }
    }
    function compile(schema2, path = "") {
      for (let prop in schema2) {
        const val = schema2[prop];
        let p = (path ? path + "." : "") + prop;
        if (Array.isArray(val)) {
          dict[p] = GENERIC_KEY_SCHEMA;
          p += "." + GENERIC_KEY_SCHEMA;
          if (val[0] === void 0)
            val[0] = {};
          if (Utils.isObject(val[0])) {
            specialObject(val[0], p);
          } else {
            dict[p] = val[0];
            compile(val[0], p);
          }
        } else if (Utils.isObject(val)) {
          specialObject(val, p);
        } else {
          permanentObject.push(p);
          dict[p] = val;
        }
      }
    }
    compile(schema);
    return {
      masks,
      dict,
      permanentObject
    };
  }
  constructor(options) {
    this.options = options;
    this.memoryTotalObject = {};
    this.memoryObject = {};
    this.permanentObject = [];
    this.propagateOldRoom = true;
    if (options.propagateOldRoom) {
      this.propagateOldRoom = options.propagateOldRoom;
    }
  }
  async join(user, room) {
    if (room["canJoin"]) {
      const authBool = await Utils.resolveValue(room["canJoin"](user, user._socket));
      if (authBool === false || typeof authBool == "string") {
        Transmitter.error(user, new NotAuthorized(authBool));
        return false;
      }
    }
    if (World.agonesSDK) {
      await World.agonesSDK.allocate();
    }
    let firstJoin = !room.users[user.id];
    room.users[user.id] = user;
    const userProxy = World.users[user.id]["proxy"];
    userProxy.$state = UserState.Connected;
    if (firstJoin) {
      if (room["onJoin"])
        await Utils.resolveValue(room["onJoin"](userProxy));
    }
    if (this.getUsersLength(room) == 1) {
      this.memoryTotalObject = _Room.extractObjectOfRoom(room, room.$schema);
    }
    const packet = new Packet({
      ...this.memoryTotalObject,
      join: firstJoin
    }, room.id);
    await Transmitter.emit(userProxy, packet, room);
    return true;
  }
  async leave(user, room) {
    if (room["onLeave"])
      room["onLeave"](user);
    const index = user._rooms.findIndex((id) => room.id == id);
    user._rooms.splice(index, 1);
    delete room.users[user.id];
    delete World.users[user.id]["proxy"];
    if (World.nbUsers == 0 && World.agonesSDK) {
      const { onBeforeShutdown, shutdownIfNotPlayers } = World.agonesOptions;
      if (shutdownIfNotPlayers) {
        if (onBeforeShutdown)
          await onBeforeShutdown();
        await World.agonesSDK.shutdown();
      }
    }
  }
  getUsersLength(room) {
    return Object.keys(room.users).length;
  }
  addInputs(room, obj) {
    room.$schema = {
      ...obj,
      ...room.$schema
    };
  }
  snapshotUser(room, userId) {
    const userSchema = this.permanentObject.filter((path) => path.startsWith("users.@")).map((path) => path.replace("users.@.", ""));
    const userObject = room.users[userId];
    if (!userObject)
      return null;
    return _Room.extractObjectOfRoom(userObject, userSchema);
  }
  snapshot(room) {
    return _Room.extractObjectOfRoom(room, this.permanentObject);
  }
  setProxy(room) {
    const self2 = this;
    const { dict, permanentObject, masks } = _Room.compileSchema(room.$schema, room);
    const proxifiedObjects = /* @__PURE__ */ new WeakSet();
    this.permanentObject = permanentObject;
    room.$dict = dict;
    const getInfoDict = (path, key, dictPath) => {
      const basePath = dict[dictPath];
      const p = (path ? path + "." : "") + key;
      const genericPath = (dictPath ? dictPath + "." : "") + (basePath == GENERIC_KEY_SCHEMA ? GENERIC_KEY_SCHEMA : key);
      return {
        fullPath: p,
        genericPath,
        infoDict: dict[genericPath],
        mask: masks[genericPath]
      };
    };
    function deepProxy(object, path = "", dictPath = "") {
      if (proxifiedObjects.has(object)) {
        return object;
      }
      return new Proxy(object, {
        set(target, key, val, receiver) {
          const { fullPath: p, infoDict, genericPath, mask } = getInfoDict(path, key, dictPath);
          if (typeof val == "object" && infoDict && val != null) {
            const valProxy = deepProxy(val, p, genericPath);
            proxifiedObjects.add(valProxy);
            if (path == "users") {
              if (!room.users[key]) {
                if (!valProxy._rooms)
                  valProxy._rooms = [];
                valProxy._rooms.push(room.id);
                if (!valProxy.id)
                  valProxy.id = Utils.generateId();
              }
              World.users[key]["proxy"] = valProxy;
            }
            Reflect.set(target, key, val, receiver);
            val = target[key];
          } else {
            if (infoDict == null ? void 0 : infoDict.$validate) {
              const { error } = infoDict.$validate.validate(val);
              if (error)
                return true;
            }
            Reflect.set(target, key, val, receiver);
            val = target[key];
          }
          if (key == "length" && dict[dictPath] == GENERIC_KEY_SCHEMA) {
            return true;
          }
          if (infoDict) {
            if (infoDict.$effects) {
              for (let propEffect of infoDict.$effects) {
                let pathEffect = "";
                if (propEffect.startsWith("$this")) {
                  if (p) {
                    const pSplit = p.split(".");
                    pSplit[pSplit.length - 1] = propEffect.replace("$this.", "");
                    pathEffect = pSplit.join(".");
                  } else {
                    pathEffect = propEffect.replace("$this.", "");
                  }
                } else {
                  pathEffect = propEffect;
                }
                self2.editMemoryObject(pathEffect, room);
              }
            }
            let newObj;
            if (Utils.isObject(infoDict) && val != null && !_Room.hasExtraProp(infoDict)) {
              newObj = _Room.extractObjectOfRoom(val, mask);
            } else if (infoDict == GENERIC_KEY_SCHEMA) {
              newObj = {};
              if (Object.keys(val).length == 0) {
                newObj["$reset"] = true;
              }
              for (let key2 in val) {
                const item = val[key2];
                if (typeof item == "string" || typeof item == "number" || typeof item == "boolean") {
                  newObj[key2] = item;
                  continue;
                }
                newObj[key2] = _Room.extractObjectOfRoom(item, dict[genericPath + "." + GENERIC_KEY_SCHEMA]);
              }
            } else {
              newObj = val;
            }
            self2.detectChanges(room, newObj, p);
          }
          return true;
        },
        get(target, key, receiver) {
          const toProxy = (val2, path2) => {
            if (typeof key != "string") {
              return val2;
            }
            if (key[0] == "_" || val2 == null) {
              return val2;
            }
            const { fullPath: p, infoDict, genericPath } = getInfoDict(path2, key, dictPath);
            if (typeof val2 == "object" && infoDict) {
              val2 = deepProxy(val2, p, genericPath);
              proxifiedObjects.add(val2);
            }
            return val2;
          };
          let val = Reflect.get(target, key, receiver);
          val = toProxy(val, path);
          return val;
        },
        deleteProperty(target, key) {
          const { fullPath: p, infoDict } = getInfoDict(path, key, dictPath);
          Reflect.deleteProperty(target, key);
          if (infoDict)
            self2.detectChanges(room, null, p);
          return true;
        }
      });
    }
    return deepProxy(room);
  }
  add(id, room) {
    room.id = id;
    room.$dict = {};
    if (!room.$schema)
      room.$schema = {};
    if (!room.$schema.users)
      room.$schema.users = [User.schema];
    if (!room.$inputs)
      room.$inputs = {};
    if (!room.users)
      room.users = {};
    if (room.$inputs)
      this.addInputs(room, room.$inputs);
    room.$detectChanges = () => {
    };
    room.$setSchema = (schema) => {
      room.$schema = schema;
      return this.setProxy(room);
    };
    room.$patchSchema = (schema) => {
      room.$schema = {
        ...room.$schema,
        ...schema
      };
      return this.setProxy(room);
    };
    room.$snapshot = () => {
      return this.snapshot(room);
    };
    room.$snapshotUser = (userId) => {
      return this.snapshotUser(room, userId);
    };
    room.$join = async (user) => {
      if (typeof user == "string") {
        user = World.users[user];
      }
      if (user) {
        return this.join(user, room);
      }
      return false;
    };
    room.$leave = async (user) => {
      if (typeof user == "string") {
        user = World.users[user]["proxy"];
      }
      await this.leave(user, room);
    };
    room.$currentState = () => this.memoryObject;
    room.$setCurrentState = (path, value) => {
      this.editMemoryObject(path, value === void 0 ? room : value);
    };
    room.$clearCurrentState = () => {
      this.memoryObject = {};
    };
    room.$parent = this;
    this.proxyRoom = room = this.setProxy(room);
    if (this.proxyRoom["onInit"])
      this.proxyRoom["onInit"]();
    return this.proxyRoom;
  }
  static extractObjectOfRoom(room, schema) {
    const newObj = {};
    const _schema = Array.isArray(schema) ? schema : Utils.propertiesToArray(schema);
    const regex = new RegExp("^(.*?)\\.\\" + GENERIC_KEY_SCHEMA);
    function extractAndSet(obj, path) {
      if (path.endsWith("@")) {
        return;
      }
      const match = regex.exec(path);
      if (match) {
        const generic = get2(room, match[1]);
        if (generic && typeof generic === "object") {
          for (let key in generic) {
            if (generic.hasOwnProperty(key)) {
              extractAndSet(obj, path.replace(GENERIC_KEY_SCHEMA, key));
            }
          }
        }
      } else {
        set2(obj, path, get2(room, path));
      }
    }
    for (let path of _schema) {
      extractAndSet(newObj, path);
    }
    return newObj;
  }
  detectChanges(room, obj, path) {
    const change = (room2) => {
      const roomInstance = room2.$parent;
      roomInstance.editMemoryObject(path, obj);
      set2(roomInstance.memoryTotalObject, path, obj);
      if (roomInstance.proxyRoom["onChanges"])
        roomInstance.proxyRoom["onChanges"](roomInstance.memoryObject);
      const id = room2.id;
      World.changes.next({
        ...World.changes.value,
        [id]: room2
      });
    };
    if (obj != null) {
      const [prop, userId] = path.split(".");
      if (prop == "users") {
        if (!this.propagateOldRoom && !room.users[userId]) {
          return;
        }
        World.forEachUserRooms(userId, change);
        return;
      }
    }
    change(room);
  }
  editMemoryObject(path, roomOrValue) {
    if (roomOrValue && typeof roomOrValue == "object" && "$currentState" in roomOrValue) {
      set2(this.memoryObject, path, get2(roomOrValue, path), true);
    } else {
      set2(this.memoryObject, path, roomOrValue, true);
    }
  }
};
Room.propNameUsers = "users";

// node_modules/simple-room/lib/transports/common.js
var TransportCommon = class {
  onConnected(cb) {
    this.onConnectedCb = cb;
  }
  onJoin(cb) {
    this.onJoinCb = cb;
  }
  onInput(cb) {
    this.onInputCb = cb;
  }
  onAction(cb) {
    this.onActionCb = cb;
  }
  onDisconnected(cb) {
    this.onDisconnectedCb = cb;
  }
};

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable2 = function() {
  function Observable3(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable3.prototype.lift = function(operator) {
    var observable2 = new Observable3();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable3.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable3.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable3.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable3.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable3.prototype[observable] = function() {
    return this;
  };
  Observable3.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable3.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable3.create = function(subscribe) {
    return new Observable3(subscribe);
  };
  return Observable3;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable2);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable2(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id = 0;
    var run = function() {
      if (!subscriber.closed) {
        id = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id = 0;
          var now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id) {
        animationFrameProvider.cancelAnimationFrame(id);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable2();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable2);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last3 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last3 = i;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      immediateProvider.clearImmediate(id);
      if (scheduler._scheduled === id) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler2 = function() {
  function Scheduler3(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler3.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler3.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  };
  Scheduler3.now = dateTimestampProvider.now;
  return Scheduler3;
}();

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler2);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state, delay2);
    }
    this.delay = delay2;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      animationFrameProvider.cancelAnimationFrame(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay2);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay2);
    }
  };
  VirtualAction2.sortActions = function(a, b) {
    if (a.delay === b.delay) {
      if (a.index === b.index) {
        return 0;
      } else if (a.index > b.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a.delay > b.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable2(function(subscriber) {
  return subscriber.complete();
});

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false)
            return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable2) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable2(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable2(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable2(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable2(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable2(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable2(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable2(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable2(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/observable/from.js
function from2(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/observable/of.js
function of2() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from2(args, scheduler);
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable2(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a;
    return isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    var result = kind === "N" ? of2(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
}();
function observeNotification(notification, observer) {
  var _a, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray = Array.isArray;

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray2 = Array.isArray;
var objectProto = Object.prototype;

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable2(noop);

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
var isArray3 = Array.isArray;

// node_modules/simple-room/node_modules/rxjs/dist/esm5/internal/operators/timeInterval.js
var TimeInterval = function() {
  function TimeInterval2(value, interval2) {
    this.value = value;
    this.interval = interval2;
  }
  return TimeInterval2;
}();

// node_modules/simple-room/lib/transports/socket.js
var Transport = class extends TransportCommon {
  constructor(io, options = {}) {
    super();
    this.io = io;
    this.options = options;
    this.bandwidthData = {};
    this.WINDOW_SECONDS = 10;
    io.on("connection", (socket) => {
      const id = socket.playerId;
      this.bandwidthData[id] = new BehaviorSubject({
        incoming: [],
        outgoing: []
      });
      this.handleConnection(socket, id);
      socket.on(":input", ({ prop, value }) => this.onInputCb(id, prop, value));
      socket.on(":action", ({ name, value }) => this.onActionCb(id, name, value));
      if (options.clientCanJoinRoom)
        socket.on(":join", (roomId) => this.onJoinCb(roomId, id));
      socket.on("disconnect", () => {
        var _a;
        (_a = this.bandwidthData[id]) == null ? void 0 : _a.unsubscribe();
        delete this.bandwidthData[id];
        this.onDisconnectedCb(id);
      });
    });
    this.use();
  }
  handleConnection(socket, id) {
    this.onConnectedCb(socket, id);
  }
  use() {
    var _a, _b;
    const { maxKbpsIncoming, maxKbpsOutgoing, auth } = this.options;
    (_b = (_a = this.io).use) == null ? void 0 : _b.call(_a, async (socket, next) => {
      let playerId;
      if (auth) {
        try {
          playerId = await Utils.resolveValue(auth(socket));
        } catch (err) {
          socket.disconnect();
          next(new NotAuthorized(err).toObject());
          return;
        }
      }
      if (!playerId)
        playerId = Utils.generateId(5);
      socket.playerId = playerId;
      socket.use((packet, nextMiddleware) => {
        var _a2, _b2;
        if (packet && packet[1]) {
          const packetSize = Utils.bufferFrom(JSON.stringify(packet)).length - 2;
          const data = { size: packetSize, timestamp: Date.now() };
          this.updateBandwidthData(playerId, { incoming: data });
          const kbps = this.calculateKbps(((_a2 = this.bandwidthData[playerId]) == null ? void 0 : _a2.value.incoming) || []);
          if (maxKbpsIncoming && kbps > maxKbpsIncoming) {
            socket.disconnect();
            return;
          }
          this.cleanOldData(((_b2 = this.bandwidthData[playerId]) == null ? void 0 : _b2.value.incoming) || []);
        }
        nextMiddleware();
      });
      const originalEmit = socket.emit;
      socket.emit = (...args) => {
        var _a2, _b2;
        const packetSize = Utils.bufferFrom(JSON.stringify(args)).length - 2;
        const data = { size: packetSize, timestamp: Date.now() };
        this.updateBandwidthData(playerId, { outgoing: data });
        const kbps = this.calculateKbps(((_a2 = this.bandwidthData[playerId]) == null ? void 0 : _a2.value.outgoing) || []);
        if (maxKbpsOutgoing && kbps > maxKbpsOutgoing) {
          socket.disconnect();
          return;
        }
        this.cleanOldData(((_b2 = this.bandwidthData[playerId]) == null ? void 0 : _b2.value.outgoing) || []);
        originalEmit.apply(socket, args);
      };
      next();
    });
  }
  updateBandwidthData(socketId, data) {
    var _a, _b;
    const currentData = ((_a = this.bandwidthData[socketId]) == null ? void 0 : _a.value) || { incoming: [], outgoing: [] };
    if (data.incoming) {
      currentData.incoming.push(data.incoming);
    }
    if (data.outgoing) {
      currentData.outgoing.push(data.outgoing);
    }
    (_b = this.bandwidthData[socketId]) == null ? void 0 : _b.next(currentData);
  }
  cleanOldData(dataArray) {
    const cutOff = Date.now() - this.WINDOW_SECONDS * 1e3;
    while (dataArray.length > 0 && dataArray[0].timestamp < cutOff) {
      dataArray.shift();
    }
  }
  calculateKbps(dataArray) {
    const totalBytes = dataArray.reduce((acc, entry) => acc + entry.size, 0);
    return totalBytes * 8 / (this.WINDOW_SECONDS * 1e3);
  }
  getTelemetry() {
    const socketsData = {};
    let totalKbps = 0;
    for (const [socketId, bandwidth] of Object.entries(this.bandwidthData)) {
      const socketData = bandwidth.value;
      const incomingKbps = this.calculateKbps(socketData.incoming);
      const outgoingKbps = this.calculateKbps(socketData.outgoing);
      socketsData[socketId] = { incomingKbps, outgoingKbps };
      totalKbps += incomingKbps + outgoingKbps;
    }
    return {
      sockets: socketsData,
      totalKbps
    };
  }
};

// node_modules/simple-room/lib/world.js
var WorldClass = class {
  constructor() {
    this.rooms = /* @__PURE__ */ new Map();
    this.users = {};
    this.userClass = User;
    this.timeoutDisconnect = 0;
    this.changes = new BehaviorSubject({});
    this._transport = null;
    this.agonesSDK = null;
    this.agonesOptions = {};
  }
  /**
   * Define user class
   *
   * @method setUserClass()
   * @returns {void}
   */
  setUserClass(userClass) {
    this.userClass = userClass;
  }
  setAgones(agones, options = {}) {
    this.agonesSDK = agones;
    this.agonesOptions = options;
  }
  /**
   * Define transportation. You can set socket.io as default
   *
   * @method transport()
   * @param {object} io
   * @returns {Transport}
   */
  transport(io, options = {}) {
    if (options.timeoutDisconnect) {
      this.timeoutDisconnect = options.timeoutDisconnect;
    }
    const transport = new Transport(io, options);
    transport.onConnected(this.connectUser.bind(this));
    transport.onDisconnected(this.disconnectUser.bind(this));
    transport.onJoin(this.joinRoom.bind(this));
    transport.onInput((id, prop, value) => {
      this.forEachUserRooms(id, (room, user) => {
        try {
          if (room.$inputs && room.$inputs[prop]) {
            room[prop] = value;
          }
        } catch (err) {
          Transmitter.error(user, err);
        }
      });
    });
    transport.onAction((id, name, value) => {
      this.forEachUserRooms(id, async (room, user) => {
        if (room.$actions && room.$actions[name]) {
          try {
            room[name](user, value);
          } catch (err) {
            Transmitter.error(user, err);
          }
        }
      });
    });
    return this._transport = transport;
  }
  /**
   * Loop over all rooms of a user
   *
   * Example
   *
   * ```js
   * World.forEachUserRooms('userid', (room, user) => {
   *      console.log(room.id)
   * })
   * ```
   *
   * @method forEachUserRooms()
   * @param {string} userId
   * @param {(room: RoomClass, user: User)} cb
   * @returns {void}
   */
  forEachUserRooms(userId, cb) {
    const user = this.getUser(userId, true);
    if (!user)
      return;
    for (let roomId of user._rooms) {
      const room = this.getRoom(roomId);
      cb(room, user);
    }
  }
  /**
  * Retrieves all users in the world
  *
  * @method getUsers()
  * @returns { {[id: string]: User} }
  */
  getUsers() {
    return this.users;
  }
  /**
   * Get a user in the world
   *
   * @param {string} id User Id
   * @param {boolean} [getProxy] Retrieves the proxied user. (true by default)
   * @returns {User | null}
   */
  getUser(id, getProxy = true) {
    if (!this.users[id])
      return null;
    if (getProxy && this.users[id]["proxy"]) {
      return this.users[id]["proxy"];
    }
    return this.users[id];
  }
  setUser(user, socket) {
    if (socket)
      user._socket = socket;
    user._rooms = [];
    this.users[user.id] = user;
    return this.users[user.id];
  }
  get nbUsers() {
    return Object.keys(this.users).length;
  }
  /**
   * Send the packages to the rooms.
   *
   * @method send()
   */
  async send() {
    for (let [_, room] of this.rooms) {
      const obj = room.$currentState();
      if (Object.keys(obj).length == 0) {
        continue;
      }
      Transmitter.addPacket(room, obj);
      for (let id in room.users) {
        const user = room.users[id];
        const packets = Transmitter.getPackets(room);
        if (packets) {
          for (let packet of packets) {
            await Transmitter.emit(user, packet, room);
          }
        }
      }
      room.$clearCurrentState();
    }
    Transmitter.clear();
  }
  /**
   * Connect a user
   *
   * @method connectUser()
   * @param {object} socket
   * @param {id} userId
   * @param {object} options
   *  - getUserInstance: function that returns a new instance of the user
   * @returns {User}
   */
  connectUser(socket, id, options = {}) {
    var _a;
    const existingUser = this.getUser(id, false);
    if (existingUser) {
      if (existingUser._timeoutDisconnect) {
        clearTimeout(existingUser._timeoutDisconnect);
        delete existingUser._timeoutDisconnect;
      }
      existingUser._socket = socket;
      existingUser.$state = UserState.Connected;
      return existingUser;
    }
    const user = ((_a = options.getUserInstance) == null ? void 0 : _a.call(options, socket)) ?? new this.userClass();
    user.id = id;
    socket.emit("uid", id);
    this.setUser(user, socket);
    return user;
  }
  /**
   * Removes the user from all rooms and removes him from the world
   *
   * @method disconnectUser()
   * @param {string} userId
   * @returns {void}
   */
  disconnectUser(userId) {
    return new Promise((resolve, reject) => {
      const user = this.getUser(userId);
      if (!user)
        return resolve();
      user.$state = UserState.Disconnected;
      const leave = () => {
        const leaveAllPromises = [];
        this.forEachUserRooms(userId, async (room, user2) => {
          if (room.$leave)
            leaveAllPromises.push(room.$leave(user2));
        });
        delete this.users[userId];
        Promise.all(leaveAllPromises).then(resolve).catch((err) => {
          Transmitter.error(user, err);
          reject(err);
        });
      };
      if (!this.timeoutDisconnect) {
        leave();
        return;
      }
      user._timeoutDisconnect = setTimeout(leave, this.timeoutDisconnect);
    });
  }
  httpUpgrade(httpServer, io) {
    httpServer.removeAllListeners("upgrade");
    httpServer.on("upgrade", (req, socket, head) => {
      if (req.url.startsWith("/socket.io/")) {
        io.engine.handleUpgrade(req, socket, head);
      } else {
        socket.destroy();
      }
    });
  }
  async joinOrLeaveRoom(type, roomId, userId) {
    const room = this.getRoom(roomId);
    if (!room)
      return;
    if (room[type]) {
      try {
        await room[type](this.getUser(userId, false));
      } catch (err) {
        Transmitter.error(this.getUser(userId, false), err);
        throw err;
      }
    }
    return room;
  }
  /**
   * Leave an existing room
   *
   * @param {string} roomId
   * @param {string} userId
   * @returns {RoomClass | undefined}
   */
  async leaveRoom(roomId, userId) {
    return this.joinOrLeaveRoom("$leave", roomId, userId);
  }
  /**
   * Join an existing room
   *
   * @param {string} roomId
   * @param {string} userId
   * @returns {RoomClass | undefined}
   */
  async joinRoom(roomId, userId) {
    return this.joinOrLeaveRoom("$join", roomId, userId);
  }
  /**
   * Add Room
   *
   * Example 1:
   *
   * ```js
   * class ChessRoom {
   *
   * }
   *
   * World.addRoom('myroom', ChessRoom)
   * ```
   *
   * Example 2:
   *
   * ```js
   * class ChessRoom {
   *  constructor(name) { }
   * }
   *
   * World.addRoom('myroom', new ChessRoom('test'))
   * ```
   *
   * @param {string} id room id
   * @param {Class or instance of Class} roomClass
   * @returns instance of Class
   */
  addRoom(id, roomClass, options = {}) {
    if (roomClass.constructor.name == "Function") {
      roomClass = new roomClass();
    }
    const room = new Room(options).add(id, roomClass);
    this.rooms.set(id, room);
    if (this.agonesSDK) {
      this.agonesSDK.setLabel("room.id", id);
    }
    return room;
  }
  /**
   * Get an existing room
   *
   * @param {string} roomId
   * @returns {RoomClass}
   */
  getRoom(id) {
    return this.rooms.get(id);
  }
  /**
   * Recover the rooms of the world
   *
   * @param {string} roomId
   * @returns {Map<string, RoomClass>}
   */
  getRooms() {
    return this.rooms;
  }
  /**
   * Delete the room
   *
   * @param {string} roomId
   * @returns {void}
   */
  removeRoom(id) {
    this.rooms.delete(id);
  }
  /**
   * Remove all rooms and users
   */
  clear() {
    var _a, _b;
    this.rooms.clear();
    this.changes.next({});
    this.users = {};
    if (this._transport) {
      (_b = (_a = this._transport.io) == null ? void 0 : _a.clear) == null ? void 0 : _b.call(_a);
    }
  }
};
var World = new WorldClass();

// node_modules/simple-room/lib/user.js
var User2 = class {
  constructor() {
    this._rooms = [];
  }
};
User2.schema = {};

// node_modules/simple-room/lib/testing/mock-socket.js
var MiddlewareHandler = class {
  constructor() {
    this.middlewares = [];
  }
  use(middleware) {
    this.middlewares.push(middleware);
  }
  run(socket, finalCallback = (err) => {
  }) {
    let index = 0;
    const next = (err) => {
      if (err) {
        finalCallback(err);
        return;
      }
      if (index >= this.middlewares.length) {
        finalCallback();
        return;
      }
      const middleware = this.middlewares[index];
      index += 1;
      middleware(socket, next);
    };
    next();
  }
  clear() {
    this.middlewares = [];
  }
};
var MockIo = class {
  constructor() {
    this.events = /* @__PURE__ */ new Map();
    this.eventsOnce = /* @__PURE__ */ new Map();
  }
  on(name, value) {
    this.events.set(name, [...this.events.get(name) || [], value]);
  }
  off(name) {
    if (this.eventsOnce.has(name)) {
      this.eventsOnce.delete(name);
      return;
    }
    this.events.delete(name);
  }
  once(name, value) {
    this.eventsOnce.set(name, value);
  }
  _trigger(name, data, client) {
    const events = this.events.get(name) || [];
    for (const event of events) {
      event(data, client);
    }
    const eventOnce = this.eventsOnce.get(name);
    if (eventOnce) {
      eventOnce(data, client);
      this.eventsOnce.delete(name);
    }
  }
};
var MockSocket = class extends MockIo {
  constructor(handshake, client) {
    super();
    this.handshake = handshake;
    this.client = client;
    this.middlewares = new MiddlewareHandler();
    this.id = client.fakeId ?? "" + Math.random();
    this.client.id = this.id;
  }
  emit(name, data) {
    this.client._trigger(name, data);
  }
  removeAllListeners(name) {
    return this.off(name);
  }
  use(cb) {
    this.middlewares.use(cb);
  }
  disconnect() {
  }
};
var MockClientIo = class extends MockIo {
  constructor(fakeId) {
    super();
    this.fakeId = fakeId;
    this.id = "";
    this._socket = null;
  }
  async connection(handshake) {
    this._socket = await serverIo.connection(this, handshake);
    this._trigger("connect", void 0);
    return this;
  }
  emit(name, data) {
    if (!this._socket)
      throw new Error("Client not connected");
    this._socket.middlewares.run([name, data], (err) => {
      if (err) {
        this._trigger("error", err);
        return;
      }
      serverIo.emit(name, data, this.id);
    });
    return this;
  }
  disconnect() {
    this.emit("disconnect", void 0);
  }
};
var MockServerIo = class extends MockIo {
  constructor() {
    super(...arguments);
    this.clients = /* @__PURE__ */ new Map();
    this.middlewares = new MiddlewareHandler();
  }
  connection(client, handshake) {
    return new Promise((resolve, reject) => {
      const socket = new MockSocket(handshake, client);
      this.clients.set(socket.id, socket);
      client.id = socket.id;
      this.middlewares.run(socket, (err) => {
        if (err) {
          client._trigger("error", err);
          return;
        }
        this._trigger("connection", socket);
        resolve(socket);
      });
    });
  }
  emit(name, data, id) {
    var _a;
    (_a = this.clients.get(id)) == null ? void 0 : _a._trigger(name, data);
  }
  use(cb) {
    this.middlewares.use(cb);
  }
  clear() {
    this.events.clear();
    this.eventsOnce.clear();
    this.clients.clear();
    this.middlewares.clear();
  }
};
var serverIo = new MockServerIo();
var ClientIo = MockClientIo;
var mock_socket_default = {
  serverIo,
  ClientIo
};

// node_modules/@rpgjs/server/lib/Player/Player.js
var import_lodash = __toESM(require_lodash(), 1);

// node_modules/@rpgjs/database/lib/common.js
function merge3(options, type, _static = {}) {
  const transformToRate = (optionName, propName) => {
    if (options[optionName]) {
      options[optionName] = options[optionName].map((element) => {
        if (!element.rate) {
          return {
            rate: 1,
            [propName]: element
          };
        }
        return element;
      });
    }
  };
  transformToRate("elements", "element");
  transformToRate("elementsDefense", "element");
  transformToRate("elementsEfficiency", "element");
  transformToRate("addStates", "state");
  transformToRate("removeStates", "state");
  transformToRate("statesDefense", "state");
  transformToRate("statesEfficiency", "state");
  return (target) => {
    const id = options.id || target.name.toLowerCase();
    target.id = id;
    target.prototype.id = id;
    target._type = type;
    for (let key in _static) {
      target[key] = options[key];
    }
    for (let key in options) {
      target.prototype[key] = options[key];
    }
    target.prototype.toJSON = function() {
      return this.id;
    };
  };
}

// node_modules/@rpgjs/database/lib/item.js
function Item(options) {
  return merge3(options, "item", {
    price: options.price
  });
}

// node_modules/@rpgjs/database/lib/actor.js
function Actor(options) {
  return merge3(options, "actor");
}

// node_modules/@rpgjs/database/lib/class.js
var ClassHooks;
(function(ClassHooks2) {
  ClassHooks2["onSet"] = "onSet";
  ClassHooks2["canEquip"] = "canEquip";
})(ClassHooks || (ClassHooks = {}));
function Class(options) {
  return merge3(options, "class");
}

// node_modules/@rpgjs/database/lib/skill.js
function Skill(options) {
  if (!options.coefficient)
    options.coefficient = {
      "int": 1
    };
  return merge3(options, "skill");
}

// node_modules/@rpgjs/database/lib/state.js
function State(options) {
  return merge3(options, "state");
}

// node_modules/@rpgjs/database/lib/weapon.js
function Weapon(options) {
  return merge3(options, "weapon", {
    price: options.price
  });
}

// node_modules/@rpgjs/database/lib/armor.js
function Armor(options) {
  return merge3(options, "armor", {
    price: options.price
  });
}

// node_modules/@rpgjs/database/lib/effect.js
var Effect;
(function(Effect2) {
  Effect2["NONE"] = "NONE";
  Effect2["CAN_NOT_SKILL"] = "CAN_NOT_SKILL";
  Effect2["CAN_NOT_ITEM"] = "CAN_NOT_ITEM";
  Effect2["ALWAYS_ATTACK_ENEMIES"] = "ALWAYS_ATTACK_ENEMIES";
  Effect2["CAN_NOT_EVADE"] = "CAN_NOT_EVADE";
  Effect2["CAN_NOT_GET_EXP"] = "CAN_NOT_GET_EXP";
  Effect2["CAN_NOT_GET_GOLD"] = "CAN_NOT_GET_GOLD";
  Effect2["PHARMACOLOGY"] = "PHARMACOLOGY";
  Effect2["CRITICAL_BONUS"] = "CRITICAL_BONUS";
  Effect2["SUPER_GUARD"] = "SUPER_GUARD";
  Effect2["GUARD"] = "GUARD";
  Effect2["PREVENT_CRITICAL"] = "PREVENT_CRITICAL";
  Effect2["HALF_SP_COST"] = "HALF_SP_COST";
  Effect2["DOUBLE_EXP_GAIN"] = "DOUBLE_EXP_GAIN";
  Effect2["AUTO_HP_RECOVER"] = "AUTO_HP_RECOVER";
  Effect2["FAST_ATTACK"] = "FAST_ATTACK";
  Effect2["DUAL_ATTACK"] = "DUAL_ATTACK";
  Effect2["SLIP_DAMAGE"] = "SLIP_DAMAGE";
})(Effect || (Effect = {}));

// node_modules/@rpgjs/database/lib/interfaces/efficiency.js
var Efficiency;
(function(Efficiency2) {
  Efficiency2[Efficiency2["VERY_VULNERABLE"] = 2] = "VERY_VULNERABLE";
  Efficiency2[Efficiency2["VULNERABLE"] = 1.5] = "VULNERABLE";
  Efficiency2[Efficiency2["NORMAL"] = 1] = "NORMAL";
  Efficiency2[Efficiency2["INVULNERABLE"] = 0.5] = "INVULNERABLE";
  Efficiency2[Efficiency2["PERFECT_INVULNERABLE"] = 0] = "PERFECT_INVULNERABLE";
  Efficiency2[Efficiency2["GAIN_HP"] = -0.5] = "GAIN_HP";
})(Efficiency || (Efficiency = {}));

// node_modules/@rpgjs/server/lib/logs/log.js
var Log = class {
  constructor(id, msg) {
    this.id = id;
    this.msg = msg;
  }
};

// node_modules/@rpgjs/server/lib/logs/item.js
var ItemLog = class {
  static notInInventory(itemClass) {
    return new Log("ITEM_NOT_INVENTORY", `The item ${itemClass.name} is not in inventory`);
  }
  static notUseItem(itemClass) {
    return new Log("NOT_USE_ITEM", `The player cannot use the ${itemClass.name} item.`);
  }
  static chanceToUseFailed(itemClass) {
    return new Log("USE_CHANCE_ITEM_FAILED", `Chance to use the ${itemClass.name} item has failed`);
  }
  static invalidToEquiped(itemClass) {
    return new Log("INVALID_ITEM_TO_EQUIP", `The item ${itemClass.name} is not a weapon or armor`);
  }
  static canNotEquip(itemClass) {
    return new Log("CANNOT_EQUIP", `The item ${itemClass.name} cannot be equiped`);
  }
  static isAlreadyEquiped(itemClass) {
    return new Log("ITEM_ALREADY_EQUIPED", `The item ${itemClass.name} is already equiped`);
  }
  static haveNotPrice(itemClass) {
    return new Log("NOT_PRICE", `Define a price > 0 to buy ${itemClass.name}`);
  }
  static notEnoughGold(itemClass, nb) {
    return new Log("NOT_ENOUGH_GOLD", `not enough gold to buy ${nb} ${itemClass.name}`);
  }
  static tooManyToSell(itemClass, nbToSell, nb) {
    return new Log("TOO_MANY_ITEM_TO_SELL", `Too many items to sell: ${nbToSell} ${itemClass.name}, only ${nb} in inventory`);
  }
  static restriction(itemClass) {
    return new Log("RESTRICTION_ITEM", `A state blocks the use of the ${itemClass.name} skill`);
  }
};

// node_modules/@rpgjs/server/lib/logs/skill.js
var SkillLog = class {
  static notLearned(skillClass) {
    return new Log("SKILL_NOT_LEARNED", `the skill ${skillClass.name} is not learned`);
  }
  static notEnoughSp(skillClass, skillSp, playerSp) {
    return new Log("NOT_ENOUGH_SP", `not enough SP to use ${skillClass.name} skill. ${skillSp} Skill'SP is is greater than ${playerSp} Player'SP`);
  }
  static chanceToUseFailed(skillClass) {
    return new Log("USE_CHANCE_SKILL_FAILED", `Chance to use the ${skillClass.name} skill has failed`);
  }
  static restriction(skillClass) {
    return new Log("RESTRICTION_SKILL", `A state blocks the use of the ${skillClass.name} skill`);
  }
  static alreadyLearned(skillClass) {
    return new Log("SKILL_ALREADY_LEARNED", `The ${skillClass.name} skill is already learned`);
  }
};

// node_modules/@rpgjs/server/lib/logs/state.js
var StateLog = class {
  static addFailed(stateClass) {
    return new Log("ADD_STATE_FAILED", `Adding the ${stateClass.name} state has failed`);
  }
  static removeFailed(stateClass) {
    return new Log("REMOVE_STATE_FAILED", `Removing the ${stateClass.name} state has failed`);
  }
  static notApplied(stateClass) {
    return new Log("STATE_NOT_APPLIED", `State ${stateClass.name} does not exist`);
  }
};

// node_modules/@rpgjs/server/lib/presets/index.js
var presets_exports = {};
__export(presets_exports, {
  AGI: () => AGI,
  AGI_CURVE: () => AGI_CURVE,
  ATK: () => ATK,
  COEFFICIENT_ELEMENTS: () => COEFFICIENT_ELEMENTS,
  DAMAGE_CRITICAL: () => DAMAGE_CRITICAL,
  DAMAGE_GUARD: () => DAMAGE_GUARD,
  DAMAGE_PHYSIC: () => DAMAGE_PHYSIC,
  DAMAGE_SKILL: () => DAMAGE_SKILL,
  DEX: () => DEX,
  DEX_CURVE: () => DEX_CURVE,
  INT: () => INT,
  INT_CURVE: () => INT_CURVE,
  MAXHP: () => MAXHP,
  MAXHP_CURVE: () => MAXHP_CURVE,
  MAXSP: () => MAXSP,
  MAXSP_CURVE: () => MAXSP_CURVE,
  PDEF: () => PDEF,
  SDEF: () => SDEF,
  STR: () => STR,
  STR_CURVE: () => STR_CURVE
});
var { random } = Utils_exports;
var MAXHP = "maxHp";
var MAXSP = "maxSp";
var ATK = "atk";
var PDEF = "pdef";
var SDEF = "sdef";
var STR = "str";
var AGI = "agi";
var INT = "int";
var DEX = "dex";
var MAXHP_CURVE = {
  start: 741,
  end: 7467
};
var MAXSP_CURVE = {
  start: 534,
  end: 5500
};
var STR_CURVE = {
  start: 67,
  end: 635
};
var AGI_CURVE = {
  start: 58,
  end: 582
};
var INT_CURVE = {
  start: 36,
  end: 7318
};
var DEX_CURVE = {
  start: 54,
  end: 564
};
var DAMAGE_CRITICAL = function(damage, a, b) {
  if (random(0, 100) < 4 * a[DEX] / b[AGI]) {
    damage *= 2;
  }
  return damage;
};
var DAMAGE_PHYSIC = function(a, b) {
  let damage = Math.round((a[ATK] - b[PDEF] / 2) * ((20 + a[STR]) / 20));
  if (damage < 0)
    damage = 0;
  return damage;
};
var DAMAGE_GUARD = function(damage) {
  return damage / 2;
};
var COEFFICIENT_ELEMENTS = function(a, b, bDef) {
  return (a.rate + 1) * (b.rate + 1) / (bDef.rate == 0 ? bDef.rate * 4 : 1);
};
var DAMAGE_SKILL = function(a, b, skill) {
  let power = skill.power + a[ATK] * (skill.coefficient[ATK] || 0);
  if (power > 0) {
    power -= b[PDEF] * (skill.coefficient[PDEF] || 0) / 2;
    power -= b[SDEF] * (skill.coefficient[SDEF] || 0) / 2;
    power = Math.max(power, 0);
  }
  let rate = 20;
  [STR, DEX, AGI, INT].forEach((val) => rate += a[val] * (skill.coefficient[val] || 0));
  return Math.round(power * rate / 20);
};

// node_modules/@rpgjs/server/lib/Player/ParameterManager.js
var { isString } = Utils_exports;
var ParameterManager = class {
  constructor() {
    this._paramsModifier = {};
    this._hp = 0;
    this._sp = 0;
    this._exp = 0;
    this._level = 0;
    this.initialLevel = 1;
    this.finalLevel = 99;
  }
  /**
   * Changes the health points
   * - Cannot exceed the MaxHP parameter
   * - Cannot have a negative value
   * - If the value is 0, a hook named `onDead()` is called in the RpgPlayer class.
   *
   * ```ts
   * player.hp = 100
   * ```
   * @title Change HP
   * @prop {number} player.hp
   * @default MaxHPValue
   * @memberof ParameterManager
   * */
  set hp(val) {
    if (val > this.param[MAXHP]) {
      val = this.param[MAXHP];
    } else if (val <= 0) {
      this["execMethod"]("onDead");
      val = 0;
    }
    this._hp = val;
  }
  get hp() {
    return this._hp;
  }
  /**
   * Changes the skill points
   * - Cannot exceed the MaxSP parameter
   * - Cannot have a negative value
   *
   * ```ts
   * player.sp = 200
   * ```
   * @title Change SP
   * @prop {number} player.sp
   * @default MaxSPValue
   * @memberof ParameterManager
   * */
  set sp(val) {
    if (val > this.param[MAXSP]) {
      val = this.param[MAXSP];
    }
    this._sp = val;
  }
  get sp() {
    return this._sp;
  }
  /**
   * Changing the player's experience.
   * ```ts
   * player.exp += 100
   * ```
   *
   * Levels are based on the experience curve.
   *
   * ```ts
   * console.log(player.level) // 1
   * console.log(player.expForNextlevel) // 150
   * player.exp += 160
   * console.log(player.level) // 2
   * ```
   *
   * @title Change Experience
   * @prop {number} player.exp
   * @default 0
   * @memberof ParameterManager
   * */
  set exp(val) {
    this._exp = val;
    const lastLevel = this.level;
    while (this.expForNextlevel < this._exp) {
      this.level += 1;
    }
  }
  get exp() {
    return this._exp;
  }
  /**
   * Changing the player's level.
   *
   * ```ts
   * player.level += 1
   * ```
   *
   * The level will be between the initial level given by the `initialLevel` and final level given by `finalLevel`
   *
   * ```ts
   * player.finalLevel = 50
   * player.level = 60
   * console.log(player.level) // 50
   * ```
   *
   * @title Change Level
   * @prop {number} player.level
   * @default 1
   * @memberof ParameterManager
   * */
  set level(val) {
    const lastLevel = this._level;
    if (this.finalLevel && val > this.finalLevel) {
      val = this.finalLevel;
    }
    if (this._class) {
      for (let i = this._level; i <= val; i++) {
        for (let skill of this._class.skillsToLearn) {
          if (skill.level == i) {
            this["learnSkill"](skill.skill);
          }
        }
      }
    }
    const hasNewLevel = val - lastLevel;
    if (hasNewLevel > 0) {
      this["execMethod"]("onLevelUp", [hasNewLevel]);
    }
    this._level = val;
  }
  get level() {
    return this._level;
  }
  /**
  * ```ts
  * console.log(player.expForNextlevel) // 150
  * ```
  * @title Experience for next level ?
  * @prop {number} player.expForNextlevel
  * @readonly
  * @memberof ParameterManager
  * */
  get expForNextlevel() {
    return this._expForLevel(this.level + 1);
  }
  /**
   * Read the value of a parameter. Put the name of the parameter.
   *
   * ```ts
   * import { Presets } from '@rpgjs/server'
   *
   * const { MAXHP } = Presets
   *
   * console.log(player.param[MAXHP])
   * ```
   *
   * > Possible to use the `player.getParamValue(name)` method instead
   * @title Get Param Value
   * @prop {object} player.param
   * @readonly
   * @memberof ParameterManager
   * */
  get param() {
    const obj = {};
    this._parameters.forEach((val, name) => {
      obj[name] = this.getParamValue(name);
    });
    return obj;
  }
  get paramsModifier() {
    const params = {};
    const paramsAvg = {};
    const changeParam = (paramsModifier) => {
      for (let key in paramsModifier) {
        const { rate, value } = paramsModifier[key];
        if (!params[key])
          params[key] = { rate: 0, value: 0 };
        if (!paramsAvg[key])
          paramsAvg[key] = 0;
        if (value)
          params[key].value += value;
        if (rate !== void 0)
          params[key].rate += rate;
        paramsAvg[key]++;
      }
    };
    const getModifier = (prop) => {
      if (!isString(prop)) {
        changeParam(prop);
        return;
      }
      for (let el of this[prop]) {
        if (!el.paramsModifier)
          continue;
        changeParam(el.paramsModifier);
      }
    };
    getModifier(this._paramsModifier);
    getModifier("states");
    getModifier("equipments");
    for (let key in params) {
      params[key].rate /= paramsAvg[key];
    }
    return params;
  }
  /**
   * Changes the values of some parameters
   *
   * > It is important that these parameters have been created beforehand with the `addParameter()` method.
   * > By default, the following settings have been created:
   * - maxhp
   * - maxsp
   * - str
   * - int
   * - dex
   * - agi
   *
   * **Object Key**
   *
   * The key of the object is the name of the parameter
   *
   * > The good practice is to retrieve the name coming from a constant
   *
   * **Object Value**
   *
   * The value of the key is an object containing:
   * ```
   * {
   *   value: number,
   *   rate: number
   * }
   * ```
   *
   * - value: Adds a number to the parameter
   * - rate: Adds a rate to the parameter
   *
   * > Note that you can put both (value and rate)
   *
   * In the case of a state or the equipment of a weapon or armor, the parameters will be changed but if the state disappears or the armor/weapon is de-equipped, then the parameters will return to the initial state.
   *
   * @prop {Object} [paramsModifier]
   * @example
   *
   * ```ts
   * import { Presets } from '@rpgjs/server'
   *
   * const { MAXHP } = Presets
   *
   * player.paramsModifier = {
   *      [MAXHP]: {
   *          value: 100
   *      }
   * }
   * ```
   *
   * 1. Player has 741 MaxHp
   * 2. After changing the parameter, he will have 841 MaxHp
   *
   * @title Set Parameters Modifier
   * @prop {number} paramsModifier
   * @memberof ParameterManager
   * */
  set paramsModifier(val) {
    this._paramsModifier = val;
    this.changeRoomState("param");
  }
  get parameters() {
    return this._parameters;
  }
  set parameters(val) {
    this._parameters = val;
  }
  _expForLevel(level) {
    const { basis, extra, accelerationA, accelerationB } = this.expCurve;
    return Math.round(basis * Math.pow(level - 1, 0.9 + accelerationA / 250) * level * (level + 1) / (6 + Math.pow(level, 2) / 50 / accelerationB) + (level - 1) * extra);
  }
  getParam(name) {
    const features = this._parameters.get(name);
    if (!features) {
      throw `Parameter ${name} not exists. Please use addParameter() before`;
    }
    return features;
  }
  getParamValue(name) {
    const features = this.getParam(name);
    let curveVal = Math.floor((features.end - features.start) * ((this.level - 1) / (this.finalLevel - this.initialLevel))) + features.start;
    const modifier = this.paramsModifier[name];
    if (modifier) {
      if (modifier.rate)
        curveVal *= modifier.rate;
      if (modifier.value)
        curveVal += modifier.value;
    }
    return curveVal;
  }
  /**
   * Give a new parameter. Give a start value and an end value.
   * The start value will be set to the level set at `player.initialLevel` and the end value will be linked to the level set at `player.finalLevel`.
   *
   * ```ts
   * const SPEED = 'speed'
   *
   * player.addParameter(SPEED, {
   *     start: 10,
   *     end: 100
   * })
   *
   * player.param[SPEED] // 10
   * player.level += 5
   * player.param[SPEED] // 14
   * ```
   *
   * @title Add custom parameters
   * @method player.addParameter(name,curve)
   * @param {name} name
   * @param {object} curve Scheme of the object: { start: number, end: number }
   * @returns {void}
   * @memberof ParameterManager
   * */
  addParameter(name, { start, end }) {
    this._parameters.set(name, {
      start,
      end
    });
    const maxHp = this.param[MAXHP];
    const maxSp = this.param[MAXSP];
    if (name == MAXHP && this.hp > maxHp) {
      this.hp = maxHp;
    } else if (name == MAXSP && this.sp > maxSp) {
      this.sp = maxSp;
    }
    this.changeRoomState("param." + name);
  }
  /**
   * Gives back in percentage of health points to skill points
   *
   * ```ts
   * import { Presets } from '@rpgjs/server'
   *
   * const { MAXHP } = Presets
   *
   * console.log(player.param[MAXHP]) // 800
   * player.hp = 100
   * player.recovery({ hp: 0.5 }) // = 800 * 0.5
   * console.log(player.hp) // 400
   * ```
   *
   * @title Recovery HP and/or SP
   * @method player.recovery(params)
   * @param {object} params Scheme of the object: { hp: number, sp: number }. The values of the numbers must be in 0 and 1
   * @returns {void}
   * @memberof ParameterManager
   * */
  recovery({ hp, sp }) {
    if (hp)
      this.hp = this.param[MAXHP] * hp;
    if (sp)
      this.sp = this.param[MAXSP] * sp;
  }
  /**
   * restores all HP and SP
   *
   * ```ts
   * import { Presets } from '@rpgjs/server'
   *
   * const { MAXHP, MAXSP } = Presets
   *
   * console.log(player.param[MAXHP], player.param[MAXSP]) // 800, 230
   * player.hp = 100
   * player.sp = 0
   * player.allRecovery()
   * console.log(player.hp, player.sp) // 800, 230
   * ```
   *
   * @title All Recovery
   * @method player.allRecovery()
   * @returns {void}
   * @memberof ParameterManager
   * */
  allRecovery() {
    this.recovery({ hp: 1, sp: 1 });
  }
};

// node_modules/@rpgjs/server/lib/Player/EffectManager.js
var { arrayUniq, arrayFlat, applyMixins } = Utils_exports;
var EffectManager = class {
  // TODO
  applyEffect(item) {
    if (item.hpValue) {
      this.hp += item.hpValue;
    }
    if (item.hpRate) {
      this.hp += this.param[MAXHP] * item.hpRate;
    }
    if (item.spValue) {
      this.sp += item.spValue;
    }
    if (item.spRate) {
      this.sp += this.param[MAXSP] * item.spRate;
    }
  }
  /**
   * ```ts
   * import { Effect } from '@rpgjs/database'
   *
   * const bool = player.hasEffect(Effect.CAN_NOT_SKILL)
   * ```
   *
   * @title Has Effect
   * @method player.hasEffect(effect)
   * @param {Effect} effect
   * @returns {boolean}
   * @memberof EffectManager
   * */
  hasEffect(effect) {
    return this.effects.includes(effect);
  }
  /**
   * Retrieves a array of effects assigned to the player, state effects and effects of weapons and armors equipped with the player's own weapons.
   *
   * ```ts
   * console.log(player.effects)
   * ```
   * @title Get Effects
   * @prop {Array<Effect>} player.effects
   * @memberof EffectManager
   * */
  get effects() {
    const getEffects = (prop) => {
      return arrayFlat(this[prop].map((el) => el.effects || []));
    };
    return arrayUniq([
      ...this._effects,
      ...getEffects("states"),
      ...getEffects("equipments")
    ]);
  }
  /**
   * Assigns effects to the player. If you give a array, it does not change the effects of the player's states and armor/weapons equipped.
   *
   * ```ts
   * import { Effect } from '@rpgjs/database'
   *
   * player.effects = [Effect.CAN_NOT_SKILL]
   * ```
   * @title Set Effects
   * @prop {Array<Effect>} player.effects
   * @memberof EffectManager
   * */
  set effects(val) {
    this._effects = val;
  }
};
applyMixins(EffectManager, [ParameterManager]);

// node_modules/@rpgjs/server/lib/Player/GoldManager.js
var GoldManager = class {
  constructor() {
    this._gold = 0;
  }
  /**
  * You can change the game money
  *
  * ```ts
  * player.gold += 100
  * ```
  *
  * @title Change Gold
  * @prop {number} player.gold
  * @default 0
  * @memberof GoldManager
  * */
  set gold(val) {
    if (val < 0) {
      val = 0;
    }
    this._gold = val;
  }
  get gold() {
    return this._gold;
  }
};

// node_modules/@rpgjs/server/lib/Player/ItemFixture.js
var ItemFixture = class {
  getFeature(name, prop) {
    const array = {};
    for (let item of this.equipments) {
      if (item[name]) {
        for (let feature of item[name]) {
          const { rate } = feature;
          const instance = feature[prop];
          const cache = array[instance.id];
          if (cache && cache.rate >= rate)
            continue;
          array[instance.id] = feature;
        }
      }
    }
    return Object.values(array);
  }
};

// node_modules/@rpgjs/server/lib/Player/StateManager.js
var { isInstanceOf, applyMixins: applyMixins2, isString: isString2 } = Utils_exports;
var StateManager = class {
  constructor() {
    this.states = [];
  }
  /**
   * Recovers the player's states defense on inventory.  This list is generated from the `statesDefense` property defined on the weapons or armors equipped.
   * If several items have the same element, only the highest rate will be taken into account.
   *
   * ```ts
   * import { Armor, State } from '@rpgjs/server'
   *
   * @State({
   *      name: 'Paralyze'
   * })
   * class Paralyze {}
   *
   * @Armor({
   *      name: 'Shield',
   *      statesDefense: [{ rate: 1, state: Paralyze }]
   * })
   * class Shield {}
   *
   * @Armor({
   *      name: 'FireShield',
   *      statesDefense: [{ rate: 0.5, state: Paralyze }]
   * })
   * class FireShield {}
   *
   * player.addItem(Shield)
   * player.addItem(FireShield)
   * player.equip(Shield)
   * player.equip(FireShield)
   *
   * console.log(player.statesDefense) // [{ rate: 1, state: instance of Paralyze }]
   * ```
   * @title Get States Defense
   * @prop {Array<{ rate: number, state: StateClass}>} player.statesDefense
   * @readonly
   * @memberof StateManager
   * */
  get statesDefense() {
    return this.getFeature("statesDefense", "state");
  }
  /**
   * Set or retrieves all the states where the player is vulnerable or not.
   *
   * ```ts
   * import { Class, State } from '@rpgjs/server'
   *
   * @State({
   *      name: 'Paralyze'
   * })
   * class Paralyze {}
   *
   * @State({
   *      name: 'Sleep'
   * })
   * class Sleep {}
   *
   * @Class({
   *      name: 'Fighter',
   *      statesEfficiency: [{ rate: 1, state: Paralyze }]
   * })
   * class Hero {}
   *
   * player.setClass(Hero)
   *
   * console.log(player.statesEfficiency) // [{ rate: 1, instance of Paralyze }]
   *
   * player.statesEfficiency = [{ rate: 2, state: Sleep }]
   *
   * console.log(player.statesEfficiency) // [{ rate: 1, state: instance of Paralyze }, { rate: 2, state: instance of Sleep }]
   * ```
   * @title Set/Get States Efficiency
   * @prop {Array<{ rate: number, state: StateClass}>} player.statesEfficiency
   * @memberof StateManager
   * */
  get statesEfficiency() {
    return this._statesEfficiency;
  }
  set statesEfficiency(val) {
    this._statesEfficiency = val;
  }
  applyStates(player, { addStates, removeStates }) {
    if (addStates) {
      for (let { state, rate } of addStates) {
        player.addState(state, rate);
      }
    }
    if (removeStates) {
      for (let { state, rate } of removeStates) {
        player.removeState(state, rate);
      }
    }
  }
  /**
   * Get a state to the player. Returns `null` if the state is not present on the player
   * ```ts
   * import Paralyze from 'your-database/states/paralyze'
   *
   * player.getState(Paralyze)
   *  ```
   *
   * @title Get State
   * @method player.getState(stateClass)
   * @param {StateClass | string} stateClass or state id
   * @returns {instance of StateClass | null}
   * @memberof StateManager
   */
  getState(stateClass) {
    if (isString2(stateClass))
      stateClass = this.databaseById(stateClass);
    return this.states.find((state) => {
      if (isString2(stateClass)) {
        return state.id == stateClass;
      }
      return isInstanceOf(state, stateClass);
    });
  }
  /**
   * Adds a state to the player. Set the chance between 0 and 1 that the state can apply
   * ```ts
   * import Paralyze from 'your-database/states/paralyze'
   *
   * try {
   *      player.addState(Paralyze)
   * }
   * catch (err) {
   *      console.log(err)
   * }
   *  ```
   *
   * @title Add State
   * @method player.addState(stateClass,chance=1)
   * @param {StateClass | string} stateClass state class or state id
   * @param {number} [chance] 1 by default
   * @throws {StateLog} addFailed
   * If the chance to add the state has failed (defined with the `chance` param)
   *  ```
   * {
   *      id: ADD_STATE_FAILED,
   *      msg: '...'
   * }
   * ```
   * @returns {instance of StateClass}
   * @memberof StateManager
   * @todo
   */
  addState(stateClass, chance = 1) {
    const state = this.getState(stateClass);
    if (isString2(stateClass)) {
      stateClass = this.databaseById(stateClass);
    }
    if (!state) {
      if (Math.random() > chance) {
        throw StateLog.addFailed(stateClass);
      }
      const instance = new stateClass();
      this.states.push(instance);
      this.applyStates(this, instance);
      return instance;
    }
    return null;
  }
  /**
   * Remove a state to the player. Set the chance between 0 and 1 that the state can be removed
   * ```ts
   * import Paralyze from 'your-database/states/paralyze'
   *
   * try {
   *      player.removeState(Paralyze)
   * }
   * catch (err) {
   *      console.log(err)
   * }
   *  ```
   *
   * @title Remove State
   * @method player.removeState(stateClass,chance=1)
   * @param {StateClass|string} stateClass class state or state id
   * @param {number} [chance] 1 by default
   * @throws {StateLog} removeFailed
   * If the chance to remove the state has failed (defined with the `chance` param)
   *  ```
   * {
   *      id: REMOVE_STATE_FAILED,
   *      msg: '...'
   * }
   * ```
   * @throws {StateLog} notApplied
   * If the status does not exist
   *  ```
   * {
   *      id: STATE_NOT_APPLIED,
   *      msg: '...'
   * }
   * ```
   * @returns {instance of StateClass}
   * @memberof StateManager
   */
  removeState(stateClass, chance = 1) {
    const index = this.states.findIndex((state) => {
      if (isString2(stateClass)) {
        return state.id == stateClass;
      }
      return isInstanceOf(state, stateClass);
    });
    if (index != -1) {
      if (Math.random() > chance) {
        throw StateLog.removeFailed(stateClass);
      }
      this.states.splice(index, 1);
    } else {
      throw StateLog.notApplied(stateClass);
    }
  }
  findStateEfficiency(stateClass) {
    return this.statesEfficiency.find((state) => isInstanceOf(state.state, stateClass));
  }
};
applyMixins2(StateManager, [ItemFixture]);

// node_modules/@rpgjs/server/lib/Player/ItemManager.js
var { isString: isString3, isInstanceOf: isInstanceOf2, applyMixins: applyMixins3 } = Utils_exports;
var ItemManager = class {
  constructor() {
    this.equipments = [];
  }
  /**
  * Retrieves the information of an object: the number and the instance
  * @title Get Item
  * @method player.getItem(itemClass)
  * @param {ItemClass | string} itemClass Identifier of the object if the parameter is a string
  * @returns {{ nb: number, item: instance of ItemClass }}
  * @memberof ItemManager
  * @example
  *
  * ```ts
  * import Potion from 'your-database/potion'
  *
  * player.addItem(Potion, 5)
  * const inventory = player.getItem(Potion)
  * console.log(inventory) // { nb: 5, item: <instance of Potion> }
  *  ```
  */
  getItem(itemClass) {
    const index = this._getItemIndex(itemClass);
    return this.items[index];
  }
  /**
   * Check if the player has the item in his inventory.
   * @title Has Item
   * @method player.hasItem(itemClass)
   * @param {ItemClass | string} itemClass Identifier of the object if the parameter is a string
   * @returns {boolean}
   * @memberof ItemManager
   * @example
   *
   * ```ts
   * import Potion from 'your-database/potion'
   *
   * player.hasItem(Potion) // false
   *  ```
   */
  hasItem(itemClass) {
    return !!this.getItem(itemClass);
  }
  _getItemIndex(itemClass) {
    return this.items.findIndex((it) => {
      if (isString3(itemClass)) {
        return it.item.id == itemClass;
      }
      return isInstanceOf2(it.item, itemClass);
    });
  }
  /**
   * Add an item in the player's inventory. You can give more than one by specifying `nb`
   *
   * `onAdd()` method is called on the ItemClass
   *
   * @title Add Item
   * @method player.addItem(item,nb=1)
   * @param {ItemClass} itemClass
   * @param {number} [nb] Default 1
   * @returns {{ nb: number, item: instance of ItemClass }}
   * @memberof ItemManager
   * @example
   *
   * ```ts
   * import Potion from 'your-database/potion'
   * player.addItem(Potion, 5)
   *  ```
   */
  addItem(itemClass, nb = 1) {
    if (isString3(itemClass))
      itemClass = this.databaseById(itemClass);
    let itemIndex = this._getItemIndex(itemClass);
    if (itemIndex != -1) {
      this.items[itemIndex].nb += nb;
    } else {
      const instance = new itemClass();
      this.items.push({
        item: instance,
        nb
      });
      itemIndex = this.items.length - 1;
    }
    const { item } = this.items[itemIndex];
    this["execMethod"]("onAdd", [this], item);
    return this.items[itemIndex];
  }
  /**
   * Deletes an item. Decreases the value `nb`. If the number falls to 0, then the item is removed from the inventory. The method then returns `undefined`
   *
   * `onRemove()` method is called on the ItemClass
   *
   * @title Remove Item
   * @method player.removeItem(item,nb=1)
   * @param {ItemClass | string} itemClass string is item id
   * @param {number} [nb] Default 1
   * @returns {{ nb: number, item: instance of ItemClass } | undefined}
   * @throws {ItemLog} notInInventory
   * If the object is not in the inventory, an exception is raised
   *  ```
   * {
   *      id: ITEM_NOT_INVENTORY,
   *      msg: '...'
   * }
   * ```
   * @memberof ItemManager
   * @example
   *
   * ```ts
   * import Potion from 'your-database/potion'
   *
   * try {
   *    player.removeItem(Potion, 5)
   * }
   * catch (err) {
   *    console.log(err)
   * }
   * ```
   */
  removeItem(itemClass, nb = 1) {
    const itemIndex = this._getItemIndex(itemClass);
    if (itemIndex == -1) {
      throw ItemLog.notInInventory(itemClass);
    }
    const currentNb = this.items[itemIndex].nb;
    const { item } = this.items[itemIndex];
    if (currentNb - nb <= 0) {
      this.items.splice(itemIndex, 1);
    } else {
      this.items[itemIndex].nb -= nb;
    }
    this["execMethod"]("onRemove", [this], item);
    return this.items[itemIndex];
  }
  /**
   * Purchases an item and reduces the amount of gold
   *
   * `onAdd()` method is called on the ItemClass
   *
   * @title Buy Item
   * @method player.buyItem(item,nb=1)
   * @param {ItemClass | string} itemClass string is item id
   * @param {number} [nb] Default 1
   * @returns {{ nb: number, item: instance of ItemClass }}
   * @throws {ItemLog} haveNotPrice
   * If you have not set a price on the item
   *  ```
   * {
   *      id: NOT_PRICE,
   *      msg: '...'
   * }
   * ```
   * @throws {ItemLog} notEnoughGold
   * If the player does not have enough money
   *  ```
   * {
   *      id: NOT_ENOUGH_GOLD,
   *      msg: '...'
   * }
   * ```
   * @memberof ItemManager
   * @example
   *
   * ```ts
   * import Potion from 'your-database/potion'
   *
   * try {
   *    player.buyItem(Potion)
   * }
   * catch (err) {
   *    console.log(err)
   * }
   * ```
   */
  buyItem(itemClass, nb = 1) {
    if (isString3(itemClass))
      itemClass = this.databaseById(itemClass);
    const ItemClass = itemClass;
    if (!ItemClass.price) {
      throw ItemLog.haveNotPrice(itemClass);
    }
    const totalPrice = nb * ItemClass.price;
    if (this.gold < totalPrice) {
      throw ItemLog.notEnoughGold(itemClass, nb);
    }
    this.gold -= totalPrice;
    return this.addItem(ItemClass, nb);
  }
  /**
   * Sell an item and the player wins the amount of the item divided by 2
   *
   * `onRemove()` method is called on the ItemClass
   *
   * @title Sell Item
   * @method player.sellItem(item,nb=1)
   * @param {ItemClass | string} itemClass string is item id
   * @param {number} [nbToSell] Default 1
   * @returns {{ nb: number, item: instance of ItemClass }}
   * @throws {ItemLog} haveNotPrice
   * If you have not set a price on the item
   *   ```
   * {
   *      id: NOT_PRICE,
   *      msg: '...'
   * }
   * ```
   * @throws {ItemLog} notInInventory
   * If the object is not in the inventory, an exception is raised
   *  ```
   * {
   *      id: ITEM_NOT_INVENTORY,
   *      msg: '...'
   * }
   * ```
   * @throws {ItemLog} tooManyToSell
   * If the number of items for sale exceeds the number of actual items in the inventory
   *  ```
   * {
   *      id: TOO_MANY_ITEM_TO_SELL,
   *      msg: '...'
   * }
   * ```
   * @memberof ItemManager
   * @example
   *
   * ```ts
   * import Potion from 'your-database/potion'
   *
   * try {
   *     player.addItem(Potion)
   *     player.sellItem(Potion)
   * }
   * catch (err) {
   *    console.log(err)
   * }
   * ```
   */
  sellItem(itemClass, nbToSell = 1) {
    if (isString3(itemClass))
      itemClass = this.databaseById(itemClass);
    const ItemClass = itemClass;
    const inventory = this.getItem(ItemClass);
    if (!inventory) {
      throw ItemLog.notInInventory(itemClass);
    }
    const { item, nb } = inventory;
    if (nb - nbToSell < 0) {
      throw ItemLog.tooManyToSell(itemClass, nbToSell, nb);
    }
    if (!ItemClass.price) {
      throw ItemLog.haveNotPrice(itemClass);
    }
    this.gold += ItemClass.price / 2 * nbToSell;
    this.removeItem(ItemClass, nbToSell);
    return inventory;
  }
  getParamItem(name) {
    let nb = 0;
    for (let item of this.equipments) {
      nb += item[name] || 0;
    }
    const modifier = this.paramsModifier[name];
    if (modifier) {
      if (modifier.value)
        nb += modifier.value;
      if (modifier.rate)
        nb *= modifier.rate;
    }
    return nb;
  }
  /**
   * recover the attack sum of items equipped on the player.
   *
   * @title Get the player's attack
   * @prop {number} player.atk
   * @memberof ItemManager
   */
  get atk() {
    return this.getParamItem(ATK);
  }
  /**
  * recover the physic defense sum of items equipped on the player.
  *
  * @title Get the player's pdef
  * @prop {number} player.pdef
  * @memberof ItemManager
  */
  get pdef() {
    return this.getParamItem(PDEF);
  }
  /**
  * recover the skill defense sum of items equipped on the player.
  *
  * @title Get the player's sdef
  * @prop {number} player.sdef
  * @memberof ItemManager
  */
  get sdef() {
    return this.getParamItem(SDEF);
  }
  /**
   *  Use an object. Applies effects and states. Removes the object from the inventory then
   *
   * `onUse()` method is called on the ItemClass (If the use has worked)
   * `onRemove()` method is called on the ItemClass
   *
   * @title Use an Item
   * @method player.useItem(item,nb=1)
   * @param {ItemClass | string} itemClass string is item id
   * @returns {{ nb: number, item: instance of ItemClass }}
   * @throws {ItemLog} restriction
   * If the player has the `Effect.CAN_NOT_ITEM` effect
   *   ```
   * {
   *      id: RESTRICTION_ITEM,
   *      msg: '...'
   * }
   * ```
   * @throws {ItemLog} notInInventory
   * If the object is not in the inventory, an exception is raised
   *  ```
   * {
   *      id: ITEM_NOT_INVENTORY,
   *      msg: '...'
   * }
   * ```
   * @throws {ItemLog} notUseItem
   * If the `consumable` property is on false
   *  ```
   * {
   *      id: NOT_USE_ITEM,
   *      msg: '...'
   * }
   * ```
   * @throws {ItemLog} chanceToUseFailed
   * Chance to use the item has failed. Chances of use is defined with `ItemClass.hitRate`
   *  ```
   * {
   *      id: USE_CHANCE_ITEM_FAILED,
   *      msg: '...'
   * }
   * ```
   * > the item is still deleted from the inventory
   *
   * `onUseFailed()` method is called on the ItemClass
   *
   * @memberof ItemManager
   * @example
   *
   * ```ts
   * import Potion from 'your-database/potion'
   *
   * try {
   *     player.addItem(Potion)
   *     player.useItem(Potion)
   * }
   * catch (err) {
   *    console.log(err)
   * }
   * ```
   */
  useItem(itemClass) {
    const inventory = this.getItem(itemClass);
    if (this.hasEffect(Effect.CAN_NOT_ITEM)) {
      throw ItemLog.restriction(itemClass);
    }
    if (!inventory) {
      throw ItemLog.notInInventory(itemClass);
    }
    const { item } = inventory;
    if (item.consumable === false) {
      throw ItemLog.notUseItem(itemClass);
    }
    const hitRate = item.hitRate ?? 1;
    if (Math.random() > hitRate) {
      this.removeItem(itemClass);
      this["execMethod"]("onUseFailed", [this], item);
      throw ItemLog.chanceToUseFailed(itemClass);
    }
    this.applyEffect(item);
    this.applyStates(this, item);
    this["execMethod"]("onUse", [this], item);
    this.removeItem(itemClass);
    return inventory;
  }
  /**
   * Equips a weapon or armor on a player. Think first to add the item in the inventory with the `addItem()` method before equipping the item.
   *
   * `onEquip()` method is called on the ItemClass
   *
   * @title Equip Weapon or Armor
   * @method player.equip(itemClass,equip=true)
   * @param {ItemClass | string} itemClass string is item id
   * @param {number} [equip] Equip the object if true or un-equipped if false
   * @returns {void}
   * @throws {ItemLog} notInInventory
   * If the item is not in the inventory
   *  ```
      {
          id: ITEM_NOT_INVENTORY,
          msg: '...'
      }
      ```
   * @throws {ItemLog} invalidToEquiped
      If the item is not by a weapon or armor
      ```
      {
          id: INVALID_ITEM_TO_EQUIP,
          msg: '...'
      }
      ```
  * @throws {ItemLog} isAlreadyEquiped
      If the item Is already equipped
      ```
      {
          id: ITEM_ALREADY_EQUIPED,
          msg: '...'
      }
      ```
   * @memberof ItemManager
   * @example
   *
   * ```ts
   * import Sword from 'your-database/sword'
   *
   * try {
   *      player.addItem(Sword)
   *      player.equip(Sword)
   * }
   * catch (err) {
   *    console.log(err)
   * }
   * ```
   */
  equip(itemClass, equip = true) {
    const inventory = this.getItem(itemClass);
    if (!inventory) {
      throw ItemLog.notInInventory(itemClass);
    }
    if (itemClass._type == "item") {
      throw ItemLog.invalidToEquiped(itemClass);
    }
    if (this._class && this._class[ClassHooks.canEquip]) {
      const canEquip = this["execMethodSync"](ClassHooks.canEquip, [inventory.item, this], this._class);
      if (!canEquip) {
        throw ItemLog.canNotEquip(itemClass);
      }
    }
    const item = inventory.item;
    if (item.equipped && equip) {
      throw ItemLog.isAlreadyEquiped(itemClass);
    }
    item.equipped = equip;
    if (!equip) {
      const index = this.equipments.findIndex((it) => it.id == item.id);
      this.equipments.splice(index, 1);
    } else {
      this.equipments.push(item);
    }
    this["execMethod"]("onEquip", [this, equip], item);
  }
};
applyMixins3(ItemManager, [GoldManager, StateManager, EffectManager]);

// node_modules/@rpgjs/server/lib/Player/SkillManager.js
var { isArray: isArray4, isString: isString4, isInstanceOf: isInstanceOf3, applyMixins: applyMixins4 } = Utils_exports;
var SkillManager = class {
  _getSkillIndex(skillClass) {
    return this.skills.findIndex((skill) => {
      if (isString4(skill)) {
        return skill.id == skillClass;
      }
      if (isString4(skillClass)) {
        return skillClass == (skill.id || skill);
      }
      return isInstanceOf3(skill, skillClass);
    });
  }
  /**
   * Retrieves a learned skill. Returns null, if not found
   * ```ts
   * import Fire from 'your-database/skills/fire'
   *
   * player.getSkill(Fire)
   *  ```
   *
   * @title Get Skill
   * @method player.getSkill(skillClass)
   * @param {SkillClass | string} skillClass or data id
   * @returns {instance of SkillClass | null}
   * @memberof SkillManager
   */
  getSkill(skillClass) {
    const index = this._getSkillIndex(skillClass);
    return this.skills[index] ?? null;
  }
  /**
   * Learn a skill. Attributes the coefficient 1 to the parameter INT (intelligence) if cd is not present on the class.
   *
   * `onLearn()` method is called on the SkillClass
   *
   * ```ts
   * import Fire from 'your-database/skills/fire'
   *
   * player.learnSkill(Fire)
   *  ```
   *
   * @title Learn Skill
   * @method player.learnSkill(skillClass)
   * @param {SkillClass | string} skillClass or data id
   * @throws {SkillLog} alreadyLearned
   *  If the player already knows the skill
   *  ```
      {
          id: SKILL_ALREADY_LEARNED,
          msg: '...'
      }
      ```
   * @returns {instance of SkillClass}
   * @memberof SkillManager
   */
  learnSkill(skillClass) {
    if (this.getSkill(skillClass)) {
      throw SkillLog.alreadyLearned(skillClass);
    }
    if (isString4(skillClass))
      skillClass = this.databaseById(skillClass);
    const instance = new skillClass();
    this.skills.push(instance);
    this["execMethod"]("onLearn", [this], instance);
    return instance;
  }
  /**
   * Forget a skill
   *
   * `onForget()` method is called on the SkillClass
   *
   * ```ts
   * import Fire from 'your-database/skills/fire'
   *
   * try {
   *      player.forgetSkill(Fire)
   * }
   * catch (err) {
   *      console.log(err)
   * }
   *  ```
   *
   * @title Forget Skill
   * @method player.learnSkill(skillClass)
   * @param {SkillClass | string} skillClass or data id
   * @throws {SkillLog} notLearned
   * If trying to forget a skill not learned
   *  ```
   * {
   *      id: SKILL_NOT_LEARNED,
   *      msg: '...'
   * }
   * ```
   * @returns {instance of SkillClass}
   * @memberof SkillManager
   */
  forgetSkill(skillClass) {
    if (isString4(skillClass))
      skillClass = this.databaseById(skillClass);
    const index = this._getSkillIndex(skillClass);
    if (index == -1) {
      throw SkillLog.notLearned(skillClass);
    }
    const instance = this.skills[index];
    this.skills.splice(index, 1);
    this["execMethod"]("onForget", [this], instance);
    return instance;
  }
  /**
   * Using a skill
   *
   * `onUse()` method is called on the SkillClass
   *
   * If other players are indicated then damage will be done to these other players. The method `applyDamage()` will be executed
   *
   * ```ts
   * import Fire from 'your-database/skills/fire'
   *
   * try {
   *      player.useSkill(Fire)
   * }
   * catch (err) {
   *      console.log(err)
   * }
   *  ```
   *
   * or
   *
   *
   * * ```ts
   * import Fire from 'your-database/skills/fire'
   *
   * try {
   *      player.useSkill(Fire, otherPlayer)
   * }
   * catch (err) {
   *      console.log(err)
   * }
   *  ```
   *
   * @title Use Skill
   * @method player.useSkill(skillClass,otherPlayer)
   * @param {SkillClass | string} skillClass or data id
   * @param {Array<RpgPlayer> | RpgPlayer} [otherPlayer]
   * @throws {SkillLog} restriction
   * If the player has the `Effect.CAN_NOT_SKILL` effect
   *  ```
   * {
   *      id: RESTRICTION_SKILL,
   *      msg: '...'
   * }
   * ```
   * @throws {SkillLog} notLearned
   * If the player tries to use an unlearned skill
   *  ```
   * {
   *      id: SKILL_NOT_LEARNED,
   *      msg: '...'
   * }
   * ```
   * @throws {SkillLog} notEnoughSp
   * If the player does not have enough SP to use the skill
   *  ```
   * {
   *      id: NOT_ENOUGH_SP,
   *      msg: '...'
   * }
   * ```
   * @throws {SkillLog} chanceToUseFailed
   * If the chance to use the skill has failed (defined with the `hitRate` property)
   *  ```
   * {
   *      id: USE_CHANCE_SKILL_FAILED,
   *      msg: '...'
   * }
   * ```
   *
   * `onUseFailed()` method is called on the SkillClass
   *
   * @returns {instance of SkillClass}
   * @memberof SkillManager
   * @todo
   */
  useSkill(skillClass, otherPlayer) {
    const skill = this.getSkill(skillClass);
    if (this.hasEffect(Effect.CAN_NOT_SKILL)) {
      throw SkillLog.restriction(skillClass);
    }
    if (!skill) {
      throw SkillLog.notLearned(skillClass);
    }
    if (skill.spCost > this.sp) {
      throw SkillLog.notEnoughSp(skillClass, skill.spCost, this.sp);
    }
    this.sp -= skill.spCost / (this.hasEffect(Effect.HALF_SP_COST) ? 2 : 1);
    const hitRate = skill.hitRate ?? 1;
    if (Math.random() > hitRate) {
      this["execMethod"]("onUseFailed", [this, otherPlayer], skill);
      throw SkillLog.chanceToUseFailed(skillClass);
    }
    if (otherPlayer) {
      let players = otherPlayer;
      if (!isArray4(players)) {
        players = [otherPlayer];
      }
      for (let player of players) {
        this.applyStates(player, skill);
        player.applyDamage(this, skill);
      }
    }
    this["execMethod"]("onUse", [this, otherPlayer], skill);
    return skill;
  }
};
applyMixins4(SkillManager, [ParameterManager, StateManager, EffectManager]);

// node_modules/@rpgjs/server/lib/Player/ClassManager.js
var { applyMixins: applyMixins5, isString: isString5 } = Utils_exports;
var ClassManager = class {
  /**
   * Assign a class to the player
   *
   * ```ts
   * import { Fighter } from 'my-database/classes/fighter'
   *
   * player.setClass(Fighter)
   * ```
   *
   * @title Set Class
   * @method player.setClass(ClassClass)
   * @param {ClassClass | string} class class or id
   * @returns {instance of ClassClass}
   * @memberof ClassManager
   * */
  setClass(_class) {
    if (isString5(_class))
      _class = this.databaseById(_class);
    this._class = new _class();
    this["execMethod"]("onSet", [this], this._class);
    return this._class;
  }
  /**
   * Allows to give a set of already defined properties to the player (default equipment, or a list of skills to learn according to the level)
   *
   * ```ts
   * import { Hero } from 'my-database/classes/hero'
   *
   * player.setActor(Hero)
   * ```
   *
   * @title Set Actor
   * @method player.setActor(ActorClass)
   * @param {ActorClass | string} actorClass actor class or id
   * @returns {instance of ActorClass}
   * @memberof ClassManager
   * */
  setActor(actorClass) {
    if (isString5(actorClass))
      actorClass = this.databaseById(actorClass);
    const actor = new actorClass();
    ["name", "initialLevel", "finalLevel", "expCurve"].forEach((key) => {
      if (actor[key])
        this[key] = actor[key];
    });
    for (let param in actor.parameters) {
      this.addParameter(param, actor.parameters[param]);
    }
    for (let item of actor.startingEquipment) {
      this.addItem(item);
      this.equip(item, true);
    }
    if (actor.class)
      this.setClass(actor.class);
    this["execMethod"]("onSet", [this], actor);
    return actor;
  }
};
applyMixins5(ClassManager, [ParameterManager, ItemManager]);

// node_modules/@rpgjs/server/lib/Player/ElementManager.js
var { arrayUniq: arrayUniq2, applyMixins: applyMixins6 } = Utils_exports;
var ElementManager = class extends ItemFixture {
  /**
  * Recovers the player's elements defense on inventory.  This list is generated from the `elementsDefense` property defined on the weapons or armors equipped.
  * If several items have the same element, only the highest rate will be taken into account.
  *
  * ```ts
  * import { Armor } from '@rpgjs/server'
  *
  * enum Elements {
  *   Fire = 'fire'
  * }
  *
  * @Armor({
  *      name: 'Shield',
  *      elementsDefense: [{ rate: 1, element: Elements.Fire }]
  * })
  * class Shield {}
  *
  * @Armor({
  *      name: 'FireShield',
  *      elementsDefense: [{ rate: 0.5, element: Elements.Fire }]
  * })
  * class FireShield {}
  *
  * player.addItem(Shield)
  * player.addItem(FireShield)
  * player.equip(Shield)
  * player.equip(FireShield)
  *
  * console.log(player.elementsDefense) // [{ rate: 1, element: 'fire' }]
  * ```
  * @title Get Elements Defense
  * @prop {Array<{ rate: number, element: Element}>} player.elementsDefense
  * @readonly
  * @memberof ElementManager
  * */
  get elementsDefense() {
    return this.getFeature("elementsDefense", "element");
  }
  /**
  * Set or retrieves all the elements where the player is vulnerable or not.
  *
  * ```ts
  * import { Class } from '@rpgjs/server'
  *
  * enum Elements {
  *   Fire = 'fire',
  *   Ice = 'ice'
  * }
  *
  * @Class({
  *      name: 'Fighter',
  *      elementsEfficiency: [{ rate: 1, element: Elements.Fire }]
  * })
  * class Hero {}
  *
  * player.setClass(Hero)
  *
  * console.log(player.elementsEfficiency) // [{ rate: 1, element: 'fire' }]
  *
  * player.elementsEfficiency = [{ rate: 2, element: Elements.Ice }]
  *
  * console.log(player.elementsEfficiency) // [{ rate: 1, element: 'fire' }, { rate: 2, element: 'ice' }]
  * ```
  * @title Set/Get Elements Efficiency
  * @prop {Array<{ rate: number, element: Element}>} player.elementsEfficiency
  * @memberof ElementManager
  * */
  get elementsEfficiency() {
    if (this._class) {
      return [...this._elementsEfficiency, ...this._class.elementsEfficiency];
    }
    return this._elementsEfficiency;
  }
  set elementsEfficiency(val) {
    this._elementsEfficiency = val;
  }
  /**
   * Retrieves a array of elements assigned to the player and the elements of the weapons / armor equipped
   *
   * ```ts
   * console.log(player.elements)
   * ```
   * @title Get Elements
   * @prop {Array<Element>} player.elements
   * @readonly
   * @memberof ElementManager
   * */
  get elements() {
    let elements = [];
    for (let item of this.equipments) {
      if (item.elements) {
        elements = [...elements, ...item.elements];
      }
    }
    return arrayUniq2(elements);
  }
  coefficientElements(otherPlayer) {
    const atkPlayerElements = otherPlayer.elements;
    const playerElements = this.elementsEfficiency;
    let coefficient = 1;
    for (let atkElement of atkPlayerElements) {
      const elementPlayer = playerElements.find((el) => el.element == atkElement.element);
      const elementPlayerDef = this.elementsDefense.find((el) => el.element == atkElement.element);
      if (!elementPlayer)
        continue;
      const fn = this.getFormulas("coefficientElements");
      if (!fn) {
        return coefficient;
      }
      coefficient += fn(atkElement, elementPlayer, elementPlayerDef || { rate: 0 });
    }
    return coefficient;
  }
};
applyMixins6(ElementManager, [ItemFixture]);

// node_modules/@rpgjs/server/lib/Gui/Gui.js
var Gui = class extends EventEmitter {
  constructor(id, player) {
    super();
    this.id = id;
    this.player = player;
    this._close = () => {
    };
    this._blockPlayerInput = false;
  }
  open(data, { waitingAction = false, blockPlayerInput = false } = {}) {
    return new Promise((resolve) => {
      this.player.moving = false;
      this.player.emit("gui.open", {
        guiId: this.id,
        data
      });
      this._blockPlayerInput = blockPlayerInput;
      if (blockPlayerInput) {
        this.player.canMove = false;
      }
      if (!waitingAction) {
        resolve(null);
      } else {
        this._close = resolve;
      }
    });
  }
  close(data) {
    this.player.emit("gui.exit", this.id);
    if (this._blockPlayerInput) {
      this.player.canMove = true;
    }
    this._close(data);
  }
};

// node_modules/@rpgjs/server/lib/Player/MoveManager.js
var { arrayFlat: arrayFlat2, random: random2, isFunction: isFunction2, capitalize } = Utils_exports;
function wait(sec) {
  return new Promise((resolve) => {
    setTimeout(resolve, sec * 1e3);
  });
}
var Frequency;
(function(Frequency2) {
  Frequency2[Frequency2["Lowest"] = 600] = "Lowest";
  Frequency2[Frequency2["Lower"] = 400] = "Lower";
  Frequency2[Frequency2["Low"] = 200] = "Low";
  Frequency2[Frequency2["High"] = 100] = "High";
  Frequency2[Frequency2["Higher"] = 50] = "Higher";
  Frequency2[Frequency2["Highest"] = 25] = "Highest";
  Frequency2[Frequency2["None"] = 0] = "None";
})(Frequency || (Frequency = {}));
var Speed;
(function(Speed2) {
  Speed2[Speed2["Slowest"] = 0.2] = "Slowest";
  Speed2[Speed2["Slower"] = 0.5] = "Slower";
  Speed2[Speed2["Slow"] = 1] = "Slow";
  Speed2[Speed2["Normal"] = 3] = "Normal";
  Speed2[Speed2["Fast"] = 5] = "Fast";
  Speed2[Speed2["Faster"] = 7] = "Faster";
  Speed2[Speed2["Fastest"] = 10] = "Fastest";
})(Speed || (Speed = {}));
var MoveList = class {
  repeatMove(direction, repeat2) {
    return new Array(repeat2).fill(direction);
  }
  repeatTileMove(direction, repeat2, propMap) {
    return (player, map2) => {
      const repeatTile = Math.floor(map2[propMap] / player.speed) * repeat2;
      return this[direction](repeatTile);
    };
  }
  right(repeat2 = 1) {
    return this.repeatMove(Direction.Right, repeat2);
  }
  left(repeat2 = 1) {
    return this.repeatMove(Direction.Left, repeat2);
  }
  up(repeat2 = 1) {
    return this.repeatMove(Direction.Up, repeat2);
  }
  down(repeat2 = 1) {
    return this.repeatMove(Direction.Down, repeat2);
  }
  wait(sec) {
    return wait(sec);
  }
  random(repeat2 = 1) {
    return new Array(repeat2).fill(null).map(() => [
      Direction.Right,
      Direction.Left,
      Direction.Up,
      Direction.Down
    ][random2(0, 3)]);
  }
  tileRight(repeat2 = 1) {
    return this.repeatTileMove("right", repeat2, "tileWidth");
  }
  tileLeft(repeat2 = 1) {
    return this.repeatTileMove("left", repeat2, "tileWidth");
  }
  tileUp(repeat2 = 1) {
    return this.repeatTileMove("up", repeat2, "tileHeight");
  }
  tileDown(repeat2 = 1) {
    return this.repeatTileMove("down", repeat2, "tileHeight");
  }
  tileRandom(repeat2 = 1) {
    return (player, map2) => {
      let directions = [];
      for (let i = 0; i < repeat2; i++) {
        const randFn = [
          this.tileRight(),
          this.tileLeft(),
          this.tileUp(),
          this.tileDown()
        ][random2(0, 3)];
        directions = [
          ...directions,
          ...randFn(player, map2)
        ];
      }
      return directions;
    };
  }
  _awayFromPlayerDirection(player, otherPlayer) {
    const directionOtherPlayer = otherPlayer.getDirection();
    let newDirection = 0;
    switch (directionOtherPlayer) {
      case Direction.Left:
      case Direction.Right:
        if (otherPlayer.position.x > player.position.x) {
          newDirection = Direction.Left;
        } else {
          newDirection = Direction.Right;
        }
        break;
      case Direction.Up:
      case Direction.Down:
        if (otherPlayer.position.y > player.position.y) {
          newDirection = Direction.Up;
        } else {
          newDirection = Direction.Down;
        }
        break;
    }
    return newDirection;
  }
  _towardPlayerDirection(player, otherPlayer) {
    const directionOtherPlayer = otherPlayer.getDirection();
    let newDirection = 0;
    switch (directionOtherPlayer) {
      case Direction.Left:
      case Direction.Right:
        if (otherPlayer.position.x > player.position.x) {
          newDirection = Direction.Right;
        } else {
          newDirection = Direction.Left;
        }
        break;
      case Direction.Up:
      case Direction.Down:
        if (otherPlayer.position.y > player.position.y) {
          newDirection = Direction.Down;
        } else {
          newDirection = Direction.Up;
        }
        break;
    }
    return newDirection;
  }
  _awayFromPlayer({ isTile, typeMov }, otherPlayer, repeat2 = 1) {
    const method = (dir) => {
      const direction = LiteralDirection[dir];
      return this[isTile ? "tile" + capitalize(direction) : direction](repeat2);
    };
    return (player, map2) => {
      let newDirection = 0;
      switch (typeMov) {
        case "away":
          newDirection = this._awayFromPlayerDirection(player, otherPlayer);
          break;
        case "toward":
          newDirection = this._towardPlayerDirection(player, otherPlayer);
          break;
      }
      let direction = method(newDirection);
      if (isFunction2(direction)) {
        direction = direction(player, map2);
      }
      return direction;
    };
  }
  towardPlayer(player, repeat2 = 1) {
    return this._awayFromPlayer({ isTile: false, typeMov: "toward" }, player, repeat2);
  }
  tileTowardPlayer(player, repeat2 = 1) {
    return this._awayFromPlayer({ isTile: true, typeMov: "toward" }, player, repeat2);
  }
  awayFromPlayer(player, repeat2 = 1) {
    return this._awayFromPlayer({ isTile: false, typeMov: "away" }, player, repeat2);
  }
  tileAwayFromPlayer(player, repeat2 = 1) {
    return this._awayFromPlayer({ isTile: true, typeMov: "away" }, player, repeat2);
  }
  turnLeft() {
    return "turn-" + Direction.Left;
  }
  turnRight() {
    return "turn-" + Direction.Right;
  }
  turnUp() {
    return "turn-" + Direction.Up;
  }
  turnDown() {
    return "turn-" + Direction.Down;
  }
  turnRandom() {
    return [
      this.turnRight(),
      this.turnLeft(),
      this.turnUp(),
      this.turnDown()
    ][random2(0, 3)];
  }
  turnAwayFromPlayer(otherPlayer) {
    return (player) => {
      const direction = this._awayFromPlayerDirection(player, otherPlayer);
      return "turn-" + direction;
    };
  }
  turnTowardPlayer(otherPlayer) {
    return (player) => {
      const direction = this._towardPlayerDirection(player, otherPlayer);
      return "turn-" + direction;
    };
  }
};
var Move = new MoveList();
var MoveManager = class {
  /**
   * Gives an itinerary.
   *
   * You can create your own motion function:
   *
   * ```ts
   * import { Direction } from '@rpgjs/server'
   *
   * const customMove = () => {
   *      return [Direction.Left, Direction.Up]
   * }
   *
   * player.moveRoutes([ customMove() ])
   * ```
   *
   * Your function can also return a function:
   *
   *  ```ts
   * import { Direction, RpgPlayer } from '@rpgjs/server'
   *
   * // This function can be found in another file. By returning a function, you have access to the player who is making a move.
   * const customMove = (otherPlayer: RpgPlayer) => {
   *      return (player: RpgPlayer, map) => {
   *          return otherPlayer.position.x > player.position.x ? Direction.Left : Direction.Right
   *      }
   * }
   *
   * player.moveRoutes([ customMove(otherPlayer) ])
   * ```
   *
   * the function contains two parameters:
   *
   * - `player`: the player concerned by the movement
   * - `map`: The information of the current map
   *
   * @title Give an itinerary
   * @method player.moveRoutes(routes)
   * @param {Array<Move>} routes
   * @returns {Promise}
   * @memberof MoveManager
   * @example
   *
   * ```ts
   * import { Move } from '@rpgjs/server'
   *
   * await player.moveRoutes([ Move.tileLeft(), Move.tileDown(2) ])
   * // The path is over when the promise is resolved
   * ```
   */
  moveRoutes(routes) {
    let count2 = 0;
    let frequence = 0;
    this.breakRoutes();
    return new Promise(async (resolve) => {
      this._finishRoute = resolve;
      routes = routes.map((route) => {
        if (isFunction2(route)) {
          const map2 = this.getCurrentMap();
          if (!map2) {
            return void 0;
          }
          return route.apply(route, [this, map2]);
        }
        return route;
      });
      routes = arrayFlat2(routes);
      const move = () => {
        if (!this) {
          return of(null);
        }
        if (!this.getCurrentMap()) {
          return of(null);
        }
        if (count2 >= this["nbPixelInTile"]) {
          if (frequence < this.frequency) {
            frequence++;
            return of(null);
          }
        }
        frequence = 0;
        count2++;
        const [route] = routes;
        if (route === void 0) {
          this.breakRoutes();
          return of(null);
        }
        let ob$ = new Observable();
        switch (route) {
          case Direction.Left:
          case Direction.Down:
          case Direction.Right:
          case Direction.Up:
            ob$ = from(this.moveByDirection(route, 1));
            break;
          case "turn-" + Direction.Left:
            ob$ = of(this.changeDirection(Direction.Left));
            break;
          case "turn-" + Direction.Right:
            ob$ = of(this.changeDirection(Direction.Right));
            break;
          case "turn-" + Direction.Up:
            ob$ = of(this.changeDirection(Direction.Up));
            break;
          case "turn-" + Direction.Down:
            ob$ = of(this.changeDirection(Direction.Down));
            break;
        }
        return ob$.pipe(tap(() => {
          routes.shift();
        }));
      };
      this.movingSubscription = this.server.tick.pipe(takeUntil(this._destroy$.pipe(tap(() => {
        this.breakRoutes(true);
      }))), switchMap(move)).subscribe();
    });
  }
  /**
   * Giving a path that repeats itself in a loop to a character
   *
   * You can stop the movement at any time with `breakRoutes()` and replay it with `replayRoutes()`.
   *
   * @title Infinite Move Routes
   * @method player.infiniteMoveRoute(routes)
   * @param {Array<Move>} routes
   * @returns {void}
   * @memberof MoveManager
   * @example
   *
   * ```ts
   * import { Move } from '@rpgjs/server'
   *
   * player.infiniteMoveRoute([ Move.tileRandom() ])
   * ```
   */
  infiniteMoveRoute(routes) {
    this._infiniteRoutes = routes;
    const move = (isBreaking) => {
      if (isBreaking)
        return;
      this.moveRoutes(routes).then(move);
    };
    move(false);
  }
  /**
   * Works only for infinite movements. You must first use the method `infiniteMoveRoute()`
   *
   * @title Stop an infinite movement
   * @method player.breakRoutes(force=false)
   * @param {boolean} [force] Forces the stop of the infinite movement
   * @returns {void}
   * @memberof MoveManager
   * @example
   *
   * ```ts
   * import { Move } from '@rpgjs/server'
   *
   * player.infiniteMoveRoute([ Move.tileRandom() ])
   * player.breakRoutes(true)
   * ```
   */
  breakRoutes(force = false) {
    var _a;
    if (this._finishRoute) {
      (_a = this.movingSubscription) == null ? void 0 : _a.unsubscribe();
      this._finishRoute(force);
    }
  }
  /**
   * Works only for infinite movements. You must first use the method `infiniteMoveRoute()`
   * If the road was stopped with `breakRoutes()`, you can restart it with this method
   *
   * @title Replay an infinite movement
   * @method player.replayRoutes()
   * @returns {void}
   * @memberof MoveManager
   * @example
   *
   * ```ts
   * import { Move } from '@rpgjs/server'
   *
   * player.infiniteMoveRoute([ Move.tileRandom() ])
   * player.breakRoutes(true)
   * player.replayRoutes()
   * ```
   */
  replayRoutes() {
    if (this._infiniteRoutes)
      this.infiniteMoveRoute(this._infiniteRoutes);
  }
  moveTo(position, options) {
    return this["_moveTo"](this.server.tick, position, options);
  }
  // TODO
  setMoveMode(mode) {
    if (mode.checkCollision)
      this.checkCollision = mode.checkCollision;
    if (mode.clientMode)
      this.clientModeMove = mode.clientMode;
    if (mode.behavior)
      this.behavior = mode.behavior;
    this.emit(SocketEvents.CallMethod, {
      objectId: this.id,
      name: SocketMethods.ModeMove,
      params: [mode]
    });
  }
};

// node_modules/@rpgjs/server/lib/Gui/DialogGui.js
var DialogPosition;
(function(DialogPosition2) {
  DialogPosition2["Top"] = "top";
  DialogPosition2["Bottom"] = "bottom";
  DialogPosition2["Middle"] = "middle";
})(DialogPosition || (DialogPosition = {}));
var DialogGui = class extends Gui {
  constructor(player) {
    super(PrebuiltGui.Dialog, player);
  }
  openDialog(message, options) {
    if (!options.choices)
      options.choices = [];
    if (options.autoClose == void 0)
      options.autoClose = false;
    if (!options.position)
      options.position = DialogPosition.Bottom;
    if (options.fullWidth == void 0)
      options.fullWidth = true;
    if (options.typewriterEffect == void 0)
      options.typewriterEffect = true;
    const event = options.talkWith;
    let memoryDir;
    if (event) {
      memoryDir = event.direction;
      event.breakRoutes(true);
      event.moveRoutes([Move.turnTowardPlayer(this.player)]);
    }
    const data = {
      autoClose: options.autoClose,
      position: options.position,
      fullWidth: options.fullWidth,
      typewriterEffect: options.typewriterEffect,
      // remove value property. It is not useful to know this on the client side.
      choices: options.choices.map((choice) => ({
        text: choice.text
      }))
    };
    return super.open({
      message,
      ...data
    }, {
      waitingAction: true,
      blockPlayerInput: true
    }).then((val) => {
      if (event) {
        event.replayRoutes();
        event.direction = memoryDir;
      }
      return val;
    });
  }
};

// node_modules/@rpgjs/server/lib/Gui/MenuGui.js
var MenuGui = class extends Gui {
  constructor(player) {
    super(PrebuiltGui.MainMenu, player);
  }
  open() {
    this.on("useItem", (id) => {
      try {
        this.player.useItem(id);
        this.player.syncChanges();
      } catch (err) {
        this.player.showNotification(err.msg);
      }
    });
    return super.open("", {
      waitingAction: true,
      blockPlayerInput: true
    });
  }
};

// node_modules/@rpgjs/server/lib/Gui/ShopGui.js
var ShopGui = class extends Gui {
  constructor(player) {
    super(PrebuiltGui.Shop, player);
  }
  open(items) {
    items = items.map((item) => {
      const it = new item();
      return {
        price: it.price,
        name: it.name,
        description: it.description,
        id: it.id,
        type: item.type
      };
    });
    this.on("buyItem", ({ id, nb }) => {
      try {
        this.player.buyItem(id, nb);
      } catch (err) {
        console.log(err);
      }
    });
    this.on("sellItem", ({ id, nb }) => {
      try {
        this.player.sellItem(id, nb);
      } catch (err) {
        console.log(err);
      }
    });
    return super.open({ items }, {
      waitingAction: true,
      blockPlayerInput: true
    });
  }
};

// node_modules/@rpgjs/server/lib/Gui/NotificationGui.js
var NotificationGui = class extends Gui {
  constructor(player) {
    super(PrebuiltGui.Notification, player);
  }
};

// node_modules/@rpgjs/server/lib/Player/GuiManager.js
var GuiManager = class {
  /**
   * Show a text. This is a graphical interface already built. Opens the GUI named `rpg-dialog`
   *
   * ```ts
   * player.showText('Hello World')
   * ```
   *
   * The method returns a promise. It is resolved when the dialog box is closed.
   *
   * ```ts
   * await player.showText('Hello World')
   * // dialog box is closed, then ...
   * ```
   *
   * **Option: position**
   *
   * You can define how the dialog box is displayed:
   * - top
   * - middle
   * - bottom
   *
   * (bottom by default)
   *
   * ```ts
   * player.showText('Hello World', {
   *      position: 'top'
   * })
   * ```
   *
   * **Option: fullWidth**
   *
   * `boolean` (true by default)
   *
   * Indicate that the dialog box will take the full width of the screen.
   *
   * ```ts
   * player.showText('Hello World', {
   *      fullWidth: true
   * })
   * ```
   *
   * **Option: autoClose**
   *
   * `boolean` (false by default)
   *
   * If false, the user will have to press Enter to close the dialog box.
   *
   *  ```ts
   * player.showText('Hello World', {
   *      autoClose: true
   * })
   * ```
   *
   * **Option: typewriterEffect**
   *
   * `boolean` (true by default)
   *
   * Performs a typewriter effect
   *
   *  ```ts
   * player.showText('Hello World', {
   *      typewriterEffect: false
   * })
   * ```
   *
   * **Option: talkWith**
   *
   * `RpgPlayer` (nothing by default)
   *
   * If you specify the event or another player, the other player will stop his or her movement and look in the player's direction.
   *
   *  ```ts
   * // Code in an event
   * player.showText('Hello World', {
   *      talkWith: this
   * })
   * ```
   *
   * @title Show Text
   * @method player.showText(text,options)
   * @param {string} text
   * @param {object} [options] the different options, see usage below
   * @returns {Promise}
   * @memberof GuiManager
   */
  showText(msg, options = {}) {
    const gui = new DialogGui(this);
    this._gui[gui.id] = gui;
    return gui.openDialog(msg, options);
  }
  /**
   * Shows a dialog box with a choice. Opens the GUI named `rpg-dialog`
   *
   * ```ts
   * const choice = await player.showChoices('What color do you prefer?', [
   *      { text: 'Black', value: 'black' },
   *      { text: 'Rather the blue', value: 'blue' },
   *      { text: 'I don\'t have a preference!', value: 'none' }
   * ])
   *
   * // If the player selects the first
   * console.log(choice) // { text: 'Black', value: 'black' }
   * ```
   *
   * @title Show Choices
   * @method player.showChoices(text,choices)
   * @param {string} text
   * @param {Array<{ text: string, value: any }>} choices
   * @param {object} [options] Same options as the openDialog method
   * @returns {Promise<Choice | null>}
   * @memberof GuiManager
   */
  showChoices(msg, choices, options) {
    return this.showText(msg, {
      choices,
      ...options
    }).then((indexSelected) => {
      if (!choices[indexSelected])
        return null;
      return choices[indexSelected];
    });
  }
  /**
   * Displays a notification . Opens the GUI named `rpg-notification`
   *
   * @title Displays a notification
   * @method player.showNotification()
   * @param {string} message - The message to display in the notification
   * @param {object} options - An object containing options for the notification
   * @param {number} options.time - The time to display the notification for (in ms). Default: 2000ms
   * @param {string} options.icon - The icon to display in the notification. Put the identifier of the spritesheet (defined on the client side)
   * @param {string} options.sound - The sound to play when the notification is shown. Set the sound ID (defined on the client side)
   * @returns {void}
   * @memberof GuiManager
   */
  showNotification(message, options = {}) {
    const gui = new NotificationGui(this);
    this._gui[gui.id] = gui;
    const data = {
      message,
      ...options
    };
    return gui.open(data);
  }
  /**
   * Calls main menu. Opens the GUI named `rpg-main-menu`
   *
   * @title Call Main Menu
   * @method player.callMainMenu()
   * @returns {void}
   * @memberof GuiManager
   */
  callMainMenu() {
    const gui = new MenuGui(this);
    this._gui[gui.id] = gui;
    return gui.open();
  }
  /**
   * Calls shop menu. Opens the GUI named `rpg-shop`
   *
   * @title Call Shop Menu
   * @method player.callShop()
   * @returns {void}
   * @memberof GuiManager
   */
  callShop(items) {
    const gui = new ShopGui(this);
    this._gui[gui.id] = gui;
    return gui.open(items);
  }
  /**
       * Call a custom Gui
  
       * ```ts
       * // Calls a client-side component, created with VueJS, named "inn".
       * const gui = player.gui('inn')
       *
       *  // You can wait for actions on the menu. It only works if the menu is open.
       * gui.on('accept', () => {
       *      player.allRecovery()
       * })
       *
       * // The GUI is opened by passing recoverable data on the client side.
       * gui.open({ hello: 'world' })
       * ```
       *
       * When opening the GUI, one can give options
       *
       * ```ts
       * await gui.open({ hello: 'world' }, {
       *      waitingAction: true,
       *      blockPlayerInput: true
       * })
       * // After the GUI is closed
       * ```
       *
       * - `blockPlayerInput`: while the GUI is open, the player can not move on the map
       * - `waitingAction`: We explicitly wait until the GUI is closed for the promise to be resolved.
       *
       * @title Call custom GUI
       * @method player.gui(guiId)
       * @param {string} guiId
       * @returns {Gui}
       * @memberof GuiManager
       */
  gui(guiId) {
    const gui = new Gui(guiId, this);
    this._gui[guiId] = gui;
    return gui;
  }
  /**
   * Closes the GUI and removes it from memory
   *
   * @title Close custom GUI
   * @method player.removeGui(guiId,data)
   * @param {string} guiId
   * @param {object} [data] Passing data if you close the GUI
   * @returns {Gui}
   * @memberof GuiManager
   */
  removeGui(guiId, data) {
    if (this._gui[guiId]) {
      this._gui[guiId].close(data);
      delete this._gui[guiId];
    }
  }
  _attachedGui(players, display) {
    if (!Utils_exports.isArray(players)) {
      players = [players];
    }
    this.emit("gui.tooltip", {
      players: players.map((player) => player.id),
      display
    });
  }
  /**
   * Display the GUI attached to the players
   *
   * If you don't specify the players as parameters, it will display the GUI of the instance
   * But you can specify which GUIs to display by specifying the players as the first parameter
   *
   * @title View to GUI attached
   * @method player.showAttachedGui(players?)
   * @param {RpgPlayer[] | RpgPlayer} [players] The GUIs attached to the players to display
   * @since 3.0.0-beta.5
   * @example
   * ```ts
   * player.showAttachedGui()
   * ```
   * ```ts
   * player.showAttachedGui(aPlayer)
   * ```
   * ```ts
   * player.showAttachedGui([player1, player2])
   * ```
   * @memberof GuiManager
   * */
  showAttachedGui(players) {
    const _players = players || this;
    this._attachedGui(_players, true);
  }
  /**
   * Hide the GUI attached to the players
   *
   * @title Hide to GUI attached
   * @method player.hideAttachedGui(players?)
   * @param {RpgPlayer[] | RpgPlayer} [players] The GUIs attached to the players to hide
   * @since 3.0.0-beta.5
   * @example
   * ```ts
   * player.hideAttachedGui()
   * ```
   * ```ts
   * player.hideAttachedGui(aPlayer)
   * ```
   * ```ts
   * player.hideAttachedGui([player1, player2])
   * ```
   * @memberof GuiManager
   * */
  hideAttachedGui(players) {
    const _players = players || this;
    this._attachedGui(_players, false);
  }
};

// node_modules/@rpgjs/server/lib/Player/VariableManager.js
var VariableManager = class {
  /**
   * Assign a variable to the player
   *
   * ```ts
   * player.setVariable('OPEN_CHEST', true)
   * ```
   *
   * @title Set variable
   * @method player.setVariable(key,val)
   * @param {string} key
   * @param {any} val
   * @returns {void}
   * @memberof VariableManager
   * */
  setVariable(key, val) {
    this.variables.set(key, val);
  }
  /**
   * Get a variable
   *
   * ```ts
   * const val = player.getVariable('OPEN_CHEST')
   * ```
   *
   * @title Get variable
   * @method player.setVariable(key,val)
   * @param {string} key
   * @returns {any}
   * @memberof VariableManager
   * */
  getVariable(key) {
    return this.variables.get(key);
  }
  /**
   * Remove a variable
   *
   * ```ts
   * player.removeVariable('OPEN_CHEST')
   * ```
   *
   * @title Remove variable
   * @method player.removeVariable(key)
   * @param {string} key
   * @returns {boolean} true if a variable existed and has been removed, or false if the variable does not exist.
   * @memberof VariableManager
   * */
  removeVariable(key) {
    return this.variables.delete(key);
  }
};

// node_modules/@rpgjs/server/lib/Player/BattleManager.js
var { applyMixins: applyMixins7 } = Utils_exports;
var BattleManager = class {
  /**
   * Apply damage. Player will lose HP. the `attackerPlayer` parameter is the other player, the one who attacks.
   *
   * If you don't set the skill parameter, it will be a physical attack.
   * The attack formula is already defined but you can customize it in the server options
   *
   * ```ts
   * player.applyDamage(attackerPlayer) // returns { damage: number }
   * ```
   *
   * @title Apply Damage
   * @method player.applyDamage(attackerPlayer,skill)
   * @param {RpgPlayer} attackerPlayer The attacking player
   * @param {any} [skill]
   * @returns {object}
   * @memberof BattleManager
   * */
  applyDamage(attackerPlayer, skill) {
    const getParam = (player) => {
      const params = {};
      this.parameters.forEach((val, key) => {
        params[key] = player.param[key];
      });
      return {
        [ATK]: player.atk,
        [PDEF]: player.pdef,
        [SDEF]: player.sdef,
        ...params
      };
    };
    let damage = 0, fn;
    let critical = false;
    let guard = false;
    let superGuard = false;
    let elementVulnerable = false;
    const paramA = getParam(attackerPlayer);
    const paramB = getParam(this);
    if (skill) {
      fn = this.getFormulas("damageSkill");
      if (!fn) {
        throw new Error("Skill Formulas not exists");
      }
      damage = fn(paramA, paramB, skill);
    } else {
      fn = this.getFormulas("damagePhysic");
      if (!fn) {
        throw new Error("Physic Formulas not exists");
      }
      damage = fn(paramA, paramB);
      const coef = this.coefficientElements(attackerPlayer);
      if (coef >= 2) {
        elementVulnerable = true;
      }
      damage *= coef;
      fn = this.getFormulas("damageCritical");
      if (fn) {
        let newDamage = fn(damage, paramA, paramB);
        if (damage != newDamage) {
          critical = true;
        }
        damage = newDamage;
      }
    }
    if (this.hasEffect(Effect.GUARD)) {
      fn = this.getFormulas("damageGuard");
      if (fn) {
        let newDamage = fn(damage, paramA, paramB);
        if (damage != newDamage) {
          guard = true;
        }
        damage = newDamage;
      }
    }
    if (this.hasEffect(Effect.SUPER_GUARD)) {
      damage /= 4;
      superGuard = true;
    }
    this.hp -= damage;
    return {
      damage,
      critical,
      elementVulnerable,
      guard,
      superGuard
    };
  }
  getFormulas(name) {
    return this.server.damageFormulas[name];
  }
};
applyMixins7(BattleManager, [ParameterManager, ElementManager, EffectManager]);

// node_modules/@rpgjs/server/lib/Player/ComponentManager.js
var defaultStyle = (style) => ({
  borderColor: "#000000",
  borderWidth: 2,
  bgColor: "#000000",
  borderRadius: 5,
  ...style
});
var bar = (current, max2, style, text) => {
  return {
    id: "bar",
    value: {
      current,
      max: max2,
      text: text === null ? "" : text || "{$current}/{$max}",
      style
    }
  };
};
var Components = {
  /**
   * Displays a bar
   *
   * Example:
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   * Components.bar('hp', 'param.maxHp', {
   *    bgColor: '#ab0606'
   * })
   * ```
   *
   * For text, you can use the following variables:
   * - {$current} current value
   * - {$max} maximum value
   * - {$percent} percentage
   *
   * Example:
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   * Components.bar('hp', 'param.maxHp', {
   *   bgColor: '#ab0606'
   * }, 'HP: {$current}/{$max}')
   * ```
   *
   * and you can also use the variables of player:
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   * Components.bar('hp', 'param.maxHp', {
   *  bgColor: '#ab0606'
   * }, 'HP: {$current}/{$max} - {name}') // HP: 100/100 - John
   * ```
   *
   * @title Bar Component
   * @param {string} current Parameter that corresponds to the current value
   * @param {string} max Parameter that corresponds to the maximum value
   * @param {object} [style] style
   * @param {string} [style.bgColor] background color. Hexadecimal format.
   * @param {string} [style.fillColor] fill color. Hexadecimal format.
   * @param {string} [style.borderColor] border color. Hexadecimal format.
   * @param {number} [style.borderWidth] border width
   * @param {number} [style.height] height
   * @param {number} [style.width] width
   * @param {number} [style.borderRadius] border radius
   * @param {number} [style.opacity] opacity
   * @param {string | null} [text] text above bar. if null, no text will be displayed. You can use the variables
   * @returns {BarComponentObject}
   * @memberof Components
   * @since 3.3.0
   */
  bar,
  /**
   * Displays a life bar
   *
   * @title HP Bar Component
   * @param {object} [style] style. See bar style (Components.bar())
   * @param {string | null} [text] test above bar (Components.bar())
   * @returns {BarComponentObject}
   * @memberof Components
   * @since 3.3.0
   */
  hpBar(style, text) {
    return bar("hp", "param.maxHp", {
      ...defaultStyle({
        fillColor: "#ab0606"
      }),
      ...style || {}
    }, text);
  },
  /**
  * Displays a SP bar
  *
  * @title SP Bar Component
  * @param {object} [style] style. See bar style (Components.bar())
  * @param {string | null} [text] test above bar (Components.bar())
  * @returns {BarComponentObject}
  * @memberof Components
  * @since 3.3.0
  */
  spBar(style, text) {
    return bar("sp", "param.maxSp", {
      ...defaultStyle({
        fillColor: "#0fa38c"
      }),
      ...style || {}
    }, text);
  },
  /**
  * Put on the text. You can read the content of a variable with {} format (see example below)
  *
  * Example:
  *
  * ```ts
  * import { Components } from '@rpgjs/server'
  * Components.text('Hello World')
  * ```
  *
  * Example with variable:
  *
  * ```ts
  * import { Components } from '@rpgjs/server'
  * Components.text('{name}')
  * ```
  *
  * Other example with position:
  *
  * ```ts
  * import { Components } from '@rpgjs/server'
  * Components.text('X: {position.x} Y: {position.y}')
  * ```
  *
  * With style:
  *
  * ```ts
  * import { Components } from '@rpgjs/server'
  * Components.text('Hello World', {
  *      fill: '#ffffff',
  *      fontSize: 20,
  *      fontFamily: 'Arial',
  *      stroke: '#000000',
  *      fontStyle: 'italic',
  *      fontWeight: 'bold'
  * })
  * ```
  *
  * @title Text Component
  * @param {string} value source
  * @param {object} [style] style
  * @param {string} [style.fill] color. Hexadecimal format.
  * @param {number} [style.fontSize] font size
  * @param {string} [style.fontFamily] font family
  * @param {string} [style.stroke] stroke color. Hexadecimal format.
  * @param {'normal' | 'italic' | 'oblique'} [style.fontStyle] font style
  * @param {'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900'} [style.fontWeight] font weight
  * @param {number} [style.opacity] opacity. Between 0 and 1
  * @param {boolean} [style.wordWrap] word wrap
  * @param {'left' | 'center' | 'right' | 'justify'} [style.align] align
  * @returns {TextComponentObject}
  * @memberof Components
  * @since 3.3.0
  */
  text(value, style) {
    return {
      id: "text",
      value: {
        text: value,
        style: {
          fill: "#ffffff",
          fontSize: 15,
          ...style || {}
        }
      }
    };
  },
  /**
   * Add a shape
   *
   * Example:
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   * Components.shape({
   *      fill: '#ffffff',
   *      type: 'circle',
   *      radius: 10
   * })
   * ```
   *
   * You can use parameters:
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   * Components.shape({
   *      fill: '#ffffff',
   *      type: 'circle',
   *      radius: 'hp'
   * })
   * ```
   *
   * Here, the radius will be the same as the hp value
   *
   * @title Shape Component
   * @param {object} value
   * @param {string} value.fill color. Hexadecimal format.
   * @param {number | string} [value.opacity] opacity. Between 0 and 1
   * @param {string} value.type type of shape. Can be 'circle' or 'rectangle', 'ellipse' or 'polygon', 'line' or 'rounded-rectangle'
   * @param {number | string} [value.radius] if type is circle, radius of the circle
   * @param {number | string} [value.width] if type is rectangle or ellipse, width of the rectangle
   * @param {number | string} [value.height] if type is rectangle or ellipse, height of the rectangle
   * @param {number | string} [value.x1] if type is line, x1 position of the line
   * @param {number | string} [value.y1] if type is line, y1 position of the line
   * @param {number | string} [value.x2] if type is line, x2 position of the line
   * @param {number | string} [value.y2] if type is line, y2 position of the line
   * @param {number[]} [value.points] if type is polygon, points of the polygon
   * @param {object} [value.line] border style
   * @param {string} [value.line.color] border color. Hexadecimal format.
   * @param {number} [value.line.width] border width
   * @param {number} [value.line.alpha] border opacity. Between 0 and 1
   * @returns {ShapeComponentObject}
   * @memberof Components
   * @since 3.3.0
   */
  shape(value) {
    return {
      id: "shape",
      value
    };
  },
  /**
   * Put the link to an image or the identifier of an image (if the spritesheet exists)
   *
   * Example:
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   * Components.image('mygraphic.png')
   * ```
   *
   * @title Image Component
   * @param {string} value source
   * @returns {ImageComponentObject}
   * @memberof Components
   * @since 3.3.0
   */
  image(value) {
    return {
      id: "image",
      value
    };
  },
  /**
   * Indicates the tile ID
   *
   * Example:
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   * Components.tile(3)
   * ```
   *
   * @title Tile Component
   * @param {number} value tile ID
   * @returns {TileComponentObject}
   * @memberof Components
   * @since 3.3.0
   */
  tile(value) {
    return {
      id: "tile",
      value
    };
  },
  debug() {
    return {
      id: "debug",
      value: ""
    };
  }
};
var ComponentManager = class {
  /**
   * Give the spritesheet identifier
   *
   * Since version 3.0.0-rc, you can define several graphic elements. If you put a number, it represents the tile ID in the tileset
   *
   * Example 1:
   * ```ts
   * player.setGraphic(['body', 'shield'])
   * ```
   *
   * Example 2:
   * ```ts
   * player.setGraphic(3) // Use tile #3
   * ```
   *
   * > You must, on the client side, create the spritesheet in question. Guide: [Create Sprite](/guide/create-sprite.html)
   *
   * @title Set Graphic
   * @method player.setGraphic(graphic)
   * @param {string | number | (string | number)[]} graphic
   * @returns {void}
   * @memberof ComponentManager
   */
  setGraphic(graphic) {
    const components = Utils_exports.isArray(graphic) ? graphic : [graphic];
    const col = [...components.map((value) => ({ id: Utils_exports.isString(value) ? "graphic" : "tile", value }))];
    this.removeComponentById("center", "graphic");
    this.mergeComponent("center", col);
  }
  /**
   * Delete components
   *
   * @title Remove Components
   * @param {string} position Position of the components. Can be: `top`, `center`, `bottom`, `left`, `right`
   * @memberof ComponentManager
   * @since 3.3.0
   */
  removeComponents(position) {
    this.layout[position].lines = [];
  }
  /**
   * Delete components by id.
   *
   * @title Remove Component By Id
   * @param {string} position Position of the components. Can be: `top`, `center`, `bottom`, `left`, `right`
   * @param {string} id Id of the component
   * @since 3.3.0
   */
  removeComponentById(position, id) {
    var _a;
    let lines = ((_a = this.layout[position]) == null ? void 0 : _a.lines) || [];
    lines = lines.map((line) => {
      line.col = line.col.filter((c) => c.id !== id);
      return line;
    });
    lines = lines.filter((line) => line.col.length > 0);
    this.layout[position].lines = lines;
  }
  /**
   * Merges components with existing components
   *
   * For use layout and options, see [setComponentsTop](/api/player.html#setcomponentstop)
   *
   * @title Merge Components
   * @param {string} position Position of the components. Can be: `top`, `center`, `bottom`, `left`, `right`
   * @param {Object} layout
   * @param {Object} options
   * @memberof ComponentManager
   * @since 3.3.0
   */
  mergeComponent(position, layout, options = {}) {
    var _a;
    if (!(layout instanceof Array)) {
      layout = [layout];
    }
    this.layout[position] = {
      lines: [
        ...((_a = this.layout[position]) == null ? void 0 : _a.lines) || [],
        ...layout.map((col) => {
          if (!Utils_exports.isArray(col)) {
            col = [col];
          }
          return { col };
        })
      ],
      ...options
    };
  }
  setComponents(position, layout, options = {}) {
    this.layout[position].lines = [];
    this.mergeComponent(position, layout, options);
  }
  /**
   * Add components to the center of the graphic.
   *
   * View [setComponentsTop](/api/player.html#setcomponentstop) for more information
   *
   * > Be careful, because if you assign, it deletes the graphics and if the lines are superimposed (unlike the other locations)
   *
   * @title Set Components Center
   * @method player.setComponentsCenter(layout,options)
   * @param {Object} layout
   * @param {Object} options
   * @memberof ComponentManager
   * @since 3.3.0
   */
  setComponentsCenter(layout, options = {}) {
    this.setComponents("center", layout, options);
  }
  /**
   * Add components to the top of the graphic. e.g. text, life bar etc. The block will be centred
   * The first array corresponds to the rows, and the nested table to the array in the row
   *
   * Example:
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   *
   * player.setComponentsTop([
   *      [Components.text('Hello World')],
   *      [Components.hpBar()]
   * ]) // 2 lines with 1 component each
   * ```
   *
   *  or
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   *
   * player.setComponentsTop([
   *      [Components.text('Hello World'), Components.hpBar()]
   * ]) // 1 line with 2 components
   * ```
   *
   * You can be faster if you only have lines
   *
   * ```ts
   * player.setComponentsTop([
   *      Components.text('Hello World'),
   *      Components.hpBar()
   * ]) // 2 lines with 1 component each
   * ```
   *
   * or one component:
   *
   * ```ts
   * player.setComponentsTop(Components.text('Hello World')) // 1 line with 1 component
   * ```
   *
   * You can add options to manage the style
   *
   * ```ts
   * player.setComponentsTop([
   *      Components.text('Hello World'),
   *      Components.hpBar()
   * ], {
   *      width: 100,
   *      height: 20,
   *      marginTop: 10,
   * })
   * ```
   *
   * @title Set Components Top
   * @method player.setComponentsTop(layout,options)
   * @param {ComponentObject[][] | ComponentObject[] | ComponentObject} layout Components
   * @param {Object} [options = {}] Options
   * @param {number} [options.width] Width of the block
   * @param {number} [options.height = 20] Height of the block
   * @param {number} [options.marginTop] Margin top
   * @param {number} [options.marginBottom] Margin bottom
   * @param {number} [options.marginLeft] Margin left
   * @param {number} [options.marginRight] Margin right
   * @memberof ComponentManager
   * @since 3.3.0
   */
  setComponentsTop(layout, options = {}) {
    this.setComponents("top", layout, options);
  }
  /**
   * Add components to the bottom of the graphic.
   *
   * View [setComponentsTop](/api/player.html#setcomponentstop) for more information
   *
   * @title Set Components Bottom
   * @method player.setComponentsBottom(layout,options)
   * @param {Object} layout
   * @param {Object} options
   * @memberof ComponentManager
   * @since 3.3.0
   */
  setComponentsBottom(layout, options = {}) {
    this.setComponents("bottom", layout, options);
  }
  /**
   * Add components to the left of the graphic.
   *
   * View [setComponentsTop](/api/player.html#setcomponentstop) for more information
   *
   * @title Set Components Left
   * @method player.setComponentsLeft(layout,options)
   * @param {Object} layout
   * @param {Object} options
   * @memberof ComponentManager
   * @since 3.3.0
   */
  setComponentsLeft(layout, options = {}) {
    this.setComponents("left", layout, options);
  }
  /**
   * Add components to the right of the graphic.
   *
   * View [setComponentsTop](/api/player.html#setcomponentstop) for more information
   *
   * @title Set Components Right
   * @method player.setComponentsRight(layout,options)
   * @param {Object} layout
   * @param {Object} options
   * @memberof ComponentManager
   * @since 3.3.0
   */
  setComponentsRight(layout, options = {}) {
    this.setComponents("right", layout, options);
  }
};

// node_modules/@rpgjs/server/lib/Game/EventManager.js
var EventMode;
(function(EventMode2) {
  EventMode2["Shared"] = "shared";
  EventMode2["Scenario"] = "scenario";
})(EventMode || (EventMode = {}));
var EventManager = class {
  /**
  * Get Event in current map
  * @title Get Event
  * @since 3.0.0-beta.7
  * @method map.getEvent(eventId)
  * @param {string} eventId Event Id
  * @returns {RpgEvent | undefined}
  * @memberof Map
  */
  getEvent(eventId) {
    return this.events[eventId];
  }
  getEventByName(eventName) {
    const events = Object.keys(this.events);
    const key = events.find((key2) => this.events[key2].name == eventName);
    if (!key)
      return;
    return this.events[key];
  }
  /**
  * Removes an event from the map. Returns false if the event is not found
  *
  * Deletion of an event forced to be performed at the end of several aynschronous notions
  *
  * @title Remove Event
  * @since 3.0.0-beta.4
  * @method map.removeEvent(eventId)
  * @param {string} eventId Event Name
  * @returns {boolean}
  * @memberof Map
  */
  removeEvent(eventId) {
    var _a, _b, _c, _d, _e, _f;
    if (!this.events[eventId])
      return false;
    const mode = this.events[eventId].mode;
    let currentState;
    if (mode == EventMode.Scenario) {
      currentState = ((_d = (_c = (_b = (_a = this.getCurrentMap()) == null ? void 0 : _a.$currentState().users) == null ? void 0 : _b[this.id]) == null ? void 0 : _c.events) == null ? void 0 : _d[eventId]) ?? {};
    } else {
      currentState = ((_e = this.$currentState().events) == null ? void 0 : _e[eventId]) ?? {};
    }
    this.removeObject(this.events[eventId], mode);
    delete this.events[eventId];
    if (mode == EventMode.Scenario) {
      (_f = this.getCurrentMap()) == null ? void 0 : _f.$setCurrentState(`users.${this.id}.events.${eventId}`, {
        ...currentState,
        deleted: true
      });
    } else {
      this.$setCurrentState(`events.${eventId}`, {
        ...currentState,
        deleted: true
      });
    }
    return true;
  }
  // @internal
  removeObject(object, mode = EventMode.Shared) {
    const map2 = this.getCurrentMap();
    if (!map2)
      return;
    map2.getShapes().forEach((shape) => shape.out(object));
    const events = Object.values(map2.game.world.getObjectsOfGroup(map2.id, object));
    for (let event of events) {
      object.getShapes().forEach((shape) => shape.out(event));
      event.getShapes().forEach((shape) => shape.out(object));
    }
    object._destroy$.next();
    object._destroy$.complete();
    if (object.type != PlayerType.Player)
      object._destroy$["_closed"] = true;
    map2.grid.clearObjectInCells(object.id);
    for (let playerId in map2.players) {
      if (object.id == playerId)
        continue;
      const otherPlayer = map2.players[playerId];
      if (otherPlayer.followingId == object.id) {
        otherPlayer.cameraFollow(otherPlayer);
      }
    }
    if (map2.nbPlayers === 1 && object.type === PlayerType.Player) {
      map2.remove(true);
    }
  }
};

// node_modules/@rpgjs/server/lib/inject.js
var instanceContext = null;
function inject(service, args = []) {
  return instanceContext.inject(service, args);
}
function setInject(context2) {
  instanceContext = context2;
}

// node_modules/@rpgjs/server/lib/Player/Player.js
var { isPromise: isPromise2, applyMixins: applyMixins8, isString: isString6 } = Utils_exports;
var commonSchemaFeature = {
  name: {
    $permanent: false
  },
  description: {
    $permanent: false
  },
  id: String
};
var itemSchemas = {
  price: {
    $permanent: false
  },
  consumable: {
    $permanent: false
  },
  ...commonSchemaFeature
};
var componentSchema = { id: String, value: String };
var layoutSchema = {
  width: Number,
  height: Number,
  marginBottom: Number,
  marginTop: Number,
  marginLeft: Number,
  marginRight: Number,
  lines: [{
    col: [componentSchema]
  }]
};
var playerSchemas = {
  position: {
    x: Number,
    y: Number,
    z: Number
  },
  direction: Number,
  teleported: {
    $permanent: false
  },
  deleted: {
    $permanent: false
  },
  moving: {
    $permanent: false
  },
  param: Object,
  hp: Number,
  sp: Number,
  gold: Number,
  level: {
    $effects: ["$this.expForNextlevel", "$this.param"]
  },
  expForNextlevel: {
    $permanent: false
  },
  exp: Number,
  name: String,
  items: [{ nb: Number, item: itemSchemas }],
  _class: commonSchemaFeature,
  equipments: [itemSchemas],
  skills: [
    {
      spCost: {
        $permanent: false
      },
      ...commonSchemaFeature
    }
  ],
  states: [commonSchemaFeature],
  effects: [String],
  layout: {
    top: layoutSchema,
    bottom: layoutSchema,
    left: layoutSchema,
    right: layoutSchema,
    center: layoutSchema
  },
  action: Number,
  map: String,
  speed: Number,
  frequency: Number,
  canMove: Boolean,
  through: Boolean,
  throughOtherPlayer: Boolean,
  width: Number,
  height: Number,
  wHitbox: Number,
  hHitbox: Number,
  // only for server
  _statesEfficiency: [{
    rate: {
      $syncWithClient: false
    },
    state: {
      $syncWithClient: false
    }
  }],
  tmpPositions: {
    $syncWithClient: false
  },
  initialLevel: {
    $syncWithClient: false
  },
  finalLevel: {
    $syncWithClient: false
  }
};
var layoutObject = {
  lines: []
};
var RpgPlayer = class _RpgPlayer extends RpgCommonPlayer {
  // redefine type (as RpgPlayer)
  get otherPlayersCollision() {
    return super.otherPlayersCollision;
  }
  get world() {
    var _a;
    return (_a = this.server) == null ? void 0 : _a.world;
  }
  constructor(playerId) {
    super(inject(RpgCommonGame), playerId);
    this.playerId = playerId;
    this.type = "player";
    this.layout = {
      top: layoutObject,
      bottom: layoutObject,
      left: layoutObject,
      right: layoutObject,
      center: layoutObject
    };
    this.events = {};
    this._rooms = [];
    this.session = null;
    this.prevMap = "";
    this.touchSide = false;
    this.tmpPositions = null;
    this.otherPossessedPlayer = null;
    this.followingId = null;
    this._dataLoading = false;
    this.gameEngine = inject(RpgCommonGame);
    this.teleported = 0;
    this.deleted = false;
    this.initialize();
  }
  /** @internal */
  initialize() {
    this.server = inject(RpgServerEngine);
    this.expCurve = {
      basis: 30,
      extra: 20,
      accelerationA: 30,
      accelerationB: 30
    };
    this.parameters = /* @__PURE__ */ new Map();
    this.variables = /* @__PURE__ */ new Map();
    this.states = [];
    this.equipments = [];
    this._effects = [];
    this.items = [];
    this.skills = [];
    this.gold = 0;
    this.exp = 0;
    this.speed = Speed.Normal;
    this.frequency = Frequency.None;
    this.canMove = true;
    this.through = false;
    this.throughOtherPlayer = true;
    this.initialLevel = 1;
    this.finalLevel = 99;
    this.level = this.initialLevel;
    this._gui = {};
    this._elementsEfficiency = [];
    this._statesEfficiency = [];
    this.moving = false;
    this.addParameter(MAXHP, MAXHP_CURVE);
    this.addParameter(MAXSP, MAXSP_CURVE);
    this.addParameter(STR, STR_CURVE);
    this.addParameter(INT, INT_CURVE);
    this.addParameter(DEX, DEX_CURVE);
    this.addParameter(AGI, AGI_CURVE);
    this.allRecovery();
  }
  _init() {
    this._socket.on("gui.interaction", ({ guiId, name, data }) => {
      if (this._gui[guiId]) {
        this._gui[guiId].emit(name, data);
        this.syncChanges();
      }
    });
    this._socket.on("gui.exit", ({ guiId, data }) => {
      this.removeGui(guiId, data);
    });
  }
  get schema() {
    return {
      ..._RpgPlayer.schemas,
      ...this.server["playerProps"]
    };
  }
  /**
   * ```ts
   * player.name = 'Link'
   * ```
   * @title Read/Give a name
   * @prop {string} player.name
   * @memberof Player
   * */
  get name() {
    return this._name;
  }
  set name(val) {
    this._name = val;
  }
  /**
   * Change your map. Indicate the positions to put the player at a place on the map
   *
   * > The map must be added to RpgServer beforehand. Guide: [Create Map](/guide/create-map.html)
   *
   * You don't have to give positions but you can put a starting position in the TMX file. Guide: [Start Position](/guide/player-start.html)
   *
   * @title Change Map
   * @method player.changeMap(mapId,positions)
   * @param {string} mapId
   * @param { {x: number, y: number, z?: number} | string } [positions]
   * @returns {Promise<RpgMap | null>} null if map not exists
   * @memberof Player
   */
  changeMap(mapId, positions) {
    return this.server.sceneMap.changeMap(mapId, this, positions);
  }
  async autoChangeMap(nextPosition) {
    const map2 = this.getCurrentMap();
    const worldMaps = map2 == null ? void 0 : map2.getInWorldMaps();
    let ret = false;
    if (worldMaps && map2) {
      const direction = this.getDirection();
      const marginLeftRight = map2.tileWidth / 2;
      const marginTopDown = map2.tileHeight / 2;
      const changeMap = async (adjacent, to) => {
        if (this.touchSide) {
          return false;
        }
        this.touchSide = true;
        const [nextMap] = worldMaps.getAdjacentMaps(map2, adjacent);
        if (!nextMap)
          return false;
        const id = nextMap.id;
        const nextMapInfo = worldMaps.getMapInfo(id);
        return !!await this.changeMap(id, to(nextMapInfo));
      };
      if (nextPosition.x < marginLeftRight && direction == Direction.Left) {
        ret = await changeMap({
          x: map2.worldX - 1,
          y: this.worldPositionY + 1
        }, (nextMapInfo) => ({
          x: nextMapInfo.width - this.wHitbox - marginLeftRight,
          y: map2.worldY - nextMapInfo.y + nextPosition.y
        }));
      } else if (nextPosition.x > map2.widthPx - this.wHitbox - marginLeftRight && direction == Direction.Right) {
        ret = await changeMap({
          x: map2.worldX + map2.widthPx + 1,
          y: this.worldPositionY + 1
        }, (nextMapInfo) => ({
          x: marginLeftRight,
          y: map2.worldY - nextMapInfo.y + nextPosition.y
        }));
      } else if (nextPosition.y < marginTopDown && direction == Direction.Up) {
        ret = await changeMap({
          x: this.worldPositionX + 1,
          y: map2.worldY - 1
        }, (nextMapInfo) => ({
          x: map2.worldX - nextMapInfo.x + nextPosition.x,
          y: nextMapInfo.height - this.hHitbox - marginTopDown
        }));
      } else if (nextPosition.y > map2.heightPx - this.hHitbox - marginTopDown && direction == Direction.Down) {
        ret = await changeMap({
          x: this.worldPositionX + 1,
          y: map2.worldY + map2.heightPx + 1
        }, (nextMapInfo) => ({
          x: map2.worldX - nextMapInfo.x + nextPosition.x,
          y: marginTopDown
        }));
      } else {
        this.touchSide = false;
      }
    }
    return ret;
  }
  /**
   * Dynamically create an event in Scenario mode on the current map
   *
   * ```ts
   * @EventData({
   *  name: 'EV-1'
   * })
   * class MyEvent extends RpgEvent {
   *  onAction() {
   *      console.log('ok')
   *  }
   * }
   *
   * player.createDynamicEvent({
   *      x: 100,
   *      y: 100,
   *      event: MyEvent
   * })
   * ```
   *
   * You can also put an array of objects to create several events at once
   *
   * @title Create Dynamic Event
   * @since 3.0.0-beta.4
   * @method player.createDynamicEvent(eventObj | eventObj[])
   * @param { { x: number, y: number, z?: number, event: eventClass } } [eventsList]
   * @returns { { [eventId: string]: RpgEvent } }
   * @memberof Player
   */
  createDynamicEvent(eventsList, forceMode = true) {
    if (!eventsList)
      return {};
    const mapInstance = this.getCurrentMap();
    if (!mapInstance) {
      throw "The player is not assigned to any map";
    }
    if (!Utils_exports.isArray(eventsList)) {
      eventsList = [eventsList];
    }
    let eventsListMode = eventsList;
    if (forceMode) {
      eventsListMode = eventsList.map((event) => {
        event.event.mode = EventMode.Scenario;
        return event;
      });
    }
    const events = mapInstance.createEvents(eventsListMode, EventMode.Scenario);
    let ret = {};
    for (let key in events) {
      this.events[key] = events[key];
      this.events[key].playerRelated = this;
      this.events[key].execMethod("onInit", [this]);
      ret = { ...ret, [key]: this.events[key] };
    }
    return ret;
  }
  /**
   * Allows to change the positions of the player on the current map.
   * You can put the X and Y positions or the name of the created shape on Tiled Map Editor.
   * If you have several shapes with the same name, one position will be chosen randomly.
   *
   * ```ts
   * player.teleport({ x: 100, y: 500 })
   * ```
   *
   * or
   *
   * ```ts
   * player.teleport('my-shape-name')
   * ```
   *
   * If no parameter:
   *
   * ```ts
   * player.teleport() // { x: 0, y: 0, z: 0 }
   * ```
   *
   * @title Teleport on the map
   * @method player.teleport(positions)
   * @param { {x: number, y: number, z?: number} | string } [positions]
   * @returns {Promise<{ {x: number, y: number, z: number} }>}
   * @memberof Player
   */
  async teleport(positions) {
    var _a;
    if (isString6(positions))
      positions = (_a = this.getCurrentMap()) == null ? void 0 : _a.getPositionByShape((shape) => shape.name == positions || shape.getType() == positions);
    if (!positions)
      positions = { x: 0, y: 0, z: 0 };
    if (!positions.z)
      positions.z = 0;
    this.teleported++;
    this.position = positions;
    this._lastFramePositions = void 0;
    await this.isCollided(this.position);
    return positions;
  }
  /**
   * Load the saved data with the method save()
   * If the player was on a map, it repositions the player on the map.
   *
   * ```ts
   * const json = player.save()
   * player.load(json)
   * ```
   *
   * @title Load progress
   * @method player.load(json)
   * @param {string} json The JSON sent by the method save()
   * @returns {Promise<boolean | RpgMap | null>}
   * @memberof Player
   */
  async load(json) {
    this._dataLoading = true;
    if (isString6(json))
      json = JSON.parse(json);
    const getData = (id) => new (this.databaseById(id))();
    for (let key in json) {
      const val = json[key];
      if (Utils_exports.isObject(val) && val.hasOwnProperty("0")) {
        json[key] = Object.values(val);
      }
    }
    const items = {};
    if (json.items) {
      for (let it of json.items) {
        items[it.item.id] = getData(it.item.id);
      }
      json.items = json.items.map((it) => ({ nb: it.nb, item: items[it.item.id] }));
      if (Array.isArray(json.equipments)) {
        json.equipments = json.equipments.map((it) => {
          items[it.id].equipped = true;
          return items[it.id];
        });
      }
    }
    if (json.states)
      json.states = json.states.map((state) => getData(state.id));
    if (json.skills)
      json.skills = json.skills.map((skill) => getData(skill.id));
    if (json.variables)
      json.variables = new Map(json.variables);
    (0, import_lodash.default)(this, json);
    this.position = json.position;
    if (json.map) {
      this.map = "";
      const map2 = await this.changeMap(json.map, json.tmpPositions || json.position);
      this._dataLoading = false;
      return map2;
    }
    this._dataLoading = false;
    return null;
  }
  /**
   * Returns a JSON with all the data to keep in memory. Then use the `load()` method to load the data
   *
   * You can also use the JSON.stringify
   *
   * ```ts
   * const json = player.save() // or JSON.stringify(player)
   * player.load(json)
   * ```
   *
   * @title Save progress
   * @method player.save()
   * @returns {string}
   * @memberof Player
   */
  save() {
    return JSON.stringify(this);
  }
  // TODO
  toObject() {
    return {
      direction: this.direction,
      id: this.id,
      canMove: this.canMove,
      position: {
        x: this.position.x,
        y: this.position.y,
        z: this.position.z
      },
      hitbox: {
        width: this.wHitbox,
        height: this.hHitbox
      },
      map: this.map,
      pendingMove: this.pendingMove,
      speed: this.speed
    };
  }
  toJSON() {
    const { permanentObject } = Room.compileSchema(this.schema);
    const snapshot = Room.extractObjectOfRoom(this, permanentObject);
    snapshot.variables = [...this.variables];
    return snapshot;
  }
  /**
       * Run the change detection cycle. Normally, as soon as a hook is called in a class, the cycle is started. But you can start it manually
       * The method calls the `onChanges` method on events and synchronizes all map data with the client.
  
       * @title Run Sync Changes
       * @method player.syncChanges()
       * @returns {void}
       * @memberof Player
       */
  syncChanges() {
    this._eventChanges();
  }
  databaseById(id) {
    const data = this.server.database[id];
    if (!data)
      throw new Error(`The ID=${id} data is not found in the database. Add the data in the property "database" of @RpgServer decorator.`);
    return data;
  }
  /**
   * Retrieves data from the current map
   *
   * returns null if the player is not assigned to a map
   *
   * @title Get Current Map
   * @method player.getCurrentMap()
   * @returns {RpgMap | null}
   * @memberof Player
   */
  getCurrentMap() {
    return this._getMap(this.map);
  }
  loadScene(name, data) {
    this.emit(SocketEvents.LoadScene, {
      name,
      data
    });
  }
  emitSceneMap() {
    const mapInstance = this.getCurrentMap();
    if (!mapInstance) {
      throw "[Emit] The player is not assigned to any map";
    }
    let { data: serializeMap } = Object.assign({}, mapInstance);
    delete serializeMap.shapes;
    delete serializeMap.events;
    delete serializeMap._events;
    for (let layer of serializeMap.layers) {
      delete layer.map;
    }
    this.loadScene("map", {
      id: mapInstance.id,
      sounds: mapInstance.sounds,
      ...serializeMap
    });
  }
  gameReload() {
    this.emit(SocketEvents.GameReload);
  }
  changeServer(url, port) {
    this.emit(SocketEvents.ChangeServer, {
      url,
      port
    });
  }
  _getMap(id) {
    return RpgCommonMap.buffer.get(id);
  }
  /**
   * Calls the showAnimation() method on the client side to display an animation on the player
   * You must remember to create the spritesheet beforehand
   *
   * For this type of spritesheet:
   *
   * ```ts
   * @Spritesheet({
   *  id: 'fire',
   *  image: require('')
   *  textures: {
   *      default: {
   *          animations: [
   *
   *          ]
   *      }
   *   }
   * })
   * export class FireAnimation {}
   * ```
   *
   * Here is the call of the method:
   *
   * ```ts
   * player.showAnimation('fire', 'default')
   * ```
   *
   * If you don't want to put an animation on top of the event but replace the event graphic with another one, set true as last parameter.
   * This is useful, if for example, you want to make an animated character (sword stroke when pressing a key)
   * When the animation is finished, the original graphic is displayed again
   *
   *
   * ```ts
   * player.showAnimation('sword_stroke', 'default', true)
   * ```
   *
   * Since version 3.0.0-rc, you can define several graphic elements. This allows you to animate them all at once
   *
   * ```ts
   * player.showAnimation(['body', 'sword_stroke'], 'default', true)
   * ```
   *
   * ::: tip
   * For this to work, the animations must have been previously defined in `setGraphic`.
   * :::
   *
   * @title Show Animation
   * @method player.showAnimation(graphic,animationName,replaceGraphic=false)
   * @param {string | string[]} graphic spritesheet identifier
   * @param {string} animationName Name of the animation in the spritesheet
   * @param {boolean} [replaceGraphic] Replace the event graphic with the animation. After the end of the animation, the original graphic is reapplied
   * @returns {void}
   * @memberof Player
   */
  showAnimation(graphic, animationName, replaceGraphic = false) {
    this.emitToMap("callMethod", {
      name: SocketMethods.ShowAnimation,
      params: [graphic, animationName, replaceGraphic]
    });
  }
  /**
   * TODO:
   * 1. It is necessary, on the client side, to make the character move even if controlled by someone else (problem: same playerId so, one will not move because of the client side prediction. Solution: create a new Id ? like session Id ?
   * 2. You would need several sockets per character. If the character changes map or changes server, all players controlling the character must be able to see it
   * 3. If the player regains control, what happens, do we return to the previous map?
   * 4. If it's an event, you must be able to get the event by id in GameEngine
   */
  takePossessionOf(otherPlayer) {
    this.otherPossessedPlayer = otherPlayer;
    this._socket.emit("playerJoined", { playerId: otherPlayer.id, session: this.session });
    this.cameraFollow(otherPlayer);
  }
  /**
   * Sends the client which event or player the camera should follow. You can set options to perform a motion animation
   *
   * @title Camera Follow
   * @method player.cameraFollow(otherPlayer,options)
   * @param {RpgPlayer | RpgEvent} otherPlayer
   * @param {options} options
   * @param {object | boolean} [options.smoothMove] - animate. Set a boolean to use default parameters
   * @param {number} [options.smoothMove.time=1000] - time to animate
   * @param {string} [options.smoothMove.ease=linear] - easing to use. Go to https://easings.net to get function name
   * @returns {void}
   * @since 3.1.0
   * @memberof Player
   */
  cameraFollow(otherPlayer, options = {}) {
    if (otherPlayer.id == this.id) {
      this.followingId = null;
    } else {
      this.followingId = otherPlayer.id;
    }
    this.emit(SocketEvents.CallMethod, {
      objectId: this.playerId,
      name: SocketMethods.CameraFollow,
      params: [otherPlayer.id, options]
    });
  }
  /**
   * Emit data to clients with socket
   *
   * @title Emit to client
   * @method player.emit(key,value)
   * @param {string} key
   * @param {any} value
   * @returns {void}
   * @memberof Player
   */
  emit(key, value) {
    if (this._socket)
      this._socket.emit(key, value);
  }
  /**
   * Listen to the data (socket) sent by the client
   *
   * @title Listen to data from the client
   * @method player.on(key,cb)
   * @param {string} key
   * @param {function} cb
   * @returns {void}
   * @memberof Player
   */
  on(key, cb) {
    if (this._socket)
      this._socket.on(key, cb);
  }
  /**
   * Adds a one-time listener function for the event named eventName
   *
   * @title Listen one-time to data from the client
   * @method player.once(key,cb)
   * @since 3.0.0-beta.5
   * @param {string} key
   * @param {function} cb
   * @returns {void}
   * @memberof Player
   */
  once(key, cb) {
    if (this._socket)
      this._socket.once(key, cb);
  }
  /**
   * Removes all listeners of the specified eventName.
   *
   * @title Removes all listeners of the client
   * @method player.off(key)
   * @since 3.0.0-beta.5
   * @param {string} key
   * @returns {void}
   * @memberof Player
   */
  off(key) {
    if (this._socket)
      this._socket.removeAllListeners(key);
  }
  disconnect() {
    if (this._socket)
      this._socket.disconnect();
  }
  emitToMap(key, value) {
    const map2 = this.getCurrentMap();
    if (map2) {
      map2.$setCurrentState(`users.${this.id}.${key}`, value);
    }
  }
  execMethodSync(methodName, methodData = [], target) {
    let ret;
    if (target && target[methodName]) {
      ret = target[methodName](...methodData);
    }
    return ret;
  }
  async execMethod(methodName, methodData = [], target) {
    const ignoreIfDataLoading = ["onLevelUp", "onDead"];
    if (ignoreIfDataLoading.includes(methodName) && this._dataLoading) {
      return;
    }
    let ret;
    if (target && target[methodName]) {
      ret = target[methodName](...methodData);
      if (isPromise2(ret))
        await ret;
    } else {
      ret = await RpgPlugin.emit(`Server.${methodName}`, [this, ...methodData], true);
    }
    this.syncChanges();
    return ret;
  }
  _triggerHook(name, val) {
    if (this[name])
      this[name](val);
    this.emit("Player." + name, val);
  }
  // @internal
  /**
   * Allows you to manually update a status in the rooms that will then be sent to the customer.
   * @param path
   * @example
   * ```ts
   * player.changeRoomState('hp')
   * ```
   */
  changeRoomState(path) {
    var _a;
    (_a = this.world) == null ? void 0 : _a.forEachUserRooms(this.id, (room) => {
      room.$setCurrentState(`users.${this.id}.${path}`);
    });
  }
  _eventChanges() {
    if (!this._getMap(this.map))
      return;
    const { events } = this._getMap(this.map);
    const arrayEvents = [...Object.values(this.events), ...Object.values(events)];
    for (let event of arrayEvents) {
      if (event.onChanges)
        event.onChanges(this);
    }
  }
  /**
   * Allows to play a sound, heard only by the player or by the players of the map
   *
   * Here is a sound, client side:
   *
   * ```ts
   * import { Sound } from '@rpgjs/client'
   * @Sound({
   *      id: 'town-music',
   *      sound: require('./sound/town.ogg')
   * })
   * export class TownMusic {}
   * ```
   *
   * Here is the call of the method, server side:
   *
   * ```ts
   * player.playSound('town-music')
   * ```
   *
   * If you want everyone to listen to the sound on the map:
   *
   * ```ts
   * player.playSound('town-music', true)
   * ```
   *
   * @title Play Sound
   * @method player.playSound(soundId,allMap=false)
   * @param {string} soundId Sound identifier, defined on the client side
   * @param {boolean} [forEveryone=false] Indicate if the sound is heard by the players on the map
   * @since 3.0.0-alpha.9
   * @returns {void}
   * @memberof Player
   */
  playSound(soundId, forEveryone = false) {
    const obj = {
      objectId: this.playerId,
      name: SocketMethods.PlaySound,
      params: [soundId]
    };
    if (!forEveryone) {
      this.emit(SocketEvents.CallMethod, obj);
      return;
    }
    this.emitToMap(SocketEvents.CallMethod, obj);
  }
};
RpgPlayer.schemas = {
  ...playerSchemas,
  events: [playerSchemas]
};
applyMixins8(RpgPlayer, [
  EventManager,
  ItemManager,
  GoldManager,
  StateManager,
  SkillManager,
  ParameterManager,
  EffectManager,
  ClassManager,
  ElementManager,
  GuiManager,
  VariableManager,
  MoveManager,
  BattleManager,
  ComponentManager
]);
var RpgEvent = class extends RpgPlayer {
  constructor(playerId) {
    super(playerId);
    this.type = "event";
    this.properties = {};
    this.playerRelated = null;
  }
  async execMethod(methodName, methodData = []) {
    if (!this[methodName]) {
      return;
    }
    const ret = this[methodName](...methodData);
    return ret;
  }
  changeRoomState(path) {
    const room = this.getCurrentMap();
    if (room) {
      room.$setCurrentState(`events.${this.id}.${path}`);
    }
  }
  /**
  * Deletes the event from the map (in shared or scenario mode)
  *
  * @title Remove
  * @since 4.0.0
  * @method event.remove()
  * @returns {boolean} true if the event has been removed. If false, the event is not on the map
  * @memberof RpgEvent
  */
  remove() {
    let bool = false;
    if (this.playerRelated)
      bool = this.playerRelated.removeEvent(this.id);
    const map2 = this.getCurrentMap();
    if (map2) {
      bool = map2.removeEvent(this.id);
    }
    return bool;
  }
  emitToMap(key, value) {
    const map2 = this.getCurrentMap();
    if (map2) {
      const eventPath = `events.${this.id}.${key}`;
      if (this.playerRelated) {
        map2.$setCurrentState(`users.${this.playerRelated.id}.${eventPath}`, value);
      } else {
        map2.$setCurrentState(eventPath, value);
      }
    }
  }
};

// node_modules/@rpgjs/server/lib/decorators/map.js
function MapData(options) {
  return (target) => {
    target.file = options.file;
    target.id = options.id;
    target.type = "map";
    target.prototype.name = options.name;
    target.prototype.file = options.file;
    target.prototype.id = options.id;
    target.prototype.sounds = options.sounds;
    target.prototype.lowMemory = options.lowMemory;
    target.prototype.$schema = {};
    if (options.syncSchema) {
      target.prototype.$schema = options.syncSchema;
    }
    if (!target.prototype.$schema.shapes) {
      target.prototype.$schema.shapes = [
        {
          type: String,
          name: String,
          x: Number,
          y: Number,
          width: Number,
          height: Number,
          properties: {
            collision: Boolean
          },
          polygon: [{ x: Number, y: Number }],
          rotation: Number,
          components: [componentSchema]
        }
      ];
    }
    if (!target.prototype.$schema.users) {
      target.prototype.$schema.users = [RpgPlayer.schemas];
    }
    if (!target.prototype.$schema.events) {
      target.prototype.$schema.events = [RpgPlayer.schemas];
    }
    target.prototype._events = options.events;
  };
}

// node_modules/@rpgjs/server/lib/decorators/event.js
function EventData(options) {
  return (target) => {
    target.mode = options.mode || EventMode.Shared;
    target.width = options.width;
    target.height = options.height;
    target.hitbox = options.hitbox;
    target._name = options.name;
    target.prototype._name = options.name;
    target.prototype.mode = target.mode;
  };
}

// node_modules/@rpgjs/server/lib/Game/Map.js
var AutoEvent = class extends RpgEvent {
  onInit() {
    const { graphic, direction, speed, frequency, move } = this.properties;
    if (graphic) {
      this.setGraphic(graphic);
    }
    if (direction) {
      this.changeDirection(direction);
    }
    if (speed) {
      this.speed = speed;
    }
    if (frequency) {
      this.frequency = frequency;
    }
    if (move == "random") {
      this.infiniteMoveRoute([Move.tileRandom()]);
    }
  }
  async onAction(player) {
    const { text } = this.properties;
    if (text) {
      await player.showText(text, {
        talkWith: this
      });
    }
  }
};
AutoEvent.hitbox = {};
var RpgMap = class extends RpgCommonMap {
  constructor(_server) {
    super();
    this._server = _server;
    this.events = {};
  }
  // alias of users property in simple-room package
  /**
   * @title Players list
   * @prop { { [playerId: string]: RpgPlayer } } [players]
   * @readonly
   * @memberof Map
   */
  get players() {
    return this["users"];
  }
  /**
   * @title Number of players
   * @prop {number} [nbPlayers]
   * @readonly
   * @memberof Map
   */
  get nbPlayers() {
    return Object.keys(this.players).length;
  }
  $additionalEmitProperties(player) {
    const lastFramePositions = player["_lastFramePositions"];
    let pos;
    let lastFrame;
    if (lastFramePositions) {
      pos = lastFramePositions.position;
      lastFrame = lastFramePositions.frame;
    }
    const data = { frame: lastFrame, pos };
    return data;
  }
  async load() {
    var _a;
    if (RpgCommonMap.buffer.has(this.id)) {
      return;
    }
    const data = await this.parseTmx(this.file);
    super.load(data);
    this.getAllObjects().forEach(this.createShape.bind(this));
    this.loadProperties(data.properties);
    (_a = this._server.workers) == null ? void 0 : _a.call("loadMap", {
      id: this.id,
      data
    });
    RpgCommonMap.buffer.set(this.id, this);
    this.loadCommonEvents(this._server.inputOptions.events);
    this.createDynamicEvent(this._events);
    if (this.onLoad)
      this.onLoad();
  }
  /**
   * Update the map with new data. Data can be a string (TMX content) or an object (parsed TMX content)
   * New Map data will be sent to all players on the map
   *
   * @title Update map
   * @method map.update(data)
   * @since 4.0.0
   * @returns {Promise<void>}
   * @param {object | string} data
   * @memberof Map
   */
  async update(data) {
    let objectData;
    if (typeof data == "string") {
      objectData = await this.parseTmx(data, this.file);
    } else {
      objectData = data;
    }
    super.load(objectData);
    RpgCommonMap.buffer.set(this.id, this);
    this.clearShapes();
    this.getAllObjects().forEach(this.createShape.bind(this));
    for (let playerId in this.players) {
      const player = this.players[playerId];
      player.emitSceneMap();
    }
  }
  /**
   * Update tileset with new data. Data can be a string (TSX content) or an object (TiledTileset)
   * Cache will be removed for this tileset
   * New tileset data will be sent to all players on the map
   * Warning: tileset is not updated for all maps, only for the current map
   *
   * @title Update tileset
   * @method map.updateTileset(data)
   * @since 4.0.0
   * @returns {<void>}
   * @param {TiledTileset | string} data
   * @memberof Map
   */
  updateTileset(data) {
    let objectData;
    if (typeof data == "string") {
      const parser = new TiledParser(data, this.file);
      objectData = parser.parseTileset();
    } else {
      objectData = data;
    }
    this.removeCacheTileset(objectData.name);
    this.update({
      ...this.data,
      tilesets: this.data.tilesets.map((tileset) => {
        if (tileset.name == objectData.name) {
          objectData.firstgid = tileset.firstgid;
          return objectData;
        }
        return tileset;
      })
    });
  }
  /**
   * Remove the map from the server. If there are still players on the map, an error will be thrown
   * Not delete the map file, only in memory
   *
   * @title Remove map
   * @method map.remove()
   * @since 4.0.0
   * @returns {void}
   * @throws {Error} If there are still players on the map
   * @memberof Map
   * */
  remove(ignorePlayers = false) {
    const players = Object.values(this.players);
    if (players.length > 0 && !ignorePlayers) {
      throw new Error(`Cannot remove map ${this.id} because there are still players on it`);
    }
    for (let eventId in this.events) {
      this.removeEvent(eventId);
    }
    RpgCommonMap.buffer.delete(this.id);
    World.removeRoom(this.id);
  }
  async parseTmx(file, relativePath = "") {
    const hasAssetsPath = !!this._server.envs.VITE_BUILT;
    const parser = new TiledParserFile(file, {
      basePath: false ? "." : "",
      staticDir: hasAssetsPath ? path_default.join(this._server.inputOptions.basePath, this._server.assetsPath) : "",
      relativePath
    });
    const data = await parser.parseFilePromise({
      getOnlyBasename: hasAssetsPath
    });
    return data;
  }
  loadProperties(properties) {
    for (let key in properties) {
      this[key] = properties[key];
    }
  }
  get game() {
    return this._server.gameEngine;
  }
  // Hook: called by simple-room package
  onLeave(player) {
    this.removeObject(player);
  }
  /**
   * Loads common events onto the game map.
   *
   * @private
   * @param {RpgClassEvent<RpgEvent>[]} commonEvents - An array of common events to load.
   * @param {RpgPlayer} [player] - The player instance on which to create the dynamic events. If not provided, the function will use the current instance.
   * @returns {void}
   */
  // @internal
  loadCommonEvents(commonEvents, player) {
    let events = [];
    this.getShapes().forEach((shape) => {
      const findEvent = commonEvents.find((event) => event._name == shape.name);
      if (!findEvent)
        return;
      const { x, y } = shape.hitbox;
      events.push({
        x,
        y,
        event: findEvent
      });
    });
    if (player) {
      player.createDynamicEvent(events, false);
    } else {
      this.createDynamicEvent(events);
    }
  }
  // TODO
  autoLoadEvent() {
    this.getShapes().forEach((shape) => {
      const { properties } = shape;
      const { x, y, pos, w, h } = shape.hitbox;
      if (shape.isEvent() && !this.events[shape.name]) {
        const mode = properties.mode || EventMode.Shared;
        AutoEvent.prototype["_name"] = shape.name;
        AutoEvent.mode = mode;
        AutoEvent.hitbox = {
          width: 32,
          height: 16
        };
        const event = this.createEvent({
          x,
          y,
          event: AutoEvent
        }, mode, shape);
        if (event)
          this.events[shape.name] = event;
      }
    });
  }
  /**
   * Edit a tile on the map. All players on the map will see the modified tile
   *
   *
   * @title Change Tile in map
   * @since 3.0.0-beta.4
   * @method map.setTile(x,y,layer,tileInfo)
   * @param {number} x Position X
   * @param {number} y Position Y
   * @param {string | ((layer: any) => boolean)} layer Name of the layer where you want to put a tile. OYou can also put a function that will act as a filter. The first parameter is the layer and you return a boolean to indicate if you modify the tile of this layer or not
   * @param {object} tileInfo Object with the following properties:
   *  - {number} gid: The tile number in tileset (from 1)
   *  - {object} properties Property of the tile. You own object. To set a collision, set the `collision:true` property
   * @example
   * ```ts
   * map.setTile(15, 18, 'mylayer', { gid: 2 })
   * ```
   * @returns {void}
   * @memberof Map
   */
  setTile(x, y, layerFilter, tileInfo) {
    const tiles = super.setTile(x, y, layerFilter, tileInfo);
    const players = Object.values(this["users"]);
    for (let player of players) {
      player.emit("changeTile", tiles);
    }
    return tiles;
  }
  getEventShape(eventName) {
    return this.getShapes().find((shape) => shape.name == eventName);
  }
  /**
   * Dynamically create an event in Shared mode
   *
   * ```ts
   * @EventData({
   *  name: 'EV-1'
   * })
   * class MyEvent extends RpgEvent {
   *  onAction() {
   *      console.log('ok')
   *  }
   * }
   *
   * map.createDynamicEvent({
   *      x: 100,
   *      y: 100,
   *      event: MyEvent
   * })
   * ```
   *
   * You can also put an array of objects to create several events at once
   *
   * @title Create Dynamic Event
   * @since 3.0.0-beta.4
   * @method map.createDynamicEvent(eventObj|eventObj[])
   * @param { { x: number, y: number, z?: number, event: eventClass } } eventsList
   * @returns { { [eventId: string]: RpgEvent } }
   * @memberof Map
   */
  createDynamicEvent(eventsList) {
    if (!eventsList)
      return {};
    if (!Utils_exports.isArray(eventsList)) {
      eventsList = [eventsList];
    }
    const events = this.createEvents(eventsList, EventMode.Shared);
    let ret = {};
    for (let key in events) {
      this.events[key] = events[key];
      this.events[key].updateInVirtualGrid();
      this.events[key].execMethod("onInit");
      ret = { ...ret, [key]: this.events[key] };
    }
    return ret;
  }
  createEvent(obj, mode, shape) {
    let event, position;
    if (obj.x === void 0) {
      event = obj;
    } else {
      event = obj.event;
      position = { x: obj.x, y: obj.y, z: obj.z ?? 0 };
    }
    if ("$decorator" in event) {
      const options = event.$decorator;
      EventData(options)(event);
    }
    if (event.mode != mode) {
      return null;
    }
    const ev = this.game.addEvent(event);
    const _shape = shape || this.getEventShape(ev.name);
    ev.map = this.id;
    ev.width = event.width || this.tileWidth;
    ev.height = event.height || this.tileHeight;
    if (_shape && _shape.properties)
      ev.properties = _shape.properties;
    if (event.hitbox)
      ev.setHitbox(event.hitbox.width, event.hitbox.height);
    ev.teleport(position || ev.name);
    return ev;
  }
  createEvents(eventsList, mode) {
    const events = {};
    if (!eventsList)
      return events;
    for (let obj of eventsList) {
      const ev = this.createEvent(obj, mode);
      if (ev) {
        events[ev.id] = ev;
      }
    }
    return events;
  }
  /**
       * Allows to create a temporary hitbox on the map that can have a movement
  For example, you can use it to explode a bomb and find all the affected players, or during a sword strike, you can create a moving hitbox and find the affected players again
       * @title Create a temporary and moving hitbox
       * @since 3.2.0
       * @method map.createMovingHitbox(hitboxes,options)
       * @param {Array<{ width: number, height: number, x: number, y: number }>} hitboxes Create several hitboxes that will give an effect of movement
       * @param {object} [options]
       * @param {speed} [options.speed=1] speed of movement (in frames)
       * @returns {Observable<AbstractObject>} You find the methods of position and movement of an event
       * @memberof Map
       * @example
       *
       * ```ts
       * // Two hitboxes that will be done very quickly
       * map.createMovingHitbox(
       *   [
       *      { x: 0, y: 0, width: 100, height: 100 },
       *      { x: 20, y: 0, width: 100, height: 100 }
       *   ]
       * ).subscribe({
       *      next(hitbox) {
       *          console.log(hitbox.otherPlayersCollision)
       *      },
       *      complete() {
       *          console.log('finish')
       *      }
       * })
       * ```
       */
  createMovingHitbox(hitboxes, options = {}) {
    return this._createMovingHitbox(this.game, this._server.tick, this.id, hitboxes, options);
  }
  setSync(schema) {
    return this.$setSchema(schema);
  }
  // Reflects itself. Just for compatibility with the EventManager class
  getCurrentMap() {
    return this;
  }
};
Utils_exports.applyMixins(RpgMap, [
  EventManager
]);

// node_modules/@rpgjs/server/lib/Game/WorldMaps.js
var RpgWorldMaps = class extends RpgCommonWorldMaps {
  load(world, sceneMap) {
    for (let worldMap of world.maps) {
      const { fileName } = worldMap;
      let id, map2;
      if (worldMap.id) {
        id = worldMap.id;
      } else if (Utils_exports.isString(fileName)) {
        id = Utils_exports.extractId(fileName);
      }
      const create = () => sceneMap.createDynamicMap({
        id,
        file: world.basePath ? `${world.basePath}/${fileName}` : fileName
      });
      if (!id) {
        map2 = create();
      } else {
        map2 = sceneMap.getMapBydId(id) ?? create();
      }
      this.addMap(worldMap, map2);
    }
    return this;
  }
};

// node_modules/@rpgjs/server/lib/Scenes/Map.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SceneMap = class {
  constructor(sceneMapObject) {
    this.maps = [];
    this.mapsById = {};
    this.worldMaps = /* @__PURE__ */ new Map();
    this.server = inject(RpgServerEngine);
    const { maps, worldMaps, events } = sceneMapObject;
    this.maps = maps;
    this.mapsById = {};
    RpgCommonMap.buffer.clear();
    if (this.maps) {
      for (let map2 of this.maps) {
        this.createDynamicMap(map2);
      }
    }
    if (worldMaps) {
      for (let worldMap of worldMaps) {
        this.createDynamicWorldMaps(worldMap);
      }
    }
  }
  /**
   * Returns an array of RpgClassMap objects that represent maps with static properties.
   *
   * @title Get maps
   * @method sceneMap.getMaps()
   * @returns {RpgClassMap<RpgMap>[]} Array of RpgClassMap objects.
   * @since 4.0.0
   * @example
   * ```typescript
   * const maps = scene.getMaps();
   * console.log(maps);
   * // Output: [
   * // { file: 'maps/level1.tmx', id: 'level1', type: 'map' },
   * // { file: 'maps/level2.tmx', id: 'level1', type: 'map' },
   * // { file: 'maps/level3.tmx', id: 'level1', type: 'map' }
   * // ]
   * ```
   * @memberof SceneMap
   */
  getMaps() {
    return Object.values(this.mapsById);
  }
  getMapBydId(id) {
    let mapClass = this.mapsById[id];
    if (!mapClass) {
      return null;
    }
    if (!Utils_exports.isClass(mapClass))
      mapClass = Utils_exports.createConstructor(mapClass);
    return mapClass;
  }
  async loadMap(id) {
    const mapClass = this.getMapBydId(id);
    if (!mapClass) {
      console.log(`Map ${id} not exists`);
      return;
    }
    let mapInstance;
    if (mapClass["buffer"].has(id)) {
      return mapClass["buffer"].get(id);
    }
    if (RpgCommonMap.buffer.has(id)) {
      mapInstance = RpgCommonMap.buffer.get(id);
    } else {
      const room = new mapClass(this.server);
      room.$schema.users = [
        {
          ...RpgPlayer.schemas,
          ...this.server["playerProps"]
        }
      ];
      mapInstance = World.addRoom(id, room);
      await mapInstance.load();
    }
    return mapInstance;
  }
  /**
  * Loads the content of a `.world` file from Tiled Map Editor into the map scene
  *
  * > Note, that if the map already exists (i.e. you have already defined an RpgMap), the world will retrieve the already existing map. Otherwise it will create a new map
  *
  * @title Create worlds dynamically
  * @method sceneMap.createDynamicWorldMaps(world)
  * @param {object} world
  * object is
  * ```ts
  * {
  *  id?: string
  *  maps: {
  *      id?: string
  *      properties?: object
  *      fileName: string;
         height: number;
         width: number;
         x: number;
         y: number;
  *  }[],
     onlyShowAdjacentMaps: boolean, // only for Tiled Map Editor
     type: 'world' // only for Tiled Map Editor
  * }
  * ```
  *
  * @since 3.0.0-beta.8
  * @memberof SceneMap
  */
  createDynamicWorldMaps(world) {
    world.id = world.id || Utils_exports.generateUID();
    const worldMap = new RpgWorldMaps(world.id).load(world, this);
    this.worldMaps.set(world.id, worldMap);
    return worldMap;
  }
  /**
   * Recover a world
   *
   * @title Recover a world
   * @method sceneMap.getWorldMaps(id)
   * @param {string} id world id
   * @return { RpgWorldMaps | undefined }
   * @since 3.0.0-beta.8
   * @memberof SceneMap
   */
  getWorldMaps(id) {
    return this.worldMaps.get(id);
  }
  /**
  * Delete a world
  *
  * @title Delete a world
  * @method sceneMap.deleteWorldMaps(id)
  * @param {string} id world id
  * @since 3.0.0-beta.8
  * @memberof SceneMap
  */
  deleteWorldMaps(id) {
    this.worldMaps.delete(id);
  }
  /**
   * Create a dynamic map
   *
   * Since version 3.0.0-beta.8, you can just pass the path to the file. The identifier will then be the name of the file
   *
   * @method sceneMap.createDynamicMap(mapData)
   * @title Create a dynamic map
   * @param {object | RpgMap | string} mapData The same property as [@MapData decorator](https://docs.rpgjs.dev/classes/map.html#mapdata-decorator)
   * @returns {RpgMap}
   * @since 3.0.0-beta.4
   * @memberof SceneMap
   * @example
   * ```ts
   * sceneMap.createDynamicMap({
   *      id: 'myid',
   *      file: require('./tmx/mymap.tmx')
   * })
   * ```
   *
   * And later, on the player:
   *
   * ```ts
   * player.changeMap('myid')
   * ```
   *
   * ---
   *
   * since beta.8
   *
   * ```ts
   * sceneMap.createDynamicMap(require('./tmx/mymap.tmx')) // id is "mymap"
   * ```
   */
  createDynamicMap(mapData) {
    if (Utils_exports.isString(mapData)) {
      const id = Utils_exports.extractId(mapData);
      if (!id) {
        throw new Error("Unable to extract the file identifier. Check that the file has only the following characters: [a-zA-Z0-9-_$!]+");
      }
      mapData = {
        id: id[1],
        file: mapData
      };
    }
    if (isTiledFormat(mapData)) {
      const tiledData = mapData;
      mapData = {
        file: { ...tiledData }
      };
    }
    if (!mapData.id)
      mapData.id = Utils_exports.generateUID();
    if (!Utils_exports.isClass(mapData)) {
      let DynamicMap = class DynamicMap extends RpgMap {
      };
      DynamicMap = __decorate([
        MapData(mapData)
      ], DynamicMap);
      mapData = DynamicMap;
    }
    const map2 = mapData;
    this.mapsById[map2.id] = map2;
    return map2;
  }
  async changeMap(mapId, player, positions) {
    const boolArray = await RpgPlugin.emit(HookServer.PlayerCanChangeMap, [player, this.getMapBydId(mapId)], true);
    if (boolArray.some((el) => el === false)) {
      return null;
    }
    if (player.map === mapId) {
      await player.teleport(positions || "start");
      return null;
    }
    player.emit("preLoadScene", {
      id: mapId
    });
    player.prevMap = player.map;
    if (player.prevMap) {
      await player.execMethod("onLeaveMap", [player.getCurrentMap()]);
      World.leaveRoom(player.prevMap, player.id);
    }
    player.map = mapId;
    player.events = {};
    player.tmpPositions = positions;
    const scalabilityArray = await RpgPlugin.emit(HookServer.ScalabilityChangeServer, player);
    if (scalabilityArray.some((el) => el === true)) {
      return true;
    }
    player.tmpPositions = null;
    const mapInstance = await this.loadMap(mapId);
    if (!mapInstance)
      return null;
    if (!player.height)
      player.height = mapInstance.tileHeight;
    if (!player.width)
      player.width = mapInstance.tileWidth;
    if (!player.hitbox.h)
      player.hitbox.h = mapInstance.tileHeight;
    if (!player.hitbox.w)
      player.hitbox.w = mapInstance.tileWidth;
    player.emitSceneMap();
    if (!World.getRoom(mapId)) {
      return null;
    }
    player.teleport(positions || "start");
    World.joinRoom(mapId, player.id);
    player = World.getUser(player.id);
    if (player) {
      mapInstance.loadCommonEvents(this.server.inputOptions.events, player);
      player.createDynamicEvent(mapInstance._events, false);
      await player.execMethod("onJoinMap", [mapInstance]);
    }
    return mapInstance;
  }
};
SceneMap.id = "map";

// node_modules/@rpgjs/server/lib/Query.js
var { isString: isString7 } = Utils_exports;
var QueryClass = class {
  /**
   * Listen to the changes on all the rooms
   *
   * ```ts
   * import { RpgWorld } from '@rpgjs/server'
   * import { map } from 'rxjs/operators' // install rxjs
   *
   * RpgWorld.changes
   *  .pipe(
   *      map(rooms => rooms['mymap'])
   *  )
   *  .subscribe((room) => {
   *      const users: any = Object.values(room.users)
   *      console.log(users)
   *  })
   * ```
   *
   * @title Subscribe to the world
   * @prop {Observable} RpgWorld.changes
   * @memberof RpgWorld
   * */
  get changes() {
    return World.changes.asObservable();
  }
  /**
   * Retrieve a player according to his ID
   *
   * ```ts
   * import { RpgWorld } from '@rpgjs/server'
   *
   * const player = RpgWorld.getPlayer(player) // player is RpgPlayer (player.id) or string (id)
   * ```
   *
   * @title Get Player
   * @method RpgWorld.getPlayer(player)
   * @param {RpgPlayer | string} player identifier
   * @returns {RpgPlayer}
   * @memberof RpgWorld
   */
  getPlayer(player) {
    const id = isString7(player) ? player : "" + player.id;
    const _player = World.getUser(id);
    return _player;
  }
  /**
   * Recover all the players of the game
   *
   * ```ts
   * import { RpgWorld } from '@rpgjs/server'
   *
   * const players = RpgWorld.getPlayers()
   * ```
   *
   * @title Get all Players
   * @method RpgWorld.getPlayers()
   * @returns {Array<RpgPlayer>}
   * @memberof RpgWorld
   */
  getPlayers() {
    const users = World.getUsers();
    const array = Object.values(users);
    return array.map((user) => this.getPlayer(user));
  }
  /**
   * Recover all map objects: players and events. If you specify the `player` parameter, it also retrieves the events in scenario mode of the player in question
   *
   * ```ts
   * import { RpgWorld } from '@rpgjs/server'
   *
   * const objects = RpgWorld.getObjectsOfMap('mapname')
   * console.log(objects)
   * ```
   *
   * Also retrieve events in Scenario mode:
   *
   * ```ts
   * import { RpgWorld } from '@rpgjs/server'
   *
   * const objects = RpgWorld.getObjectsOfMap('mapname', 'playerid')
   * ```
   *
   * @title Get all objects of map
   * @method RpgWorld.getObjectsOfMap(map,playerId?)
   * @param {string} map Map Name
   * @param {RpgPlayer | string} playerId player identifier
   * @returns {Array<RpgPlayer>}
   * @memberof RpgWorld
   */
  getObjectsOfMap(map2, playerId) {
    return Object.values(this._getObjectsOfMap(map2, playerId));
  }
  _getObjectsOfMap(map2, playerId) {
    const room = World.getRoom(map2);
    let player = null;
    if (playerId) {
      player = this.getPlayer(playerId);
    }
    return {
      ...room.users,
      ...room.events,
      ...player ? player.events : {}
    };
  }
  /**
   * Find all the shapes of the map
   *
   * ```ts
   * import { RpgWorld } from '@rpgjs/server'
   *
   * const shapes = RpgWorld.getShapesOfMap('mapname')
   * console.log(shapes)
   * ```
   *
   * @title Get all shapes of map
   * @method RpgWorld.getShapesOfMap(map)
   * @param {string} map Map Name
   * @returns {Array<RpgShape>}
   * @memberof RpgWorld
   */
  getShapesOfMap(map2) {
    return Object.values(this._getShapesOfMap(map2));
  }
  _getShapesOfMap(map2) {
    const room = World.getRoom(map2);
    return room.shapes;
  }
  // TODO
  getRooms() {
    return World.getRooms();
  }
  getRoom(name) {
    return World.getRoom(name);
  }
  /**
   * Recover all the players of a map
   *
   * ```ts
   * import { RpgWorld } from '@rpgjs/server'
   *
   * const players = RpgWorld.getPlayersOfMap('mapname')
   * ```
   *
   * @title Get all Players a map
   * @method RpgWorld.getPlayersOfMap(map)
   * @param {string} map Map Name
   * @returns {Array<RpgPlayer>}
   * @memberof RpgWorld
   */
  getPlayersOfMap(map2) {
    const room = World.getRoom(map2);
    return Object.values(room.users);
  }
};
var Query = new QueryClass();

// node_modules/@rpgjs/server/lib/server.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RpgServerEngine = class {
  constructor() {
    this.database = {};
    this.globalConfig = {};
    this.damageFormulas = {};
    this.serverId = process.env.SERVER_ID || Utils_exports.generateUID();
    this.scenes = /* @__PURE__ */ new Map();
    this.totalConnected = 0;
    this.scheduler = new Scheduler();
    this.gameEngine = inject(RpgCommonGame);
    this.world = World;
    this.envs = {};
    this.inputOptions = {};
  }
  /**
   * Combat formulas
   *
   * @prop {Socket Io Server} [io]
   * @memberof RpgServerEngine
   */
  initialize(io, inputOptions) {
    this.io = io;
    this.inputOptions = inputOptions;
    this.envs = inputOptions.envs || {};
    if (this.inputOptions.workers) {
      console.log("workers enabled");
      this.workers = this.gameEngine.createWorkers(this.inputOptions.workers).load();
    }
  }
  async _init() {
    this.damageFormulas = this.inputOptions.damageFormulas || {};
    this.damageFormulas = {
      damageSkill: DAMAGE_SKILL,
      damagePhysic: DAMAGE_PHYSIC,
      damageCritical: DAMAGE_CRITICAL,
      coefficientElements: COEFFICIENT_ELEMENTS,
      ...this.damageFormulas
    };
    this.globalConfig = this.inputOptions.globalConfig;
    if (!this.inputOptions.maps)
      this.inputOptions.maps = [];
    if (!this.inputOptions.events)
      this.inputOptions.events = [];
    if (!this.inputOptions.worldMaps)
      this.inputOptions.worldMaps = [];
    this.playerProps = this.inputOptions.playerProps;
    this.inputOptions.maps = [
      ...Utils_exports.arrayFlat(await RpgPlugin.emit(HookServer.AddMap, this.inputOptions.maps)) || [],
      ...this.inputOptions.maps
    ];
    this.inputOptions.events = [
      ...Utils_exports.arrayFlat(await RpgPlugin.emit(HookServer.AddEvent, this.inputOptions.events)) || [],
      ...this.inputOptions.events
    ];
    this.inputOptions.worldMaps = [
      ...Utils_exports.arrayFlat(await RpgPlugin.emit(HookServer.AddWorldMaps, this.inputOptions.worldMaps)) || [],
      ...this.inputOptions.worldMaps
    ];
    this.globalConfig.inputs = {
      ...DefaultInput,
      ...this.globalConfig.inputs || {}
    };
    if (!this.inputOptions.database)
      this.inputOptions.database = {};
    const datas = await RpgPlugin.emit(HookServer.AddDatabase, this.inputOptions.database) || [];
    for (let element of datas) {
      if (Array.isArray(element)) {
        for (let data of element) {
          this.addInDatabase(data.id, data);
        }
      } else {
        for (let id in element) {
          this.addInDatabase(element[id].id ?? id, element[id]);
        }
      }
    }
    this.loadScenes();
  }
  /**
   * Adds data to the server's database (in RAM) for later use
   *
   *
   * @method server.addInDatabase(id,data)
   * @title Add in database
   * @param {number} id resource id
   * @param {class | object} dataClass A class representing the data. You can just add a object if you specify the type
   * @enum {string} [type] The type of data
   *
   * item
   * weapon
   * armor
   * skill
   * class
   * state
   * actor
   * @since 3.0.0-beta.4
   * @example
   * ```ts
   * @Item({
   *      name: 'Potion',
   *      description: 'Gives 100 HP',
   * })
   * class MyItem() {}
   *
   * server.addInDatabase('dynamic_item', MyItem)
   * ```
   *
   * or with an object
   *
   * ```ts
   * server.addInDatabase('dynamic_item', {
   *      name: 'Potion',
   *      description: 'Gives 100 HP',
   * }, 'item')
   * ```
   *
   * @returns {void}
   * @memberof RpgServerEngine
   */
  addInDatabase(id, dataClass, type) {
    if (Utils_exports.isClass(dataClass)) {
      this.database[id] = dataClass;
      return;
    }
    if (!type) {
      throw new Error(`You must specify a type for the database ${id}`);
    }
    switch (type) {
      case "item":
        let ItemClass = class ItemClass {
        };
        ItemClass = __decorate2([
          Item(dataClass)
        ], ItemClass);
        this.database[id] = ItemClass;
        break;
      case "weapon":
        let WeaponClass = class WeaponClass {
        };
        WeaponClass = __decorate2([
          Weapon(dataClass)
        ], WeaponClass);
        this.database[id] = WeaponClass;
        break;
      case "armor":
        let ArmorClass = class ArmorClass {
        };
        ArmorClass = __decorate2([
          Armor(dataClass)
        ], ArmorClass);
        this.database[id] = ArmorClass;
        break;
      case "skill":
        let SkillClass = class SkillClass {
        };
        SkillClass = __decorate2([
          Skill(dataClass)
        ], SkillClass);
        this.database[id] = SkillClass;
        break;
      case "class":
        let ClassClass = class ClassClass {
        };
        ClassClass = __decorate2([
          Class(dataClass)
        ], ClassClass);
        this.database[id] = ClassClass;
        break;
      case "state":
        let StateClass = class StateClass {
        };
        StateClass = __decorate2([
          State(dataClass)
        ], StateClass);
        this.database[id] = StateClass;
        break;
      case "actor":
        let ActorClass = class ActorClass {
        };
        ActorClass = __decorate2([
          Actor(dataClass)
        ], ActorClass);
        this.database[id] = ActorClass;
        break;
    }
  }
  /**
  * Start the RPG server
  *
  * @method server.start()
  * @title Start Server
  * @returns {void}
  * @memberof RpgServerEngine
  */
  async start(inputOptions, scheduler = true) {
    if (inputOptions)
      this.inputOptions = inputOptions;
    await this._init();
    this.tick.subscribe(({ timestamp: timestamp2, deltaTime }) => {
      this.step(timestamp2, deltaTime);
    });
    if (scheduler)
      this.scheduler.start({
        fps: (inputOptions == null ? void 0 : inputOptions.fps) || 60
      });
    this.gameEngine.start({
      getObject(id) {
        return Query.getPlayer(id);
      },
      getObjectsOfGroup(groupId, player) {
        return Query._getObjectsOfMap(groupId, player);
      },
      getShapesOfGroup(map2) {
        return Query._getShapesOfMap(map2);
      }
    });
    this.transport(this.io);
    await RpgPlugin.emit(HookServer.Start, this);
  }
  transport(io) {
    const timeoutDisconnect = this.globalConfig.timeoutDisconnect ?? 0;
    const auth = this.globalConfig.disableAuth ? () => Utils_exports.generateUID() : async (socket) => {
      const val = await RpgPlugin.emit(HookServer.Auth, [this, socket], true);
      if (val.length == 0) {
        return Utils_exports.generateUID();
      }
      return val[val.length - 1];
    };
    const transport = new Transport(io, {
      timeoutDisconnect,
      auth
    });
    this.world.timeoutDisconnect = timeoutDisconnect;
    transport.onConnected(this.onPlayerConnected.bind(this));
    transport.onDisconnected(this.onPlayerDisconnected.bind(this));
    return transport;
  }
  get tick() {
    return this.scheduler.tick;
  }
  /**
   * Sends all packages to clients. The sending is done automatically but you can decide to send yourself by calling this method (for example, for unit tests)
   *
   * @method server.send()
   * @title Send All Packets
   * @returns {void}
   * @memberof RpgServerEngine
   */
  send() {
    return this.world.send();
  }
  async updatePlayersMove(deltaTimeInt) {
    const players = this.world.getUsers();
    const obj = [];
    let p = [];
    for (let playerId in players) {
      const playerInstance = players[playerId]["proxy"];
      if (!playerInstance)
        continue;
      const player = playerInstance.otherPossessedPlayer ?? playerInstance;
      if (player.pendingMove.length > 0) {
        const lastFrame = player.pendingMove[player.pendingMove.length - 1];
        if (this.inputOptions.workers)
          obj.push(player.toObject());
        else {
          p.push(this.gameEngine.processInput(player.playerId, this.globalConfig.inputs).then((val) => {
            player.pendingMove = [];
            player.moving = false;
            player._lastFramePositions = {
              frame: lastFrame.frame,
              position: { ...player.position }
            };
            return player;
          }));
        }
      }
    }
    if (this.inputOptions.workers) {
      this.workers.call("movePlayers", obj).then((players2) => {
        for (let playerId in players2) {
          const player = this.world.getUser(playerId);
          const data = players2[playerId];
          if (player) {
            player.position = data.position;
            player.direction = data.direction;
          }
          RpgPlugin.emit("Server.onInput", [player, {
            input: data.direction,
            moving: true
          }], true);
        }
      });
    }
    return Promise.all(p);
  }
  nextTick(timestamp2) {
    this.scheduler.nextTick(timestamp2);
  }
  step(t, dt) {
    this.updatePlayersMove(1);
    if (this.scheduler.frame % 4 === 0) {
      this.send();
    }
    RpgPlugin.emit(HookServer.Step, this);
  }
  loadScenes() {
    this.scenes.set(SceneMap.id, new SceneMap({
      maps: this.inputOptions.maps,
      events: this.inputOptions.events,
      worldMaps: this.inputOptions.worldMaps
    }));
  }
  getScene(name) {
    return this.scenes.get(name);
  }
  /**
   * Return the scene that manages the maps of the game
   * @prop {SceneMap} [sceneMap]
   * @since 3.0.0-beta.4
   * @memberof RpgServerEngine
   */
  get sceneMap() {
    return this.getScene(SceneMap.id);
  }
  get module() {
    return RpgPlugin;
  }
  get assetsPath() {
    var _a;
    return ((_a = this.envs) == null ? void 0 : _a["VITE_ASSETS_PATH"]) || "assets";
  }
  sendToPlayer(currentPlayer, eventName, data) {
    currentPlayer._socket.emit(eventName, data);
  }
  getPlayerBySession(session) {
    const users = this.world.getUsers();
    for (let userId in users) {
      const user = users[userId];
      if (user.session === session) {
        return user;
      }
    }
    return null;
  }
  onPlayerConnected(socket, playerId) {
    const existingUser = this.world.getUser(playerId, false);
    this.world.connectUser(socket, playerId);
    let player;
    if (!existingUser) {
      const { token } = socket.handshake.auth;
      player = new RpgPlayer(playerId);
      player.session = token;
      this.world.setUser(player, socket);
      player._init();
      if (!token) {
        const newToken = Utils_exports.generateUID() + "-" + Utils_exports.generateUID() + "-" + Utils_exports.generateUID();
        player.session = newToken;
      }
      if (!token) {
        player.execMethod("onConnected");
      } else {
        RpgPlugin.emit(HookServer.ScalabilityPlayerConnected, player);
      }
    } else {
      player = existingUser;
      if (player.map) {
        player.emit("preLoadScene", {
          reconnect: true,
          id: player.map
        });
        player.emitSceneMap();
        this.world.joinRoom(player.map, playerId);
      }
    }
    socket.emit("playerJoined", { playerId, session: player.session });
    socket.on("move", (data) => {
      if (!(data == null ? void 0 : data.input))
        return;
      if (!Array.isArray(data.input))
        return;
      const controlPlayer = player.otherPossessedPlayer ?? player;
      if (!controlPlayer.canMove) {
        return;
      }
      for (let input of data.input) {
        controlPlayer.pendingMove.push({
          input,
          frame: data.frame
        });
      }
    });
  }
  onPlayerDisconnected(playerId) {
    const player = World.getUser(playerId);
    player.execMethod("onDisconnected");
    this.world.disconnectUser(playerId);
  }
  stop() {
    this.scheduler.stop();
  }
};

// node_modules/@rpgjs/server/lib/MatchMaker.js
var RpgMatchMaker = class {
  constructor(options) {
    this.options = options;
    this.endpoint = options.endpoint;
    this.headers = options.headers;
    this.callback = options.callback;
  }
  async getServer(player) {
    const currentServerId = inject(RpgServerEngine).serverId;
    const payload = {
      playerId: player.id,
      mapName: player.map
    };
    let res = {};
    if (this.callback) {
      res = this.callback(payload);
      if (Utils_exports.isPromise(res)) {
        res = await res;
      }
    }
    if (this.endpoint) {
      try {
        res = await axios_default.post(this.endpoint, payload, {
          headers: this.headers
        }).then((res2) => res2.data);
      } catch (err) {
        console.log("There is a problem with the MatchMaker webservice.");
        throw err;
      }
    }
    if (currentServerId == res.serverId) {
      return null;
    }
    return res;
  }
};

// node_modules/@rpgjs/server/lib/entry-point.js
async function entry_point_default(modules, options) {
  const context2 = new InjectContext();
  setInject(context2);
  inject(RpgCommonGame, [GameSide.Server]);
  if (!options.globalConfig)
    options.globalConfig = {};
  const relations = {
    onConnected: HookServer.PlayerConnected,
    onInput: HookServer.PlayerInput,
    onJoinMap: HookServer.PlayerJoinMap,
    onLeaveMap: HookServer.PlayerLeaveMap,
    onLevelUp: HookServer.PlayerLevelUp,
    onDead: HookServer.PlayerDead,
    onDisconnected: HookServer.PlayerDisconnected,
    onInShape: HookServer.PlayerInShape,
    onOutShape: HookServer.PlayerOutShape,
    onMove: HookServer.PlayerMove,
    canChangeMap: HookServer.PlayerCanChangeMap
  };
  const relationsEngine = {
    onStart: HookServer.Start,
    onStep: HookServer.Step,
    auth: HookServer.Auth
  };
  const { playerProps } = await loadModules(modules, {
    side: "server",
    relations: {
      player: relations,
      engine: relationsEngine,
      scalability: {
        onConnected: HookServer.ScalabilityPlayerConnected,
        doChangeServer: HookServer.ScalabilityChangeServer
      }
    }
  }, (mod) => {
    const { scalability } = mod;
    if (scalability) {
      const { hooks, stateStore, matchMaker } = scalability;
      const matchMakerInstance = new RpgMatchMaker(matchMaker);
      RpgPlugin.on(HookServer.Start, () => {
        return stateStore.connect();
      });
      mod.scalability._hooks = {};
      for (let hookName in hooks) {
        let originalHook = mod.scalability.hooks[hookName];
        mod.scalability._hooks[hookName] = function(player) {
          return originalHook(stateStore, matchMakerInstance, player);
        };
      }
    }
    return mod;
  });
  const serverEngine = inject(RpgServerEngine, [
    options.io,
    {
      debug: {},
      updateRate: 10,
      stepRate: 60,
      timeoutInterval: 0,
      countConnections: false,
      playerProps,
      ...options
    }
  ]);
  return serverEngine;
}

// node_modules/@rpgjs/server/lib/Monitor/index.js
var Monitor = class extends EventEmitter {
  constructor() {
    super(...arguments);
    this.monitors = /* @__PURE__ */ new Map();
    this.totalConnected = 0;
  }
  get status() {
    return {
      loop: this.loopMs,
      totalConnected: this.totalConnected
    };
  }
  getStatusOf(id) {
    return this.monitors.get(id);
  }
  update(server) {
    const { scheduler, options } = server;
    if (this.lastTime) {
      const hrtime = process.hrtime(this.lastTime);
      this.loopMs = hrtime[1] / 1e6;
    }
    const period = scheduler.options.period;
    if (this.loopMs > period + 20) {
      const { stepRate } = options;
      console.warn("%s - Warning Low FPS. %s players connected. Game Loop: %s FPS", /* @__PURE__ */ new Date(), this.totalConnected, Math.round(stepRate / (this.loopMs / period)));
    }
    this.lastTime = process.hrtime();
  }
  addMonitor(socket) {
    this.totalConnected++;
  }
  removeMonitor(id) {
    this.monitors.delete(id);
    this.totalConnected--;
  }
};
var Monitor_default = new Monitor();

export {
  mock_socket_default,
  presets_exports,
  Gui,
  Frequency,
  Speed,
  Move,
  Components,
  EventMode,
  inject,
  RpgPlayer,
  RpgEvent,
  MapData,
  EventData,
  RpgMap,
  RpgWorldMaps,
  SceneMap,
  Query,
  RpgServerEngine,
  RpgMatchMaker,
  entry_point_default,
  Monitor_default
};
//# sourceMappingURL=chunk-XB3CBZHP.js.map
