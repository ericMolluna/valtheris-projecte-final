{
  "version": 3,
  "sources": ["../../lodash.merge/index.js", "../../simple-room/src/utils.ts", "../../simple-room/src/packet.ts", "../../simple-room/src/transmitter.ts", "../../simple-room/src/rooms/default.ts", "../../simple-room/src/errors/error.ts", "../../simple-room/src/errors/not-authorized.ts", "../../simple-room/src/room.ts", "../../simple-room/src/transports/common.ts", "../../simple-room/node_modules/rxjs/src/internal/util/isFunction.ts", "../../simple-room/node_modules/rxjs/src/internal/util/createErrorClass.ts", "../../simple-room/node_modules/rxjs/src/internal/util/UnsubscriptionError.ts", "../../simple-room/node_modules/rxjs/src/internal/util/arrRemove.ts", "../../simple-room/node_modules/rxjs/src/internal/Subscription.ts", "../../simple-room/node_modules/rxjs/src/internal/config.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/timeoutProvider.ts", "../../simple-room/node_modules/rxjs/src/internal/util/reportUnhandledError.ts", "../../simple-room/node_modules/rxjs/src/internal/util/noop.ts", "../../simple-room/node_modules/rxjs/src/internal/NotificationFactories.ts", "../../simple-room/node_modules/rxjs/src/internal/util/errorContext.ts", "../../simple-room/node_modules/rxjs/src/internal/Subscriber.ts", "../../simple-room/node_modules/rxjs/src/internal/symbol/observable.ts", "../../simple-room/node_modules/rxjs/src/internal/util/identity.ts", "../../simple-room/node_modules/rxjs/src/internal/util/pipe.ts", "../../simple-room/node_modules/rxjs/src/internal/Observable.ts", "../../simple-room/node_modules/rxjs/src/internal/util/lift.ts", "../../simple-room/node_modules/rxjs/src/internal/operators/OperatorSubscriber.ts", "../../simple-room/node_modules/rxjs/src/internal/operators/refCount.ts", "../../simple-room/node_modules/rxjs/src/internal/observable/ConnectableObservable.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/performanceTimestampProvider.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/animationFrameProvider.ts", "../../simple-room/node_modules/rxjs/src/internal/observable/dom/animationFrames.ts", "../../simple-room/node_modules/rxjs/src/internal/util/ObjectUnsubscribedError.ts", "../../simple-room/node_modules/rxjs/src/internal/Subject.ts", "../../simple-room/node_modules/rxjs/src/internal/BehaviorSubject.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/dateTimestampProvider.ts", "../../simple-room/node_modules/rxjs/src/internal/ReplaySubject.ts", "../../simple-room/node_modules/rxjs/src/internal/AsyncSubject.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/Action.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/intervalProvider.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/AsyncAction.ts", "../../simple-room/node_modules/rxjs/src/internal/util/Immediate.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/immediateProvider.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/AsapAction.ts", "../../simple-room/node_modules/rxjs/src/internal/Scheduler.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/AsyncScheduler.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/AsapScheduler.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/asap.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/async.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/QueueAction.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/QueueScheduler.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/queue.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/AnimationFrameAction.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/AnimationFrameScheduler.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/animationFrame.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduler/VirtualTimeScheduler.ts", "../../simple-room/node_modules/rxjs/src/internal/observable/empty.ts", "../../simple-room/node_modules/rxjs/src/internal/util/isScheduler.ts", "../../simple-room/node_modules/rxjs/src/internal/util/args.ts", "../../simple-room/node_modules/rxjs/src/internal/util/isArrayLike.ts", "../../simple-room/node_modules/rxjs/src/internal/util/isPromise.ts", "../../simple-room/node_modules/rxjs/src/internal/util/isInteropObservable.ts", "../../simple-room/node_modules/rxjs/src/internal/util/isAsyncIterable.ts", "../../simple-room/node_modules/rxjs/src/internal/util/throwUnobservableError.ts", "../../simple-room/node_modules/rxjs/src/internal/symbol/iterator.ts", "../../simple-room/node_modules/rxjs/src/internal/util/isIterable.ts", "../../simple-room/node_modules/rxjs/src/internal/util/isReadableStreamLike.ts", "../../simple-room/node_modules/rxjs/src/internal/observable/innerFrom.ts", "../../simple-room/node_modules/rxjs/src/internal/util/executeSchedule.ts", "../../simple-room/node_modules/rxjs/src/internal/operators/observeOn.ts", "../../simple-room/node_modules/rxjs/src/internal/operators/subscribeOn.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduled/scheduleObservable.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduled/schedulePromise.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduled/scheduleArray.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduled/scheduleIterable.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduled/scheduleAsyncIterable.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduled/scheduleReadableStreamLike.ts", "../../simple-room/node_modules/rxjs/src/internal/scheduled/scheduled.ts", "../../simple-room/node_modules/rxjs/src/internal/observable/from.ts", "../../simple-room/node_modules/rxjs/src/internal/observable/of.ts", "../../simple-room/node_modules/rxjs/src/internal/observable/throwError.ts", "../../simple-room/node_modules/rxjs/src/internal/Notification.ts", "../../simple-room/node_modules/rxjs/src/internal/util/EmptyError.ts", "../../simple-room/node_modules/rxjs/src/internal/util/ArgumentOutOfRangeError.ts", "../../simple-room/node_modules/rxjs/src/internal/util/NotFoundError.ts", "../../simple-room/node_modules/rxjs/src/internal/util/SequenceError.ts", "../../simple-room/node_modules/rxjs/src/internal/operators/timeout.ts", "../../simple-room/node_modules/rxjs/src/internal/util/mapOneOrManyArgs.ts", "../../simple-room/node_modules/rxjs/src/internal/util/argsArgArrayOrObject.ts", "../../simple-room/node_modules/rxjs/src/internal/observable/never.ts", "../../simple-room/node_modules/rxjs/src/internal/util/argsOrArgArray.ts", "../../simple-room/node_modules/rxjs/src/internal/operators/timeInterval.ts", "../../simple-room/src/transports/socket.ts", "../../simple-room/src/world.ts", "../../simple-room/src/user.ts", "../../simple-room/src/testing/mock-socket.ts", "../../@rpgjs/server/src/Player/Player.ts", "../../@rpgjs/database/src/common.ts", "../../@rpgjs/database/src/item.ts", "../../@rpgjs/database/src/actor.ts", "../../@rpgjs/database/src/class.ts", "../../@rpgjs/database/src/skill.ts", "../../@rpgjs/database/src/state.ts", "../../@rpgjs/database/src/weapon.ts", "../../@rpgjs/database/src/armor.ts", "../../@rpgjs/database/src/effect.ts", "../../@rpgjs/database/src/interfaces/efficiency.ts", "../../@rpgjs/server/src/logs/log.ts", "../../@rpgjs/server/src/logs/item.ts", "../../@rpgjs/server/src/logs/skill.ts", "../../@rpgjs/server/src/logs/state.ts", "../../@rpgjs/server/src/presets/index.ts", "../../@rpgjs/server/src/Player/ParameterManager.ts", "../../@rpgjs/server/src/Player/EffectManager.ts", "../../@rpgjs/server/src/Player/GoldManager.ts", "../../@rpgjs/server/src/Player/ItemFixture.ts", "../../@rpgjs/server/src/Player/StateManager.ts", "../../@rpgjs/server/src/Player/ItemManager.ts", "../../@rpgjs/server/src/Player/SkillManager.ts", "../../@rpgjs/server/src/Player/ClassManager.ts", "../../@rpgjs/server/src/Player/ElementManager.ts", "../../@rpgjs/server/src/Gui/Gui.ts", "../../@rpgjs/server/src/Player/MoveManager.ts", "../../@rpgjs/server/src/Gui/DialogGui.ts", "../../@rpgjs/server/src/Gui/MenuGui.ts", "../../@rpgjs/server/src/Gui/ShopGui.ts", "../../@rpgjs/server/src/Gui/NotificationGui.ts", "../../@rpgjs/server/src/Player/GuiManager.ts", "../../@rpgjs/server/src/Player/VariableManager.ts", "../../@rpgjs/server/src/Player/BattleManager.ts", "../../@rpgjs/server/src/Player/ComponentManager.ts", "../../@rpgjs/server/src/Game/EventManager.ts", "../../@rpgjs/server/src/inject.ts", "../../@rpgjs/server/src/decorators/map.ts", "../../@rpgjs/server/src/decorators/event.ts", "../../@rpgjs/server/src/Game/Map.ts", "../../@rpgjs/server/src/Game/WorldMaps.ts", "../../@rpgjs/server/src/Scenes/Map.ts", "../../@rpgjs/server/src/Query.ts", "../../@rpgjs/server/src/server.ts", "../../@rpgjs/server/src/MatchMaker.ts", "../../@rpgjs/server/src/entry-point.ts", "../../@rpgjs/server/src/Monitor/index.ts"],
  "sourcesContent": ["/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeMax = Math.max,\n    nativeNow = Date.now;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */\nvar merge = createAssigner(function(object, source, srcIndex) {\n  baseMerge(object, source, srcIndex);\n});\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = merge;\n", "import { Room } from \"./room\";\n\nexport const GENERIC_KEY_SCHEMA = '@'\n\nexport class Utils {\n    static isObject(val) {\n        return typeof val === 'object' && !Array.isArray(val) && val != null\n    }\n\n    static propertiesToArray(obj: any) {\n        const addDelimiter = (a, b) =>\n            a ? `${a}.${b}` : b;\n\n        const paths = (obj = {}, head = '') => {\n            return Object.entries(obj)\n                .reduce((product, array) => {\n                    const [key] = array\n                    const value: any = array[1]\n                    const extraProp = Room.hasExtraProp(value)\n                    let fullPath = addDelimiter(head, key == '0' ? GENERIC_KEY_SCHEMA : key)\n                    if (extraProp) {\n                        if (value.$syncWithClient === false) {\n                            return product\n                        }\n                    }\n                    if (key[0] != '_' && !extraProp && (Utils.isObject(value) || Array.isArray(value))) {\n                        if (Object.keys(value).length == 0) {\n                            return product.concat(fullPath)\n                        }\n                        return product.concat(paths(value, fullPath))\n                    }\n                    else {\n                        return product.concat(fullPath)\n                    }\n                }, []);\n        }\n        return paths(obj);\n    }\n\n    static generateId(n: number = 5) {\n        return Math.random().toString(36).substring(n)\n    }\n\n    static async resolveValue(value) {\n        if (value instanceof Promise) {\n            return await value\n        }\n        return value\n    }\n\n    static set(obj, path, value, onlyPlainObject = false) {\n        if (Object(obj) !== obj) return obj;\n\n        if (typeof path === 'string') {\n            path = path.split('.');\n        }\n\n        let len = path.length;\n        if (!len) return obj;\n\n        let current = obj;\n        for (let i = 0; i < len - 1; i++) {\n            let segment = path[i];\n            let nextSegment = path[i + 1];\n            let isNextNumeric = !isNaN(nextSegment) && isFinite(nextSegment);\n\n            if (!current[segment] || typeof current[segment] !== 'object') {\n                current[segment] = (isNextNumeric && !onlyPlainObject) ? [] : {};\n            }\n\n            current = current[segment];\n        }\n\n        current[path[len - 1]] = value;\n\n        return obj;\n    }\n\n    static get(obj, path) {\n        const keys = path.split('.');\n        let current = obj;\n\n        for (let key of keys) {\n            if (current[key] === undefined) {\n                return undefined;\n            }\n            current = current[key];\n        }\n\n        return current;\n    }\n\n    static bufferFrom(input: string | ArrayBuffer | ArrayBufferView): Uint8Array {\n        if (typeof input === 'string') {\n            // If the input is a string, convert it to an ArrayBuffer\n            let encoder = new TextEncoder();\n            return encoder.encode(input);\n        } else if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {\n            // If the input is an ArrayBuffer or a view of it, return it as Uint8Array\n            return new Uint8Array(input as ArrayBuffer);\n        } else {\n            // Extend this function for other types of inputs as needed\n            throw new Error('Input type not supported');\n        }\n    }\n}", "import msgpack from 'msgpack-lite'\n\n\nexport type MessageBuffer = [string, number, any]\n\nexport class Packet {\n    constructor(private data: any, private roomId: string) { }\n\n    get body() {\n        return this.data\n    }\n\n    message(otherData?): MessageBuffer {\n        return [this.roomId, Date.now(), otherData ?? this.data]\n    }\n\n    clone(data) {\n        return new Packet(data, this.roomId)\n    }\n\n    encode(otherData?) {\n        return msgpack.encode(this.message(otherData))\n    }\n}", "import { Packet } from './packet'\nimport { RoomClass } from './interfaces/room.interface';\nimport { User } from './rooms/default';\nimport { CustomError } from './errors/error';\nimport { Utils } from './utils'\n\nconst { get, set } = Utils\n\nclass TransmitterClass {\n\n    public encode: boolean = true\n\n    private packets: {\n        [roomId: string]: Packet[]\n    } = {}\n\n    addPacket(room: RoomClass, obj: Object): void {\n        const { id } = room\n        if (!id) return\n        if (!this.packets[id]) this.packets[id] = []\n        this.packets[id].push(new Packet(obj, id))\n    }\n\n    forEach(cb: (packet: Packet[], roomId: string) => void): void {\n        for (let roomId in this.packets) {\n            cb(this.packets[roomId], roomId)\n        }\n    }\n\n    getPackets(room: RoomClass): Packet[] | undefined {\n        if (!room.id) return\n        return this.packets[room.id]\n    }\n\n    clear(room?: RoomClass): void {\n        if (room && room.id) {\n            this.packets[room.id] = []\n        }\n        else {\n            this.packets = {}\n        }\n    }\n\n    error(user: User, error: CustomError | string): void {\n        const err =  error instanceof Error ? error.toObject ? error.toObject() : error.message : error\n        user._socket.emit('error', err)\n    }\n\n    async emit(user: User, packet: Packet, room: RoomClass): Promise<void> {\n        let data = packet.body\n        if (room.$additionalEmitProperties) {\n            let additionalData = await Utils.resolveValue(room.$additionalEmitProperties(user, packet.body))\n            if (additionalData !== undefined) {\n                if (typeof additionalData === 'string') {\n                    additionalData = [additionalData]\n                }\n                if (Array.isArray(additionalData)){\n                    const newData = structuredClone(data)\n                    for (let path of additionalData) {\n                        set(newData, path, get(room, path))\n                    }\n                    data = newData\n                }\n                else {\n                    data = { ...data, ...additionalData }\n                }\n            }       \n        }\n        user._socket.emit('w', this.encode ? packet.encode(data) : packet.message(data))\n    }\n}\n\nexport const Transmitter = new TransmitterClass()", "export enum UserState {\n    Connected = 'C',\n    Disconnected = 'D'\n}\n\nexport class User {\n    static schema = {\n        $state: String\n    }\n    id: string\n    $state: UserState = UserState.Connected\n    _socket\n    _secretSessionId: string = ''\n    _rooms: any[] = []\n    _timeoutDisconnect: any\n}\n\nexport class DefaultRoom  {\n   $schema = {\n        users: [User.schema]\n   }\n   users = {}\n}", "export class CustomError extends Error {\n    status = 500;\n    code = 'INTERNAL_SERVER_ERROR'\n    message: string = \"Internal Server error\";\n\n    constructor(private customMessage: any) {\n        super(customMessage);\n    }\n\n    toObject() {\n        return {\n            message: this.customMessage || this.message,\n            status: this.status,\n            code: this.code\n        }\n    }\n}", "import { CustomError } from \"./error\";\n\nexport class NotAuthorized extends CustomError {\n    status = 401;\n    code = 'NOT_AUTHORIZED';\n    message: string = \"Not authorized\";\n\n    constructor(customMessage: any) {\n        super(customMessage);\n    }\n}", "import { Utils, GENERIC_KEY_SCHEMA } from './utils'\nimport { Transmitter } from './transmitter'\nimport { Packet } from './packet'\nimport { RoomClass } from './interfaces/room.interface';\nimport { User, UserState } from './rooms/default'\nimport { World } from './world'\nimport { NotAuthorized } from './errors/not-authorized';\n\nconst { set, get } = Utils\n\nexport interface RoomOptions {\n    /**\n     * If true, the old room will be propagated to the new room when the user changes rooms\n     * @default true\n     * @type {boolean}\n     * @memberof RoomOptions\n     * @since 3.1.0\n     */\n    propagateOldRoom?: boolean\n}\n\nexport class Room {\n    private proxyRoom: RoomClass\n    private memoryTotalObject: object = {}\n    private memoryObject: object = {}\n    private permanentObject: string[] = []\n    private propagateOldRoom: boolean = true\n\n    static readonly propNameUsers: string = 'users'\n\n    static hasExtraProp(obj: any) {\n        return obj.$default !== undefined ||\n            obj.$syncWithClient !== undefined ||\n            obj.$permanent !== undefined ||\n            obj.$validate !== undefined ||\n            obj.$effects !== undefined ||\n            obj.$type !== undefined\n    }\n\n    static compileSchema(schema, room?): { masks: object, dict: object, permanentObject: string[] } {\n        const dict = {}\n        const masks = {}\n        const permanentObject: string[] = []\n\n        function specialObject(val, p) {\n            if (Room.hasExtraProp(val)) {\n                if (val.$permanent ?? true) permanentObject.push(p)\n                if (room && val.$default !== undefined) {\n                    // TODO\n                    //set(room, p, val.$default)\n                }\n                if (val.$syncWithClient === false) {\n                    return\n                }\n                // Force to take a type (number here - not important) and not object. Otherwise, Proxy will traverse this object from \n                dict[p] = {\n                    ...val\n                }\n            }\n            else {\n                dict[p] = val\n                masks[p] = Utils.propertiesToArray(val)\n                compile(val, p)\n            }\n        }\n\n        function compile(schema, path = '') {\n            for (let prop in schema) {\n                const val = schema[prop]\n                let p = (path ? path + '.' : '') + prop\n                if (Array.isArray(val)) {\n                    dict[p] = GENERIC_KEY_SCHEMA\n                    p += '.' + GENERIC_KEY_SCHEMA\n                    if (val[0] === undefined) val[0] = {}\n                    if (Utils.isObject(val[0])) {\n                        specialObject(val[0], p)\n                    }\n                    else {\n                        dict[p] = val[0]\n                        compile(val[0], p)\n                    }\n                }\n                else if (Utils.isObject(val)) {\n                    specialObject(val, p)\n                }\n                else {\n                    permanentObject.push(p)\n                    dict[p] = val\n                }\n            }\n        }\n\n        compile(schema)\n\n        return {\n            masks,\n            dict,\n            permanentObject\n        }\n    }\n\n    constructor(private options: RoomOptions) {\n        if (options.propagateOldRoom) {\n            this.propagateOldRoom = options.propagateOldRoom\n        }\n    }\n\n    private async join(user: User, room: RoomClass): Promise<boolean> {\n        if (room['canJoin']) {\n            const authBool = await Utils.resolveValue(room['canJoin'](user, user._socket))\n            if (authBool === false || typeof authBool == 'string') {\n                Transmitter.error(user, new NotAuthorized(authBool))\n                return false\n            }\n        }\n\n        if (World.agonesSDK) {\n            await World.agonesSDK.allocate()\n        }\n\n        let firstJoin = !room.users[user.id]\n\n        room.users[user.id] = user\n\n        const userProxy = World.users[user.id]['proxy']\n        userProxy.$state = UserState.Connected\n\n        if (firstJoin) {\n            if (room['onJoin']) await Utils.resolveValue(room['onJoin'](userProxy))\n        }\n\n        if (this.getUsersLength(room) == 1) {\n            // If it's the first to arrive in the room, we save the default values of the room\n            this.memoryTotalObject = Room.extractObjectOfRoom(room, room.$schema)\n        }\n        const packet = new Packet({\n            ...this.memoryTotalObject,\n            join: firstJoin\n        }, <string>room.id)\n\n        await Transmitter.emit(userProxy, packet, room)\n\n        return true\n    }\n\n    private async leave(user: User, room: RoomClass): Promise<void> {\n        if (room['onLeave']) room['onLeave'](user)\n        const index = user._rooms.findIndex(id => room.id == id)\n        user._rooms.splice(index, 1)\n        delete room.users[user.id]\n        delete World.users[user.id]['proxy']\n        if (World.nbUsers == 0 && World.agonesSDK) {\n            const { onBeforeShutdown, shutdownIfNotPlayers } = World.agonesOptions\n            if (shutdownIfNotPlayers) {\n                if (onBeforeShutdown) await onBeforeShutdown()\n                await World.agonesSDK.shutdown()\n            }\n        }\n    }\n\n    private getUsersLength(room: RoomClass) {\n        return Object.keys(room.users).length\n    }\n\n    addInputs(room: RoomClass, obj: Object): void {\n        room.$schema = {\n            ...obj,\n            ...room.$schema\n        }\n    }\n\n    snapshotUser(room: RoomClass, userId: string) {\n        const userSchema = this.permanentObject\n            .filter(path => path.startsWith('users.@'))\n            .map(path => path.replace('users.@.', ''))\n        const userObject = room.users[userId]\n        if (!userObject) return null\n        return Room.extractObjectOfRoom(userObject, userSchema)\n    }\n\n    snapshot(room: RoomClass) {\n        return Room.extractObjectOfRoom(room, this.permanentObject)\n    }\n\n    setProxy(room: RoomClass) {\n        const self = this\n        const { dict, permanentObject, masks } = Room.compileSchema(room.$schema, room)\n        const proxifiedObjects = new WeakSet()\n\n        this.permanentObject = permanentObject\n        room.$dict = dict\n\n        const getInfoDict = (path, key, dictPath): { fullPath: string, genericPath: string, infoDict: any, mask: string[] } => {\n            const basePath = dict[dictPath]\n            const p: string = (path ? path + '.' : '') + key as string\n            const genericPath = (dictPath ? dictPath + '.' : '') +\n                (basePath == GENERIC_KEY_SCHEMA ? GENERIC_KEY_SCHEMA : key as string)\n            return {\n                fullPath: p,\n                genericPath,\n                infoDict: dict[genericPath],\n                mask: masks[genericPath],\n            }\n        }\n\n        function deepProxy(object, path = '', dictPath = '') {\n            if (proxifiedObjects.has(object)) {\n                return object;\n            }\n            return new Proxy(object, {\n                set(target, key: string, val, receiver) {\n                    const { fullPath: p, infoDict, genericPath, mask } = getInfoDict(path, key, dictPath)\n                    // TODO: block set if deleted. Not apply in player\n                    // if (target._isDeleted) {\n                    //     return false\n                    // }\n                    if (typeof val == 'object' && infoDict && val != null) {\n                        const valProxy = deepProxy(val, p, genericPath)\n                        proxifiedObjects.add(valProxy);\n                        if (path == 'users') {\n                            if (!room.users[key]) {\n                                if (!valProxy._rooms) valProxy._rooms = []\n                                valProxy._rooms.push(room.id)\n                                if (!valProxy.id) valProxy.id = Utils.generateId()\n                            }\n                            World.users[key]['proxy'] = valProxy\n                        }\n                        Reflect.set(target, key, val, receiver)\n                        val = target[key]\n                    }\n                    else {\n                        if (infoDict?.$validate) {\n                            const { error } = infoDict.$validate.validate(val)\n                            if (error) return true\n                        }\n                        Reflect.set(target, key, val, receiver)\n                        val = target[key] // Reflect calls the modifiers, so we get the new value\n                    }\n                    if (key == 'length' && dict[dictPath] == GENERIC_KEY_SCHEMA) {\n                        return true\n                    }\n                    if (infoDict) {\n                        if (infoDict.$effects) {\n                            for (let propEffect of infoDict.$effects) {\n                                let pathEffect = ''\n                                if (propEffect.startsWith('$this')) {\n                                    // replace last property in string. Example: users.test.name by users.test.fullname\n                                    if (p) {\n                                        const pSplit = p.split('.')\n                                        pSplit[pSplit.length - 1] = propEffect.replace('$this.', '')\n                                        pathEffect = pSplit.join('.')\n                                    }\n                                    else {\n                                        pathEffect = propEffect.replace('$this.', '')\n                                    }\n                                }\n                                else {\n                                    pathEffect = propEffect\n                                }\n                                self.editMemoryObject(pathEffect, room)\n                            }\n                        }\n                        let newObj\n                        if (Utils.isObject(infoDict) && val != null && !Room.hasExtraProp(infoDict)) {\n                            newObj = Room.extractObjectOfRoom(val, mask)\n                        }\n                        else if (infoDict == GENERIC_KEY_SCHEMA) {\n                            newObj = {}\n                            // reset the object\n                            if (Object.keys(val).length == 0) {\n                                newObj['$reset'] = true\n                            }\n                            for (let key in val) {\n                                const item = val[key]\n                                if (typeof item == 'string' ||\n                                    typeof item == 'number' ||\n                                    typeof item == 'boolean') {\n                                    newObj[key] = item\n                                    continue\n                                }\n                                newObj[key] = Room.extractObjectOfRoom(item, dict[genericPath + '.' + GENERIC_KEY_SCHEMA])\n                            }\n                        }\n                        else {\n                            newObj = val\n                        }\n                        self.detectChanges(room, newObj, p)\n                    }\n                    return true\n                },\n                get(target, key, receiver) {\n                    const toProxy = (val, path) => {\n                        if (typeof key != 'string') {\n                            return val\n                        }\n                        if (key[0] == '_' || val == null) {\n                            return val\n                        }\n                        const { fullPath: p, infoDict, genericPath } = getInfoDict(path, key, dictPath)\n                        if (typeof val == 'object' && infoDict) {\n                            val = deepProxy(val, p, genericPath)\n                            proxifiedObjects.add(val);\n                        }\n                        return val\n                    }\n                    let val = Reflect.get(target, key, receiver)\n                    val = toProxy(val, path)\n                    return val\n                },\n                deleteProperty(target, key) {\n                    const { fullPath: p, infoDict } = getInfoDict(path, key, dictPath)\n                    //target[key]._isDeleted = true\n\n                    Reflect.deleteProperty(target, key)\n                    if (infoDict) self.detectChanges(room, null, p)\n                    return true\n                }\n            })\n        }\n\n        return deepProxy(room)\n    }\n\n    add(id: string, room: RoomClass): RoomClass {\n        room.id = id\n        room.$dict = {}\n        if (!room.$schema) room.$schema = {}\n        if (!room.$schema.users) room.$schema.users = [User.schema]\n        if (!room.$inputs) room.$inputs = {}\n        if (!room.users) room.users = {}\n        if (room.$inputs) this.addInputs(room, room.$inputs)\n\n        room.$detectChanges = () => {\n            //this.detectChanges(room)\n        }\n\n        room.$setSchema = (schema) => {\n            room.$schema = schema\n            return this.setProxy(room)\n        }\n\n        room.$patchSchema = (schema) => {\n            room.$schema = {\n                ...room.$schema,\n                ...schema\n            }\n            return this.setProxy(room)\n        }\n\n        room.$snapshot = () => {\n            return this.snapshot(room)\n        }\n\n        room.$snapshotUser = (userId: string) => {\n            return this.snapshotUser(room, userId)\n        }\n\n        room.$join = async (user: User | string): Promise<boolean> => {\n            if (typeof user == 'string') {\n                user = World.users[user]\n            }\n            if (user) {\n                return this.join(user as any, room)\n            }\n            return false\n        }\n\n        room.$leave = async (user: User | string) => {\n            if (typeof user == 'string') {\n                user = World.users[user]['proxy']\n            }\n            await this.leave(user as User, room)\n        }\n\n        room.$currentState = () => this.memoryObject\n        room.$setCurrentState = (path: string, value?) => {\n            this.editMemoryObject(path, value === undefined ? room : value)\n        }\n        room.$clearCurrentState = () => {\n            this.memoryObject = {}\n        }\n\n        room.$parent = this\n\n        this.proxyRoom = room = this.setProxy(room)\n        if (this.proxyRoom['onInit']) this.proxyRoom['onInit']()\n        return this.proxyRoom\n    }\n\n    static extractObjectOfRoom(room: Object, schema): any {\n        const newObj = {};\n        const _schema = Array.isArray(schema) ? schema : Utils.propertiesToArray(schema);\n        const regex = new RegExp('^(.*?)\\\\.\\\\' + GENERIC_KEY_SCHEMA);\n\n        function extractAndSet(obj: any, path: string) {\n            if (path.endsWith('@')) {\n                return\n            }\n            const match = regex.exec(path);\n            if (match) {\n                const generic = get(room, match[1]);\n                if (generic && typeof generic === 'object') {\n                    for (let key in generic) {\n                        if (generic.hasOwnProperty(key)) {\n                            extractAndSet(obj, path.replace(GENERIC_KEY_SCHEMA, key));\n                        }\n                    }\n                }\n            } else {\n                set(obj, path, get(room, path));\n            }\n        }\n        for (let path of _schema) {\n            extractAndSet(newObj, path);\n        }\n        return newObj;\n    }\n\n    detectChanges(room: RoomClass, obj: Object | null, path: string): void {\n\n        const change = (room) => {\n            const roomInstance = room.$parent\n            roomInstance.editMemoryObject(path, obj)\n            set(roomInstance.memoryTotalObject, path, obj)\n\n            if (roomInstance.proxyRoom['onChanges']) roomInstance.proxyRoom['onChanges'](roomInstance.memoryObject)\n\n            const id: string = room.id as string\n\n            World.changes.next({\n                ...World.changes.value,\n                [id]: room\n            })\n        }\n\n        // If after changing a room, we continue to use the wrong player instance, we ignore the changes made on an old proxy \n        if (obj != null) {\n            const [prop, userId] = path.split('.')\n            if (prop == 'users') {\n                if (!this.propagateOldRoom && !room.users[userId]) {\n                    return\n                }\n                World.forEachUserRooms(userId, change)\n                return\n            }\n        }\n        change(room)\n    }\n\n    editMemoryObject(path: string, roomOrValue: any): void {\n        if (roomOrValue && typeof roomOrValue == 'object' && '$currentState' in roomOrValue) {\n            set(this.memoryObject, path, get(roomOrValue, path), true)\n        }\n        else {\n            set(this.memoryObject, path, roomOrValue, true)\n        }\n    }\n}", "import { DefaultRoom, User } from '../rooms/default'\n\nexport class TransportCommon {\n\n    protected onConnectedCb\n    protected onDisconnectedCb\n    protected onJoinCb\n    protected onInputCb\n    protected onActionCb\n    protected onAuthCb\n\n    onConnected(cb) {\n        this.onConnectedCb = cb\n    }\n\n    onJoin(cb) {\n        this.onJoinCb = cb\n    }\n\n    onInput(cb) {\n        this.onInputCb = cb\n    }\n\n    onAction(cb) {\n        this.onActionCb = cb\n    }\n\n    onDisconnected(cb) {\n        this.onDisconnectedCb = cb\n    }\n}", "/**\n * Returns true if the object is a function.\n * @param value The value to check\n */\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n", "/**\n * Used to create Error subclasses until the community moves away from ES5.\n *\n * This is because compiling from TypeScript down to ES5 has issues with subclassing Errors\n * as well as other built-in types: https://github.com/Microsoft/TypeScript/issues/12123\n *\n * @param createImpl A factory function to create the actual constructor implementation. The returned\n * function should be a named function that calls `_super` internally.\n */\nexport function createErrorClass<T>(createImpl: (_super: any) => any): T {\n  const _super = (instance: any) => {\n    Error.call(instance);\n    instance.stack = new Error().stack;\n  };\n\n  const ctorFunc = createImpl(_super);\n  ctorFunc.prototype = Object.create(Error.prototype);\n  ctorFunc.prototype.constructor = ctorFunc;\n  return ctorFunc;\n}\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (errors: any[]): UnsubscriptionError;\n}\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = createErrorClass(\n  (_super) =>\n    function UnsubscriptionErrorImpl(this: any, errors: (Error | string)[]) {\n      _super(this);\n      this.message = errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : '';\n      this.name = 'UnsubscriptionError';\n      this.errors = errors;\n    }\n);\n", "/**\n * Removes an item from an array, mutating it.\n * @param arr The array to remove the item from\n * @param item The item to remove\n */\nexport function arrRemove<T>(arr: T[] | undefined | null, item: T) {\n  if (arr) {\n    const index = arr.indexOf(item);\n    0 <= index && arr.splice(index, 1);\n  }\n}\n", "import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic, Unsubscribable } from './types';\nimport { arrRemove } from './util/arrRemove';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n  })();\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   */\n  public closed = false;\n\n  private _parentage: Subscription[] | Subscription | null = null;\n\n  /**\n   * The list of registered finalizers to execute upon unsubscription. Adding and removing from this\n   * list occurs in the {@link #add} and {@link #remove} methods.\n   */\n  private _finalizers: Exclude<TeardownLogic, void>[] | null = null;\n\n  /**\n   * @param initialTeardown A function executed first as part of the finalization\n   * process that is kicked off when {@link #unsubscribe} is called.\n   */\n  constructor(private initialTeardown?: () => void) {}\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let errors: any[] | undefined;\n\n    if (!this.closed) {\n      this.closed = true;\n\n      // Remove this from it's parents.\n      const { _parentage } = this;\n      if (_parentage) {\n        this._parentage = null;\n        if (Array.isArray(_parentage)) {\n          for (const parent of _parentage) {\n            parent.remove(this);\n          }\n        } else {\n          _parentage.remove(this);\n        }\n      }\n\n      const { initialTeardown: initialFinalizer } = this;\n      if (isFunction(initialFinalizer)) {\n        try {\n          initialFinalizer();\n        } catch (e) {\n          errors = e instanceof UnsubscriptionError ? e.errors : [e];\n        }\n      }\n\n      const { _finalizers } = this;\n      if (_finalizers) {\n        this._finalizers = null;\n        for (const finalizer of _finalizers) {\n          try {\n            execFinalizer(finalizer);\n          } catch (err) {\n            errors = errors ?? [];\n            if (err instanceof UnsubscriptionError) {\n              errors = [...errors, ...err.errors];\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n\n      if (errors) {\n        throw new UnsubscriptionError(errors);\n      }\n    }\n  }\n\n  /**\n   * Adds a finalizer to this subscription, so that finalization will be unsubscribed/called\n   * when this subscription is unsubscribed. If this subscription is already {@link #closed},\n   * because it has already been unsubscribed, then whatever finalizer is passed to it\n   * will automatically be executed (unless the finalizer itself is also a closed subscription).\n   *\n   * Closed Subscriptions cannot be added as finalizers to any subscription. Adding a closed\n   * subscription to a any subscription will result in no operation. (A noop).\n   *\n   * Adding a subscription to itself, or adding `null` or `undefined` will not perform any\n   * operation at all. (A noop).\n   *\n   * `Subscription` instances that are added to this instance will automatically remove themselves\n   * if they are unsubscribed. Functions and {@link Unsubscribable} objects that you wish to remove\n   * will need to be removed manually with {@link #remove}\n   *\n   * @param teardown The finalization logic to add to this subscription.\n   */\n  add(teardown: TeardownLogic): void {\n    // Only add the finalizer if it's not undefined\n    // and don't add a subscription to itself.\n    if (teardown && teardown !== this) {\n      if (this.closed) {\n        // If this subscription is already closed,\n        // execute whatever finalizer is handed to it automatically.\n        execFinalizer(teardown);\n      } else {\n        if (teardown instanceof Subscription) {\n          // We don't add closed subscriptions, and we don't add the same subscription\n          // twice. Subscription unsubscribe is idempotent.\n          if (teardown.closed || teardown._hasParent(this)) {\n            return;\n          }\n          teardown._addParent(this);\n        }\n        (this._finalizers = this._finalizers ?? []).push(teardown);\n      }\n    }\n  }\n\n  /**\n   * Checks to see if a this subscription already has a particular parent.\n   * This will signal that this subscription has already been added to the parent in question.\n   * @param parent the parent to check for\n   */\n  private _hasParent(parent: Subscription) {\n    const { _parentage } = this;\n    return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n  }\n\n  /**\n   * Adds a parent to this subscription so it can be removed from the parent if it\n   * unsubscribes on it's own.\n   *\n   * NOTE: THIS ASSUMES THAT {@link _hasParent} HAS ALREADY BEEN CHECKED.\n   * @param parent The parent subscription to add\n   */\n  private _addParent(parent: Subscription) {\n    const { _parentage } = this;\n    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n  }\n\n  /**\n   * Called on a child when it is removed via {@link #remove}.\n   * @param parent The parent to remove\n   */\n  private _removeParent(parent: Subscription) {\n    const { _parentage } = this;\n    if (_parentage === parent) {\n      this._parentage = null;\n    } else if (Array.isArray(_parentage)) {\n      arrRemove(_parentage, parent);\n    }\n  }\n\n  /**\n   * Removes a finalizer from this subscription that was previously added with the {@link #add} method.\n   *\n   * Note that `Subscription` instances, when unsubscribed, will automatically remove themselves\n   * from every other `Subscription` they have been added to. This means that using the `remove` method\n   * is not a common thing and should be used thoughtfully.\n   *\n   * If you add the same finalizer instance of a function or an unsubscribable object to a `Subscription` instance\n   * more than once, you will need to call `remove` the same number of times to remove all instances.\n   *\n   * All finalizer instances are removed to free up memory upon unsubscription.\n   *\n   * @param teardown The finalizer to remove from this subscription\n   */\n  remove(teardown: Exclude<TeardownLogic, void>): void {\n    const { _finalizers } = this;\n    _finalizers && arrRemove(_finalizers, teardown);\n\n    if (teardown instanceof Subscription) {\n      teardown._removeParent(this);\n    }\n  }\n}\n\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\n\nexport function isSubscription(value: any): value is Subscription {\n  return (\n    value instanceof Subscription ||\n    (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe))\n  );\n}\n\nfunction execFinalizer(finalizer: Unsubscribable | (() => void)) {\n  if (isFunction(finalizer)) {\n    finalizer();\n  } else {\n    finalizer.unsubscribe();\n  }\n}\n", "import { Subscriber } from './Subscriber';\nimport { ObservableNotification } from './types';\n\n/**\n * The {@link GlobalConfig} object for RxJS. It is used to configure things\n * like how to react on unhandled errors.\n */\nexport const config: GlobalConfig = {\n  onUnhandledError: null,\n  onStoppedNotification: null,\n  Promise: undefined,\n  useDeprecatedSynchronousErrorHandling: false,\n  useDeprecatedNextContext: false,\n};\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like how to react on unhandled errors. Accessible via {@link config}\n * object.\n */\nexport interface GlobalConfig {\n  /**\n   * A registration point for unhandled errors from RxJS. These are errors that\n   * cannot were not handled by consuming code in the usual subscription path. For\n   * example, if you have this configured, and you subscribe to an observable without\n   * providing an error handler, errors from that subscription will end up here. This\n   * will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onUnhandledError: ((err: any) => void) | null;\n\n  /**\n   * A registration point for notifications that cannot be sent to subscribers because they\n   * have completed, errored or have been explicitly unsubscribed. By default, next, complete\n   * and error notifications sent to stopped subscribers are noops. However, sometimes callers\n   * might want a different behavior. For example, with sources that attempt to report errors\n   * to stopped subscribers, a caller can configure RxJS to throw an unhandled error instead.\n   * This will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onStoppedNotification: ((notification: ObservableNotification<any>, subscriber: Subscriber<any>) => void) | null;\n\n  /**\n   * The promise constructor used by default for {@link Observable#toPromise toPromise} and {@link Observable#forEach forEach}\n   * methods.\n   *\n   * @deprecated As of version 8, RxJS will no longer support this sort of injection of a\n   * Promise constructor. If you need a Promise implementation other than native promises,\n   * please polyfill/patch Promise as you see appropriate. Will be removed in v8.\n   */\n  Promise?: PromiseConstructorLike;\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BUY TIME\n   * FOR MIGRATION REASONS.\n   *\n   * @deprecated As of version 8, RxJS will no longer support synchronous throwing\n   * of unhandled errors. All errors will be thrown on a separate call stack to prevent bad\n   * behaviors described above. Will be removed in v8.\n   */\n  useDeprecatedSynchronousErrorHandling: boolean;\n\n  /**\n   * If true, enables an as-of-yet undocumented feature from v5: The ability to access\n   * `unsubscribe()` via `this` context in `next` functions created in observers passed\n   * to `subscribe`.\n   *\n   * This is being removed because the performance was severely problematic, and it could also cause\n   * issues when types other than POJOs are passed to subscribe as subscribers, as they will likely have\n   * their `this` context overwritten.\n   *\n   * @deprecated As of version 8, RxJS will no longer support altering the\n   * context of next functions provided as part of an observer to Subscribe. Instead,\n   * you will have access to a subscription or a signal or token that will allow you to do things like\n   * unsubscribe and test closed status. Will be removed in v8.\n   */\n  useDeprecatedNextContext: boolean;\n}\n", "import type { TimerHandle } from './timerHandle';\ntype SetTimeoutFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearTimeoutFunction = (handle: TimerHandle) => void;\n\ninterface TimeoutProvider {\n  setTimeout: SetTimeoutFunction;\n  clearTimeout: ClearTimeoutFunction;\n  delegate:\n    | {\n        setTimeout: SetTimeoutFunction;\n        clearTimeout: ClearTimeoutFunction;\n      }\n    | undefined;\n}\n\nexport const timeoutProvider: TimeoutProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setTimeout(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = timeoutProvider;\n    if (delegate?.setTimeout) {\n      return delegate.setTimeout(handler, timeout, ...args);\n    }\n    return setTimeout(handler, timeout, ...args);\n  },\n  clearTimeout(handle) {\n    const { delegate } = timeoutProvider;\n    return (delegate?.clearTimeout || clearTimeout)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\n\n/**\n * Handles an error on another job either with the user-configured {@link onUnhandledError},\n * or by throwing it on that new job so it can be picked up by `window.onerror`, `process.on('error')`, etc.\n *\n * This should be called whenever there is an error that is out-of-band with the subscription\n * or when an error hits a terminal boundary of the subscription and no error handler was provided.\n *\n * @param err the error to report\n */\nexport function reportUnhandledError(err: any) {\n  timeoutProvider.setTimeout(() => {\n    const { onUnhandledError } = config;\n    if (onUnhandledError) {\n      // Execute the user-configured error handler.\n      onUnhandledError(err);\n    } else {\n      // Throw so it is picked up by the runtime's uncaught error mechanism.\n      throw err;\n    }\n  });\n}\n", "/* tslint:disable:no-empty */\nexport function noop() { }\n", "import { CompleteNotification, NextNotification, ErrorNotification } from './types';\n\n/**\n * A completion object optimized for memory use and created to be the\n * same \"shape\" as other notifications in v8.\n * @internal\n */\nexport const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined) as CompleteNotification)();\n\n/**\n * Internal use only. Creates an optimized error notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function errorNotification(error: any): ErrorNotification {\n  return createNotification('E', undefined, error) as any;\n}\n\n/**\n * Internal use only. Creates an optimized next notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function nextNotification<T>(value: T) {\n  return createNotification('N', value, undefined) as NextNotification<T>;\n}\n\n/**\n * Ensures that all notifications created internally have the same \"shape\" in v8.\n *\n * TODO: This is only exported to support a crazy legacy test in `groupBy`.\n * @internal\n */\nexport function createNotification(kind: 'N' | 'E' | 'C', value: any, error: any) {\n  return {\n    kind,\n    value,\n    error,\n  };\n}\n", "import { config } from '../config';\n\nlet context: { errorThrown: boolean; error: any } | null = null;\n\n/**\n * Handles dealing with errors for super-gross mode. Creates a context, in which\n * any synchronously thrown errors will be passed to {@link captureError}. Which\n * will record the error such that it will be rethrown after the call back is complete.\n * TODO: Remove in v8\n * @param cb An immediately executed function.\n */\nexport function errorContext(cb: () => void) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    const isRoot = !context;\n    if (isRoot) {\n      context = { errorThrown: false, error: null };\n    }\n    cb();\n    if (isRoot) {\n      const { errorThrown, error } = context!;\n      context = null;\n      if (errorThrown) {\n        throw error;\n      }\n    }\n  } else {\n    // This is the general non-deprecated path for everyone that\n    // isn't crazy enough to use super-gross mode (useDeprecatedSynchronousErrorHandling)\n    cb();\n  }\n}\n\n/**\n * Captures errors only in super-gross mode.\n * @param err the error to capture\n */\nexport function captureError(err: any) {\n  if (config.useDeprecatedSynchronousErrorHandling && context) {\n    context.errorThrown = true;\n    context.error = err;\n  }\n}\n", "import { isFunction } from './util/isFunction';\nimport { Observer, ObservableNotification } from './types';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param next The `next` callback of an Observer.\n   * @param error The `error` callback of an\n   * Observer.\n   * @param complete The `complete` callback of an\n   * Observer.\n   * @return A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\n   * If you have a specific use case, please file an issue.\n   */\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\n    return new SafeSubscriber(next, error, complete);\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected isStopped: boolean = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\n   */\n  constructor(destination?: Subscriber<any> | Observer<any>) {\n    super();\n    if (destination) {\n      this.destination = destination;\n      // Automatically chain subscriptions together here.\n      // if destination is a Subscription, then it is a Subscriber.\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value!);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null!;\n    }\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  protected _complete(): void {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\n\n/**\n * This bind is captured here because we want to be able to have\n * compatibility with monoid libraries that tend to use a method named\n * `bind`. In particular, a library called Monio requires this.\n */\nconst _bind = Function.prototype.bind;\n\nfunction bind<Fn extends (...args: any[]) => any>(fn: Fn, thisArg: any): Fn {\n  return _bind.call(fn, thisArg);\n}\n\n/**\n * Internal optimization only, DO NOT EXPOSE.\n * @internal\n */\nclass ConsumerObserver<T> implements Observer<T> {\n  constructor(private partialObserver: Partial<Observer<T>>) {}\n\n  next(value: T): void {\n    const { partialObserver } = this;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n\n  error(err: any): void {\n    const { partialObserver } = this;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  }\n\n  complete(): void {\n    const { partialObserver } = this;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n}\n\nexport class SafeSubscriber<T> extends Subscriber<T> {\n  constructor(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((e?: any) => void) | null,\n    complete?: (() => void) | null\n  ) {\n    super();\n\n    let partialObserver: Partial<Observer<T>>;\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      // The first argument is a function, not an observer. The next\n      // two arguments *could* be observers, or they could be empty.\n      partialObserver = {\n        next: (observerOrNext ?? undefined) as (((value: T) => void) | undefined),\n        error: error ?? undefined,\n        complete: complete ?? undefined,\n      };\n    } else {\n      // The first argument is a partial observer.\n      let context: any;\n      if (this && config.useDeprecatedNextContext) {\n        // This is a deprecated path that made `this.unsubscribe()` available in\n        // next handler functions passed to subscribe. This only exists behind a flag\n        // now, as it is *very* slow.\n        context = Object.create(observerOrNext);\n        context.unsubscribe = () => this.unsubscribe();\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context),\n          error: observerOrNext.error && bind(observerOrNext.error, context),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n        };\n      } else {\n        // The \"normal\" path. Just use the partial observer directly.\n        partialObserver = observerOrNext;\n      }\n    }\n\n    // Wrap the partial observer to ensure it's a full observer, and\n    // make sure proper error handling is accounted for.\n    this.destination = new ConsumerObserver(partialObserver);\n  }\n}\n\nfunction handleUnhandledError(error: any) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    // Ideal path, we report this as an unhandled error,\n    // which is thrown on a new call stack.\n    reportUnhandledError(error);\n  }\n}\n\n/**\n * An error handler used when no error handler was supplied\n * to the SafeSubscriber -- meaning no error handler was supplied\n * do the `subscribe` call on our observable.\n * @param err The error to handle\n */\nfunction defaultErrorHandler(err: any) {\n  throw err;\n}\n\n/**\n * A handler for notifications that cannot be sent to a stopped subscriber.\n * @param notification The notification being sent\n * @param subscriber The stopped subscriber\n */\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\n  const { onStoppedNotification } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\n/**\n * The observer used as a stub for subscriptions where the user did not\n * pass any arguments to `subscribe`. Comes with the default error handling\n * behavior.\n */\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop,\n};\n", "/**\n * Symbol.observable or a string \"@@observable\". Used for interop\n *\n * @deprecated We will no longer be exporting this symbol in upcoming versions of RxJS.\n * Instead polyfill and use Symbol.observable directly *or* use https://www.npmjs.com/package/symbol-observable\n */\nexport const observable: string | symbol = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n", "/**\n * This function takes one parameter and just returns it. Simply put,\n * this is like `<T>(x: T): T => x`.\n *\n * ## Examples\n *\n * This is useful in some cases when using things like `mergeMap`\n *\n * ```ts\n * import { interval, take, map, range, mergeMap, identity } from 'rxjs';\n *\n * const source$ = interval(1000).pipe(take(5));\n *\n * const result$ = source$.pipe(\n *   map(i => range(i)),\n *   mergeMap(identity) // same as mergeMap(x => x)\n * );\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * Or when you want to selectively apply an operator\n *\n * ```ts\n * import { interval, take, identity } from 'rxjs';\n *\n * const shouldLimit = () => Math.random() < 0.5;\n *\n * const source$ = interval(1000);\n *\n * const result$ = source$.pipe(shouldLimit() ? take(5) : identity);\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * @param x Any value that is returned by this function\n * @returns The value passed as the first parameter to this function\n */\nexport function identity<T>(x: T): T {\n  return x;\n}\n", "import { identity } from './identity';\nimport { UnaryFunction } from '../types';\n\nexport function pipe(): typeof identity;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>\n): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>\n): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>\n): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>\n): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>\n): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>\n): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>,\n  ...fns: UnaryFunction<any, any>[]\n): UnaryFunction<T, unknown>;\n\n/**\n * pipe() can be called on one or more functions, each of which can take one argument (\"UnaryFunction\")\n * and uses it to return a value.\n * It returns a function that takes one argument, passes it to the first UnaryFunction, and then\n * passes the result to the next one, passes that result to the next one, and so on.  \n */\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (fns.length === 0) {\n    return identity as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n", "import { Operator } from './Operator';\nimport { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription, Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, Subscribable, Observer } from './types';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  source: Observable<any> | undefined;\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  operator: Operator<any, T> | undefined;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new Observable by calling the Observable constructor\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new observable\n   * @nocollapse\n   * @deprecated Use `new Observable()` instead. Will be removed in v8.\n   */\n  static create: (...args: any[]) => any = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  };\n\n  /**\n   * Creates a new Observable, with this Observable instance as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param operator the operator defining the operation to take on the observable\n   * @return a new observable with the Operator applied\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * If you have implemented an operator using `lift`, it is recommended that you create an\n   * operator by simply returning `new Observable()` directly. See \"Creating new operators from\n   * scratch\" section here: https://rxjs.dev/guide/operators\n   */\n  lift<R>(operator?: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observerOrNext?: Partial<Observer<T>> | ((value: T) => void)): Subscription;\n  /** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\n  subscribe(next?: ((value: T) => void) | null, error?: ((error: any) => void) | null, complete?: (() => void) | null): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular, do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided and an error happens,\n   * it will be thrown asynchronously. Errors thrown asynchronously cannot be caught using `try`/`catch`. Instead,\n   * use the {@link onUnhandledError} configuration option or use a runtime handler (like `window.onerror` or\n   * `process.on('error)`) to be notified of unhandled errors. Because of this, it's recommended that you provide\n   * an `error` method to avoid missing thrown errors.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of an Observer,\n   * if you do not need to listen for something, you can omit a function by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to the `error` function, as with an Observer, if not provided, errors emitted by an Observable will be thrown asynchronously.\n   *\n   * You can, however, subscribe with no parameters at all. This may be the case where you're not interested in terminal events\n   * and you also handled emissions internally by using operators (e.g. using `tap`).\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * #### Examples\n   *\n   * Subscribe with an {@link guide/observer Observer}\n   *\n   * ```ts\n   * import { of } from 'rxjs';\n   *\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() {\n   *     // We actually could just remove this method,\n   *     // since we do not really care about errors right now.\n   *   },\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   *   .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Subscribe with functions ({@link deprecations/subscribe-arguments deprecated})\n   *\n   * ```ts\n   * import { of } from 'rxjs'\n   *\n   * let sum = 0;\n   *\n   * of(1, 2, 3).subscribe(\n   *   value => {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   () => console.log('Sum equals: ' + sum)\n   * );\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Cancel a subscription\n   *\n   * ```ts\n   * import { interval } from 'rxjs';\n   *\n   * const subscription = interval(1000).subscribe({\n   *   next(num) {\n   *     console.log(num)\n   *   },\n   *   complete() {\n   *     // Will not be called, even when cancelling subscription.\n   *     console.log('completed!');\n   *   }\n   * });\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // 'unsubscribed!' after 2.5s\n   * ```\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   * or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   * Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   * the error will be thrown asynchronously as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {Subscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((error: any) => void) | null,\n    complete?: (() => void) | null\n  ): Subscription {\n    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n\n    errorContext(() => {\n      const { operator, source } = this;\n      subscriber.add(\n        operator\n          ? // We're dealing with a subscription in the\n            // operator chain to one of our lifted operators.\n            operator.call(subscriber, source)\n          : source\n          ? // If `source` has a value, but `operator` does not, something that\n            // had intimate knowledge of our API, like our `Subject`, must have\n            // set it. We're going to just call `_subscribe` directly.\n            this._subscribe(subscriber)\n          : // In all other cases, we're likely wrapping a user-provided initializer\n            // function, so we need to catch errors and handle them appropriately.\n            this._trySubscribe(subscriber)\n      );\n    });\n\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      // We don't need to return anything in this case,\n      // because it's just going to try to `add()` to a subscription\n      // above.\n      sink.error(err);\n    }\n  }\n\n  /**\n   * Used as a NON-CANCELLABLE means of subscribing to an observable, for use with\n   * APIs that expect promises, like `async/await`. You cannot unsubscribe from this.\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * #### Example\n   *\n   * ```ts\n   * import { interval, take } from 'rxjs';\n   *\n   * const source$ = interval(1000).pipe(take(4));\n   *\n   * async function getTotal() {\n   *   let total = 0;\n   *\n   *   await source$.forEach(value => {\n   *     total += value;\n   *     console.log('observable -> ' + value);\n   *   });\n   *\n   *   return total;\n   * }\n   *\n   * getTotal().then(\n   *   total => console.log('Total: ' + total)\n   * );\n   *\n   * // Expected:\n   * // 'observable -> 0'\n   * // 'observable -> 1'\n   * // 'observable -> 2'\n   * // 'observable -> 3'\n   * // 'Total: 6'\n   * ```\n   *\n   * @param next a handler for each value emitted by the observable\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void): Promise<void>;\n\n  /**\n   * @param next a handler for each value emitted by the observable\n   * @param promiseCtor a constructor function used to instantiate the Promise\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   * @deprecated Passing a Promise constructor will no longer be available\n   * in upcoming versions of RxJS. This is because it adds weight to the library, for very\n   * little benefit. If you need this functionality, it is recommended that you either\n   * polyfill Promise, or you create an adapter to convert the returned native promise\n   * to whatever promise implementation you wanted. Will be removed in v8.\n   */\n  forEach(next: (value: T) => void, promiseCtor: PromiseConstructorLike): Promise<void>;\n\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      const subscriber = new SafeSubscriber<T>({\n        next: (value) => {\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscriber.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve,\n      });\n      this.subscribe(subscriber);\n    }) as Promise<void>;\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source?.subscribe(subscriber);\n  }\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>\n  ): Observable<D>;\n  pipe<A, B, C, D, E>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>\n  ): Observable<E>;\n  pipe<A, B, C, D, E, F>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>\n  ): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>\n  ): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>\n  ): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>\n  ): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>,\n    ...operations: OperatorFunction<any, any>[]\n  ): Observable<unknown>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { interval, filter, map, scan } from 'rxjs';\n   *\n   * interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: typeof Promise): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: PromiseConstructorLike): Promise<T | undefined>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Subscribe to this Observable and get a Promise resolving on\n   * `complete` with the last emission (if any).\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * @method toPromise\n   * @param [promiseCtor] a constructor function used to instantiate\n   * the Promise\n   * @return A Promise that resolves with the last value emit, or\n   * rejects on an error. If there were no emissions, Promise\n   * resolves with undefined.\n   * @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise\n   */\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: T | undefined;\n      this.subscribe(\n        (x: T) => (value = x),\n        (err: any) => reject(err),\n        () => resolve(value)\n      );\n    }) as Promise<T | undefined>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  return promiseCtor ?? config.Promise ?? Promise;\n}\n\nfunction isObserver<T>(value: any): value is Observer<T> {\n  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\n\nfunction isSubscriber<T>(value: any): value is Subscriber<T> {\n  return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n", "import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\nimport { isFunction } from './isFunction';\n\n/**\n * Used to determine if an object is an Observable with a lift function.\n */\nexport function hasLift(source: any): source is { lift: InstanceType<typeof Observable>['lift'] } {\n  return isFunction(source?.lift);\n}\n\n/**\n * Creates an `OperatorFunction`. Used to define operators throughout the library in a concise way.\n * @param init The logic to connect the liftedSource to the subscriber at the moment of subscription.\n */\nexport function operate<T, R>(\n  init: (liftedSource: Observable<T>, subscriber: Subscriber<R>) => (() => void) | void\n): OperatorFunction<T, R> {\n  return (source: Observable<T>) => {\n    if (hasLift(source)) {\n      return source.lift(function (this: Subscriber<R>, liftedSource: Observable<T>) {\n        try {\n          return init(liftedSource, this);\n        } catch (err) {\n          this.error(err);\n        }\n      });\n    }\n    throw new TypeError('Unable to lift unknown Observable type');\n  };\n}\n", "import { Subscriber } from '../Subscriber';\n\n/**\n * Creates an instance of an `OperatorSubscriber`.\n * @param destination The downstream subscriber.\n * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n * and send to the `destination` error handler.\n * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n * this handler are sent to the `destination` error handler.\n * @param onFinalize Additional teardown logic here. This will only be called on teardown if the\n * subscriber itself is not already closed. This is called after all other teardown logic is executed.\n */\nexport function createOperatorSubscriber<T>(\n  destination: Subscriber<any>,\n  onNext?: (value: T) => void,\n  onComplete?: () => void,\n  onError?: (err: any) => void,\n  onFinalize?: () => void\n): Subscriber<T> {\n  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\n\n/**\n * A generic helper for allowing operators to be created with a Subscriber and\n * use closures to capture necessary state from the operator function itself.\n */\nexport class OperatorSubscriber<T> extends Subscriber<T> {\n  /**\n   * Creates an instance of an `OperatorSubscriber`.\n   * @param destination The downstream subscriber.\n   * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n   * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n   * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n   * and send to the `destination` error handler.\n   * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n   * this handler are sent to the `destination` error handler.\n   * @param onFinalize Additional finalization logic here. This will only be called on finalization if the\n   * subscriber itself is not already closed. This is called after all other finalization logic is executed.\n   * @param shouldUnsubscribe An optional check to see if an unsubscribe call should truly unsubscribe.\n   * NOTE: This currently **ONLY** exists to support the strange behavior of {@link groupBy}, where unsubscription\n   * to the resulting observable does not actually disconnect from the source if there are active subscriptions\n   * to any grouped observable. (DO NOT EXPOSE OR USE EXTERNALLY!!!)\n   */\n  constructor(\n    destination: Subscriber<any>,\n    onNext?: (value: T) => void,\n    onComplete?: () => void,\n    onError?: (err: any) => void,\n    private onFinalize?: () => void,\n    private shouldUnsubscribe?: () => boolean\n  ) {\n    // It's important - for performance reasons - that all of this class's\n    // members are initialized and that they are always initialized in the same\n    // order. This will ensure that all OperatorSubscriber instances have the\n    // same hidden class in V8. This, in turn, will help keep the number of\n    // hidden classes involved in property accesses within the base class as\n    // low as possible. If the number of hidden classes involved exceeds four,\n    // the property accesses will become megamorphic and performance penalties\n    // will be incurred - i.e. inline caches won't be used.\n    //\n    // The reasons for ensuring all instances have the same hidden class are\n    // further discussed in this blog post from Benedikt Meurer:\n    // https://benediktmeurer.de/2018/03/23/impact-of-polymorphism-on-component-based-frameworks-like-react/\n    super(destination);\n    this._next = onNext\n      ? function (this: OperatorSubscriber<T>, value: T) {\n          try {\n            onNext(value);\n          } catch (err) {\n            destination.error(err);\n          }\n        }\n      : super._next;\n    this._error = onError\n      ? function (this: OperatorSubscriber<T>, err: any) {\n          try {\n            onError(err);\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._error;\n    this._complete = onComplete\n      ? function (this: OperatorSubscriber<T>) {\n          try {\n            onComplete();\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._complete;\n  }\n\n  unsubscribe() {\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n      const { closed } = this;\n      super.unsubscribe();\n      // Execute additional teardown if we have any and we didn't already do so.\n      !closed && this.onFinalize?.();\n    }\n  }\n}\n", "import { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Make a {@link ConnectableObservable} behave like a ordinary observable and automates the way\n * you can connect to it.\n *\n * Internally it counts the subscriptions to the observable and subscribes (only once) to the source if\n * the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it\n * unsubscribes from the source. This way you can make sure that everything before the *published*\n * refCount has only a single subscription independently of the number of subscribers to the target\n * observable.\n *\n * Note that using the {@link share} operator is exactly the same as using the `multicast(() => new Subject())` operator\n * (making the observable hot) and the *refCount* operator in a sequence.\n *\n * ![](refCount.png)\n *\n * ## Example\n *\n * In the following example there are two intervals turned into connectable observables\n * by using the *publish* operator. The first one uses the *refCount* operator, the\n * second one does not use it. You will notice that a connectable observable does nothing\n * until you call its connect function.\n *\n * ```ts\n * import { interval, tap, publish, refCount } from 'rxjs';\n *\n * // Turn the interval observable into a ConnectableObservable (hot)\n * const refCountInterval = interval(400).pipe(\n *   tap(num => console.log(`refCount ${ num }`)),\n *   publish(),\n *   refCount()\n * );\n *\n * const publishedInterval = interval(400).pipe(\n *   tap(num => console.log(`publish ${ num }`)),\n *   publish()\n * );\n *\n * refCountInterval.subscribe();\n * refCountInterval.subscribe();\n * // 'refCount 0' -----> 'refCount 1' -----> etc\n * // All subscriptions will receive the same value and the tap (and\n * // every other operator) before the `publish` operator will be executed\n * // only once per event independently of the number of subscriptions.\n *\n * publishedInterval.subscribe();\n * // Nothing happens until you call .connect() on the observable.\n * ```\n *\n * @return A function that returns an Observable that automates the connection\n * to ConnectableObservable.\n * @see {@link ConnectableObservable}\n * @see {@link share}\n * @see {@link publish}\n * @deprecated Replaced with the {@link share} operator. How `share` is used\n * will depend on the connectable observable you created just prior to the\n * `refCount` operator.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let connection: Subscription | null = null;\n\n    (source as any)._refCount++;\n\n    const refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, () => {\n      if (!source || (source as any)._refCount <= 0 || 0 < --(source as any)._refCount) {\n        connection = null;\n        return;\n      }\n\n      ///\n      // Compare the local RefCountSubscriber's connection Subscription to the\n      // connection Subscription on the shared ConnectableObservable. In cases\n      // where the ConnectableObservable source synchronously emits values, and\n      // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n      // execution continues to here before the RefCountOperator has a chance to\n      // supply the RefCountSubscriber with the shared connection Subscription.\n      // For example:\n      // ```\n      // range(0, 10).pipe(\n      //   publish(),\n      //   refCount(),\n      //   take(5),\n      // )\n      // .subscribe();\n      // ```\n      // In order to account for this case, RefCountSubscriber should only dispose\n      // the ConnectableObservable's shared connection Subscription if the\n      // connection Subscription exists, *and* either:\n      //   a. RefCountSubscriber doesn't have a reference to the shared connection\n      //      Subscription yet, or,\n      //   b. RefCountSubscriber's connection Subscription reference is identical\n      //      to the shared connection Subscription\n      ///\n\n      const sharedConnection = (source as any)._connection;\n      const conn = connection;\n      connection = null;\n\n      if (sharedConnection && (!conn || sharedConnection === conn)) {\n        sharedConnection.unsubscribe();\n      }\n\n      subscriber.unsubscribe();\n    });\n\n    source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      connection = (source as ConnectableObservable<T>).connect();\n    }\n  });\n}\n", "import { Subject } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { hasLift } from '../util/lift';\n\n/**\n * @class ConnectableObservable<T>\n * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n * If you are using the `refCount` method of `ConnectableObservable`, use the {@link share} operator\n * instead.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n  protected _subject: Subject<T> | null = null;\n  protected _refCount: number = 0;\n  protected _connection: Subscription | null = null;\n\n  /**\n   * @param source The source observable\n   * @param subjectFactory The factory that creates the subject used internally.\n   * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n   * `new ConnectableObservable(source, factory)` is equivalent to\n   * `connectable(source, { connector: factory })`.\n   * When the `refCount()` method is needed, the {@link share} operator should be used instead:\n   * `new ConnectableObservable(source, factory).refCount()` is equivalent to\n   * `source.pipe(share({ connector: factory }))`.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  constructor(public source: Observable<T>, protected subjectFactory: () => Subject<T>) {\n    super();\n    // If we have lift, monkey patch that here. This is done so custom observable\n    // types will compose through multicast. Otherwise the resulting observable would\n    // simply be an instance of `ConnectableObservable`.\n    if (hasLift(source)) {\n      this.lift = source.lift;\n    }\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject!;\n  }\n\n  protected _teardown() {\n    this._refCount = 0;\n    const { _connection } = this;\n    this._subject = this._connection = null;\n    _connection?.unsubscribe();\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use {@link connectable} instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      connection = this._connection = new Subscription();\n      const subject = this.getSubject();\n      connection.add(\n        this.source.subscribe(\n          createOperatorSubscriber(\n            subject as any,\n            undefined,\n            () => {\n              this._teardown();\n              subject.complete();\n            },\n            (err) => {\n              this._teardown();\n              subject.error(err);\n            },\n            () => this._teardown()\n          )\n        )\n      );\n\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use the {@link share} operator instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n", "import { TimestampProvider } from '../types';\n\ninterface PerformanceTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const performanceTimestampProvider: PerformanceTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (performanceTimestampProvider.delegate || performance).now();\n  },\n  delegate: undefined,\n};\n", "import { Subscription } from '../Subscription';\n\ninterface AnimationFrameProvider {\n  schedule(callback: FrameRequestCallback): Subscription;\n  requestAnimationFrame: typeof requestAnimationFrame;\n  cancelAnimationFrame: typeof cancelAnimationFrame;\n  delegate:\n    | {\n        requestAnimationFrame: typeof requestAnimationFrame;\n        cancelAnimationFrame: typeof cancelAnimationFrame;\n      }\n    | undefined;\n}\n\nexport const animationFrameProvider: AnimationFrameProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  schedule(callback) {\n    let request = requestAnimationFrame;\n    let cancel: typeof cancelAnimationFrame | undefined = cancelAnimationFrame;\n    const { delegate } = animationFrameProvider;\n    if (delegate) {\n      request = delegate.requestAnimationFrame;\n      cancel = delegate.cancelAnimationFrame;\n    }\n    const handle = request((timestamp) => {\n      // Clear the cancel function. The request has been fulfilled, so\n      // attempting to cancel the request upon unsubscription would be\n      // pointless.\n      cancel = undefined;\n      callback(timestamp);\n    });\n    return new Subscription(() => cancel?.(handle));\n  },\n  requestAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.requestAnimationFrame || requestAnimationFrame)(...args);\n  },\n  cancelAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.cancelAnimationFrame || cancelAnimationFrame)(...args);\n  },\n  delegate: undefined,\n};\n", "import { Observable } from '../../Observable';\nimport { TimestampProvider } from '../../types';\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\n\n/**\n * An observable of animation frames\n *\n * Emits the amount of time elapsed since subscription and the timestamp on each animation frame.\n * Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.\n *\n * Every subscription will start a separate animation loop. Since animation frames are always scheduled\n * by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously\n * should not be much different or have more overhead than looping over an array of events during\n * a single animation frame. However, if for some reason the developer would like to ensure the\n * execution of animation-related handlers are all executed during the same task by the engine,\n * the `share` operator can be used.\n *\n * This is useful for setting up animations with RxJS.\n *\n * ## Examples\n *\n * Tweening a div to move it on the screen\n *\n * ```ts\n * import { animationFrames, map, takeWhile, endWith } from 'rxjs';\n *\n * function tween(start: number, end: number, duration: number) {\n *   const diff = end - start;\n *   return animationFrames().pipe(\n *     // Figure out what percentage of time has passed\n *     map(({ elapsed }) => elapsed / duration),\n *     // Take the vector while less than 100%\n *     takeWhile(v => v < 1),\n *     // Finish with 100%\n *     endWith(1),\n *     // Calculate the distance traveled between start and end\n *     map(v => v * diff + start)\n *   );\n * }\n *\n * // Setup a div for us to move around\n * const div = document.createElement('div');\n * document.body.appendChild(div);\n * div.style.position = 'absolute';\n * div.style.width = '40px';\n * div.style.height = '40px';\n * div.style.backgroundColor = 'lime';\n * div.style.transform = 'translate3d(10px, 0, 0)';\n *\n * tween(10, 200, 4000).subscribe(x => {\n *   div.style.transform = `translate3d(${ x }px, 0, 0)`;\n * });\n * ```\n *\n * Providing a custom timestamp provider\n *\n * ```ts\n * import { animationFrames, TimestampProvider } from 'rxjs';\n *\n * // A custom timestamp provider\n * let now = 0;\n * const customTSProvider: TimestampProvider = {\n *   now() { return now++; }\n * };\n *\n * const source$ = animationFrames(customTSProvider);\n *\n * // Log increasing numbers 0...1...2... on every animation frame.\n * source$.subscribe(({ elapsed }) => console.log(elapsed));\n * ```\n *\n * @param timestampProvider An object with a `now` method that provides a numeric timestamp\n */\nexport function animationFrames(timestampProvider?: TimestampProvider) {\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\n}\n\n/**\n * Does the work of creating the observable for `animationFrames`.\n * @param timestampProvider The timestamp provider to use to create the observable\n */\nfunction animationFramesFactory(timestampProvider?: TimestampProvider) {\n  return new Observable<{ timestamp: number; elapsed: number }>((subscriber) => {\n    // If no timestamp provider is specified, use performance.now() - as it\n    // will return timestamps 'compatible' with those passed to the run\n    // callback and won't be affected by NTP adjustments, etc.\n    const provider = timestampProvider || performanceTimestampProvider;\n\n    // Capture the start time upon subscription, as the run callback can remain\n    // queued for a considerable period of time and the elapsed time should\n    // represent the time elapsed since subscription - not the time since the\n    // first rendered animation frame.\n    const start = provider.now();\n\n    let id = 0;\n    const run = () => {\n      if (!subscriber.closed) {\n        id = animationFrameProvider.requestAnimationFrame((timestamp: DOMHighResTimeStamp | number) => {\n          id = 0;\n          // Use the provider's timestamp to calculate the elapsed time. Note that\n          // this means - if the caller hasn't passed a provider - that\n          // performance.now() will be used instead of the timestamp that was\n          // passed to the run callback. The reason for this is that the timestamp\n          // passed to the callback can be earlier than the start time, as it\n          // represents the time at which the browser decided it would render any\n          // queued frames - and that time can be earlier the captured start time.\n          const now = provider.now();\n          subscriber.next({\n            timestamp: timestampProvider ? now : timestamp,\n            elapsed: now - start,\n          });\n          run();\n        });\n      }\n    };\n\n    run();\n\n    return () => {\n      if (id) {\n        animationFrameProvider.cancelAnimationFrame(id);\n      }\n    };\n  });\n}\n\n/**\n * In the common case, where the timestamp provided by the rAF API is used,\n * we use this shared observable to reduce overhead.\n */\nconst DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface ObjectUnsubscribedError extends Error {}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ObjectUnsubscribedError;\n}\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = createErrorClass(\n  (_super) =>\n    function ObjectUnsubscribedErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ObjectUnsubscribedError';\n      this.message = 'object unsubscribed';\n    }\n);\n", "import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n  closed = false;\n\n  private currentObservers: Observer<T>[] | null = null;\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  observers: Observer<T>[] = [];\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  isStopped = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  hasError = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  thrownError: any = null;\n\n  /**\n   * Creates a \"subject\" by basically gluing an observer to an observable.\n   *\n   * @nocollapse\n   * @deprecated Recommended you do not use. Will be removed at some point in the future. Plans for replacement still under discussion.\n   */\n  static create: (...args: any[]) => any = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  };\n\n  constructor() {\n    // NOTE: This must be here to obscure Observable's constructor.\n    super();\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = operator as any;\n    return subject as any;\n  }\n\n  /** @internal */\n  protected _throwIfClosed() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n  }\n\n  next(value: T) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        if (!this.currentObservers) {\n          this.currentObservers = Array.from(this.observers);\n        }\n        for (const observer of this.currentObservers) {\n          observer.next(value);\n        }\n      }\n    });\n  }\n\n  error(err: any) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.hasError = this.isStopped = true;\n        this.thrownError = err;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.error(err);\n        }\n      }\n    });\n  }\n\n  complete() {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.isStopped = true;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.complete();\n        }\n      }\n    });\n  }\n\n  unsubscribe() {\n    this.isStopped = this.closed = true;\n    this.observers = this.currentObservers = null!;\n  }\n\n  get observed() {\n    return this.observers?.length > 0;\n  }\n\n  /** @internal */\n  protected _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    this._throwIfClosed();\n    return super._trySubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\n    const { hasError, isStopped, observers } = this;\n    if (hasError || isStopped) {\n      return EMPTY_SUBSCRIPTION;\n    }\n    this.currentObservers = null;\n    observers.push(subscriber);\n    return new Subscription(() => {\n      this.currentObservers = null;\n      arrRemove(observers, subscriber);\n    });\n  }\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\n    const { hasError, thrownError, isStopped } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped) {\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create custom Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return {Observable} Observable that the Subject casts to\n   */\n  asObservable(): Observable<T> {\n    const observable: any = new Observable<T>();\n    observable.source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(\n    /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n    public destination?: Observer<T>,\n    source?: Observable<T>\n  ) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    this.destination?.next?.(value);\n  }\n\n  error(err: any) {\n    this.destination?.error?.(err);\n  }\n\n  complete() {\n    this.destination?.complete?.();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    return this.source?.subscribe(subscriber) ?? EMPTY_SUBSCRIPTION;\n  }\n}\n", "import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n\n/**\n * A variant of Subject that requires an initial value and emits its current\n * value whenever it is subscribed to.\n *\n * @class BehaviorSubject<T>\n */\nexport class BehaviorSubject<T> extends Subject<T> {\n  constructor(private _value: T) {\n    super();\n  }\n\n  get value(): T {\n    return this.getValue();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    const subscription = super._subscribe(subscriber);\n    !subscription.closed && subscriber.next(this._value);\n    return subscription;\n  }\n\n  getValue(): T {\n    const { hasError, thrownError, _value } = this;\n    if (hasError) {\n      throw thrownError;\n    }\n    this._throwIfClosed();\n    return _value;\n  }\n\n  next(value: T): void {\n    super.next((this._value = value));\n  }\n}\n", "import { TimestampProvider } from '../types';\n\ninterface DateTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const dateTimestampProvider: DateTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (dateTimestampProvider.delegate || Date).now();\n  },\n  delegate: undefined,\n};\n", "import { Subject } from './Subject';\nimport { TimestampProvider } from './types';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * A variant of {@link Subject} that \"replays\" old values to new subscribers by emitting them when they first subscribe.\n *\n * `ReplaySubject` has an internal buffer that will store a specified number of values that it has observed. Like `Subject`,\n * `ReplaySubject` \"observes\" values by having them passed to its `next` method. When it observes a value, it will store that\n * value for a time determined by the configuration of the `ReplaySubject`, as passed to its constructor.\n *\n * When a new subscriber subscribes to the `ReplaySubject` instance, it will synchronously emit all values in its buffer in\n * a First-In-First-Out (FIFO) manner. The `ReplaySubject` will also complete, if it has observed completion; and it will\n * error if it has observed an error.\n *\n * There are two main configuration items to be concerned with:\n *\n * 1. `bufferSize` - This will determine how many items are stored in the buffer, defaults to infinite.\n * 2. `windowTime` - The amount of time to hold a value in the buffer before removing it from the buffer.\n *\n * Both configurations may exist simultaneously. So if you would like to buffer a maximum of 3 values, as long as the values\n * are less than 2 seconds old, you could do so with a `new ReplaySubject(3, 2000)`.\n *\n * ### Differences with BehaviorSubject\n *\n * `BehaviorSubject` is similar to `new ReplaySubject(1)`, with a couple of exceptions:\n *\n * 1. `BehaviorSubject` comes \"primed\" with a single value upon construction.\n * 2. `ReplaySubject` will replay values, even after observing an error, where `BehaviorSubject` will not.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n * @see {@link shareReplay}\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _buffer: (T | number)[] = [];\n  private _infiniteTimeWindow = true;\n\n  /**\n   * @param bufferSize The size of the buffer to replay on subscription\n   * @param windowTime The amount of time the buffered items will stay buffered\n   * @param timestampProvider An object with a `now()` method that provides the current timestamp. This is used to\n   * calculate the amount of time something has been buffered.\n   */\n  constructor(\n    private _bufferSize = Infinity,\n    private _windowTime = Infinity,\n    private _timestampProvider: TimestampProvider = dateTimestampProvider\n  ) {\n    super();\n    this._infiniteTimeWindow = _windowTime === Infinity;\n    this._bufferSize = Math.max(1, _bufferSize);\n    this._windowTime = Math.max(1, _windowTime);\n  }\n\n  next(value: T): void {\n    const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;\n    if (!isStopped) {\n      _buffer.push(value);\n      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n    }\n    this._trimBuffer();\n    super.next(value);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._trimBuffer();\n\n    const subscription = this._innerSubscribe(subscriber);\n\n    const { _infiniteTimeWindow, _buffer } = this;\n    // We use a copy here, so reentrant code does not mutate our array while we're\n    // emitting it to a new subscriber.\n    const copy = _buffer.slice();\n    for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n      subscriber.next(copy[i] as T);\n    }\n\n    this._checkFinalizedStatuses(subscriber);\n\n    return subscription;\n  }\n\n  private _trimBuffer() {\n    const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;\n    // If we don't have an infinite buffer size, and we're over the length,\n    // use splice to truncate the old buffer values off. Note that we have to\n    // double the size for instances where we're not using an infinite time window\n    // because we're storing the values and the timestamps in the same array.\n    const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n\n    // Now, if we're not in an infinite time window, remove all values where the time is\n    // older than what is allowed.\n    if (!_infiniteTimeWindow) {\n      const now = _timestampProvider.now();\n      let last = 0;\n      // Search the array for the first timestamp that isn't expired and\n      // truncate the buffer up to that point.\n      for (let i = 1; i < _buffer.length && (_buffer[i] as number) <= now; i += 2) {\n        last = i;\n      }\n      last && _buffer.splice(0, last + 1);\n    }\n  }\n}\n", "import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\n\n/**\n * A variant of Subject that only emits a value when it completes. It will emit\n * its latest value to all its observers on completion.\n *\n * @class AsyncSubject<T>\n */\nexport class AsyncSubject<T> extends Subject<T> {\n  private _value: T | null = null;\n  private _hasValue = false;\n  private _isComplete = false;\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<T>) {\n    const { hasError, _hasValue, _value, thrownError, isStopped, _isComplete } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped || _isComplete) {\n      _hasValue && subscriber.next(_value!);\n      subscriber.complete();\n    }\n  }\n\n  next(value: T): void {\n    if (!this.isStopped) {\n      this._value = value;\n      this._hasValue = true;\n    }\n  }\n\n  complete(): void {\n    const { _hasValue, _value, _isComplete } = this;\n    if (!_isComplete) {\n      this._isComplete = true;\n      _hasValue && super.next(_value!);\n      super.complete();\n    }\n  }\n}\n", "import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n", "import type { TimerHandle } from './timerHandle';\ntype SetIntervalFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearIntervalFunction = (handle: TimerHandle) => void;\n\ninterface IntervalProvider {\n  setInterval: SetIntervalFunction;\n  clearInterval: ClearIntervalFunction;\n  delegate:\n    | {\n        setInterval: SetIntervalFunction;\n        clearInterval: ClearIntervalFunction;\n      }\n    | undefined;\n}\n\nexport const intervalProvider: IntervalProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setInterval(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = intervalProvider;\n    if (delegate?.setInterval) {\n      return delegate.setInterval(handler, timeout, ...args);\n    }\n    return setInterval(handler, timeout, ...args);\n  },\n  clearInterval(handle) {\n    const { delegate } = intervalProvider;\n    return (delegate?.clearInterval || clearInterval)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { intervalProvider } from './intervalProvider';\nimport { arrRemove } from '../util/arrRemove';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncAction<T> extends Action<T> {\n  public id: TimerHandle | undefined;\n  public state?: T;\n  // @ts-ignore: Property has no initializer and is not definitely assigned\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id ?? this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, _id?: TimerHandle, delay: number = 0): TimerHandle {\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(_scheduler: AsyncScheduler, id?: TimerHandle, delay: number | null = 0): TimerHandle | undefined {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay != null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    if (id != null) {\n      intervalProvider.clearInterval(id);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, _delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      // HACK: Since code elsewhere is relying on the \"truthiness\" of the\n      // return here, we can't have it return \"\" or 0 or false.\n      // TODO: Clean this up when we refactor schedulers mid-version-8 or so.\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      const { id, scheduler } = this;\n      const { actions } = scheduler;\n\n      this.work = this.state = this.scheduler = null!;\n      this.pending = false;\n\n      arrRemove(actions, this);\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n\n      this.delay = null!;\n      super.unsubscribe();\n    }\n  }\n}\n", "let nextHandle = 1;\n// The promise needs to be created lazily otherwise it won't be patched by Zones\nlet resolved: Promise<any>;\nconst activeHandles: { [key: number]: any } = {};\n\n/**\n * Finds the handle in the list of active handles, and removes it.\n * Returns `true` if found, `false` otherwise. Used both to clear\n * Immediate scheduled tasks, and to identify if a task should be scheduled.\n */\nfunction findAndClearHandle(handle: number): boolean {\n  if (handle in activeHandles) {\n    delete activeHandles[handle];\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper functions to schedule and unschedule microtasks.\n */\nexport const Immediate = {\n  setImmediate(cb: () => void): number {\n    const handle = nextHandle++;\n    activeHandles[handle] = true;\n    if (!resolved) {\n      resolved = Promise.resolve();\n    }\n    resolved.then(() => findAndClearHandle(handle) && cb());\n    return handle;\n  },\n\n  clearImmediate(handle: number): void {\n    findAndClearHandle(handle);\n  },\n};\n\n/**\n * Used for internal testing purposes only. Do not export from library.\n */\nexport const TestTools = {\n  pending() {\n    return Object.keys(activeHandles).length;\n  }\n};\n", "import { Immediate } from '../util/Immediate';\nimport type { TimerHandle } from './timerHandle';\nconst { setImmediate, clearImmediate } = Immediate;\n\ntype SetImmediateFunction = (handler: () => void, ...args: any[]) => TimerHandle;\ntype ClearImmediateFunction = (handle: TimerHandle) => void;\n\ninterface ImmediateProvider {\n  setImmediate: SetImmediateFunction;\n  clearImmediate: ClearImmediateFunction;\n  delegate:\n    | {\n        setImmediate: SetImmediateFunction;\n        clearImmediate: ClearImmediateFunction;\n      }\n    | undefined;\n}\n\nexport const immediateProvider: ImmediateProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setImmediate(...args) {\n    const { delegate } = immediateProvider;\n    return (delegate?.setImmediate || setImmediate)(...args);\n  },\n  clearImmediate(handle) {\n    const { delegate } = immediateProvider;\n    return (delegate?.clearImmediate || clearImmediate)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { AsyncAction } from './AsyncAction';\nimport { AsapScheduler } from './AsapScheduler';\nimport { SchedulerAction } from '../types';\nimport { immediateProvider } from './immediateProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsapAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AsapScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested microtask and set the scheduled flag to undefined\n    // so the next AsapAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && actions[actions.length - 1]?.id !== id) {\n      immediateProvider.clearImmediate(id);\n      if (scheduler._scheduled === id) {\n        scheduler._scheduled = undefined;\n      }\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n", "import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}. Will be made internal in v8.\n */\nexport class Scheduler implements SchedulerLike {\n  public static now: () => number = dateTimestampProvider.now;\n\n  constructor(private schedulerActionCtor: typeof Action, now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.schedulerActionCtor<T>(this, work).schedule(state, delay);\n  }\n}\n", "import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @internal\n   */\n  public _active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @internal\n   */\n  public _scheduled: TimerHandle | undefined;\n\n  constructor(SchedulerAction: typeof Action, now: () => number = Scheduler.now) {\n    super(SchedulerAction, now);\n  }\n\n  public flush(action: AsyncAction<any>): void {\n    const { actions } = this;\n\n    if (this._active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this._active = true;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions.shift()!)); // exhaust the scheduler queue\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions.shift()!)) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AsapScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\n\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * ## Example\n * Compare async and asap scheduler<\n * ```ts\n * import { asapScheduler, asyncScheduler } from 'rxjs';\n *\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\n * asapScheduler.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n * ```\n */\n\nexport const asapScheduler = new AsapScheduler(AsapAction);\n\n/**\n * @deprecated Renamed to {@link asapScheduler}. Will be removed in v8.\n */\nexport const asap = asapScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * const task = () => console.log('it works!');\n *\n * asyncScheduler.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * asyncScheduler.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n */\n\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\n\n/**\n * @deprecated Renamed to {@link asyncScheduler}. Will be removed in v8.\n */\nexport const async = asyncScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class QueueAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: QueueScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);\n  }\n\n  protected requestAsyncId(scheduler: QueueScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n\n    if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n\n    // Otherwise flush the scheduler starting with this action.\n    scheduler.flush(this);\n\n    // HACK: In the past, this was returning `void`. However, `void` isn't a valid\n    // `TimerHandle`, and generally the return value here isn't really used. So the\n    // compromise is to return `0` which is both \"falsy\" and a valid `TimerHandle`,\n    // as opposed to refactoring every other instanceo of `requestAsyncId`.\n    return 0;\n  }\n}\n", "import { AsyncScheduler } from './AsyncScheduler';\n\nexport class QueueScheduler extends AsyncScheduler {\n}\n", "import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(() => {\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n */\n\nexport const queueScheduler = new QueueScheduler(QueueAction);\n\n/**\n * @deprecated Renamed to {@link queueScheduler}. Will be removed in v8.\n */\nexport const queue = queueScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nimport { SchedulerAction } from '../types';\nimport { animationFrameProvider } from './animationFrameProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AnimationFrameScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If an animation frame has already been requested, don't request another\n    // one. If an animation frame hasn't been requested yet, request one. Return\n    // the current animation frame request id.\n    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested animation frame and set the scheduled flag to\n    // undefined so the next AnimationFrameAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && actions[actions.length - 1]?.id !== id) {\n      animationFrameProvider.cancelAnimationFrame(id as number);\n      scheduler._scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AnimationFrameScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\n\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * ## Example\n * Schedule div height animation\n * ```ts\n * // html: <div style=\"background: #0ff;\"></div>\n * import { animationFrameScheduler } from 'rxjs';\n *\n * const div = document.querySelector('div');\n *\n * animationFrameScheduler.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see a div element growing in height\n * ```\n */\n\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\n\n/**\n * @deprecated Renamed to {@link animationFrameScheduler}. Will be removed in v8.\n */\nexport const animationFrame = animationFrameScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class VirtualTimeScheduler extends AsyncScheduler {\n  /** @deprecated Not used in VirtualTimeScheduler directly. Will be removed in v8. */\n  static frameTimeFactor = 10;\n\n  /**\n   * The current frame for the state of the virtual scheduler instance. The difference\n   * between two \"frames\" is synonymous with the passage of \"virtual time units\". So if\n   * you record `scheduler.frame` to be `1`, then later, observe `scheduler.frame` to be at `11`,\n   * that means `10` virtual time units have passed.\n   */\n  public frame: number = 0;\n\n  /**\n   * Used internally to examine the current virtual action index being processed.\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  public index: number = -1;\n\n  /**\n   * This creates an instance of a `VirtualTimeScheduler`. Experts only. The signature of\n   * this constructor is likely to change in the long run.\n   *\n   * @param schedulerActionCtor The type of Action to initialize when initializing actions during scheduling.\n   * @param maxFrames The maximum number of frames to process before stopping. Used to prevent endless flush cycles.\n   */\n  constructor(schedulerActionCtor: typeof AsyncAction = VirtualAction as any, public maxFrames: number = Infinity) {\n    super(schedulerActionCtor, () => this.frame);\n  }\n\n  /**\n   * Prompt the Scheduler to execute all of its queued actions, therefore\n   * clearing its queue.\n   * @return {void}\n   */\n  public flush(): void {\n    const { actions, maxFrames } = this;\n    let error: any;\n    let action: AsyncAction<any> | undefined;\n\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    }\n\n    if (error) {\n      while ((action = actions.shift())) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\nexport class VirtualAction<T> extends AsyncAction<T> {\n  protected active: boolean = true;\n\n  constructor(\n    protected scheduler: VirtualTimeScheduler,\n    protected work: (this: SchedulerAction<T>, state?: T) => void,\n    protected index: number = (scheduler.index += 1)\n  ) {\n    super(scheduler, work);\n    this.index = scheduler.index = index;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (Number.isFinite(delay)) {\n      if (!this.id) {\n        return super.schedule(state, delay);\n      }\n      this.active = false;\n      // If an action is rescheduled, we save allocations by mutating its state,\n      // pushing it to the end of the scheduler queue, and recycling the action.\n      // But since the VirtualTimeScheduler is used for testing, VirtualActions\n      // must be immutable so they can be inspected later.\n      const action = new VirtualAction(this.scheduler, this.work);\n      this.add(action);\n      return action.schedule(state, delay);\n    } else {\n      // If someone schedules something with Infinity, it'll never happen. So we\n      // don't even schedule it.\n      return Subscription.EMPTY;\n    }\n  }\n\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle {\n    this.delay = scheduler.frame + delay;\n    const { actions } = scheduler;\n    actions.push(this);\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\n    return 1;\n  }\n\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle | undefined {\n    return undefined;\n  }\n\n  protected _execute(state: T, delay: number): any {\n    if (this.active === true) {\n      return super._execute(state, delay);\n    }\n  }\n\n  private static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\n/**\n * A simple Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.</span>\n *\n * ![](empty.png)\n *\n * A simple Observable that only emits the complete notification. It can be used\n * for composing with other Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n *\n * Log complete notification\n *\n * ```ts\n * import { EMPTY } from 'rxjs';\n *\n * EMPTY.subscribe({\n *   next: () => console.log('Next'),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Outputs\n * // Complete!\n * ```\n *\n * Emit the number 7, then complete\n *\n * ```ts\n * import { EMPTY, startWith } from 'rxjs';\n *\n * const result = EMPTY.pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n *\n * // Outputs\n * // 7\n * ```\n *\n * Map and flatten only odd numbers to the sequence `'a'`, `'b'`, `'c'`\n *\n * ```ts\n * import { interval, mergeMap, of, EMPTY } from 'rxjs';\n *\n * const interval$ = interval(1000);\n * const result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : EMPTY),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval, e.g. (0, 1, 2, 3, ...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1, print a, b, c (each on its own)\n * // if x % 2 is not equal to 1, nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link NEVER}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const EMPTY = new Observable<never>((subscriber) => subscriber.complete());\n\n/**\n * @param scheduler A {@link SchedulerLike} to use for scheduling\n * the emission of the complete notification.\n * @deprecated Replaced with the {@link EMPTY} constant or {@link scheduled} (e.g. `scheduled([], scheduler)`). Will be removed in v8.\n */\nexport function empty(scheduler?: SchedulerLike) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nfunction emptyScheduled(scheduler: SchedulerLike) {\n  return new Observable<never>((subscriber) => scheduler.schedule(() => subscriber.complete()));\n}\n", "import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && isFunction(value.schedule);\n}\n", "import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\nimport { isScheduler } from './isScheduler';\n\nfunction last<T>(arr: T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n\nexport function popResultSelector(args: any[]): ((...args: unknown[]) => unknown) | undefined {\n  return isFunction(last(args)) ? args.pop() : undefined;\n}\n\nexport function popScheduler(args: any[]): SchedulerLike | undefined {\n  return isScheduler(last(args)) ? args.pop() : undefined;\n}\n\nexport function popNumber(args: any[], defaultValue: number): number {\n  return typeof last(args) === 'number' ? args.pop()! : defaultValue;\n}\n", "export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number' && typeof x !== 'function');", "import { isFunction } from \"./isFunction\";\n\n/**\n * Tests to see if the object is \"thennable\".\n * @param value the object to test\n */\nexport function isPromise(value: any): value is PromiseLike<any> {\n  return isFunction(value?.then);\n}\n", "import { InteropObservable } from '../types';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\nexport function isInteropObservable(input: any): input is InteropObservable<any> {\n  return isFunction(input[Symbol_observable]);\n}\n", "import { isFunction } from './isFunction';\n\nexport function isAsyncIterable<T>(obj: any): obj is AsyncIterable<T> {\n  return Symbol.asyncIterator && isFunction(obj?.[Symbol.asyncIterator]);\n}\n", "/**\n * Creates the TypeError to throw if an invalid object is passed to `from` or `scheduled`.\n * @param input The object that was passed.\n */\nexport function createInvalidObservableTypeError(input: any) {\n  // TODO: We should create error codes that can be looked up, so this can be less verbose.\n  return new TypeError(\n    `You provided ${\n      input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`\n    } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`\n  );\n}\n", "export function getSymbolIterator(): symbol {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator' as any;\n  }\n\n  return Symbol.iterator;\n}\n\nexport const iterator = getSymbolIterator();\n", "import { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being an Iterable */\nexport function isIterable(input: any): input is Iterable<any> {\n  return isFunction(input?.[Symbol_iterator]);\n}\n", "import { ReadableStreamLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport async function* readableStreamLikeToAsyncGenerator<T>(readableStream: ReadableStreamLike<T>): AsyncGenerator<T> {\n  const reader = readableStream.getReader();\n  try {\n    while (true) {\n      const { value, done } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value!;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function isReadableStreamLike<T>(obj: any): obj is ReadableStreamLike<T> {\n  // We don't want to use instanceof checks because they would return\n  // false for instances from another Realm, like an <iframe>.\n  return isFunction(obj?.getReader);\n}\n", "import { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { ObservableInput, ObservedValueOf, ReadableStreamLike } from '../types';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { Subscriber } from '../Subscriber';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function innerFrom<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\nexport function innerFrom<T>(input: ObservableInput<T>): Observable<T> {\n  if (input instanceof Observable) {\n    return input;\n  }\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return fromInteropObservable(input);\n    }\n    if (isArrayLike(input)) {\n      return fromArrayLike(input);\n    }\n    if (isPromise(input)) {\n      return fromPromise(input);\n    }\n    if (isAsyncIterable(input)) {\n      return fromAsyncIterable(input);\n    }\n    if (isIterable(input)) {\n      return fromIterable(input);\n    }\n    if (isReadableStreamLike(input)) {\n      return fromReadableStreamLike(input);\n    }\n  }\n\n  throw createInvalidObservableTypeError(input);\n}\n\n/**\n * Creates an RxJS Observable from an object that implements `Symbol.observable`.\n * @param obj An object that properly implements `Symbol.observable`.\n */\nexport function fromInteropObservable<T>(obj: any) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    const obs = obj[Symbol_observable]();\n    if (isFunction(obs.subscribe)) {\n      return obs.subscribe(subscriber);\n    }\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  });\n}\n\n/**\n * Synchronously emits the values of an array like and completes.\n * This is exported because there are creation functions and operators that need to\n * make direct use of the same logic, and there's no reason to make them run through\n * `from` conditionals because we *know* they're dealing with an array.\n * @param array The array to emit values from\n */\nexport function fromArrayLike<T>(array: ArrayLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    // Loop over the array and emit each value. Note two things here:\n    // 1. We're making sure that the subscriber is not closed on each loop.\n    //    This is so we don't continue looping over a very large array after\n    //    something like a `take`, `takeWhile`, or other synchronous unsubscription\n    //    has already unsubscribed.\n    // 2. In this form, reentrant code can alter that array we're looping over.\n    //    This is a known issue, but considered an edge case. The alternative would\n    //    be to copy the array before executing the loop, but this has\n    //    performance implications.\n    for (let i = 0; i < array.length && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromPromise<T>(promise: PromiseLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    promise\n      .then(\n        (value) => {\n          if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n          }\n        },\n        (err: any) => subscriber.error(err)\n      )\n      .then(null, reportUnhandledError);\n  });\n}\n\nexport function fromIterable<T>(iterable: Iterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    for (const value of iterable) {\n      subscriber.next(value);\n      if (subscriber.closed) {\n        return;\n      }\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromAsyncIterable<T>(asyncIterable: AsyncIterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    process(asyncIterable, subscriber).catch((err) => subscriber.error(err));\n  });\n}\n\nexport function fromReadableStreamLike<T>(readableStream: ReadableStreamLike<T>) {\n  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\n\nasync function process<T>(asyncIterable: AsyncIterable<T>, subscriber: Subscriber<T>) {\n  for await (const value of asyncIterable) {\n    subscriber.next(value);\n    // A side-effect may have closed our subscriber,\n    // check before the next iteration.\n    if (subscriber.closed) {\n      return;\n    }\n  }\n  subscriber.complete();\n}\n", "import { Subscription } from '../Subscription';\nimport { SchedulerAction, SchedulerLike } from '../types';\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay: number,\n  repeat: true\n): void;\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay?: number,\n  repeat?: false\n): Subscription;\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay = 0,\n  repeat = false\n): Subscription | void {\n  const scheduleSubscription = scheduler.schedule(function (this: SchedulerAction<any>) {\n    work();\n    if (repeat) {\n      parentSubscription.add(this.schedule(null, delay));\n    } else {\n      this.unsubscribe();\n    }\n  }, delay);\n\n  parentSubscription.add(scheduleSubscription);\n\n  if (!repeat) {\n    // Because user-land scheduler implementations are unlikely to properly reuse\n    // Actions for repeat scheduling, we can't trust that the returned subscription\n    // will control repeat subscription scenarios. So we're trying to avoid using them\n    // incorrectly within this library.\n    return scheduleSubscription;\n  }\n}\n", "/** @prettier */\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * ## Example\n *\n * Ensure values in subscribe are called just before browser repaint\n *\n * ```ts\n * import { interval, observeOn, animationFrameScheduler } from 'rxjs';\n *\n * const someDiv = document.createElement('div');\n * someDiv.style.cssText = 'width: 200px;background: #09c';\n * document.body.appendChild(someDiv);\n * const intervals = interval(10);      // Intervals are scheduled\n *                                      // with async scheduler by default...\n * intervals.pipe(\n *   observeOn(animationFrameScheduler) // ...but we will observe on animationFrame\n * )                                    // scheduler to ensure smooth animation.\n * .subscribe(val => {\n *   someDiv.style.height = val + 'px';\n * });\n * ```\n *\n * @see {@link delay}\n *\n * @param scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param delay Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return A function that returns an Observable that emits the same\n * notifications as the source Observable, but with provided scheduler.\n */\nexport function observeOn<T>(scheduler: SchedulerLike, delay = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay),\n        () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay),\n        (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)\n      )\n    );\n  });\n}\n", "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\n *\n * With `subscribeOn` you can decide what type of scheduler a specific Observable will be using when it is subscribed to.\n *\n * Schedulers control the speed and order of emissions to observers from an Observable stream.\n *\n * ![](subscribeOn.png)\n *\n * ## Example\n *\n * Given the following code:\n *\n * ```ts\n * import { of, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3);\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * ```\n *\n * Both Observable `a` and `b` will emit their values directly and synchronously once they are subscribed to.\n *\n * If we instead use the `subscribeOn` operator declaring that we want to use the {@link asyncScheduler} for values emitted by Observable `a`:\n *\n * ```ts\n * import { of, subscribeOn, asyncScheduler, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3).pipe(subscribeOn(asyncScheduler));\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 4\n * // 5\n * // 6\n * // 1\n * // 2\n * // 3\n * ```\n *\n * The reason for this is that Observable `b` emits its values directly and synchronously like before\n * but the emissions from `a` are scheduled on the event loop because we are now using the {@link asyncScheduler} for that specific Observable.\n *\n * @param scheduler The {@link SchedulerLike} to perform subscription actions on.\n * @param delay A delay to pass to the scheduler to delay subscriptions\n * @return A function that returns an Observable modified so that its\n * subscriptions happen on the specified {@link SchedulerLike}.\n */\nexport function subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\n  });\n}\n", "import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { InteropObservable, SchedulerLike } from '../types';\n\nexport function scheduleObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n", "import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { SchedulerLike } from '../types';\n\nexport function schedulePromise<T>(input: PromiseLike<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\nexport function scheduleArray<T>(input: ArrayLike<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    // The current array index.\n    let i = 0;\n    // Start iterating over the array like on a schedule.\n    return scheduler.schedule(function () {\n      if (i === input.length) {\n        // If we have hit the end of the array like in the\n        // previous job, we can complete.\n        subscriber.complete();\n      } else {\n        // Otherwise let's next the value at the current index,\n        // then increment our index.\n        subscriber.next(input[i++]);\n        // If the last emission didn't cause us to close the subscriber\n        // (via take or some side effect), reschedule the job and we'll\n        // make another pass.\n        if (!subscriber.closed) {\n          this.schedule();\n        }\n      }\n    });\n  });\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from '../util/isFunction';\nimport { executeSchedule } from '../util/executeSchedule';\n\n/**\n * Used in {@link scheduled} to create an observable from an Iterable.\n * @param input The iterable to create an observable from\n * @param scheduler The scheduler to use\n */\nexport function scheduleIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    let iterator: Iterator<T, T>;\n\n    // Schedule the initial creation of the iterator from\n    // the iterable. This is so the code in the iterable is\n    // not called until the scheduled job fires.\n    executeSchedule(subscriber, scheduler, () => {\n      // Create the iterator.\n      iterator = (input as any)[Symbol_iterator]();\n\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          let value: T;\n          let done: boolean | undefined;\n          try {\n            // Pull the value out of the iterator\n            ({ value, done } = iterator.next());\n          } catch (err) {\n            // We got an error while pulling from the iterator\n            subscriber.error(err);\n            return;\n          }\n\n          if (done) {\n            // If it is \"done\" we just complete. This mimics the\n            // behavior of JavaScript's `for..of` consumption of\n            // iterables, which will not emit the value from an iterator\n            // result of `{ done: true: value: 'here' }`.\n            subscriber.complete();\n          } else {\n            // The iterable is not done, emit the value.\n            subscriber.next(value);\n          }\n        },\n        0,\n        true\n      );\n    });\n\n    // During finalization, if we see this iterator has a `return` method,\n    // then we know it is a Generator, and not just an Iterator. So we call\n    // the `return()` function. This will ensure that any `finally { }` blocks\n    // inside of the generator we can hit will be hit properly.\n    return () => isFunction(iterator?.return) && iterator.return();\n  });\n}\n", "import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport function scheduleAsyncIterable<T>(input: AsyncIterable<T>, scheduler: SchedulerLike) {\n  if (!input) {\n    throw new Error('Iterable cannot be null');\n  }\n  return new Observable<T>((subscriber) => {\n    executeSchedule(subscriber, scheduler, () => {\n      const iterator = input[Symbol.asyncIterator]();\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          iterator.next().then((result) => {\n            if (result.done) {\n              // This will remove the subscriptions from\n              // the parent subscription.\n              subscriber.complete();\n            } else {\n              subscriber.next(result.value);\n            }\n          });\n        },\n        0,\n        true\n      );\n    });\n  });\n}\n", "import { SchedulerLike, ReadableStreamLike } from '../types';\nimport { Observable } from '../Observable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\n\nexport function scheduleReadableStreamLike<T>(input: ReadableStreamLike<T>, scheduler: SchedulerLike): Observable<T> {\n  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);\n}\n", "import { scheduleObservable } from './scheduleObservable';\nimport { schedulePromise } from './schedulePromise';\nimport { scheduleArray } from './scheduleArray';\nimport { scheduleIterable } from './scheduleIterable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isIterable } from '../util/isIterable';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isReadableStreamLike } from '../util/isReadableStreamLike';\nimport { scheduleReadableStreamLike } from './scheduleReadableStreamLike';\n\n/**\n * Converts from a common {@link ObservableInput} type to an observable where subscription and emissions\n * are scheduled on the provided scheduler.\n *\n * @see {@link from}\n * @see {@link of}\n *\n * @param input The observable, array, promise, iterable, etc you would like to schedule\n * @param scheduler The scheduler to use to schedule the subscription and emissions from\n * the returned observable.\n */\nexport function scheduled<T>(input: ObservableInput<T>, scheduler: SchedulerLike): Observable<T> {\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return scheduleObservable(input, scheduler);\n    }\n    if (isArrayLike(input)) {\n      return scheduleArray(input, scheduler);\n    }\n    if (isPromise(input)) {\n      return schedulePromise(input, scheduler);\n    }\n    if (isAsyncIterable(input)) {\n      return scheduleAsyncIterable(input, scheduler);\n    }\n    if (isIterable(input)) {\n      return scheduleIterable(input, scheduler);\n    }\n    if (isReadableStreamLike(input)) {\n      return scheduleReadableStreamLike(input, scheduler);\n    }\n  }\n  throw createInvalidObservableTypeError(input);\n}\n", "import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\nimport { scheduled } from '../scheduled/scheduled';\nimport { innerFrom } from './innerFrom';\n\nexport function from<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function from<O extends ObservableInput<any>>(input: O, scheduler: SchedulerLike | undefined): Observable<ObservedValueOf<O>>;\n\n/**\n * Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.\n *\n * <span class=\"informal\">Converts almost anything to an Observable.</span>\n *\n * ![](from.png)\n *\n * `from` converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an\n * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable\" target=\"_blank\">iterable</a>\n * object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated\n * as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be\n * converted through this operator.\n *\n * ## Examples\n *\n * Converts an array to an Observable\n *\n * ```ts\n * import { from } from 'rxjs';\n *\n * const array = [10, 20, 30];\n * const result = from(array);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 10\n * // 20\n * // 30\n * ```\n *\n * Convert an infinite iterable (from a generator) to an Observable\n *\n * ```ts\n * import { from, take } from 'rxjs';\n *\n * function* generateDoubles(seed) {\n *    let i = seed;\n *    while (true) {\n *      yield i;\n *      i = 2 * i; // double it\n *    }\n * }\n *\n * const iterator = generateDoubles(3);\n * const result = from(iterator).pipe(take(10));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 3\n * // 6\n * // 12\n * // 24\n * // 48\n * // 96\n * // 192\n * // 384\n * // 768\n * // 1536\n * ```\n *\n * With `asyncScheduler`\n *\n * ```ts\n * import { from, asyncScheduler } from 'rxjs';\n *\n * console.log('start');\n *\n * const array = [10, 20, 30];\n * const result = from(array, asyncScheduler);\n *\n * result.subscribe(x => console.log(x));\n *\n * console.log('end');\n *\n * // Logs:\n * // 'start'\n * // 'end'\n * // 10\n * // 20\n * // 30\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link fromEventPattern}\n *\n * @param {ObservableInput<T>} A subscription object, a Promise, an Observable-like,\n * an Array, an iterable, or an array-like object to be converted.\n * @param {SchedulerLike} An optional {@link SchedulerLike} on which to schedule the emission of values.\n * @return {Observable<T>}\n */\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T> {\n  return scheduler ? scheduled(input, scheduler) : innerFrom(input);\n}\n", "import { SchedulerLike, ValueFromArray } from '../types';\nimport { Observable } from '../Observable';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\n\n// Devs are more likely to pass null or undefined than they are a scheduler\n// without accompanying values. To make things easier for (naughty) devs who\n// use the `strictNullChecks: false` TypeScript compiler option, these\n// overloads with explicit null and undefined values are included.\n\nexport function of(value: null): Observable<null>;\nexport function of(value: undefined): Observable<undefined>;\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of(scheduler: SchedulerLike): Observable<never>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of<A extends readonly unknown[]>(...valuesAndScheduler: [...A, SchedulerLike]): Observable<ValueFromArray<A>>;\n\nexport function of(): Observable<never>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function of<T>(): Observable<T>;\nexport function of<T>(value: T): Observable<T>;\nexport function of<A extends readonly unknown[]>(...values: A): Observable<ValueFromArray<A>>;\n\n/**\n * Converts the arguments to an observable sequence.\n *\n * <span class=\"informal\">Each argument becomes a `next` notification.</span>\n *\n * ![](of.png)\n *\n * Unlike {@link from}, it does not do any flattening and emits each argument in whole\n * as a separate `next` notification.\n *\n * ## Examples\n *\n * Emit the values `10, 20, 30`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of(10, 20, 30)\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: 10\n * // next: 20\n * // next: 30\n * // the end\n * ```\n *\n * Emit the array `[1, 2, 3]`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of([1, 2, 3])\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: [1, 2, 3]\n * // the end\n * ```\n *\n * @see {@link from}\n * @see {@link range}\n *\n * @param {...T} values A comma separated list of arguments you want to be emitted\n * @return {Observable} An Observable that emits the arguments\n * described above and then completes.\n */\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\n  const scheduler = popScheduler(args);\n  return from(args as T[], scheduler);\n}\n", "import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { SchedulerLike } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * Creates an observable that will create an error instance and push it to the consumer as an error\n * immediately upon subscription.\n *\n * <span class=\"informal\">Just errors and does nothing else</span>\n *\n * ![](throw.png)\n *\n * This creation function is useful for creating an observable that will create an error and error every\n * time it is subscribed to. Generally, inside of most operators when you might want to return an errored\n * observable, this is unnecessary. In most cases, such as in the inner return of {@link concatMap},\n * {@link mergeMap}, {@link defer}, and many others, you can simply throw the error, and RxJS will pick\n * that up and notify the consumer of the error.\n *\n * ## Example\n *\n * Create a simple observable that will create a new error with a timestamp and log it\n * and the message every time you subscribe to it\n *\n * ```ts\n * import { throwError } from 'rxjs';\n *\n * let errorCount = 0;\n *\n * const errorWithTimestamp$ = throwError(() => {\n *   const error: any = new Error(`This is error number ${ ++errorCount }`);\n *   error.timestamp = Date.now();\n *   return error;\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * // Logs the timestamp and a new error message for each subscription\n * ```\n *\n * ### Unnecessary usage\n *\n * Using `throwError` inside of an operator or creation function\n * with a callback, is usually not necessary\n *\n * ```ts\n * import { of, concatMap, timer, throwError } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // This is probably overkill.\n *       return throwError(() => new Error(`Invalid time ${ ms }`));\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * You can just throw the error instead\n *\n * ```ts\n * import { of, concatMap, timer } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // Cleaner and easier to read for most folks.\n *       throw new Error(`Invalid time ${ ms }`);\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * @param errorFactory A factory function that will create the error instance that is pushed.\n */\nexport function throwError(errorFactory: () => any): Observable<never>;\n\n/**\n * Returns an observable that will error with the specified error immediately upon subscription.\n *\n * @param error The error instance to emit\n * @deprecated Support for passing an error value will be removed in v8. Instead, pass a factory function to `throwError(() => new Error('test'))`. This is\n * because it will create the error at the moment it should be created and capture a more appropriate stack trace. If\n * for some reason you need to create the error ahead of time, you can still do that: `const err = new Error('test'); throwError(() => err);`.\n */\nexport function throwError(error: any): Observable<never>;\n\n/**\n * Notifies the consumer of an error using a given scheduler by scheduling it at delay `0` upon subscription.\n *\n * @param errorOrErrorFactory An error instance or error factory\n * @param scheduler A scheduler to use to schedule the error notification\n * @deprecated The `scheduler` parameter will be removed in v8.\n * Use `throwError` in combination with {@link observeOn}: `throwError(() => new Error('test')).pipe(observeOn(scheduler));`.\n * Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function throwError(errorOrErrorFactory: any, scheduler: SchedulerLike): Observable<never>;\n\nexport function throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable<never> {\n  const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;\n  const init = (subscriber: Subscriber<never>) => subscriber.error(errorFactory());\n  return new Observable(scheduler ? (subscriber) => scheduler.schedule(init as any, 0, subscriber) : init);\n}\n", "import { PartialObserver, ObservableNotification, CompleteNotification, NextNotification, ErrorNotification } from './types';\nimport { Observable } from './Observable';\nimport { EMPTY } from './observable/empty';\nimport { of } from './observable/of';\nimport { throwError } from './observable/throwError';\nimport { isFunction } from './util/isFunction';\n\n// TODO: When this enum is removed, replace it with a type alias. See #4556.\n/**\n * @deprecated Use a string literal instead. `NotificationKind` will be replaced with a type alias in v8.\n * It will not be replaced with a const enum as those are not compatible with isolated modules.\n */\nexport enum NotificationKind {\n  NEXT = 'N',\n  ERROR = 'E',\n  COMPLETE = 'C',\n}\n\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n * @deprecated It is NOT recommended to create instances of `Notification` directly.\n * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n * Will be removed in v8.\n */\nexport class Notification<T> {\n  /**\n   * A value signifying that the notification will \"next\" if observed. In truth,\n   * This is really synonymous with just checking `kind === \"N\"`.\n   * @deprecated Will be removed in v8. Instead, just check to see if the value of `kind` is `\"N\"`.\n   */\n  readonly hasValue: boolean;\n\n  /**\n   * Creates a \"Next\" notification object.\n   * @param kind Always `'N'`\n   * @param value The value to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createNext createNext} instead.\n   */\n  constructor(kind: 'N', value?: T);\n  /**\n   * Creates an \"Error\" notification object.\n   * @param kind Always `'E'`\n   * @param value Always `undefined`\n   * @param error The error to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createError createError} instead.\n   */\n  constructor(kind: 'E', value: undefined, error: any);\n  /**\n   * Creates a \"completion\" notification object.\n   * @param kind Always `'C'`\n   * @deprecated Internal implementation detail. Use {@link Notification#createComplete createComplete} instead.\n   */\n  constructor(kind: 'C');\n  constructor(public readonly kind: 'N' | 'E' | 'C', public readonly value?: T, public readonly error?: any) {\n    this.hasValue = kind === 'N';\n  }\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   */\n  observe(observer: PartialObserver<T>): void {\n    return observeNotification(this as ObservableNotification<T>, observer);\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void): void;\n  do(nextHandler: (value: T) => void, errorHandler?: (err: any) => void, completeHandler?: () => void): void {\n    const { kind, value, error } = this;\n    return kind === 'N' ? nextHandler?.(value!) : kind === 'E' ? errorHandler?.(error) : completeHandler?.();\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void): void;\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(observer: PartialObserver<T>): void;\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\n    return isFunction((nextOrObserver as any)?.next)\n      ? this.observe(nextOrObserver as PartialObserver<T>)\n      : this.do(nextOrObserver as (value: T) => void, error as any, complete as any);\n  }\n\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   *\n   * @deprecated Will be removed in v8. To convert a `Notification` to an {@link Observable},\n   * use {@link of} and {@link dematerialize}: `of(notification).pipe(dematerialize())`.\n   */\n  toObservable(): Observable<T> {\n    const { kind, value, error } = this;\n    // Select the observable to return by `kind`\n    const result =\n      kind === 'N'\n        ? // Next kind. Return an observable of that value.\n          of(value!)\n        : //\n        kind === 'E'\n        ? // Error kind. Return an observable that emits the error.\n          throwError(() => error)\n        : //\n        kind === 'C'\n        ? // Completion kind. Kind is \"C\", return an observable that just completes.\n          EMPTY\n        : // Unknown kind, return falsy, so we error below.\n          0;\n    if (!result) {\n      // TODO: consider removing this check. The only way to cause this would be to\n      // use the Notification constructor directly in a way that is not type-safe.\n      // and direct use of the Notification constructor is deprecated.\n      throw new TypeError(`Unexpected notification kind ${kind}`);\n    }\n    return result;\n  }\n\n  private static completeNotification = new Notification('C') as Notification<never> & CompleteNotification;\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param {T} value The `next` value.\n   * @return {Notification<T>} The \"next\" Notification representing the\n   * argument.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createNext<T>(value: T) {\n    return new Notification('N', value) as Notification<T> & NextNotification<T>;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param {any} [err] The `error` error.\n   * @return {Notification<T>} The \"error\" Notification representing the\n   * argument.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createError(err?: any) {\n    return new Notification('E', undefined, err) as Notification<never> & ErrorNotification;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return {Notification<any>} The valueless \"complete\" Notification.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createComplete(): Notification<never> & CompleteNotification {\n    return Notification.completeNotification;\n  }\n}\n\n/**\n * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n * If the handler is missing it will do nothing. Even if the notification is an error, if\n * there is no error handler on the observer, an error will not be thrown, it will noop.\n * @param notification The notification object to observe.\n * @param observer The observer to notify.\n */\nexport function observeNotification<T>(notification: ObservableNotification<T>, observer: PartialObserver<T>) {\n  const { kind, value, error } = notification as any;\n  if (typeof kind !== 'string') {\n    throw new TypeError('Invalid notification, missing \"kind\"');\n  }\n  kind === 'N' ? observer.next?.(value!) : kind === 'E' ? observer.error?.(error) : observer.complete?.();\n}\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface EmptyError extends Error {}\n\nexport interface EmptyErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): EmptyError;\n}\n\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n * @see {@link firstValueFrom}\n * @see {@link lastValueFrom}\n *\n * @class EmptyError\n */\nexport const EmptyError: EmptyErrorCtor = createErrorClass((_super) => function EmptyErrorImpl(this: any) {\n  _super(this);\n  this.name = 'EmptyError';\n  this.message = 'no elements in sequence';\n});\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface ArgumentOutOfRangeError extends Error {}\n\nexport interface ArgumentOutOfRangeErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ArgumentOutOfRangeError;\n}\n\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nexport const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor = createErrorClass(\n  (_super) =>\n    function ArgumentOutOfRangeErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ArgumentOutOfRangeError';\n      this.message = 'argument out of range';\n    }\n);\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface NotFoundError extends Error {}\n\nexport interface NotFoundErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): NotFoundError;\n}\n\n/**\n * An error thrown when a value or values are missing from an\n * observable sequence.\n *\n * @see {@link operators/single}\n *\n * @class NotFoundError\n */\nexport const NotFoundError: NotFoundErrorCtor = createErrorClass(\n  (_super) =>\n    function NotFoundErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'NotFoundError';\n      this.message = message;\n    }\n);\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface SequenceError extends Error {}\n\nexport interface SequenceErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): SequenceError;\n}\n\n/**\n * An error thrown when something is wrong with the sequence of\n * values arriving on the observable.\n *\n * @see {@link operators/single}\n *\n * @class SequenceError\n */\nexport const SequenceError: SequenceErrorCtor = createErrorClass(\n  (_super) =>\n    function SequenceErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'SequenceError';\n      this.message = message;\n    }\n);\n", "import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { isValidDate } from '../util/isDate';\nimport { Subscription } from '../Subscription';\nimport { operate } from '../util/lift';\nimport { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createErrorClass } from '../util/createErrorClass';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport interface TimeoutConfig<T, O extends ObservableInput<unknown> = ObservableInput<T>, M = unknown> {\n  /**\n   * The time allowed between values from the source before timeout is triggered.\n   */\n  each?: number;\n\n  /**\n   * The relative time as a `number` in milliseconds, or a specific time as a `Date` object,\n   * by which the first value must arrive from the source before timeout is triggered.\n   */\n  first?: number | Date;\n\n  /**\n   * The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\n   */\n  scheduler?: SchedulerLike;\n\n  /**\n   * A factory used to create observable to switch to when timeout occurs. Provides\n   * a {@link TimeoutInfo} about the source observable's emissions and what delay or\n   * exact time triggered the timeout.\n   */\n  with?: (info: TimeoutInfo<T, M>) => O;\n\n  /**\n   * Optional additional metadata you can provide to code that handles\n   * the timeout, will be provided through the {@link TimeoutError}.\n   * This can be used to help identify the source of a timeout or pass along\n   * other information related to the timeout.\n   */\n  meta?: M;\n}\n\nexport interface TimeoutInfo<T, M = unknown> {\n  /** Optional metadata that was provided to the timeout configuration. */\n  readonly meta: M;\n  /** The number of messages seen before the timeout */\n  readonly seen: number;\n  /** The last message seen */\n  readonly lastValue: T | null;\n}\n\n/**\n * An error emitted when a timeout occurs.\n */\nexport interface TimeoutError<T = unknown, M = unknown> extends Error {\n  /**\n   * The information provided to the error by the timeout\n   * operation that created the error. Will be `null` if\n   * used directly in non-RxJS code with an empty constructor.\n   * (Note that using this constructor directly is not recommended,\n   * you should create your own errors)\n   */\n  info: TimeoutInfo<T, M> | null;\n}\n\nexport interface TimeoutErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new <T = unknown, M = unknown>(info?: TimeoutInfo<T, M>): TimeoutError<T, M>;\n}\n\n/**\n * An error thrown by the {@link timeout} operator.\n *\n * Provided so users can use as a type and do quality comparisons.\n * We recommend you do not subclass this or create instances of this class directly.\n * If you have need of a error representing a timeout, you should\n * create your own error class and use that.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nexport const TimeoutError: TimeoutErrorCtor = createErrorClass(\n  (_super) =>\n    function TimeoutErrorImpl(this: any, info: TimeoutInfo<any> | null = null) {\n      _super(this);\n      this.message = 'Timeout has occurred';\n      this.name = 'TimeoutError';\n      this.info = info;\n    }\n);\n\n/**\n * If `with` is provided, this will return an observable that will switch to a different observable if the source\n * does not push values within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ## Examples\n *\n * Emit a custom error if there is too much time between values\n *\n * ```ts\n * import { interval, timeout, throwError } from 'rxjs';\n *\n * class CustomTimeoutError extends Error {\n *   constructor() {\n *     super('It was too slow');\n *     this.name = 'CustomTimeoutError';\n *   }\n * }\n *\n * const slow$ = interval(900);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => throwError(() => new CustomTimeoutError())\n *   })\n * )\n * .subscribe({\n *   error: console.error\n * });\n * ```\n *\n * Switch to a faster observable if your source is slow.\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * const slow$ = interval(900);\n * const fast$ = interval(500);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => fast$,\n *   })\n * )\n * .subscribe(console.log);\n * ```\n * @param config The configuration for the timeout.\n */\nexport function timeout<T, O extends ObservableInput<unknown>, M = unknown>(\n  config: TimeoutConfig<T, O, M> & { with: (info: TimeoutInfo<T, M>) => O }\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n\n/**\n * Returns an observable that will error or switch to a different observable if the source does not push values\n * within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ### Handling TimeoutErrors\n *\n * If no `with` property was provided, subscriptions to the resulting observable may emit an error of {@link TimeoutError}.\n * The timeout error provides useful information you can examine when you're handling the error. The most common way to handle\n * the error would be with {@link catchError}, although you could use {@link tap} or just the error handler in your `subscribe` call\n * directly, if your error handling is only a side effect (such as notifying the user, or logging).\n *\n * In this case, you would check the error for `instanceof TimeoutError` to validate that the error was indeed from `timeout`, and\n * not from some other source. If it's not from `timeout`, you should probably rethrow it if you're in a `catchError`.\n *\n * ## Examples\n *\n * Emit a {@link TimeoutError} if the first value, and _only_ the first value, does not arrive within 5 seconds\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * // A random interval that lasts between 0 and 10 seconds per tick\n * const source$ = interval(Math.round(Math.random() * 10_000));\n *\n * source$.pipe(\n *   timeout({ first: 5_000 })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * Emit a {@link TimeoutError} if the source waits longer than 5 seconds between any two values or the first value\n * and subscription.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n *\n * Emit a {@link TimeoutError} if the source does not emit before 7 seconds, _or_ if the source waits longer than\n * 5 seconds between any two values after the first.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ first: 7_000, each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n */\nexport function timeout<T, M = unknown>(config: Omit<TimeoutConfig<T, any, M>, 'with'>): OperatorFunction<T, T>;\n\n/**\n * Returns an observable that will error if the source does not push its first value before the specified time passed as a `Date`.\n * This is functionally the same as `timeout({ first: someDate })`.\n *\n * <span class=\"informal\">Errors if the first value doesn't show up before the given date and time</span>\n *\n * ![](timeout.png)\n *\n * @param first The date to at which the resulting observable will timeout if the source observable\n * does not emit at least one value.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(first: Date, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an observable that will error if the source does not push a value within the specified time in milliseconds.\n * This is functionally the same as `timeout({ each: milliseconds })`.\n *\n * <span class=\"informal\">Errors if it waits too long between any value</span>\n *\n * ![](timeout.png)\n *\n * @param each The time allowed between each pushed value from the source before the resulting observable\n * will timeout.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(each: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * ![](timeout.png)\n *\n * @see {@link timeoutWith}\n *\n * @return A function that returns an Observable that mirrors behaviour of the\n * source Observable, unless timeout happens when it throws an error.\n */\nexport function timeout<T, O extends ObservableInput<any>, M>(\n  config: number | Date | TimeoutConfig<T, O, M>,\n  schedulerArg?: SchedulerLike\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  // Intentionally terse code.\n  // If the first argument is a valid `Date`, then we use it as the `first` config.\n  // Otherwise, if the first argument is a `number`, then we use it as the `each` config.\n  // Otherwise, it can be assumed the first argument is the configuration object itself, and\n  // we destructure that into what we're going to use, setting important defaults as we do.\n  // NOTE: The default for `scheduler` will be the `scheduler` argument if it exists, or\n  // it will default to the `asyncScheduler`.\n  const {\n    first,\n    each,\n    with: _with = timeoutErrorFactory,\n    scheduler = schedulerArg ?? asyncScheduler,\n    meta = null!,\n  } = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config) as TimeoutConfig<T, O, M>;\n\n  if (first == null && each == null) {\n    // Ensure timeout was provided at runtime.\n    throw new TypeError('No timeout provided.');\n  }\n\n  return operate((source, subscriber) => {\n    // This subscription encapsulates our subscription to the\n    // source for this operator. We're capturing it separately,\n    // because if there is a `with` observable to fail over to,\n    // we want to unsubscribe from our original subscription, and\n    // hand of the subscription to that one.\n    let originalSourceSubscription: Subscription;\n    // The subscription for our timeout timer. This changes\n    // every time we get a new value.\n    let timerSubscription: Subscription;\n    // A bit of state we pass to our with and error factories to\n    // tell what the last value we saw was.\n    let lastValue: T | null = null;\n    // A bit of state we pass to the with and error factories to\n    // tell how many values we have seen so far.\n    let seen = 0;\n    const startTimer = (delay: number) => {\n      timerSubscription = executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          try {\n            originalSourceSubscription.unsubscribe();\n            innerFrom(\n              _with!({\n                meta,\n                lastValue,\n                seen,\n              })\n            ).subscribe(subscriber);\n          } catch (err) {\n            subscriber.error(err);\n          }\n        },\n        delay\n      );\n    };\n\n    originalSourceSubscription = source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // clear the timer so we can emit and start another one.\n          timerSubscription?.unsubscribe();\n          seen++;\n          // Emit\n          subscriber.next((lastValue = value));\n          // null | undefined are both < 0. Thanks, JavaScript.\n          each! > 0 && startTimer(each!);\n        },\n        undefined,\n        undefined,\n        () => {\n          if (!timerSubscription?.closed) {\n            timerSubscription?.unsubscribe();\n          }\n          // Be sure not to hold the last value in memory after unsubscription\n          // it could be quite large.\n          lastValue = null;\n        }\n      )\n    );\n\n    // Intentionally terse code.\n    // If we've `seen` a value, that means the \"first\" clause was met already, if it existed.\n    //   it also means that a timer was already started for \"each\" (in the next handler above).\n    // If `first` was provided, and it's a number, then use it.\n    // If `first` was provided and it's not a number, it's a Date, and we get the difference between it and \"now\".\n    // If `first` was not provided at all, then our first timer will be the value from `each`.\n    !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler!.now()) : each!);\n  });\n}\n\n/**\n * The default function to use to emit an error when timeout occurs and a `with` function\n * is not specified.\n * @param info The information about the timeout to pass along to the error\n */\nfunction timeoutErrorFactory(info: TimeoutInfo<any>): Observable<never> {\n  throw new TimeoutError(info);\n}\n", "import { OperatorFunction } from \"../types\";\nimport { map } from \"../operators/map\";\n\nconst { isArray } = Array;\n\nfunction callOrApply<T, R>(fn: ((...values: T[]) => R), args: T|T[]): R {\n    return isArray(args) ? fn(...args) : fn(args);\n}\n\n/**\n * Used in several -- mostly deprecated -- situations where we need to \n * apply a list of arguments or a single argument to a result selector.\n */\nexport function mapOneOrManyArgs<T, R>(fn: ((...values: T[]) => R)): OperatorFunction<T|T[], R> {\n    return map(args => callOrApply(fn, args))\n}", "const { isArray } = Array;\nconst { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;\n\n/**\n * Used in functions where either a list of arguments, a single array of arguments, or a\n * dictionary of arguments can be returned. Returns an object with an `args` property with\n * the arguments in an array, if it is a dictionary, it will also return the `keys` in another\n * property.\n */\nexport function argsArgArrayOrObject<T, O extends Record<string, T>>(args: T[] | [O] | [T[]]): { args: T[]; keys: string[] | null } {\n  if (args.length === 1) {\n    const first = args[0];\n    if (isArray(first)) {\n      return { args: first, keys: null };\n    }\n    if (isPOJO(first)) {\n      const keys = getKeys(first);\n      return {\n        args: keys.map((key) => first[key]),\n        keys,\n      };\n    }\n  }\n\n  return { args: args as T[], keys: null };\n}\n\nfunction isPOJO(obj: any): obj is object {\n  return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\n}\n", "import { Observable } from '../Observable';\nimport { noop } from '../util/noop';\n\n/**\n * An Observable that emits no items to the Observer and never completes.\n *\n * ![](never.png)\n *\n * A simple Observable that emits neither values nor errors nor the completion\n * notification. It can be used for testing purposes or for composing with other\n * Observables. Please note that by never emitting a complete notification, this\n * Observable keeps the subscription from being disposed automatically.\n * Subscriptions need to be manually disposed.\n *\n * ##  Example\n *\n * Emit the number 7, then never emit anything else (not even complete)\n *\n * ```ts\n * import { NEVER, startWith } from 'rxjs';\n *\n * const info = () => console.log('Will not be called');\n *\n * const result = NEVER.pipe(startWith(7));\n * result.subscribe({\n *   next: x => console.log(x),\n *   error: info,\n *   complete: info\n * });\n * ```\n *\n * @see {@link Observable}\n * @see {@link EMPTY}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const NEVER = new Observable<never>(noop);\n\n/**\n * @deprecated Replaced with the {@link NEVER} constant. Will be removed in v8.\n */\nexport function never() {\n  return NEVER;\n}\n", "const { isArray } = Array;\n\n/**\n * Used in operators and functions that accept either a list of arguments, or an array of arguments\n * as a single argument.\n */\nexport function argsOrArgArray<T>(args: (T | T[])[]): T[] {\n  return args.length === 1 && isArray(args[0]) ? args[0] : (args as T[]);\n}\n", "import { asyncScheduler } from '../scheduler/async';\nimport { SchedulerLike, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits an object containing the current value, and the time that has\n * passed between emitting the current value and the previous value, which is\n * calculated by using the provided `scheduler`'s `now()` method to retrieve\n * the current time at each emission, then calculating the difference. The `scheduler`\n * defaults to {@link asyncScheduler}, so by default, the `interval` will be in\n * milliseconds.\n *\n * <span class=\"informal\">Convert an Observable that emits items into one that\n * emits indications of the amount of time elapsed between those emissions.</span>\n *\n * ![](timeInterval.png)\n *\n * ## Example\n *\n * Emit interval between current value with the last value\n *\n * ```ts\n * import { interval, timeInterval } from 'rxjs';\n *\n * const seconds = interval(1000);\n *\n * seconds\n *   .pipe(timeInterval())\n *   .subscribe(value => console.log(value));\n *\n * // NOTE: The values will never be this precise,\n * // intervals created with `interval` or `setInterval`\n * // are non-deterministic.\n *\n * // { value: 0, interval: 1000 }\n * // { value: 1, interval: 1000 }\n * // { value: 2, interval: 1000 }\n * ```\n *\n * @param {SchedulerLike} [scheduler] Scheduler used to get the current time.\n * @return A function that returns an Observable that emits information about\n * value and interval.\n */\nexport function timeInterval<T>(scheduler: SchedulerLike = asyncScheduler): OperatorFunction<T, TimeInterval<T>> {\n  return operate((source, subscriber) => {\n    let last = scheduler.now();\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const now = scheduler.now();\n        const interval = now - last;\n        last = now;\n        subscriber.next(new TimeInterval(value, interval));\n      })\n    );\n  });\n}\n\n// TODO(benlesh): make this an interface, export the interface, but not the implemented class,\n// there's no reason users should be manually creating this type.\n\nexport class TimeInterval<T> {\n  /**\n   * @deprecated Internal implementation detail, do not construct directly. Will be made an interface in v8.\n   */\n  constructor(public value: T, public interval: number) {}\n}\n", "import { TransportCommon } from './common';\nimport { BehaviorSubject } from 'rxjs';\nimport { Utils } from '../utils';\nimport { NotAuthorized } from '../errors/not-authorized';\n\nexport type BandwidthSocket = { incoming: { size: number, timestamp: number }[], outgoing: { size: number, timestamp: number }[] }\nexport type BandwidthData = Record<string, BehaviorSubject<BandwidthSocket>>\nexport type TransportOptions = {\n    maxKbpsIncoming?: number\n    maxKbpsOutgoing?: number\n    clientCanJoinRoom?: boolean\n    timeoutDisconnect?: number,\n    auth?: (socket: any) => Promise<string | never> | string | never\n}\n\nexport class Transport extends TransportCommon {\n    private bandwidthData: BandwidthData = {};\n    private readonly WINDOW_SECONDS = 10; // Store data for the last 10 seconds\n\n    constructor(public io: any, private options: TransportOptions = {}) {\n        super();\n\n        io.on('connection', (socket) => {\n            const id = socket.playerId\n            this.bandwidthData[id] = new BehaviorSubject({\n                incoming: [] as any,\n                outgoing: [] as any\n            });\n\n            this.handleConnection(socket, id);\n\n            socket.on(':input', ({ prop, value }) => this.onInputCb(id, prop, value));\n            socket.on(':action', ({ name, value }) => this.onActionCb(id, name, value));\n            if (options.clientCanJoinRoom) socket.on(':join', (roomId) => this.onJoinCb(roomId, id));\n            socket.on('disconnect', () => {\n                this.bandwidthData[id]?.unsubscribe();\n                delete this.bandwidthData[id];\n                this.onDisconnectedCb(id);\n            });\n        });\n\n        this.use();\n    }\n\n    private handleConnection(socket: any, id: string) {\n        this.onConnectedCb(socket, id);\n    }\n\n    private use() {\n        const { maxKbpsIncoming, maxKbpsOutgoing, auth } = this.options;\n        this.io.use?.(async (socket, next) => {\n            let playerId\n\n            if (auth) {\n                try {\n                    playerId = await Utils.resolveValue(auth(socket))\n                }\n                catch (err) {\n                    socket.disconnect();\n                    next(new NotAuthorized(err).toObject())\n                    return\n                }\n            }\n\n            if (!playerId) playerId = Utils.generateId(5)\n\n            socket.playerId = playerId;\n\n            // Intercept incoming messages\n            socket.use((packet, nextMiddleware) => {\n                if (packet && packet[1]) {\n                    const packetSize = Utils.bufferFrom(JSON.stringify(packet)).length - 2;\n                    const data = { size: packetSize, timestamp: Date.now() };\n\n                    this.updateBandwidthData(playerId, { incoming: data });\n                    const kbps = this.calculateKbps(this.bandwidthData[playerId]?.value.incoming || []);\n                    if (maxKbpsIncoming && kbps > maxKbpsIncoming) {\n                        socket.disconnect();\n                        return;\n                    }\n\n                    this.cleanOldData(this.bandwidthData[playerId]?.value.incoming || []);\n                }\n                nextMiddleware();\n            });\n\n            // Intercept outgoing messages\n            const originalEmit = socket.emit;\n            socket.emit = (...args) => {\n                const packetSize = Utils.bufferFrom(JSON.stringify(args)).length - 2;\n                const data = { size: packetSize, timestamp: Date.now() };\n\n                this.updateBandwidthData(playerId, { outgoing: data });\n                const kbps = this.calculateKbps(this.bandwidthData[playerId]?.value.outgoing || []);\n                if (maxKbpsOutgoing && kbps > maxKbpsOutgoing) {\n                    socket.disconnect();\n                    return;\n                }\n\n                this.cleanOldData(this.bandwidthData[playerId]?.value.outgoing || []);\n                originalEmit.apply(socket, args);\n            };\n\n            next();\n        });\n    }\n\n    private updateBandwidthData(socketId: string, data: { incoming?: { size: number, timestamp: number }, outgoing?: { size: number, timestamp: number } }) {\n        const currentData = this.bandwidthData[socketId]?.value || { incoming: [], outgoing: [] };\n\n        if (data.incoming) {\n            currentData.incoming.push(data.incoming);\n        }\n        if (data.outgoing) {\n            currentData.outgoing.push(data.outgoing);\n        }\n\n        this.bandwidthData[socketId]?.next(currentData);\n    }\n\n    private cleanOldData(dataArray: { size: number, timestamp: number }[]) {\n        const cutOff = Date.now() - (this.WINDOW_SECONDS * 1000);\n        while (dataArray.length > 0 && dataArray[0].timestamp < cutOff) {\n            dataArray.shift();\n        }\n    }\n\n    private calculateKbps(dataArray: { size: number, timestamp: number }[]): number {\n        const totalBytes = dataArray.reduce((acc, entry) => acc + entry.size, 0);\n        return (totalBytes * 8) / (this.WINDOW_SECONDS * 1000); // Convert bytes to kilobits and divide by seconds\n    }\n\n    public getTelemetry(): {\n        sockets: Record<string, { incomingKbps: number, outgoingKbps: number }>,\n        totalKbps: number\n    } {\n        const socketsData: Record<string, { incomingKbps: number, outgoingKbps: number }> = {};\n        let totalKbps = 0;\n\n        for (const [socketId, bandwidth] of Object.entries(this.bandwidthData)) {\n            const socketData = bandwidth.value;\n            const incomingKbps = this.calculateKbps(socketData.incoming);\n            const outgoingKbps = this.calculateKbps(socketData.outgoing);\n            socketsData[socketId] = { incomingKbps, outgoingKbps };\n            totalKbps += incomingKbps + outgoingKbps;\n        }\n\n        return {\n            sockets: socketsData,\n            totalKbps\n        };\n    }\n}\n", "import { Room, RoomOptions } from './room'\nimport { Transmitter } from './transmitter'\nimport { Transport, TransportOptions } from './transports/socket'\nimport { User, UserState } from './rooms/default'\nimport { RoomClass } from './interfaces/room.interface'\nimport { BehaviorSubject } from 'rxjs'\nimport type { IAgonesOptions, IAgones } from './interfaces/agones.interface'\n\nexport class WorldClass {\n\n    private rooms: Map<string, RoomClass> = new Map()\n    public users: {\n        [key: string]: User\n    } = {}\n    private userClass = User\n    timeoutDisconnect: number = 0\n    changes: BehaviorSubject<any> = new BehaviorSubject({})\n    private _transport: Transport | null = null\n\n    public agonesSDK: IAgones | null = null\n    public agonesOptions: IAgonesOptions = {}\n\n    /**\n     * Define user class\n     * \n     * @method setUserClass()\n     * @returns {void}\n     */\n    setUserClass(userClass: any) {\n        this.userClass = userClass\n    }\n\n    setAgones(agones: IAgones, options: IAgonesOptions = {}) {\n        this.agonesSDK = agones\n        this.agonesOptions = options\n    }\n\n    /**\n     * Define transportation. You can set socket.io as default\n     * \n     * @method transport()\n     * @param {object} io\n     * @returns {Transport}\n     */\n    transport(io, options: TransportOptions = {}): Transport {\n        if (options.timeoutDisconnect) {\n            this.timeoutDisconnect = options.timeoutDisconnect\n        }\n        const transport = new Transport(io, options)\n        transport.onConnected(this.connectUser.bind(this))\n        transport.onDisconnected(this.disconnectUser.bind(this))\n        transport.onJoin(this.joinRoom.bind(this))\n        transport.onInput((id: string, prop: string, value: any) => {\n            this.forEachUserRooms(id, (room: RoomClass, user) => {\n                try {\n                    if (room.$inputs && room.$inputs[prop]) {\n                        room[prop] = value\n                    }\n                }\n                catch (err: any) {\n                    Transmitter.error(user, err)\n                }\n            })\n        })\n        transport.onAction((id: string, name: string, value: any) => {\n            this.forEachUserRooms(id, async (room, user) => {\n                if (room.$actions && room.$actions[name]) {\n                    try {\n                        room[name](user, value)\n                    }\n                    catch (err: any) {\n                        Transmitter.error(user, err)\n                    }\n                }\n            })\n        })\n        return this._transport = transport\n    }\n\n    /**\n     * Loop over all rooms of a user\n     * \n     * Example\n     * \n     * ```js\n     * World.forEachUserRooms('userid', (room, user) => {\n     *      console.log(room.id)\n     * })\n     * ```\n     * \n     * @method forEachUserRooms()\n     * @param {string} userId\n     * @param {(room: RoomClass, user: User)} cb\n     * @returns {void}\n     */\n    forEachUserRooms<T = User>(userId: string, cb: (room: RoomClass, user: T) => void): void {\n        const user = this.getUser(userId, true)\n        if (!user) return\n        for (let roomId of user._rooms) {\n            const room = this.getRoom(roomId) as RoomClass\n            cb(room, user as any)\n        }\n    }\n\n    /**\n    * Retrieves all users in the world\n    * \n    * @method getUsers()\n    * @returns { {[id: string]: User} }\n    */\n    getUsers<T = User>(): { [id: string]: T } {\n        return this.users as any\n    }\n\n    /**\n     * Get a user in the world\n     * \n     * @param {string} id User Id \n     * @param {boolean} [getProxy] Retrieves the proxied user. (true by default) \n     * @returns {User | null}\n     */\n    getUser<T = User>(id: string, getProxy: boolean = true): T | null {\n        if (!this.users[id]) return null\n        if (getProxy && this.users[id]['proxy']) {\n            return this.users[id]['proxy']\n        }\n        return this.users[id] as any\n    }\n\n    setUser(user, socket?) {\n        if (socket) user._socket = socket\n        user._rooms = []\n        this.users[user.id] = user\n        return this.users[user.id]\n    }\n\n    get nbUsers(): number {\n        return Object.keys(this.users).length\n    }\n\n    /**\n     * Send the packages to the rooms. \n     * \n     * @method send()\n     */\n    async send(): Promise<void> {\n        for (let [_, room] of this.rooms) {\n            const obj = room.$currentState()\n            if (Object.keys(obj).length == 0) {\n                continue\n            }\n            Transmitter.addPacket(room, obj)\n            for (let id in room.users) {\n                const user = room.users[id]\n                const packets = Transmitter.getPackets(room)\n                if (packets) {\n                    for (let packet of packets) {\n                        await Transmitter.emit(user, packet, room)\n                    }\n                }\n            }\n            room.$clearCurrentState()\n        }\n        Transmitter.clear()\n    }\n\n    /**\n     * Connect a user\n     * \n     * @method connectUser()\n     * @param {object} socket \n     * @param {id} userId \n     * @param {object} options\n     *  - getUserInstance: function that returns a new instance of the user\n     * @returns {User}\n     */\n    connectUser<T = User>(socket, id: string, options: {\n        getUserInstance?: any\n    } = {}): T {\n        const existingUser = this.getUser(id, false)\n        if (existingUser) {\n            if (existingUser._timeoutDisconnect) {\n                clearTimeout(existingUser._timeoutDisconnect)\n                delete existingUser._timeoutDisconnect\n            }\n            existingUser._socket = socket\n            existingUser.$state = UserState.Connected\n            return existingUser as any\n        }\n        const user = options.getUserInstance?.(socket) ?? new this.userClass()\n        user.id = id\n        socket.emit('uid', id)\n        this.setUser(user, socket)\n        return user as any\n    }\n\n    /**\n     * Removes the user from all rooms and removes him from the world\n     * \n     * @method disconnectUser()\n     * @param {string} userId \n     * @returns {void}\n     */\n    disconnectUser(userId: string): Promise<void> {\n        return new Promise((resolve: any, reject) => {\n            const user = this.getUser(userId)\n\n            if (!user) return resolve()\n\n            user.$state = UserState.Disconnected\n\n            const leave = () => {\n                const leaveAllPromises: Promise<void>[] = []\n                this.forEachUserRooms(userId, async (room: RoomClass, user: User) => {\n                    if (room.$leave) leaveAllPromises.push(room.$leave(user))\n                })\n                delete this.users[userId]\n                Promise.all(leaveAllPromises)\n                    .then(resolve)\n                    .catch(err => {\n                        Transmitter.error(user as User, err)\n                        reject(err)\n                    })\n            }\n\n            if (!this.timeoutDisconnect) {\n                leave()\n                return\n            }\n\n            user._timeoutDisconnect = setTimeout(leave, this.timeoutDisconnect)\n        })\n    }\n\n    httpUpgrade(httpServer, io) {\n        httpServer.removeAllListeners(\"upgrade\");\n\n        httpServer.on(\"upgrade\", (req: any, socket, head) => {\n            if (req.url.startsWith(\"/socket.io/\")) {\n                io.engine.handleUpgrade(req, socket, head);\n            } else {\n                socket.destroy();\n            }\n        })\n    }\n\n    private async joinOrLeaveRoom(type: string, roomId: string, userId: string): Promise<RoomClass | undefined> {\n        const room = this.getRoom(roomId)\n        if (!room) return\n        if (room[type]) {\n            try {\n                await room[type](this.getUser(userId, false))\n            }\n            catch (err: any) {\n                Transmitter.error(this.getUser(userId, false) as User, err)\n                throw err\n            }\n        }\n        return room\n    }\n\n    /**\n     * Leave an existing room\n     * \n     * @param {string} roomId \n     * @param {string} userId \n     * @returns {RoomClass | undefined}\n     */\n    async leaveRoom(roomId: string, userId: string): Promise<RoomClass | undefined> {\n        return this.joinOrLeaveRoom('$leave', roomId, userId)\n    }\n\n    /**\n     * Join an existing room\n     * \n     * @param {string} roomId \n     * @param {string} userId \n     * @returns {RoomClass | undefined}\n     */\n    async joinRoom(roomId: string, userId: string): Promise<RoomClass | undefined> {\n        return this.joinOrLeaveRoom('$join', roomId, userId)\n    }\n\n    /**\n     * Add Room\n     * \n     * Example 1:\n     * \n     * ```js\n     * class ChessRoom {\n     * \n     * }\n     * \n     * World.addRoom('myroom', ChessRoom)\n     * ```\n     * \n     * Example 2:\n     * \n     * ```js\n     * class ChessRoom {\n     *  constructor(name) { }\n     * }\n     * \n     * World.addRoom('myroom', new ChessRoom('test'))\n     * ```\n     * \n     * @param {string} id room id \n     * @param {Class or instance of Class} roomClass \n     * @returns instance of Class\n     */\n    addRoom<T = any>(id: string, roomClass, options: RoomOptions = {}): T {\n        if (roomClass.constructor.name == 'Function') {\n            roomClass = new roomClass()\n        }\n        const room = new Room(options).add(id, roomClass)\n        this.rooms.set(id, room)\n        if (this.agonesSDK) {\n            this.agonesSDK.setLabel('room.id', id)\n        }\n        return room as any\n    }\n\n    /**\n     * Get an existing room\n     * \n     * @param {string} roomId \n     * @returns {RoomClass}\n     */\n    getRoom(id: string): RoomClass | undefined {\n        return this.rooms.get(id)\n    }\n\n    /**\n     * Recover the rooms of the world\n     * \n     * @param {string} roomId \n     * @returns {Map<string, RoomClass>}\n     */\n    getRooms() {\n        return this.rooms\n    }\n\n    /**\n     * Delete the room\n     * \n     * @param {string} roomId \n     * @returns {void}\n     */\n    removeRoom(id: string): void {\n        this.rooms.delete(id)\n    }\n\n    /**\n     * Remove all rooms and users\n     */\n    clear() {\n        this.rooms.clear()\n        this.changes.next({})\n        this.users = {}\n        if (this._transport) {\n            this._transport.io?.clear?.()\n        }\n    }\n}\n\nexport const World = new WorldClass()", "export class User {\n    static schema = {}\n    id: string\n    _socket\n    _rooms = []\n}", "class MiddlewareHandler {\n    middlewares: any[] = [];\n\n    use(middleware) {\n        this.middlewares.push(middleware);\n    }\n\n    run(socket, finalCallback = (err?) => { }) {\n        let index = 0;\n\n        const next = (err?) => {\n\n            if (err) {\n                finalCallback(err);\n                return;\n            }\n\n            if (index >= this.middlewares.length) {\n                finalCallback();\n                return;\n            }\n\n            const middleware = this.middlewares[index];\n            index += 1;\n\n            middleware(socket, next);\n        };\n\n        next();\n    }\n\n    clear() {\n        this.middlewares = []\n    }\n}\n\n\nclass MockIo {\n    events: Map<string, any[]> = new Map()\n    eventsOnce: Map<string, any> = new Map()\n\n    on(name: string, value) {\n        this.events.set(name, [...(this.events.get(name) || []), value])\n    }\n\n    off(name: string) {\n        if (this.eventsOnce.has(name)) {\n            this.eventsOnce.delete(name)\n            return\n        }\n        this.events.delete(name)\n    }\n\n    once(name: string, value) {\n        this.eventsOnce.set(name, value)\n    }\n\n    _trigger(name: string, data, client?) {\n        const events = this.events.get(name) || []\n        for (const event of events) {\n            event(data, client)\n        }\n        const eventOnce = this.eventsOnce.get(name)\n        if (eventOnce) {\n            eventOnce(data, client)\n            this.eventsOnce.delete(name)\n        }\n    }\n}\n\nclass MockSocket extends MockIo {\n    id: string\n    middlewares = new MiddlewareHandler()\n\n    constructor(public handshake, private client) {\n        super()\n        this.id = client.fakeId ?? '' + Math.random()\n        this.client.id = this.id\n    }\n\n    emit(name: string, data) {\n        this.client._trigger(name, data)\n    }\n\n    removeAllListeners(name: string) {\n        return this.off(name)\n    }\n\n    use(cb: (packet, next) => void) {\n        this.middlewares.use(cb)\n    }\n\n    disconnect() { }\n}\n\nclass MockClientIo extends MockIo {\n    id: string = ''\n    _socket: any = null\n\n    constructor(public fakeId?: string) {\n        super()\n    }\n\n    async connection(handshake?: any) {\n        this._socket = await serverIo.connection(this, handshake)\n        this._trigger('connect', undefined)\n        return this\n    }\n\n    emit(name: string, data) {\n        if (!this._socket) throw new Error('Client not connected')\n        this._socket.middlewares.run([name, data], (err) => {\n            if (err) {\n                this._trigger('error', err)\n                return\n            }\n            serverIo.emit(name, data, this.id)\n        })\n        return this\n    }\n\n    disconnect() {\n        this.emit('disconnect', undefined)\n    }\n}\n\nclass MockServerIo extends MockIo {\n    private clients: Map<string, MockSocket> = new Map()\n    private middlewares = new MiddlewareHandler()\n\n    connection(client, handshake): Promise<MockSocket> {\n        return new Promise((resolve, reject) => {\n            const socket = new MockSocket(handshake, client)\n            this.clients.set(socket.id, socket)\n            client.id = socket.id\n            this.middlewares.run(socket, (err) => {\n                if (err) {\n                    client._trigger('error', err)\n                    return\n                }\n                this._trigger('connection', socket)\n                resolve(socket)\n            })\n        })\n    }\n\n    emit(name: string, data, id) {\n        this.clients.get(id)?._trigger(name, data)\n    }\n\n    use(cb: (socket, next) => void) {\n        this.middlewares.use(cb)\n    }\n\n    clear() {\n        this.events.clear()\n        this.eventsOnce.clear()\n        this.clients.clear()\n        this.middlewares.clear()\n    }\n}\n\nconst serverIo = new MockServerIo()\nconst ClientIo = MockClientIo\n\nexport default {\n    serverIo,\n    ClientIo\n}", "import { RpgCommonPlayer, Utils, RpgPlugin, RpgCommonGame, RpgCommonMap, Direction } from '@rpgjs/common'\nimport { Room, WorldClass } from 'simple-room'\nimport { RpgMap, EventPosOption } from '../Game/Map'\nimport { Query } from '../Query'\nimport merge from 'lodash.merge'\nimport { ItemManager } from './ItemManager'\nimport { GoldManager } from './GoldManager'\nimport { StateManager } from './StateManager';\nimport { SkillManager } from './SkillManager'\nimport { ParameterManager } from './ParameterManager';\nimport { EffectManager } from './EffectManager';\nimport { ClassManager } from './ClassManager';\nimport { ElementManager } from './ElementManager'\nimport { GuiManager } from './GuiManager'\nimport { VariableManager } from './VariableManager'\nimport { Frequency, MoveManager, Speed } from './MoveManager'\nimport { BattleManager } from './BattleManager'\n\nimport {\n    MAXHP,\n    MAXSP,\n    STR,\n    INT,\n    DEX,\n    AGI,\n    MAXHP_CURVE,\n    MAXSP_CURVE,\n    STR_CURVE,\n    INT_CURVE,\n    DEX_CURVE,\n    AGI_CURVE\n} from '../presets'\nimport { RpgServerEngine } from '../server'\nimport { RpgClassMap } from '../Scenes/Map'\nimport { RpgTiledWorldMap } from '../Game/WorldMaps'\nimport { CameraOptions, PositionXY_OptionalZ, SocketEvents, SocketMethods, LayoutObject } from '@rpgjs/types'\nimport { ComponentManager } from './ComponentManager'\nimport { Subject } from 'rxjs'\nimport { EventManager, EventMode } from '../Game/EventManager'\nimport { inject } from '../inject'\n\nconst {\n    isPromise,\n    applyMixins,\n    isString\n} = Utils\n\nexport interface Position { x: number, y: number, z: number }\n\nconst commonSchemaFeature = {\n    name: {\n        $permanent: false\n    },\n    description: {\n        $permanent: false\n    },\n    id: String\n}\n\nconst itemSchemas = {\n    price: {\n        $permanent: false\n    },\n    consumable: {\n        $permanent: false\n    },\n    ...commonSchemaFeature\n}\n\nexport const componentSchema = { id: String, value: String }\nexport const layoutSchema = {\n    width: Number,\n    height: Number,\n    marginBottom: Number,\n    marginTop: Number,\n    marginLeft: Number,\n    marginRight: Number,\n    lines: [{\n        col: [componentSchema]\n    }]\n}\n\nconst playerSchemas = {\n    position: {\n        x: Number,\n        y: Number,\n        z: Number\n    },\n    direction: Number,\n\n    teleported: {\n        $permanent: false\n    },\n\n    deleted: {\n        $permanent: false\n    },\n\n    moving: {\n        $permanent: false\n    },\n\n    param: Object,\n    hp: Number,\n    sp: Number,\n    gold: Number,\n    level: {\n        $effects: ['$this.expForNextlevel', '$this.param']\n    },\n    expForNextlevel: {\n        $permanent: false\n    },\n    exp: Number,\n    name: String,\n    items: [{ nb: Number, item: itemSchemas }],\n    _class: commonSchemaFeature,\n    equipments: [itemSchemas],\n    skills: [\n        {\n            spCost: {\n                $permanent: false\n            },\n            ...commonSchemaFeature\n        }\n    ],\n    states: [commonSchemaFeature],\n    effects: [String],\n\n    layout: {\n        top: layoutSchema,\n        bottom: layoutSchema,\n        left: layoutSchema,\n        right: layoutSchema,\n        center: layoutSchema\n    },\n\n    action: Number,\n    map: String,\n\n    speed: Number,\n    frequency: Number,\n    canMove: Boolean,\n    through: Boolean,\n    throughOtherPlayer: Boolean,\n\n    width: Number,\n    height: Number,\n    wHitbox: Number,\n    hHitbox: Number,\n\n    // only for server\n\n    _statesEfficiency: [{\n        rate: {\n            $syncWithClient: false\n        },\n        state: {\n            $syncWithClient: false\n        }\n    }],\n    tmpPositions: {\n        $syncWithClient: false\n    },\n    initialLevel: {\n        $syncWithClient: false\n    },\n    finalLevel: {\n        $syncWithClient: false\n    },\n}\n\nconst layoutObject = {\n    lines: []\n}\n\nexport class RpgPlayer extends RpgCommonPlayer {\n    public readonly type: string = 'player'\n    static schemas = {\n        ...playerSchemas,\n        events: [playerSchemas]\n    }\n\n    layout: LayoutObject<any> = {\n        top: layoutObject,\n        bottom: layoutObject,\n        left: layoutObject,\n        right: layoutObject,\n        center: layoutObject\n    }\n\n    private _name\n    public events: any = {}\n    public param: any\n    public _rooms = []\n    public session: string | null = null\n    public prevMap: string = ''\n\n    /** \n    * ```ts\n    * retreive the server instance\n    * ``` \n    * @title Server Instance\n    * @prop {RpgServerEngine} player.server\n    * @deprecated Use `inject(RpgServerEngine)` instead. Will be removed in v5\n    * @memberof Player\n    * */\n    public server: RpgServerEngine\n    private touchSide: boolean = false\n\n    /** @internal */\n    public tmpPositions: Position | string | null = null\n    public otherPossessedPlayer: RpgPlayer | RpgEvent | null = null\n    public followingId: string | null = null\n\n    // Indicates whether to load data with load(). In this case, hooks are not triggered.\n    private _dataLoading: boolean = false\n\n    _lastFramePositions: {\n        frame: number\n        position: Position\n    } | undefined\n\n    /**\n     * @deprecated Use `inject(RpgCommonGame)` instead. Will be removed in v5\n     */\n    public gameEngine: RpgCommonGame = inject(RpgCommonGame)\n\n    // redefine type (as RpgPlayer)\n    get otherPlayersCollision(): RpgPlayer[] {\n        return super.otherPlayersCollision as RpgPlayer[]\n    }\n\n    get world(): WorldClass | undefined {\n        return this.server?.world\n    }\n\n    // As soon as a teleport has been made, the value is changed to force the client to change the positions on the map without making a move.\n    teleported: number = 0\n\n    // a flag that lets the client know if the event is suppressed. The client can, for example, end animations before completely deleting the object (client side).\n    deleted: boolean = false\n\n    constructor(public playerId: string) {\n        super(inject(RpgCommonGame), playerId)\n        this.initialize()\n    }\n\n    /** @internal */\n    initialize() {\n        this.server = inject(RpgServerEngine)\n        this.expCurve = {\n            basis: 30,\n            extra: 20,\n            accelerationA: 30,\n            accelerationB: 30\n        }\n        this.parameters = new Map()\n        this.variables = new Map()\n        this.states = []\n        this.equipments = []\n        this._effects = []\n        this.items = []\n        this.skills = []\n        this.gold = 0\n        this.exp = 0\n        this.speed = Speed.Normal\n        this.frequency = Frequency.None\n        this.canMove = true\n        this.through = false\n        this.throughOtherPlayer = true\n        this.initialLevel = 1\n        this.finalLevel = 99\n        this.level = this.initialLevel\n        this._gui = {}\n        this._elementsEfficiency = []\n        this._statesEfficiency = []\n        this.moving = false\n\n        this.addParameter(MAXHP, MAXHP_CURVE)\n        this.addParameter(MAXSP, MAXSP_CURVE)\n        this.addParameter(STR, STR_CURVE)\n        this.addParameter(INT, INT_CURVE)\n        this.addParameter(DEX, DEX_CURVE)\n        this.addParameter(AGI, AGI_CURVE)\n        this.allRecovery()\n    }\n\n    _init() {\n        this._socket.on('gui.interaction', ({ guiId, name, data }) => {\n            if (this._gui[guiId]) {\n                this._gui[guiId].emit(name, data)\n                this.syncChanges()\n            }\n        })\n        this._socket.on('gui.exit', ({ guiId, data }) => {\n            this.removeGui(guiId, data)\n        })\n    }\n\n    private get schema() {\n        return {\n            ...RpgPlayer.schemas,\n            ...this.server['playerProps']\n        }\n    }\n\n    /** \n     * ```ts\n     * player.name = 'Link'\n     * ``` \n     * @title Read/Give a name\n     * @prop {string} player.name\n     * @memberof Player\n     * */\n    get name(): string {\n        return this._name\n    }\n\n    set name(val: string) {\n        this._name = val\n    }\n\n    /**\n     * Change your map. Indicate the positions to put the player at a place on the map\n     * \n     * > The map must be added to RpgServer beforehand. Guide: [Create Map](/guide/create-map.html)\n     * \n     * You don't have to give positions but you can put a starting position in the TMX file. Guide: [Start Position](/guide/player-start.html)\n     * \n     * @title Change Map\n     * @method player.changeMap(mapId,positions)\n     * @param {string} mapId\n     * @param { {x: number, y: number, z?: number} | string } [positions]\n     * @returns {Promise<RpgMap | null>} null if map not exists\n     * @memberof Player\n     */\n    changeMap(mapId: string, positions?: { x: number, y: number, z?: number } | string): Promise<RpgMap | null | boolean> {\n        return this.server.sceneMap.changeMap(mapId, this, positions)\n    }\n\n    async autoChangeMap(nextPosition: Position): Promise<boolean> {\n        const map = this.getCurrentMap()\n        const worldMaps = map?.getInWorldMaps()\n        let ret: boolean = false\n        if (worldMaps && map) {\n            const direction = this.getDirection()\n            const marginLeftRight = map.tileWidth / 2\n            const marginTopDown = map.tileHeight / 2\n\n            const changeMap = async (adjacent, to) => {\n                if (this.touchSide) {\n                    return false\n                }\n                this.touchSide = true\n                const [nextMap] = worldMaps.getAdjacentMaps(map, adjacent) as RpgClassMap<RpgMap>[]\n                if (!nextMap) return false\n                const id = nextMap.id as string\n                const nextMapInfo = worldMaps.getMapInfo(id) as RpgTiledWorldMap\n                return !!(await this.changeMap(id, to(nextMapInfo)))\n            }\n\n            if (nextPosition.x < marginLeftRight && direction == Direction.Left) {\n                ret = await changeMap({\n                    x: map.worldX - 1,\n                    y: this.worldPositionY + 1\n                }, nextMapInfo => ({\n                    x: (nextMapInfo.width) - this.wHitbox - marginLeftRight,\n                    y: map.worldY - nextMapInfo.y + nextPosition.y\n                }))\n            }\n            else if (nextPosition.x > map.widthPx - this.wHitbox - marginLeftRight && direction == Direction.Right) {\n                ret = await changeMap({\n                    x: map.worldX + map.widthPx + 1,\n                    y: this.worldPositionY + 1\n                }, nextMapInfo => ({\n                    x: marginLeftRight,\n                    y: map.worldY - nextMapInfo.y + nextPosition.y\n                }))\n            }\n            else if (nextPosition.y < marginTopDown && direction == Direction.Up) {\n                ret = await changeMap({\n                    x: this.worldPositionX + 1,\n                    y: map.worldY - 1\n                }, nextMapInfo => ({\n                    x: map.worldX - nextMapInfo.x + nextPosition.x,\n                    y: (nextMapInfo.height) - this.hHitbox - marginTopDown,\n                }))\n            }\n            else if (nextPosition.y > map.heightPx - this.hHitbox - marginTopDown && direction == Direction.Down) {\n                ret = await changeMap({\n                    x: this.worldPositionX + 1,\n                    y: map.worldY + map.heightPx + 1\n                }, nextMapInfo => ({\n                    x: map.worldX - nextMapInfo.x + nextPosition.x,\n                    y: marginTopDown,\n                }))\n            }\n            else {\n                this.touchSide = false\n            }\n        }\n        return ret\n    }\n\n    /**\n     * Dynamically create an event in Scenario mode on the current map\n     * \n     * ```ts\n     * @EventData({\n     *  name: 'EV-1'\n     * })\n     * class MyEvent extends RpgEvent {\n     *  onAction() {\n     *      console.log('ok')\n     *  }\n     * } \n     *\n     * player.createDynamicEvent({\n     *      x: 100,\n     *      y: 100,\n     *      event: MyEvent\n     * })\n     * ```\n     * \n     * You can also put an array of objects to create several events at once\n     * \n     * @title Create Dynamic Event\n     * @since 3.0.0-beta.4\n     * @method player.createDynamicEvent(eventObj | eventObj[])\n     * @param { { x: number, y: number, z?: number, event: eventClass } } [eventsList]\n     * @returns { { [eventId: string]: RpgEvent } }\n     * @memberof Player\n     */\n    createDynamicEvent(eventsList: EventPosOption | EventPosOption[], forceMode: boolean = true): {\n        [eventId: string]: RpgEvent\n    } {\n        if (!eventsList) return {}\n        const mapInstance = this.getCurrentMap<RpgMap>()\n        if (!mapInstance) {\n            throw 'The player is not assigned to any map'\n        }\n        if (!Utils.isArray(eventsList)) {\n            eventsList = [eventsList as EventPosOption]\n        }\n        let eventsListMode = eventsList\n        if (forceMode) {\n            eventsListMode = (eventsList as EventPosOption[]).map(event => {\n                event.event.mode = EventMode.Scenario\n                return event\n            })\n        }\n        const events = mapInstance.createEvents(eventsListMode as EventPosOption[], EventMode.Scenario)\n        let ret = {}\n        for (let key in events) {\n            this.events[key] = events[key]\n            this.events[key].playerRelated = this\n            this.events[key].execMethod('onInit', [this])\n            // force to get Proxy object to sync with client\n            ret = { ...ret, [key]: this.events[key] }\n        }\n        return ret\n    }\n\n    /**\n     * Allows to change the positions of the player on the current map. \n     * You can put the X and Y positions or the name of the created shape on Tiled Map Editor.\n     * If you have several shapes with the same name, one position will be chosen randomly.\n     * \n     * ```ts\n     * player.teleport({ x: 100, y: 500 })\n     * ```\n     * \n     * or\n     * \n     * ```ts\n     * player.teleport('my-shape-name')\n     * ```\n     * \n     * If no parameter: \n     * \n     * ```ts\n     * player.teleport() // { x: 0, y: 0, z: 0 }\n     * ```\n     * \n     * @title Teleport on the map\n     * @method player.teleport(positions)\n     * @param { {x: number, y: number, z?: number} | string } [positions]\n     * @returns {Promise<{ {x: number, y: number, z: number} }>}\n     * @memberof Player\n     */\n    async teleport(positions?: PositionXY_OptionalZ | string): Promise<Position> {\n        if (isString(positions)) positions = <Position>this.getCurrentMap()?.getPositionByShape(shape => shape.name == positions || shape.getType() == positions)\n        if (!positions) positions = { x: 0, y: 0, z: 0 }\n        if (!(positions as Position).z) (positions as Position).z = 0\n        this.teleported++\n        this.position = positions as Position\n        // delete last frame positions because when the character is teleported, no server reconciliation is needed on the client side\n        this._lastFramePositions = undefined\n        // force interaction with event or shape\n        await this.isCollided(this.position)\n        return (positions as Position)\n    }\n\n    /**\n     * Load the saved data with the method save()\n     * If the player was on a map, it repositions the player on the map. \n     * \n     * ```ts\n     * const json = player.save()\n     * player.load(json)\n     * ```\n     * \n     * @title Load progress\n     * @method player.load(json)\n     * @param {string} json The JSON sent by the method save()\n     * @returns {Promise<boolean | RpgMap | null>}\n     * @memberof Player\n     */\n    async load(json: any): Promise<boolean | RpgMap | null> {\n        this._dataLoading = true\n\n        if (isString(json)) json = JSON.parse(json)\n\n        const getData = (id) => new (this.databaseById(id))()\n\n        for (let key in json) {\n            const val = json[key]\n            if (Utils.isObject(val) && val.hasOwnProperty('0')) {\n                json[key] = Object.values(val)\n            }\n        }\n\n        const items = {}\n\n        if (json.items) {\n            for (let it of json.items) {\n                items[it.item.id] = getData(it.item.id)\n            }\n            json.items = json.items.map(it => ({ nb: it.nb, item: items[it.item.id] }))\n            if (Array.isArray(json.equipments)) {\n                json.equipments = json.equipments.map(it => {\n                    items[it.id].equipped = true\n                    return items[it.id]\n                })\n            }\n        }\n        if (json.states) json.states = json.states.map(state => getData(state.id))\n        if (json.skills) json.skills = json.skills.map(skill => getData(skill.id))\n        if (json.variables) json.variables = new Map(json.variables)\n\n        merge(this, json)\n\n        this.position = json.position\n\n        if (json.map) {\n            this.map = ''\n            const map = await this.changeMap(json.map, json.tmpPositions || json.position)\n            this._dataLoading = false\n            return map\n        }\n\n        this._dataLoading = false\n\n        return null\n    }\n\n    /**\n     * Returns a JSON with all the data to keep in memory. Then use the `load()` method to load the data\n     * \n     * You can also use the JSON.stringify \n     * \n     * ```ts\n     * const json = player.save() // or JSON.stringify(player)\n     * player.load(json)\n     * ```\n     * \n     * @title Save progress\n     * @method player.save()\n     * @returns {string}\n     * @memberof Player\n     */\n    save() {\n        return JSON.stringify(this)\n    }\n\n    // TODO\n    toObject() {\n        return {\n            direction: this.direction,\n            id: this.id,\n            canMove: this.canMove,\n            position: {\n                x: this.position.x,\n                y: this.position.y,\n                z: this.position.z\n            },\n            hitbox: {\n                width: this.wHitbox,\n                height: this.hHitbox\n            },\n            map: this.map,\n            pendingMove: this.pendingMove,\n            speed: this.speed\n        }\n    }\n\n    toJSON() {\n        const { permanentObject } = Room.compileSchema(this.schema)\n        const snapshot = Room.extractObjectOfRoom(this, permanentObject)\n        snapshot.variables = [...this.variables]\n        return snapshot\n    }\n\n    /**\n     * Run the change detection cycle. Normally, as soon as a hook is called in a class, the cycle is started. But you can start it manually\n     * The method calls the `onChanges` method on events and synchronizes all map data with the client.\n\n     * @title Run Sync Changes\n     * @method player.syncChanges()\n     * @returns {void}\n     * @memberof Player\n     */\n    syncChanges() {\n        this._eventChanges()\n    }\n\n    databaseById(id: string) {\n        const data = this.server.database[id]\n        if (!data) throw new Error(`The ID=${id} data is not found in the database. Add the data in the property \"database\" of @RpgServer decorator.`)\n        return data\n    }\n\n    /**\n     * Retrieves data from the current map\n     * \n     * returns null if the player is not assigned to a map\n     * \n     * @title Get Current Map\n     * @method player.getCurrentMap()\n     * @returns {RpgMap | null}\n     * @memberof Player\n     */\n    getCurrentMap<T extends RpgMap = RpgMap>(): T | null {\n        return this._getMap(this.map)\n    }\n\n    loadScene(name: string, data: any): void {\n        this.emit(SocketEvents.LoadScene, {\n            name,\n            data\n        })\n    }\n\n    emitSceneMap() {\n        const mapInstance = this.getCurrentMap<RpgMap>()\n        if (!mapInstance) {\n            throw '[Emit] The player is not assigned to any map'\n        }\n        let { data: serializeMap } = Object.assign({}, mapInstance) as any\n        delete serializeMap.shapes\n        delete serializeMap.events\n        delete serializeMap._events\n\n        for (let layer of serializeMap.layers) {\n            delete layer.map\n        }\n\n        this.loadScene('map', {\n            id: mapInstance.id,\n            sounds: mapInstance.sounds,\n            ...serializeMap\n        })\n    }\n\n    gameReload() {\n        this.emit(SocketEvents.GameReload)\n    }\n\n    changeServer(url: string, port: number) {\n        this.emit(SocketEvents.ChangeServer, {\n            url,\n            port\n        })\n    }\n\n    private _getMap(id) {\n        return RpgCommonMap.buffer.get(id)\n    }\n\n    /**\n     * Calls the showAnimation() method on the client side to display an animation on the player\n     * You must remember to create the spritesheet beforehand\n     * \n     * For this type of spritesheet:\n     * \n     * ```ts\n     * @Spritesheet({\n     *  id: 'fire',\n     *  image: require('')\n     *  textures: {\n     *      default: {\n     *          animations: [\n     *          \n     *          ]\n     *      }\n     *   }\n     * })\n     * export class FireAnimation {}\n     * ```\n     * \n     * Here is the call of the method:\n     * \n     * ```ts\n     * player.showAnimation('fire', 'default')\n     * ```\n     * \n     * If you don't want to put an animation on top of the event but replace the event graphic with another one, set true as last parameter.\n     * This is useful, if for example, you want to make an animated character (sword stroke when pressing a key)\n     * When the animation is finished, the original graphic is displayed again\n     * \n     * \n     * ```ts\n     * player.showAnimation('sword_stroke', 'default', true)\n     * ```\n     * \n     * Since version 3.0.0-rc, you can define several graphic elements. This allows you to animate them all at once\n     * \n     * ```ts\n     * player.showAnimation(['body', 'sword_stroke'], 'default', true)\n     * ```\n     * \n     * ::: tip\n     * For this to work, the animations must have been previously defined in `setGraphic`.\n     * :::\n     * \n     * @title Show Animation\n     * @method player.showAnimation(graphic,animationName,replaceGraphic=false)\n     * @param {string | string[]} graphic spritesheet identifier\n     * @param {string} animationName Name of the animation in the spritesheet\n     * @param {boolean} [replaceGraphic] Replace the event graphic with the animation. After the end of the animation, the original graphic is reapplied\n     * @returns {void}\n     * @memberof Player\n     */\n    showAnimation(graphic: string | string[], animationName: string, replaceGraphic: boolean = false) {\n        this.emitToMap('callMethod', {\n            name: SocketMethods.ShowAnimation,\n            params: [graphic, animationName, replaceGraphic]\n        })\n    }\n\n    /**\n     * TODO:\n     * 1. It is necessary, on the client side, to make the character move even if controlled by someone else (problem: same playerId so, one will not move because of the client side prediction. Solution: create a new Id ? like session Id ?\n     * 2. You would need several sockets per character. If the character changes map or changes server, all players controlling the character must be able to see it\n     * 3. If the player regains control, what happens, do we return to the previous map?\n     * 4. If it's an event, you must be able to get the event by id in GameEngine\n     */\n    takePossessionOf(otherPlayer: RpgPlayer | RpgEvent) {\n        this.otherPossessedPlayer = otherPlayer\n        this._socket.emit('playerJoined', { playerId: otherPlayer.id, session: this.session })\n        this.cameraFollow(otherPlayer)\n    }\n\n    /**\n     * Sends the client which event or player the camera should follow. You can set options to perform a motion animation\n     * \n     * @title Camera Follow\n     * @method player.cameraFollow(otherPlayer,options)\n     * @param {RpgPlayer | RpgEvent} otherPlayer\n     * @param {options} options\n     * @param {object | boolean} [options.smoothMove] - animate. Set a boolean to use default parameters\n     * @param {number} [options.smoothMove.time=1000] - time to animate\n     * @param {string} [options.smoothMove.ease=linear] - easing to use. Go to https://easings.net to get function name\n     * @returns {void}\n     * @since 3.1.0\n     * @memberof Player\n     */\n    cameraFollow(otherPlayer: RpgPlayer | RpgEvent, options: CameraOptions = {}) {\n        if (otherPlayer.id == this.id) {\n            this.followingId = null\n        }\n        else {\n            this.followingId = otherPlayer.id\n        }\n        this.emit(SocketEvents.CallMethod, {\n            objectId: this.playerId,\n            name: SocketMethods.CameraFollow,\n            params: [otherPlayer.id, options]\n        })\n    }\n\n    /**\n     * Emit data to clients with socket\n     * \n     * @title Emit to client\n     * @method player.emit(key,value)\n     * @param {string} key\n     * @param {any} value\n     * @returns {void}\n     * @memberof Player\n     */\n    public emit(key: string, value?: any): void {\n        if (this._socket) this._socket.emit(key, value)\n    }\n\n\n    /**\n     * Listen to the data (socket) sent by the client\n     * \n     * @title Listen to data from the client\n     * @method player.on(key,cb)\n     * @param {string} key\n     * @param {function} cb\n     * @returns {void}\n     * @memberof Player\n     */\n    public on(key: string, cb: Function) {\n        if (this._socket) this._socket.on(key, cb)\n    }\n\n    /**\n     * Adds a one-time listener function for the event named eventName\n     * \n     * @title Listen one-time to data from the client\n     * @method player.once(key,cb)\n     * @since 3.0.0-beta.5\n     * @param {string} key\n     * @param {function} cb\n     * @returns {void}\n     * @memberof Player\n     */\n    public once(key: string, cb: Function) {\n        if (this._socket) this._socket.once(key, cb)\n    }\n\n    /**\n     * Removes all listeners of the specified eventName.\n     * \n     * @title Removes all listeners of the client\n     * @method player.off(key)\n     * @since 3.0.0-beta.5\n     * @param {string} key\n     * @returns {void}\n     * @memberof Player\n     */\n    public off(key: string) {\n        if (this._socket) this._socket.removeAllListeners(key)\n    }\n\n    disconnect() {\n        if (this._socket) this._socket.disconnect()\n    }\n\n    emitToMap(key: string, value: any) {\n        const map = this.getCurrentMap()\n        if (map) {\n            map.$setCurrentState(`users.${this.id}.${key}`, value)\n        }\n    }\n\n    private execMethodSync<T>(methodName: string, methodData = [], target?: any): T {\n        let ret\n        if (target && target[methodName]) {\n            ret = target[methodName](...methodData)\n        }\n        return ret\n    }\n\n    async execMethod(methodName: string, methodData = [], target?: any) {\n        const ignoreIfDataLoading = ['onLevelUp', 'onDead']\n        if (ignoreIfDataLoading.includes(methodName) && this._dataLoading) {\n            return\n        }\n        let ret\n        if (target && target[methodName]) {\n            ret = target[methodName](...methodData)\n            if (isPromise(ret)) await ret\n        }\n        else {\n            ret = await RpgPlugin.emit(`Server.${methodName}`, [this, ...methodData], true)\n        }\n        this.syncChanges()\n        return ret\n    }\n\n    _triggerHook(name, val?) {\n        if (this[name]) this[name](val)\n        this.emit('Player.' + name, val)\n    }\n\n    // @internal\n    /**\n     * Allows you to manually update a status in the rooms that will then be sent to the customer.\n     * @param path \n     * @example\n     * ```ts\n     * player.changeRoomState('hp')\n     * ```\n     */\n    changeRoomState(path: string) {\n        this.world?.forEachUserRooms(this.id, (room) => {\n            (room as any).$setCurrentState(`users.${this.id}.${path}`)\n        })\n    }\n\n    private _eventChanges() {\n        if (!this._getMap(this.map)) return\n        const {\n            events\n        } = this._getMap(this.map)\n        const arrayEvents: any[] = [...Object.values(this.events), ...Object.values(events)]\n        for (let event of arrayEvents) {\n            if (event.onChanges) event.onChanges(this)\n        }\n    }\n\n    /**\n     * Allows to play a sound, heard only by the player or by the players of the map\n     * \n     * Here is a sound, client side:\n     * \n     * ```ts\n     * import { Sound } from '@rpgjs/client'\n     * @Sound({\n     *      id: 'town-music',\n     *      sound: require('./sound/town.ogg')\n     * })\n     * export class TownMusic {}\n     * ```\n     * \n     * Here is the call of the method, server side:\n     * \n     * ```ts\n     * player.playSound('town-music')\n     * ```\n     * \n     * If you want everyone to listen to the sound on the map:\n     * \n     * ```ts\n     * player.playSound('town-music', true)\n     * ```\n     * \n     * @title Play Sound\n     * @method player.playSound(soundId,allMap=false)\n     * @param {string} soundId Sound identifier, defined on the client side\n     * @param {boolean} [forEveryone=false] Indicate if the sound is heard by the players on the map\n     * @since 3.0.0-alpha.9\n     * @returns {void}\n     * @memberof Player\n     */\n    playSound(soundId: string, forEveryone: boolean = false) {\n        const obj = {\n            objectId: this.playerId,\n            name: SocketMethods.PlaySound,\n            params: [soundId]\n        }\n        if (!forEveryone) {\n            this.emit(SocketEvents.CallMethod, obj)\n            return\n        }\n        this.emitToMap(SocketEvents.CallMethod, obj)\n    }\n\n}\n\nexport interface RpgPlayer extends\n    EventManager,\n    ItemManager,\n    GoldManager,\n    StateManager,\n    SkillManager,\n    ParameterManager,\n    EffectManager,\n    ClassManager,\n    ElementManager,\n    GuiManager,\n    VariableManager,\n    MoveManager,\n    BattleManager,\n    ComponentManager {\n    _socket: any\n    vision,\n    attachShape: any\n}\n\napplyMixins(RpgPlayer, [\n    EventManager,\n    ItemManager,\n    GoldManager,\n    StateManager,\n    SkillManager,\n    ParameterManager,\n    EffectManager,\n    ClassManager,\n    ElementManager,\n    GuiManager,\n    VariableManager,\n    MoveManager,\n    BattleManager,\n    ComponentManager\n])\n\nexport interface RpgClassEvent<T> {\n    _name: string\n    new(): T,\n}\n\nexport class RpgEvent extends RpgPlayer {\n\n    public readonly type: string = 'event'\n    properties: any = {}\n    mode: EventMode\n    playerRelated: RpgPlayer | null = null\n\n    constructor(playerId: string) {\n        super(playerId)\n    }\n\n    async execMethod(methodName: string, methodData = []) {\n        if (!this[methodName]) {\n            return\n        }\n        const ret = this[methodName](...methodData)\n        return ret\n    }\n\n    changeRoomState(path: string) {\n        const room = this.getCurrentMap()\n        if (room) {\n            (room as any).$setCurrentState(`events.${this.id}.${path}`)\n        }\n    }\n\n    /**\n    * Deletes the event from the map (in shared or scenario mode)\n    * \n    * @title Remove\n    * @since 4.0.0\n    * @method event.remove()\n    * @returns {boolean} true if the event has been removed. If false, the event is not on the map\n    * @memberof RpgEvent\n    */\n    remove(): boolean {\n        let bool = false\n        if (this.playerRelated) bool = this.playerRelated.removeEvent(this.id)\n        const map = this.getCurrentMap()\n        if (map) {\n            bool = map.removeEvent(this.id)\n        }\n        return bool\n    }\n\n    override emitToMap(key: string, value: any) {\n        const map = this.getCurrentMap()\n        if (map) {\n            const eventPath = `events.${this.id}.${key}`\n            if (this.playerRelated) {\n                map.$setCurrentState(`users.${this.playerRelated.id}.${eventPath}`, value)\n            }\n            else {\n                map.$setCurrentState(eventPath, value)\n            }\n        }\n    }\n}\n", "import { DatabaseTypes } from \"./interfaces/types\"\n\nexport interface Data {\n     /** \n     * The id of the item. The identifier makes it possible to find an object in the database. By default, the identifier is the name of the class\n     * @prop {string} [id]\n     * @memberof Item\n     * @memberof Weapon\n     * @memberof Armor\n     * @memberof Class\n     * @memberof Enemy\n     * @memberof Skill\n     * @memberof State\n     * @memberof Actor\n     * */ \n    id?: string\n     /** \n     * The name of the item. \n     * @prop {string} [name]\n     * @memberof Item\n     * @memberof Weapon\n     * @memberof Armor\n     * @memberof Class\n     * @memberof Enemy\n     * @memberof Skill\n     * @memberof State\n     * @memberof Actor\n     * */ \n    name?: string,\n     /** \n     * The description of the item. \n     * @prop {string} [description]\n     * @memberof Item\n     * @memberof Weapon\n     * @memberof Armor\n     * @memberof Class\n     * @memberof Enemy\n     * @memberof Skill\n     * @memberof State\n     * @memberof Actor\n     * */ \n    description?: string\n}\n\nexport function merge(options, type: DatabaseTypes, _static = {}) {\n    \n    const transformToRate = (optionName: string, propName: string) => {\n        if (options[optionName]) {\n            options[optionName] = options[optionName].map(element => {\n                if (!element.rate) {\n                    return {\n                        rate: 1,\n                        [propName]: element\n                    }\n                }\n                return element\n            })\n        }\n    }\n\n    transformToRate('elements', 'element')\n    transformToRate('elementsDefense', 'element')\n    transformToRate('elementsEfficiency', 'element')\n\n    transformToRate('addStates', 'state')\n    transformToRate('removeStates', 'state')\n    transformToRate('statesDefense', 'state')\n    transformToRate('statesEfficiency', 'state')\n\n    return (target) => {\n        const id = options.id || target.name.toLowerCase()\n        target.id = id\n        target.prototype.id = id\n        target._type = type\n        for (let key in _static) {\n            target[key] = options[key]\n        }\n        for (let key in options) {\n            target.prototype[key] = options[key]\n        }\n        target.prototype.toJSON = function() {\n            return this.id\n        }\n    }\n}\n\nexport interface RpgClassDatabase<T> {\n    new ()\n}\n", "import { merge, Data } from './common'\nimport { ElementsOption, Elements } from './interfaces/elements';\nimport { ParamsModifierOption } from './interfaces/params-modifier'\nimport { StatesOption, States } from './interfaces/states';\n\nexport interface ItemClass {\n    new(...args: any[]): ItemInstance;\n    price?: number;\n    _type?: string;\n}\n\nexport interface ItemGlobalOptions extends ParamsModifierOption, Data, ElementsOption, StatesOption {\n     /** \n     * The price of the item. If the price is undefined, then it will not be possible to buy or sell the item.\n     * @prop {number} [price]\n     * @memberof Item\n     * @memberof Weapon\n     * @memberof Armor\n     * */\n    price?: number\n}\n\nexport interface EquipmentOptions extends ItemGlobalOptions {\n    pdef?: number,\n    sdef?: number,\n    params?: object\n    statesDefense?: States\n    elementsDefense?: Elements\n}\n\nexport interface ItemOptions extends ItemGlobalOptions {\n    /** \n     * The number of heart points given back by the item \n     * @prop {number} [hpValue]\n     * @memberof Item\n     * */ \n    hpValue?: number,\n    /** The success rate of the item. Value between 0 and 1. Even if the use of the item failed, the item will be removed from the player's inventory. \n     * @prop {number} [hitRate]\n     * @default 1\n     * @memberof Item\n     * */ \n    hitRate?: number,\n    /** \n     * Indicate if the item can be used. If not, an error will be sent \n     * @prop {boolean} [consumable]\n     * @default true\n     * @memberof Item\n     * */ \n    consumable?: boolean\n}\n\nexport interface ItemInstance extends ItemOptions {}\n\nexport function Item(options: ItemOptions) {\n    return merge(options, 'item', {\n        price: options.price\n    })\n}", "import { merge, Data } from './common'\nimport { EfficiencyOptions } from './interfaces/efficiency'\n\nexport interface ActorGlobalOptions extends EfficiencyOptions, Data {\n    /** \n     * Give parameters. Give a start value and an end value. \n     * The start value will be set to the level set at `initialLevel` and the end value will be linked to the level set at `finalLevel`.\n     * \n     * ```ts\n     * import { Presets } from '@rpgjs/server'\n     * \n     * const { MAXHP } = Presets \n     * \n     * parameters: {\n     *      [MAXHP]: {\n     *          start: 700,\n     *          end: 10000\n     *      }\n     * }\n     * ```\n     * \n     * @prop {object} [parameters]\n     * @param {object} \n     * @memberof Actor\n     * @memberof Enemy\n     * */\n    parameters?: {\n        [key: string]: {\n            start: number, \n            end: number\n        }\n    },\n   \n    /** \n     * Allows to give a default equipment\n     * \n     * ```ts\n     * import { Sword } from 'my-database/weapons/sword'\n     * \n     * startingEquipment: [Sword]\n     * ```\n     * \n     * @prop {Array<WeaponClass | ArmorClass>} [startingEquipment]\n     * @memberof Actor\n     * @memberof Enemy\n     * */\n    startingEquipment?: any[]\n\n     /** \n     * Assigns a default class\n     * \n     * ```ts\n     * import { Fighter } from 'my-database/classes/fighter'\n     * \n     * class: Fighter\n     * ```\n     * @prop {ClassClass} [class]\n     * @memberof Actor\n     * @memberof Enemy\n     * */\n    class?: any\n}\n\nexport interface ActorOptions extends ActorGlobalOptions {\n     /** \n     * @title Set initial level\n     * @prop {number} [initialLevel]\n     * @memberof Actor\n     * */\n    initialLevel?: number,\n\n    /** \n     * @title Set final level\n     * @prop {number} [finalLevel]\n     * @memberof Actor\n     * */\n    finalLevel?: number,\n\n    /** \n     * With Object-based syntax, you can use following options:\n     * - `basis: number`\n     * - `extra: number`\n     * - `accelerationA: number`\n     * - `accelerationB: number`\n     * @title Experience Curve\n     * @prop {object} [expCurve]\n     * @memberof Actor\n     * */\n    expCurve?: {\n        basis: number,\n        extra: number,\n        accelerationA: number,\n        accelerationB: number\n    }\n}\n\nexport function Actor(options: ActorOptions) {\n    return merge(options, 'actor')\n}", "import { merge, RpgClassDatabase, Data } from './common'\nimport { ISkill } from './skill'\nimport { EfficiencyOptions } from './interfaces/efficiency'\n\ndeclare type RpgPlayer = any;\n\nexport enum ClassHooks {\n    onSet = 'onSet',\n    canEquip = 'canEquip'\n}\n\nexport interface ClassCanEquip {\n    canEquip(item: any, player: RpgPlayer): boolean\n}\n\nexport interface ClassOnSet {\n    onSet(player: RpgPlayer): void\n}\n\nexport interface ClassOptions extends EfficiencyOptions, Data {\n    /** \n     * Indicate which skill will be learned when the level is reached\n     * \n     * ```ts\n     * import { Fire } from 'my-database/skills/fire'\n     * \n     * skillsToLearn: [{ level: 5, skill: Fire }]\n     * ```\n     * \n     * @prop {Array<{ level: number, skill: SkillClass }>} [skillsToLearn]\n     * @memberof Class\n     * */\n    skillsToLearn?: [\n        { level: number, skill: RpgClassDatabase<ISkill> }\n    ]\n}\n\nexport function Class(options: ClassOptions) {\n    return merge(options, 'class')\n}", "import { merge, Data } from './common'\nimport { StatesOption } from './interfaces/states'\nimport { ElementsOption } from './interfaces/elements';\n\nexport interface ISkill {\n    onUse()\n}\n\nexport interface SkillOptions extends StatesOption, ElementsOption, Data {\n    /** \n     * Indicates how much SP will be removed when the skill is used.\n     * \n     * @prop {number} [spCost]\n     * @memberof Skill\n     * */\n    spCost?: number\n    /** \n     * Indicates the power of the skill\n     * \n     * @prop {number} [power]\n     * @memberof Skill\n     * */\n    power?: number\n    /** \n     * The coefficient indicates which parameter influences the skill\n     * \n     * ```ts\n     * import { Presets } from '@rpgjs/server'\n     * \n     * const { ATK } = Presets\n     * \n     * coefficient: {\n     *      [ATK]: 2\n     * }\n     * ```\n     * \n     * Below, The ATK parameter will be taken into account, added and multiplied by 2.\n     * \n     * > It depends on the fight formula. By default, the coefficients are used on ATK, PDEF SDEF, STR, DEX, AGI, INT\n     * \n     * @prop {object} [coefficient]\n     * @memberof Skill\n     * */\n    coefficient?: {\n        [param: string]: number\n    },\n\n     /** \n     * The variance of the damage. For example, if you put `20` and the damage is 500 then the player can lose between 480 and 520 HP.\n     * @prop {number} [variance]\n     * @memberof Skill\n     * */\n    variance?: number\n\n    /** \n     * The rate of chance, between 0 and 1 that the skill will take effect\n     * @prop {number} [hitRate]\n     * @memberof Skill\n     * */\n    hitRate?: number\n}\n\nexport function Skill(options: SkillOptions) {\n    if (!options.coefficient) options.coefficient = {\n        'int': 1\n    }\n    return merge(options, 'skill')\n}", "import { merge, Data } from './common'\nimport { EfficiencyOptions } from './interfaces/efficiency'\nimport { ParamsModifierOption } from './interfaces/params-modifier'\nimport { EffectsOption } from './interfaces/effects';\n\nexport interface StateOptions extends EfficiencyOptions, ParamsModifierOption, EffectsOption, Data { }\n\nexport function State(options: StateOptions) {\n    return merge(options, 'state')\n}", "import { merge } from './common'\nimport { EquipmentOptions } from './item'\n\nexport interface WeaponClass {\n    new(...args: any[]): WeaponInstance;\n    price?: number;\n    _type?: string;\n}\n\nexport interface WeaponOptions extends EquipmentOptions {\n    atk?: number\n}\n\nexport interface WeaponInstance extends WeaponOptions {\n    equipped?: boolean\n}\n\nexport function Weapon(options: WeaponOptions) {\n    return merge(options, 'weapon', {\n        price: options.price\n    })\n}", "import { merge } from './common'\nimport { EquipmentOptions } from './item'\n\nexport interface ArmorClass {\n    new(...args: any[]): ArmorInstance;\n    price?: number;\n    _type?: string;\n}\n\nexport interface ArmorOptions extends EquipmentOptions { }\n\nexport interface ArmorInstance extends ArmorOptions {\n    equipped?: boolean\n}\n\nexport function Armor(options: ArmorOptions) {\n    return merge(options, 'armor', {\n        price: options.price\n    })\n}", " /** \n * @title Existing effects\n * @enum {string}\n * \n * Effect.NONE | No effect\n * Effect.CAN_NOT_SKILL | The player will not be able to use a skill. The `player.useSkill()` method will return an exception with the `RESTRICTION_SKILL` id\n * Effect.CAN_NOT_ITEM | The player may not use an item. The `player.useItem()` method will return an exception with the `RESTRICTION_ITEM` id\n * Effect.GUARD | The player goes on defense. When using applyDamage(), damage will be reduced using the damageGuard formula\n * Effect.SUPER_GUARD | Damage with the applyDamage() method will be divided by 4\n * Effect.HALF_SP_COST | The cost of the SP will be halved when calling the `useSkill()` method\n * @memberof Effect\n * */\nexport enum Effect {\n    NONE = 'NONE',\n    CAN_NOT_SKILL = 'CAN_NOT_SKILL',\n    CAN_NOT_ITEM = 'CAN_NOT_ITEM',\n    ALWAYS_ATTACK_ENEMIES = 'ALWAYS_ATTACK_ENEMIES',\n    CAN_NOT_EVADE = 'CAN_NOT_EVADE',\n    CAN_NOT_GET_EXP = 'CAN_NOT_GET_EXP',\n    CAN_NOT_GET_GOLD = 'CAN_NOT_GET_GOLD',\n    PHARMACOLOGY = 'PHARMACOLOGY',\n    // Increases the chances of making a critical hit\n    CRITICAL_BONUS = 'CRITICAL_BONUS',\n    SUPER_GUARD = 'SUPER_GUARD',\n    GUARD = 'GUARD',\n    // the chances of making a critical strike are set to 0\n    PREVENT_CRITICAL = 'PREVENT_CRITICAL',\n    HALF_SP_COST = 'HALF_SP_COST',\n    DOUBLE_EXP_GAIN = 'DOUBLE_EXP_GAIN',\n    AUTO_HP_RECOVER = 'AUTO_HP_RECOVER',\n    // He's the first to attack\n    FAST_ATTACK = 'FAST_ATTACK',\n    // The hero can attack twice\n    DUAL_ATTACK = 'DUAL_ATTACK',\n    // Each turn, the hero loses 10% of his health points.\n    SLIP_DAMAGE = 'SLIP_DAMAGE',\n}\n", "import { Elements } from \"./elements\";\nimport { States } from \"./states\";\n\nexport interface EfficiencyOptions {\n    /** \n     * List of states.\n     * \n     * Changes the efficiency of the states. It indicates whether or not the player with a class or state will be vulnerable to the state.\n     * It is a multiplying coefficient for damage calculations.\n     * \n     * To help, you can use the Efficiency enumerations\n     * \n     * @prop {Array<{ rate: number, element: StateClass} | StateClass>} [statesEfficiency]\n     * @enum {number}\n     * @example \n     * \n     * Example 1\n     * \n     * ```ts\n     * import { Paralyze } from 'my-database/states/paralyze'\n     * \n     * statesEfficiency: [Paralyze] // rate is 1 by default\n     * ```\n     * \n     * Example 2 \n     * \n     * ```ts\n     * import { Paralyze } from 'my-database/states/paralyze'\n     * \n     * statesEfficiency: [{ rate: 1.5, state: Paralyze }]\n     * ```\n     * Example 3 (todo)\n     * \n     * ```ts\n     * import { Efficiency } from '@rpgjs/server'\n     * import { Paralyze } from 'my-database/states/paralyze'\n     * \n     * statesEfficiency: [{ rate: Efficiency.VULNERABLE, state: Paralyze }]\n     * ```\n     * @memberof State\n     * @memberof Class\n     * @memberof Enemy\n     * @memberof Actor\n     * @todo \n     * */\n    statesEfficiency?: States\n    /** \n     * List of elements.\n     * \n     * Changes the efficiency of the elements. It indicates whether or not the player with a class or state will be vulnerable to the element.\n     * It is a multiplying coefficient for damage calculations.\n     * \n     * To help, you can use the Efficiency enumerations\n     * \n     * @prop {Array<{ rate: number, element: Element} | Element>} [elementsEfficiency]\n     * @enum {number}\n     * \n     * Efficiency.GAIN_HP | -0.5 value\n     * Efficiency.PERFECT_INVULNERABLE | 0 value\n     * Efficiency.INVULNERABLE | 0.5 value\n     * Efficiency.NORMAL | 1 value\n     * Efficiency.VULNERABLE | 1.5 value\n     * Efficiency.VERY_VULNERABLE | 2 value\n     * @example \n     * \n     * Example 1\n     * \n     * ```ts\n     * import { Element } from 'my-database/elements'\n     * \n     * elementsEfficiency: [Element.Fire] // rate is 1 by default\n     * ```\n     * \n     * Example 2 \n     * \n     * ```ts\n     * import { Element } from 'my-database/elements'\n     * \n     * elementsEfficiency: [{ rate: 1.5, element: Element.Fire }]\n     * ```\n     * Example 3 \n     * \n     * ```ts\n     * import { Efficiency } from '@rpgjs/server'\n     * import { Element } from 'my-database/elements'\n     * \n     * elementsEfficiency: [{ rate: Efficiency.VULNERABLE, element: Element.Fire }]\n     * ```\n     * @memberof State\n     * @memberof Class\n     * @memberof Enemy\n     * @memberof Actor\n     * */\n    elementsEfficiency?: Elements\n}\n\nexport enum Efficiency {\n    VERY_VULNERABLE = 2,\n    VULNERABLE = 1.5,\n    NORMAL = 1,\n    INVULNERABLE = 0.5,\n    PERFECT_INVULNERABLE = 0,\n    GAIN_HP = -0.5\n}", "export class Log {\n    constructor(private id: string, private msg: string) {}\n}", "import { Log } from './log'\n\nexport class ItemLog {\n    static notInInventory(itemClass) {\n        return new Log('ITEM_NOT_INVENTORY', `The item ${itemClass.name} is not in inventory`)\n    }\n    static notUseItem(itemClass) {\n        return new Log('NOT_USE_ITEM', `The player cannot use the ${itemClass.name} item.`)\n    }\n    static chanceToUseFailed(itemClass) {\n        return new Log('USE_CHANCE_ITEM_FAILED', `Chance to use the ${itemClass.name} item has failed`)\n    }\n    static invalidToEquiped(itemClass) {\n        return new Log('INVALID_ITEM_TO_EQUIP', `The item ${itemClass.name} is not a weapon or armor`)\n    }\n    static canNotEquip(itemClass) {\n        return new Log('CANNOT_EQUIP', `The item ${itemClass.name} cannot be equiped`)\n    }\n    static isAlreadyEquiped(itemClass) {\n        return new Log('ITEM_ALREADY_EQUIPED', `The item ${itemClass.name} is already equiped`)\n    }\n    static haveNotPrice(itemClass) {\n        return new Log('NOT_PRICE', `Define a price > 0 to buy ${itemClass.name}`)\n    }\n    static notEnoughGold(itemClass, nb) {\n        return new Log('NOT_ENOUGH_GOLD', `not enough gold to buy ${nb} ${itemClass.name}`)\n    }\n    static tooManyToSell(itemClass, nbToSell, nb) {\n        return new Log('TOO_MANY_ITEM_TO_SELL', `Too many items to sell: ${nbToSell} ${itemClass.name}, only ${nb} in inventory`)\n    }\n    static restriction(itemClass) {\n        return new Log('RESTRICTION_ITEM', `A state blocks the use of the ${itemClass.name} skill`)\n    }\n}", "import { Log } from './log'\n\nexport class SkillLog {\n    static notLearned(skillClass) {\n        return new Log('SKILL_NOT_LEARNED', `the skill ${skillClass.name} is not learned`)\n    }\n    static notEnoughSp(skillClass, skillSp, playerSp) {\n        return new Log('NOT_ENOUGH_SP', `not enough SP to use ${skillClass.name} skill. ${skillSp} Skill'SP is is greater than ${playerSp} Player'SP`)\n    }\n    static chanceToUseFailed(skillClass) {\n        return new Log('USE_CHANCE_SKILL_FAILED', `Chance to use the ${skillClass.name} skill has failed`)\n    }\n    static restriction(skillClass) {\n        return new Log('RESTRICTION_SKILL', `A state blocks the use of the ${skillClass.name} skill`)\n    }\n    static alreadyLearned(skillClass) {\n        return new Log('SKILL_ALREADY_LEARNED', `The ${skillClass.name} skill is already learned`)\n    }\n}", "import { Log } from './log'\n\nexport class StateLog {\n    static addFailed(stateClass) {\n        return new Log('ADD_STATE_FAILED', `Adding the ${stateClass.name} state has failed`)\n    }\n    static removeFailed(stateClass) {\n        return new Log('REMOVE_STATE_FAILED', `Removing the ${stateClass.name} state has failed`)\n    }\n    static notApplied(stateClass) {\n        return new Log('STATE_NOT_APPLIED', `State ${stateClass.name} does not exist`)\n    }\n}", "import { Utils } from '@rpgjs/common'\n\nconst { random } = Utils\n\nexport const MAXHP: string = 'maxHp'\nexport const MAXSP: string = 'maxSp'\nexport const ATK: string = 'atk'\nexport const PDEF: string = 'pdef'\nexport const SDEF: string = 'sdef'\nexport const STR: string = 'str'\nexport const AGI: string = 'agi'\nexport const INT: string = 'int'\nexport const DEX: string = 'dex'\n\nexport const MAXHP_CURVE = {\n    start: 741,\n    end: 7467\n}\nexport const MAXSP_CURVE = {\n    start: 534,\n    end: 5500\n}\nexport const STR_CURVE = {\n    start: 67,\n    end: 635\n}\nexport const AGI_CURVE = {\n    start: 58,\n    end: 582\n}\nexport const INT_CURVE = {\n    start: 36,\n    end: 7318\n}\nexport const DEX_CURVE = {\n    start: 54,\n    end: 564\n}\n\nexport const DAMAGE_CRITICAL = function(damage, a, b) {\n    if (random(0, 100) < 4 * a[DEX] / b[AGI]) {\n        damage *= 2\n    }\n    return damage\n}\n\nexport const DAMAGE_PHYSIC = function(a, b) {\n    let damage = Math.round((a[ATK] - b[PDEF] / 2) * ((20 + a[STR]) / 20))\n    if (damage < 0) damage = 0\n    return damage\n}\n\nexport const DAMAGE_GUARD = function(damage) {\n    return damage / 2\n}\n\nexport const COEFFICIENT_ELEMENTS = function(a, b, bDef) {\n    return ((a.rate + 1) * (b.rate + 1)) / (bDef.rate == 0 ? bDef.rate * 4 : 1)\n}\n\nexport const DAMAGE_SKILL = function(a, b, skill) {\n    let power = skill.power + (a[ATK] * (skill.coefficient[ATK] || 0))\n    if (power > 0) {\n        power -= b[PDEF] * (skill.coefficient[PDEF] || 0) / 2\n        power -= b[SDEF] * (skill.coefficient[SDEF] || 0) / 2\n        power = Math.max(power, 0)\n    }\n    let rate = 20;\n    [STR, DEX, AGI, INT].forEach(val => rate += a[val] * (skill.coefficient[val] || 0))\n    return Math.round(power * rate / 20)\n}", "import { Utils } from '@rpgjs/common'\nimport { \n    MAXHP, \n    MAXSP,\n} from '../presets'\n\nconst { \n    isString\n} = Utils\n\nexport class ParameterManager {\n\n    private _paramsModifier: {\n        [key: string]: {\n            value?: number,\n            rate?: number\n        }\n    } = {}\n\n    private _parameters: Map<string, {\n        start: number,\n        end: number\n    }>\n\n    private _hp = 0\n    private _sp = 0\n    private _exp: number = 0\n    private _level: number = 0\n\n     /** \n     * ```ts\n     * player.initialLevel = 5\n     * ``` \n     * \n     * @title Set initial level\n     * @prop {number} player.initialLevel\n     * @default 1\n     * @memberof ParameterManager\n     * */\n    public initialLevel:number = 1\n\n    /** \n     * ```ts\n     * player.finalLevel = 50\n     * ``` \n     * \n     * @title Set final level\n     * @prop {number} player.finalLevel\n     * @default 99\n     * @memberof ParameterManager\n     * */\n    public finalLevel:number = 99\n\n    /** \n     * With Object-based syntax, you can use following options:\n     * - `basis: number`\n     * - `extra: number`\n     * - `accelerationA: number`\n     * - `accelerationB: number`\n     * @title Change Experience Curve\n     * @prop {object} player.expCurve\n     * @default \n     *  ```ts\n     * {\n     *      basis: 30,\n     *      extra: 20,\n     *      accelerationA: 30,\n     *      accelerationB: 30\n     * }\n     * ```\n     * @memberof ParameterManager\n     * */\n    public expCurve: { \n        basis: number,\n        extra: number,\n        accelerationA: number\n        accelerationB: number\n    }\n    \n    /** \n     * Changes the health points\n     * - Cannot exceed the MaxHP parameter\n     * - Cannot have a negative value\n     * - If the value is 0, a hook named `onDead()` is called in the RpgPlayer class.\n     * \n     * ```ts\n     * player.hp = 100\n     * ``` \n     * @title Change HP\n     * @prop {number} player.hp\n     * @default MaxHPValue\n     * @memberof ParameterManager\n     * */\n    set hp(val: number) {\n        if (val > this.param[MAXHP]) {\n            val = this.param[MAXHP]\n        }\n        else if (val <= 0) {\n            this['execMethod']('onDead') \n            val = 0\n        }\n        this._hp = val\n    }\n\n    get hp(): number {\n        return this._hp\n    }\n\n    /** \n     * Changes the skill points\n     * - Cannot exceed the MaxSP parameter\n     * - Cannot have a negative value\n     * \n     * ```ts\n     * player.sp = 200\n     * ``` \n     * @title Change SP\n     * @prop {number} player.sp\n     * @default MaxSPValue\n     * @memberof ParameterManager\n     * */\n    set sp(val: number) {\n        if (val > this.param[MAXSP]) {\n            val = this.param[MAXSP]\n        }\n        this._sp = val\n    }\n\n    get sp(): number {\n        return this._sp\n    }\n\n    /** \n     * Changing the player's experience. \n     * ```ts\n     * player.exp += 100\n     * ```\n     * \n     * Levels are based on the experience curve.\n     * \n     * ```ts\n     * console.log(player.level) // 1\n     * console.log(player.expForNextlevel) // 150\n     * player.exp += 160\n     * console.log(player.level) // 2\n     * ```\n     * \n     * @title Change Experience\n     * @prop {number} player.exp\n     * @default 0\n     * @memberof ParameterManager\n     * */\n    set exp(val: number) {\n        this._exp = val\n        const lastLevel = this.level\n        while (this.expForNextlevel < this._exp) {\n            this.level += 1\n        }\n        //const hasNewLevel = player.level - lastLevel\n    }\n\n    get exp(): number {\n        return this._exp\n    }\n\n    /** \n     * Changing the player's level. \n     * \n     * ```ts\n     * player.level += 1\n     * ``` \n     * \n     * The level will be between the initial level given by the `initialLevel` and final level given by `finalLevel`\n     * \n     * ```ts\n     * player.finalLevel = 50\n     * player.level = 60 \n     * console.log(player.level) // 50\n     * ```\n     * \n     * @title Change Level\n     * @prop {number} player.level\n     * @default 1\n     * @memberof ParameterManager\n     * */\n    set level(val: number) {\n        const lastLevel = this._level\n        if (this.finalLevel && val > this.finalLevel) {\n            val = this.finalLevel\n        }\n        if (this._class) {\n            for (let i = this._level ; i <= val; i++) {\n                for (let skill of this._class.skillsToLearn) {\n                    if (skill.level == i) {\n                        this['learnSkill'](skill.skill)\n                    }\n                }\n            }\n        }\n        const hasNewLevel = val - lastLevel\n        if (hasNewLevel > 0) {\n            this['execMethod']('onLevelUp', <any>[hasNewLevel])   \n        }\n        this._level = val\n    }\n\n    get level(): number {\n        return this._level\n    }\n\n     /** \n     * ```ts\n     * console.log(player.expForNextlevel) // 150\n     * ```\n     * @title Experience for next level ?\n     * @prop {number} player.expForNextlevel\n     * @readonly\n     * @memberof ParameterManager\n     * */\n    get expForNextlevel(): number {\n        return this._expForLevel(this.level + 1)\n    }\n\n    /** \n     * Read the value of a parameter. Put the name of the parameter.\n     * \n     * ```ts\n     * import { Presets } from '@rpgjs/server'\n     * \n     * const { MAXHP } = Presets \n     * \n     * console.log(player.param[MAXHP])\n     * ```\n     * \n     * > Possible to use the `player.getParamValue(name)` method instead\n     * @title Get Param Value\n     * @prop {object} player.param\n     * @readonly\n     * @memberof ParameterManager\n     * */\n    get param() {\n        const obj = {}\n        this._parameters.forEach((val, name) => {\n            obj[name] = this.getParamValue(name)\n        })\n        return obj\n    }\n\n    get paramsModifier() {\n        const params = {}\n        const paramsAvg = {}\n        const changeParam = (paramsModifier) => {\n            for (let key in paramsModifier) {\n                const { rate, value } = paramsModifier[key]\n                if (!params[key]) params[key] = { rate: 0, value: 0 }\n                if (!paramsAvg[key]) paramsAvg[key] = 0\n                if (value) params[key].value += value\n                if (rate !== undefined) params[key].rate += rate\n                paramsAvg[key]++\n            }\n        }\n        const getModifier = (prop) => {\n            if (!isString(prop)) {\n                changeParam(prop)\n                return\n            }\n            for (let el of this[prop]) {\n                if (!el.paramsModifier) continue\n                changeParam(el.paramsModifier)\n            }\n        }\n        getModifier(this._paramsModifier)\n        getModifier('states')\n        getModifier('equipments')\n        for (let key in params) {\n            params[key].rate /= paramsAvg[key]\n        }\n        return params\n    }\n\n    /** \n     * Changes the values of some parameters\n     * \n     * > It is important that these parameters have been created beforehand with the `addParameter()` method.\n     * > By default, the following settings have been created: \n     * - maxhp\n     * - maxsp\n     * - str\n     * - int\n     * - dex\n     * - agi\n     * \n     * **Object Key**\n     * \n     * The key of the object is the name of the parameter\n     * \n     * > The good practice is to retrieve the name coming from a constant\n     * \n     * **Object Value**\n     * \n     * The value of the key is an object containing: \n     * ``` \n     * {\n     *   value: number,\n     *   rate: number\n     * }\n     * ```\n     * \n     * - value: Adds a number to the parameter\n     * - rate: Adds a rate to the parameter\n     * \n     * > Note that you can put both (value and rate)\n     * \n     * In the case of a state or the equipment of a weapon or armor, the parameters will be changed but if the state disappears or the armor/weapon is de-equipped, then the parameters will return to the initial state.\n     * \n     * @prop {Object} [paramsModifier]\n     * @example\n     * \n     * ```ts\n     * import { Presets } from '@rpgjs/server'\n     * \n     * const { MAXHP } = Presets\n     * \n     * player.paramsModifier = {\n     *      [MAXHP]: {\n     *          value: 100\n     *      }\n     * }\n     * ```\n     * \n     * 1. Player has 741 MaxHp\n     * 2. After changing the parameter, he will have 841 MaxHp\n     * \n     * @title Set Parameters Modifier\n     * @prop {number} paramsModifier\n     * @memberof ParameterManager\n     * */\n    set paramsModifier(val: { \n        [key: string]: {\n            value?: number,\n            rate?: number\n        }\n    }) {\n        this._paramsModifier = val\n        this.changeRoomState('param')\n    }\n\n    get parameters() {\n        return this._parameters\n    }\n\n    set parameters(val) {\n        this._parameters = val\n    }\n\n    private _expForLevel(level: number): number {\n        const {\n            basis,\n            extra,\n            accelerationA,\n            accelerationB\n        } = this.expCurve\n        return Math.round(basis * (Math.pow(level - 1, 0.9 + accelerationA / 250)) * level * (level + 1) / (6 + Math.pow(level, 2) / 50 / accelerationB) + (level - 1) * extra)\n    }\n\n    private getParam(name: string) {\n        const features = this._parameters.get(name)\n        if (!features) {\n            throw `Parameter ${name} not exists. Please use addParameter() before`\n        }\n        return features\n    }\n\n    getParamValue(name: string): number | never {\n        const features = this.getParam(name)\n        let curveVal = Math.floor((features.end - features.start) * ((this.level-1) / (this.finalLevel - this.initialLevel))) + features.start\n        const modifier = this.paramsModifier[name]\n        if (modifier) {\n            if (modifier.rate) curveVal *= modifier.rate\n            if (modifier.value) curveVal += modifier.value\n        }\n        return curveVal\n    }\n\n    /** \n     * Give a new parameter. Give a start value and an end value. \n     * The start value will be set to the level set at `player.initialLevel` and the end value will be linked to the level set at `player.finalLevel`.\n     * \n     * ```ts\n     * const SPEED = 'speed'\n     * \n     * player.addParameter(SPEED, {\n     *     start: 10,\n     *     end: 100\n     * })\n     * \n     * player.param[SPEED] // 10\n     * player.level += 5\n     * player.param[SPEED] // 14\n     * ```\n     * \n     * @title Add custom parameters\n     * @method player.addParameter(name,curve)\n     * @param {name} name \n     * @param {object} curve Scheme of the object: { start: number, end: number }\n     * @returns {void}\n     * @memberof ParameterManager\n     * */\n    addParameter(name: string, { start, end }: { start: number, end: number }): void {\n        this._parameters.set(name, {\n            start,\n            end\n        })\n        const maxHp = this.param[MAXHP]\n        const maxSp = this.param[MAXSP]\n        if (name == MAXHP && this.hp > maxHp) {\n            this.hp = maxHp // forcing hp not to exceed maxp \n        }\n        else if (name == MAXSP && this.sp > maxSp) {\n            this.sp = maxSp\n        }\n        this.changeRoomState('param.' + name)\n    }\n\n    /** \n     * Gives back in percentage of health points to skill points\n     * \n     * ```ts\n     * import { Presets } from '@rpgjs/server'\n     * \n     * const { MAXHP } = Presets \n     * \n     * console.log(player.param[MAXHP]) // 800\n     * player.hp = 100\n     * player.recovery({ hp: 0.5 }) // = 800 * 0.5\n     * console.log(player.hp) // 400\n     * ```\n     * \n     * @title Recovery HP and/or SP\n     * @method player.recovery(params)\n     * @param {object} params Scheme of the object: { hp: number, sp: number }. The values of the numbers must be in 0 and 1\n     * @returns {void}\n     * @memberof ParameterManager\n     * */\n    recovery({ hp, sp }: { hp?: number, sp?: number }) {\n        if (hp) this.hp = this.param[MAXHP] * hp\n        if (sp) this.sp = this.param[MAXSP] * sp\n    }\n\n    /** \n     * restores all HP and SP\n     * \n     * ```ts\n     * import { Presets } from '@rpgjs/server'\n     * \n     * const { MAXHP, MAXSP } = Presets \n     * \n     * console.log(player.param[MAXHP], player.param[MAXSP]) // 800, 230\n     * player.hp = 100\n     * player.sp = 0\n     * player.allRecovery()\n     * console.log(player.hp, player.sp) // 800, 230\n     * ```\n     * \n     * @title All Recovery\n     * @method player.allRecovery()\n     * @returns {void}\n     * @memberof ParameterManager\n     * */\n    allRecovery(): void {\n        this.recovery({ hp: 1, sp: 1 })\n    }\n}\n\nexport interface ParameterManager {\n    _class,\n    $schema,\n    changeRoomState(key: string): void\n}", "import { Utils }  from '@rpgjs/common'\nimport { Effect } from '@rpgjs/database'\nimport { ParameterManager } from './ParameterManager'\n\nimport {\n    MAXHP, \n    MAXSP\n} from '../presets'\n\nconst { \n    arrayUniq,\n    arrayFlat,\n    applyMixins\n} = Utils\n\nexport class EffectManager {\n    \n    _effects: Effect[]\n\n    // TODO\n    applyEffect(item) {\n        if (item.hpValue) {\n            this.hp += item.hpValue\n        }\n        if (item.hpRate) {\n            this.hp += this.param[MAXHP] * item.hpRate\n        }\n        if (item.spValue) {\n            this.sp += item.spValue\n        }\n        if (item.spRate) {\n            this.sp += this.param[MAXSP] * item.spRate\n        }\n    }\n\n    /** \n     * ```ts\n     * import { Effect } from '@rpgjs/database'\n     * \n     * const bool = player.hasEffect(Effect.CAN_NOT_SKILL)\n     * ```\n     * \n     * @title Has Effect\n     * @method player.hasEffect(effect)\n     * @param {Effect} effect\n     * @returns {boolean}\n     * @memberof EffectManager\n     * */\n    hasEffect(effect: Effect): boolean {\n        return this.effects.includes(effect)\n    }\n\n    /** \n     * Retrieves a array of effects assigned to the player, state effects and effects of weapons and armors equipped with the player's own weapons.\n     * \n     * ```ts\n     * console.log(player.effects)\n     * ``` \n     * @title Get Effects\n     * @prop {Array<Effect>} player.effects\n     * @memberof EffectManager\n     * */\n    get effects(): any[] {\n        const getEffects = (prop) => {\n            return arrayFlat(this[prop]\n                .map(el => el.effects || []))\n        }\n        return arrayUniq([\n            ...this._effects,\n            ...getEffects('states'),\n            ...getEffects('equipments')\n        ])\n    }\n\n    /** \n     * Assigns effects to the player. If you give a array, it does not change the effects of the player's states and armor/weapons equipped.\n     * \n     * ```ts\n     * import { Effect } from '@rpgjs/database'\n     * \n     * player.effects = [Effect.CAN_NOT_SKILL]\n     * ``` \n     * @title Set Effects\n     * @prop {Array<Effect>} player.effects\n     * @memberof EffectManager\n     * */\n    set effects(val) {\n        this._effects = val\n    }\n}\n\napplyMixins(EffectManager, [ParameterManager])\n\nexport interface EffectManager extends ParameterManager { }\n\n", "export class GoldManager {\n    private _gold: number = 0\n\n     /** \n     * You can change the game money\n     * \n     * ```ts\n     * player.gold += 100\n     * ```\n     * \n     * @title Change Gold\n     * @prop {number} player.gold\n     * @default 0\n     * @memberof GoldManager\n     * */\n    set gold(val: number) {\n        if (val < 0) {\n            val = 0\n        }\n        this._gold = val\n    }\n\n    get gold(): number {\n        return this._gold\n    }\n}", "import { ItemInstance } from \"@rpgjs/database\"\n\nexport class ItemFixture {\n    protected getFeature(name, prop): any {\n        const array = {}\n        for (let item of this.equipments) {\n            if (item[name]) {\n                for (let feature of item[name]) {\n                    const { rate } = feature\n                    const instance = feature[prop]\n                    const cache = array[instance.id]\n                    if (cache && cache.rate >= rate) continue\n                    array[instance.id] = feature\n                }\n            }\n        }\n        return Object.values(array)\n    }\n}\n\n\nexport interface ItemFixture{ \n    equipments: ItemInstance[]\n}\n", "import { Utils }  from '@rpgjs/common'\nimport { ItemFixture } from './ItemFixture'\nimport { RpgPlayer } from './Player'\nimport { StateLog } from '../logs/state'\n\nconst { \n    isInstanceOf,\n    applyMixins,\n    isString\n} = Utils\n\ntype StateClass = { new(...args: any[]) }\n\nexport class StateManager {\n\n    states: any[] = []\n\n    _statesEfficiency: { rate: number, state: any }[]\n\n    /** \n     * Recovers the player's states defense on inventory.  This list is generated from the `statesDefense` property defined on the weapons or armors equipped.\n     * If several items have the same element, only the highest rate will be taken into account.\n     * \n     * ```ts\n     * import { Armor, State } from '@rpgjs/server'\n     * \n     * @State({\n     *      name: 'Paralyze'\n     * })\n     * class Paralyze {}\n     * \n     * @Armor({\n     *      name: 'Shield',\n     *      statesDefense: [{ rate: 1, state: Paralyze }]\n     * })\n     * class Shield {}\n     * \n     * @Armor({\n     *      name: 'FireShield',\n     *      statesDefense: [{ rate: 0.5, state: Paralyze }]\n     * })\n     * class FireShield {}\n     *\n     * player.addItem(Shield)\n     * player.addItem(FireShield)\n     * player.equip(Shield)\n     * player.equip(FireShield)\n     * \n     * console.log(player.statesDefense) // [{ rate: 1, state: instance of Paralyze }]\n     * ``` \n     * @title Get States Defense\n     * @prop {Array<{ rate: number, state: StateClass}>} player.statesDefense\n     * @readonly\n     * @memberof StateManager\n     * */\n    get statesDefense(): { rate: number, state: any }[] {\n        return this.getFeature('statesDefense', 'state')\n    }\n\n    /** \n     * Set or retrieves all the states where the player is vulnerable or not. \n     * \n     * ```ts\n     * import { Class, State } from '@rpgjs/server'\n     * \n     * @State({\n     *      name: 'Paralyze'\n     * })\n     * class Paralyze {}\n     * \n     * @State({\n     *      name: 'Sleep'\n     * })\n     * class Sleep {}\n     * \n     * @Class({\n     *      name: 'Fighter',\n     *      statesEfficiency: [{ rate: 1, state: Paralyze }]\n     * })\n     * class Hero {}\n     * \n     * player.setClass(Hero)\n     * \n     * console.log(player.statesEfficiency) // [{ rate: 1, instance of Paralyze }]\n     * \n     * player.statesEfficiency = [{ rate: 2, state: Sleep }]\n     * \n     * console.log(player.statesEfficiency) // [{ rate: 1, state: instance of Paralyze }, { rate: 2, state: instance of Sleep }]\n     * ``` \n     * @title Set/Get States Efficiency\n     * @prop {Array<{ rate: number, state: StateClass}>} player.statesEfficiency\n     * @memberof StateManager\n     * */\n    get statesEfficiency() {\n        return this._statesEfficiency\n    }\n\n    set statesEfficiency(val) {\n        this._statesEfficiency = val\n    }\n\n    applyStates(player: RpgPlayer, { addStates, removeStates }) {\n        if (addStates) {\n            for (let { state, rate } of addStates) {\n                player.addState(state, rate)\n            }\n        }\n        if (removeStates) {\n            for (let { state, rate } of removeStates) {\n                player.removeState(state, rate)\n            }\n        } \n    }\n\n    /**\n     * Get a state to the player. Returns `null` if the state is not present on the player\n     * ```ts\n     * import Paralyze from 'your-database/states/paralyze'\n     * \n     * player.getState(Paralyze)\n     *  ```\n     * \n     * @title Get State\n     * @method player.getState(stateClass)\n     * @param {StateClass | string} stateClass or state id\n     * @returns {instance of StateClass | null}\n     * @memberof StateManager\n     */\n    getState(stateClass: StateClass | string) {\n        if (isString(stateClass)) stateClass = this.databaseById(stateClass)\n        return this.states.find((state) => {\n            if (isString(stateClass)) {\n                return state.id == stateClass\n            }\n            return isInstanceOf(state, stateClass)\n        })\n    }\n\n    /**\n     * Adds a state to the player. Set the chance between 0 and 1 that the state can apply\n     * ```ts\n     * import Paralyze from 'your-database/states/paralyze'\n     * \n     * try { \n     *      player.addState(Paralyze)\n     * }\n     * catch (err) {\n     *      console.log(err)\n     * }\n     *  ```\n     * \n     * @title Add State\n     * @method player.addState(stateClass,chance=1)\n     * @param {StateClass | string} stateClass state class or state id\n     * @param {number} [chance] 1 by default\n     * @throws {StateLog} addFailed \n     * If the chance to add the state has failed (defined with the `chance` param)\n     *  ```\n     * {\n     *      id: ADD_STATE_FAILED,\n     *      msg: '...'\n     * }\n     * ```\n     * @returns {instance of StateClass}\n     * @memberof StateManager\n     * @todo\n     */\n    addState(stateClass: StateClass | string, chance = 1): object | null {\n        const state = this.getState(stateClass)\n        if (isString(stateClass)) {\n            stateClass = this.databaseById(stateClass)\n        }\n        if (!state) {\n            if (Math.random() > chance) {\n                throw StateLog.addFailed(stateClass)\n            }\n            //const efficiency = this.findStateEfficiency(stateClass)\n            const instance = new (stateClass as StateClass)()\n            this.states.push(instance)\n            this.applyStates(<any>this, instance)\n            return instance\n        }\n        return null\n    }\n\n    /**\n     * Remove a state to the player. Set the chance between 0 and 1 that the state can be removed\n     * ```ts\n     * import Paralyze from 'your-database/states/paralyze'\n     * \n     * try { \n     *      player.removeState(Paralyze)\n     * }\n     * catch (err) {\n     *      console.log(err)\n     * }\n     *  ```\n     * \n     * @title Remove State\n     * @method player.removeState(stateClass,chance=1)\n     * @param {StateClass|string} stateClass class state or state id\n     * @param {number} [chance] 1 by default\n     * @throws {StateLog} removeFailed \n     * If the chance to remove the state has failed (defined with the `chance` param)\n     *  ```\n     * {\n     *      id: REMOVE_STATE_FAILED,\n     *      msg: '...'\n     * }\n     * ```\n     * @throws {StateLog} notApplied \n     * If the status does not exist\n     *  ```\n     * {\n     *      id: STATE_NOT_APPLIED,\n     *      msg: '...'\n     * }\n     * ```\n     * @returns {instance of StateClass}\n     * @memberof StateManager\n     */\n    removeState(stateClass: StateClass | string, chance = 1) {\n        const index = this.states.findIndex((state) => {\n            if (isString(stateClass)) {\n                return state.id == stateClass\n            }\n            return isInstanceOf(state, stateClass)\n        })\n        if (index != -1) {\n            if (Math.random() > chance) {\n                throw StateLog.removeFailed(stateClass)\n            }\n            this.states.splice(index, 1)\n        }\n        else {\n            throw StateLog.notApplied(stateClass)\n        }\n    }\n\n    private findStateEfficiency(stateClass) {\n        return this.statesEfficiency.find(state => isInstanceOf(state.state, stateClass))\n    }\n}\n\napplyMixins(StateManager, [ItemFixture])\n\nexport interface StateManager extends ItemFixture { \n    databaseById(stateClass: any),\n}", "import { Utils } from '@rpgjs/common'\nimport { Effect, ClassHooks, ItemClass, ItemInstance, WeaponInstance, ArmorInstance, WeaponClass, ArmorClass } from '@rpgjs/database'\nimport { ItemLog } from '../logs'\nimport { EffectManager } from './EffectManager'\nimport { GoldManager } from './GoldManager'\nimport { StateManager } from './StateManager'\n\nimport {\n    ATK,\n    PDEF,\n    SDEF\n} from '../presets'\n\nconst {\n    isString,\n    isInstanceOf,\n    applyMixins\n} = Utils\n\n\ntype Inventory = { nb: number, item: ItemInstance }\n\nexport class ItemManager {\n\n    items: Inventory[]\n    equipments: ItemInstance[] = []\n\n    /**\n    * Retrieves the information of an object: the number and the instance \n    * @title Get Item\n    * @method player.getItem(itemClass)\n    * @param {ItemClass | string} itemClass Identifier of the object if the parameter is a string\n    * @returns {{ nb: number, item: instance of ItemClass }}\n    * @memberof ItemManager\n    * @example\n    * \n    * ```ts\n    * import Potion from 'your-database/potion'\n    * \n    * player.addItem(Potion, 5)\n    * const inventory = player.getItem(Potion)\n    * console.log(inventory) // { nb: 5, item: <instance of Potion> }\n    *  ```\n    */\n    getItem(itemClass: ItemClass | string): Inventory {\n        const index: number = this._getItemIndex(itemClass)\n        return this.items[index]\n    }\n\n    /**\n     * Check if the player has the item in his inventory.\n     * @title Has Item\n     * @method player.hasItem(itemClass)\n     * @param {ItemClass | string} itemClass Identifier of the object if the parameter is a string\n     * @returns {boolean}\n     * @memberof ItemManager\n     * @example\n     * \n     * ```ts\n     * import Potion from 'your-database/potion'\n     * \n     * player.hasItem(Potion) // false\n     *  ```\n     */\n    hasItem(itemClass: ItemClass | string): boolean {\n        return !!this.getItem(itemClass)\n    }\n\n    _getItemIndex(itemClass: ItemClass | string): number {\n        return this.items.findIndex((it: Inventory): boolean => {\n            if (isString(itemClass)) {\n                return it.item.id == itemClass\n            }\n            return isInstanceOf(it.item, itemClass)\n        })\n    }\n    /**\n     * Add an item in the player's inventory. You can give more than one by specifying `nb`\n     * \n     * `onAdd()` method is called on the ItemClass\n     * \n     * @title Add Item\n     * @method player.addItem(item,nb=1)\n     * @param {ItemClass} itemClass \n     * @param {number} [nb] Default 1\n     * @returns {{ nb: number, item: instance of ItemClass }}\n     * @memberof ItemManager\n     * @example\n     * \n     * ```ts\n     * import Potion from 'your-database/potion'\n     * player.addItem(Potion, 5)\n     *  ```\n     */\n    addItem(itemClass: ItemClass | string, nb: number = 1): Inventory {\n        if (isString(itemClass)) itemClass = this.databaseById(itemClass)\n        let itemIndex: number = this._getItemIndex(itemClass)\n        if (itemIndex != -1) {\n            this.items[itemIndex].nb += nb\n        }\n        else {\n            const instance = new (itemClass as ItemClass)()\n            this.items.push({\n                item: instance,\n                nb\n            })\n            itemIndex = this.items.length - 1\n        }\n        const { item } = this.items[itemIndex]\n        this['execMethod']('onAdd', [this], item)\n        return this.items[itemIndex]\n    }\n\n    /**\n     * Deletes an item. Decreases the value `nb`. If the number falls to 0, then the item is removed from the inventory. The method then returns `undefined`\n     * \n     * `onRemove()` method is called on the ItemClass\n     * \n     * @title Remove Item\n     * @method player.removeItem(item,nb=1)\n     * @param {ItemClass | string} itemClass string is item id\n     * @param {number} [nb] Default 1\n     * @returns {{ nb: number, item: instance of ItemClass } | undefined}\n     * @throws {ItemLog} notInInventory \n     * If the object is not in the inventory, an exception is raised\n     *  ```\n     * {\n     *      id: ITEM_NOT_INVENTORY,\n     *      msg: '...'\n     * }\n     * ```\n     * @memberof ItemManager\n     * @example\n     * \n     * ```ts\n     * import Potion from 'your-database/potion'\n     * \n     * try {\n     *    player.removeItem(Potion, 5)\n     * }\n     * catch (err) {\n     *    console.log(err)\n     * }\n     * ```\n     */\n    removeItem(itemClass: ItemClass | string, nb: number = 1): Inventory | undefined {\n        const itemIndex: number = this._getItemIndex(itemClass)\n        if (itemIndex == -1) {\n            throw ItemLog.notInInventory(itemClass)\n        }\n        const currentNb: number = this.items[itemIndex].nb\n        const { item } = this.items[itemIndex]\n        if (currentNb - nb <= 0) {\n            this.items.splice(itemIndex, 1)\n        }\n        else {\n            this.items[itemIndex].nb -= nb\n        }\n        this['execMethod']('onRemove', [this], item)\n        return this.items[itemIndex]\n    }\n\n    /**\n     * Purchases an item and reduces the amount of gold\n     * \n     * `onAdd()` method is called on the ItemClass\n     * \n     * @title Buy Item\n     * @method player.buyItem(item,nb=1)\n     * @param {ItemClass | string} itemClass string is item id\n     * @param {number} [nb] Default 1\n     * @returns {{ nb: number, item: instance of ItemClass }}\n     * @throws {ItemLog} haveNotPrice \n     * If you have not set a price on the item\n     *  ```\n     * {\n     *      id: NOT_PRICE,\n     *      msg: '...'\n     * }\n     * ```\n     * @throws {ItemLog} notEnoughGold \n     * If the player does not have enough money\n     *  ```\n     * {\n     *      id: NOT_ENOUGH_GOLD,\n     *      msg: '...'\n     * }\n     * ```\n     * @memberof ItemManager\n     * @example\n     * \n     * ```ts\n     * import Potion from 'your-database/potion'\n     * \n     * try {\n     *    player.buyItem(Potion)\n     * }\n     * catch (err) {\n     *    console.log(err)\n     * }\n     * ```\n     */\n    buyItem(itemClass: ItemClass | string, nb = 1): Inventory {\n        if (isString(itemClass)) itemClass = this.databaseById(itemClass)\n        const ItemClass = itemClass as ItemClass\n        if (!ItemClass.price) {\n            throw ItemLog.haveNotPrice(itemClass)\n        }\n        const totalPrice = nb * ItemClass.price\n        if (this.gold < totalPrice) {\n            throw ItemLog.notEnoughGold(itemClass, nb)\n        }\n        this.gold -= totalPrice\n        return this.addItem(ItemClass, nb)\n    }\n\n    /**\n     * Sell an item and the player wins the amount of the item divided by 2\n     * \n     * `onRemove()` method is called on the ItemClass\n     * \n     * @title Sell Item\n     * @method player.sellItem(item,nb=1)\n     * @param {ItemClass | string} itemClass string is item id\n     * @param {number} [nbToSell] Default 1\n     * @returns {{ nb: number, item: instance of ItemClass }}\n     * @throws {ItemLog} haveNotPrice \n     * If you have not set a price on the item\n     *   ```\n     * {\n     *      id: NOT_PRICE,\n     *      msg: '...'\n     * }\n     * ```\n     * @throws {ItemLog} notInInventory \n     * If the object is not in the inventory, an exception is raised\n     *  ```\n     * {\n     *      id: ITEM_NOT_INVENTORY,\n     *      msg: '...'\n     * }\n     * ```\n     * @throws {ItemLog} tooManyToSell \n     * If the number of items for sale exceeds the number of actual items in the inventory\n     *  ```\n     * {\n     *      id: TOO_MANY_ITEM_TO_SELL,\n     *      msg: '...'\n     * }\n     * ```\n     * @memberof ItemManager\n     * @example\n     * \n     * ```ts\n     * import Potion from 'your-database/potion'\n     * \n     * try {\n     *     player.addItem(Potion)\n     *     player.sellItem(Potion)\n     * }\n     * catch (err) {\n     *    console.log(err)\n     * }\n     * ```\n     */\n    sellItem(itemClass: ItemClass | string, nbToSell = 1): Inventory {\n        if (isString(itemClass)) itemClass = this.databaseById(itemClass)\n        const ItemClass = itemClass as ItemClass\n        const inventory = this.getItem(ItemClass)\n        if (!inventory) {\n            throw ItemLog.notInInventory(itemClass)\n        }\n        const { item, nb } = inventory\n        if (nb - nbToSell < 0) {\n            throw ItemLog.tooManyToSell(itemClass, nbToSell, nb)\n        }\n        if (!ItemClass.price) {\n            throw ItemLog.haveNotPrice(itemClass)\n        }\n        this.gold += (ItemClass.price / 2) * nbToSell\n        this.removeItem(ItemClass, nbToSell)\n        return inventory\n    }\n\n    private getParamItem(name: string): number {\n        let nb = 0\n        for (let item of this.equipments) {\n            nb += item[name] || 0\n        }\n        const modifier = this.paramsModifier[name]\n        if (modifier) {\n            if (modifier.value) nb += modifier.value\n            if (modifier.rate) nb *= modifier.rate\n        }\n        return nb\n    }\n\n    /**\n     * recover the attack sum of items equipped on the player.\n     * \n     * @title Get the player's attack\n     * @prop {number} player.atk\n     * @memberof ItemManager\n     */\n    get atk(): number {\n        return this.getParamItem(ATK)\n    }\n\n    /**\n    * recover the physic defense sum of items equipped on the player.\n    * \n    * @title Get the player's pdef\n    * @prop {number} player.pdef\n    * @memberof ItemManager\n    */\n    get pdef(): number {\n        return this.getParamItem(PDEF)\n    }\n\n    /**\n    * recover the skill defense sum of items equipped on the player.\n    * \n    * @title Get the player's sdef\n    * @prop {number} player.sdef\n    * @memberof ItemManager\n    */\n    get sdef(): number {\n        return this.getParamItem(SDEF)\n    }\n\n    /**\n     *  Use an object. Applies effects and states. Removes the object from the inventory then\n     * \n     * `onUse()` method is called on the ItemClass (If the use has worked)\n     * `onRemove()` method is called on the ItemClass\n     * \n     * @title Use an Item\n     * @method player.useItem(item,nb=1)\n     * @param {ItemClass | string} itemClass string is item id\n     * @returns {{ nb: number, item: instance of ItemClass }}\n     * @throws {ItemLog} restriction \n     * If the player has the `Effect.CAN_NOT_ITEM` effect\n     *   ```\n     * {\n     *      id: RESTRICTION_ITEM,\n     *      msg: '...'\n     * }\n     * ```\n     * @throws {ItemLog} notInInventory \n     * If the object is not in the inventory, an exception is raised\n     *  ```\n     * {\n     *      id: ITEM_NOT_INVENTORY,\n     *      msg: '...'\n     * }\n     * ```\n     * @throws {ItemLog} notUseItem \n     * If the `consumable` property is on false\n     *  ```\n     * {\n     *      id: NOT_USE_ITEM,\n     *      msg: '...'\n     * }\n     * ```\n     * @throws {ItemLog} chanceToUseFailed \n     * Chance to use the item has failed. Chances of use is defined with `ItemClass.hitRate`\n     *  ```\n     * {\n     *      id: USE_CHANCE_ITEM_FAILED,\n     *      msg: '...'\n     * }\n     * ```\n     * > the item is still deleted from the inventory\n     * \n     * `onUseFailed()` method is called on the ItemClass\n     * \n     * @memberof ItemManager\n     * @example\n     * \n     * ```ts\n     * import Potion from 'your-database/potion'\n     * \n     * try {\n     *     player.addItem(Potion)\n     *     player.useItem(Potion)\n     * }\n     * catch (err) {\n     *    console.log(err)\n     * }\n     * ```\n     */\n    useItem(itemClass: ItemClass | string): Inventory {\n        const inventory = this.getItem(itemClass)\n        if (this.hasEffect(Effect.CAN_NOT_ITEM)) {\n            throw ItemLog.restriction(itemClass)\n        }\n        if (!inventory) {\n            throw ItemLog.notInInventory(itemClass)\n        }\n        const { item } = inventory\n        if (item.consumable === false) {\n            throw ItemLog.notUseItem(itemClass)\n        }\n        const hitRate = item.hitRate ?? 1\n        if (Math.random() > hitRate) {\n            this.removeItem(itemClass)\n            this['execMethod']('onUseFailed', [this], item)\n            throw ItemLog.chanceToUseFailed(itemClass)\n        }\n        this.applyEffect(item)\n        this.applyStates(<any>this, <any>item)\n        this['execMethod']('onUse', [this], item)\n        this.removeItem(itemClass)\n        return inventory\n    }\n\n    /**\n     * Equips a weapon or armor on a player. Think first to add the item in the inventory with the `addItem()` method before equipping the item.\n     * \n     * `onEquip()` method is called on the ItemClass\n     * \n     * @title Equip Weapon or Armor\n     * @method player.equip(itemClass,equip=true)\n     * @param {ItemClass | string} itemClass string is item id\n     * @param {number} [equip] Equip the object if true or un-equipped if false\n     * @returns {void}\n     * @throws {ItemLog} notInInventory \n     * If the item is not in the inventory\n     *  ```\n        {\n            id: ITEM_NOT_INVENTORY,\n            msg: '...'\n        }\n        ```\n     * @throws {ItemLog} invalidToEquiped \n        If the item is not by a weapon or armor\n        ```\n        {\n            id: INVALID_ITEM_TO_EQUIP,\n            msg: '...'\n        }\n        ```\n    * @throws {ItemLog} isAlreadyEquiped \n        If the item Is already equipped\n        ```\n        {\n            id: ITEM_ALREADY_EQUIPED,\n            msg: '...'\n        }\n        ```\n     * @memberof ItemManager\n     * @example\n     * \n     * ```ts\n     * import Sword from 'your-database/sword'\n     * \n     * try {\n     *      player.addItem(Sword)\n     *      player.equip(Sword)\n     * }\n     * catch (err) {\n     *    console.log(err)\n     * }\n     * ```\n     */\n    equip(itemClass: WeaponClass | ArmorClass | string, equip: boolean = true): void {\n        const inventory: Inventory = this.getItem(itemClass)\n        if (!inventory) {\n            throw ItemLog.notInInventory(itemClass)\n        }\n        if ((itemClass as ItemClass)._type == 'item') {\n            throw ItemLog.invalidToEquiped(itemClass)\n        }\n\n        if (this._class && this._class[ClassHooks.canEquip]) {\n            const canEquip = this['execMethodSync'](ClassHooks.canEquip, [inventory.item, this], this._class)\n            if (!canEquip) {\n                throw ItemLog.canNotEquip(itemClass)\n            }\n        }\n\n        const item: WeaponInstance | ArmorInstance = inventory.item as any\n        \n        if (item.equipped && equip) {\n            throw ItemLog.isAlreadyEquiped(itemClass)\n        }\n        item.equipped = equip\n        if (!equip) {\n            const index = this.equipments.findIndex(it => it.id == item.id)\n            this.equipments.splice(index, 1)\n        }\n        else {\n            this.equipments.push(item)\n        }\n        this['execMethod']('onEquip', [this, equip], item)\n    }\n}\n\napplyMixins(ItemManager, [GoldManager, StateManager, EffectManager])\n\nexport interface ItemManager extends GoldManager, StateManager, EffectManager {\n    databaseById(itemClass: any),\n}", "import { Utils }  from '@rpgjs/common'\nimport { Effect } from '@rpgjs/database'\nimport { SkillLog } from '../logs'\nimport { StateManager } from './StateManager'\nimport { EffectManager } from './EffectManager'\nimport { ParameterManager } from './ParameterManager';\nimport { RpgPlayer } from './Player';\n\nconst { \n    isArray, \n    isString, \n    isInstanceOf,\n    applyMixins\n} = Utils\n\ntype SkillClass = { new(...args: any[]) }\n\nexport class SkillManager {\n\n    skills: any[]\n\n    private _getSkillIndex(skillClass: SkillClass | string) {\n        return this.skills.findIndex(skill => {\n            if (isString(skill)) {\n                return skill.id == skillClass\n            }\n            if (isString(skillClass)) {\n                return skillClass == (skill.id || skill)\n            }\n            return isInstanceOf(skill, skillClass)\n        })\n    }\n\n    /**\n     * Retrieves a learned skill. Returns null, if not found\n     * ```ts\n     * import Fire from 'your-database/skills/fire'\n     * \n     * player.getSkill(Fire)\n     *  ```\n     * \n     * @title Get Skill\n     * @method player.getSkill(skillClass)\n     * @param {SkillClass | string} skillClass or data id\n     * @returns {instance of SkillClass | null}\n     * @memberof SkillManager\n     */\n    getSkill(skillClass: SkillClass | string) {\n        const index = this._getSkillIndex(skillClass)\n        return this.skills[index] ?? null\n    }\n\n    /**\n     * Learn a skill. Attributes the coefficient 1 to the parameter INT (intelligence) if cd is not present on the class.\n     * \n     * `onLearn()` method is called on the SkillClass\n     * \n     * ```ts\n     * import Fire from 'your-database/skills/fire'\n     * \n     * player.learnSkill(Fire)\n     *  ```\n     * \n     * @title Learn Skill\n     * @method player.learnSkill(skillClass)\n     * @param {SkillClass | string} skillClass or data id\n     * @throws {SkillLog} alreadyLearned\n     *  If the player already knows the skill\n     *  ```\n        {\n            id: SKILL_ALREADY_LEARNED,\n            msg: '...'\n        }\n        ```\n     * @returns {instance of SkillClass}\n     * @memberof SkillManager\n     */\n    learnSkill(skillClass: SkillClass | string) {\n        if (this.getSkill(skillClass)) {\n            throw SkillLog.alreadyLearned(skillClass)\n        }\n        if (isString(skillClass)) skillClass = this.databaseById(skillClass)\n        const instance = new (skillClass as SkillClass)()\n        this.skills.push(instance)\n        this['execMethod']('onLearn', [this], instance)\n        return instance\n    }\n\n    /**\n     * Forget a skill\n     * \n     * `onForget()` method is called on the SkillClass\n     * \n     * ```ts\n     * import Fire from 'your-database/skills/fire'\n     * \n     * try {\n     *      player.forgetSkill(Fire) \n     * }\n     * catch (err) {\n     *      console.log(err)\n     * }\n     *  ```\n     * \n     * @title Forget Skill\n     * @method player.learnSkill(skillClass)\n     * @param {SkillClass | string} skillClass or data id\n     * @throws {SkillLog} notLearned \n     * If trying to forget a skill not learned\n     *  ```\n     * {\n     *      id: SKILL_NOT_LEARNED,\n     *      msg: '...'\n     * }\n     * ```\n     * @returns {instance of SkillClass}\n     * @memberof SkillManager\n     */\n    forgetSkill(skillClass: SkillClass | string) {\n        if (isString(skillClass)) skillClass = this.databaseById(skillClass)\n        const index = this._getSkillIndex(skillClass)\n        if (index == -1) {\n            throw SkillLog.notLearned(skillClass)\n        }\n        const instance = this.skills[index]\n        this.skills.splice(index, 1)\n        this['execMethod']('onForget', [this], instance)\n        return instance\n    }\n\n    /**\n     * Using a skill\n     * \n     * `onUse()` method is called on the SkillClass\n     * \n     * If other players are indicated then damage will be done to these other players. The method `applyDamage()` will be executed\n     * \n     * ```ts\n     * import Fire from 'your-database/skills/fire'\n     * \n     * try {\n     *      player.useSkill(Fire) \n     * }\n     * catch (err) {\n     *      console.log(err)\n     * }\n     *  ```\n     * \n     * or \n     * \n     * \n     * * ```ts\n     * import Fire from 'your-database/skills/fire'\n     * \n     * try {\n     *      player.useSkill(Fire, otherPlayer) \n     * }\n     * catch (err) {\n     *      console.log(err)\n     * }\n     *  ```\n     * \n     * @title Use Skill\n     * @method player.useSkill(skillClass,otherPlayer)\n     * @param {SkillClass | string} skillClass or data id\n     * @param {Array<RpgPlayer> | RpgPlayer} [otherPlayer] \n     * @throws {SkillLog} restriction \n     * If the player has the `Effect.CAN_NOT_SKILL` effect \n     *  ```\n     * {\n     *      id: RESTRICTION_SKILL,\n     *      msg: '...'\n     * }\n     * ```\n     * @throws {SkillLog} notLearned \n     * If the player tries to use an unlearned skill\n     *  ```\n     * {\n     *      id: SKILL_NOT_LEARNED,\n     *      msg: '...'\n     * }\n     * ```\n     * @throws {SkillLog} notEnoughSp \n     * If the player does not have enough SP to use the skill\n     *  ```\n     * {\n     *      id: NOT_ENOUGH_SP,\n     *      msg: '...'\n     * }\n     * ```\n     * @throws {SkillLog} chanceToUseFailed \n     * If the chance to use the skill has failed (defined with the `hitRate` property)\n     *  ```\n     * {\n     *      id: USE_CHANCE_SKILL_FAILED,\n     *      msg: '...'\n     * }\n     * ```\n     * \n     * `onUseFailed()` method is called on the SkillClass\n     * \n     * @returns {instance of SkillClass}\n     * @memberof SkillManager\n     * @todo\n     */\n    useSkill(skillClass: SkillClass | string, otherPlayer?: RpgPlayer | RpgPlayer[]) {\n        const skill = this.getSkill(skillClass)\n        if (this.hasEffect(Effect.CAN_NOT_SKILL)) {\n            throw SkillLog.restriction(skillClass)\n        }\n        if (!skill) {\n            throw SkillLog.notLearned(skillClass)\n        }\n        if (skill.spCost > this.sp) {\n            throw SkillLog.notEnoughSp(skillClass, skill.spCost, this.sp)\n        }\n        this.sp -= (skill.spCost / (this.hasEffect(Effect.HALF_SP_COST) ? 2 : 1))\n        const hitRate = skill.hitRate ?? 1\n        if (Math.random() > hitRate) {\n            this['execMethod']('onUseFailed', [this, otherPlayer], skill)\n            throw SkillLog.chanceToUseFailed(skillClass)\n        }\n        if (otherPlayer) {\n            let players: any = otherPlayer\n            if (!isArray(players)) {\n                players = [otherPlayer]\n            }\n            for (let player of players) {\n                this.applyStates(player, skill)\n                player.applyDamage(this, skill)\n            } \n        }\n        this['execMethod']('onUse', [this, otherPlayer], skill)\n        return skill\n    }\n}\n\napplyMixins(SkillManager, [ParameterManager, StateManager, EffectManager])\n\nexport interface SkillManager extends ParameterManager, StateManager, EffectManager { \n    databaseById(skillClass: any),\n}\n", "import { Utils }  from '@rpgjs/common'\nimport { ParameterManager } from './ParameterManager'\nimport { ItemManager } from './ItemManager'\n\nconst { \n    applyMixins,\n    isString\n} = Utils\n\ntype ClassClass = { new(...args: any[]) }\ntype ActorClass = { new(...args: any[]) }\n\nexport class ClassManager {\n\n    _class: any\n\n    /** \n     * Assign a class to the player\n     * \n     * ```ts\n     * import { Fighter } from 'my-database/classes/fighter'\n     * \n     * player.setClass(Fighter)\n     * ```\n     * \n     * @title Set Class\n     * @method player.setClass(ClassClass)\n     * @param {ClassClass | string} class class or id\n     * @returns {instance of ClassClass} \n     * @memberof ClassManager\n     * */\n    setClass(_class: ClassClass | string) {\n        if (isString(_class)) _class = this.databaseById(_class)\n        this._class = new (_class as ClassClass)()\n        this['execMethod']('onSet', [this], this._class)\n        return this._class\n    }\n\n    /** \n     * Allows to give a set of already defined properties to the player (default equipment, or a list of skills to learn according to the level)\n     * \n     * ```ts\n     * import { Hero } from 'my-database/classes/hero'\n     * \n     * player.setActor(Hero)\n     * ```\n     * \n     * @title Set Actor\n     * @method player.setActor(ActorClass)\n     * @param {ActorClass | string} actorClass actor class or id\n     * @returns {instance of ActorClass} \n     * @memberof ClassManager\n     * */\n    setActor(actorClass: ActorClass | string) {\n        if (isString(actorClass)) actorClass = this.databaseById(actorClass)\n        const actor = new (actorClass as ActorClass)();\n        ['name', 'initialLevel', 'finalLevel', 'expCurve'].forEach(key => {\n            if (actor[key]) this[key] = actor[key]\n        })\n        for (let param in actor.parameters) {\n            this.addParameter(param, actor.parameters[param])\n        }\n        for (let item of actor.startingEquipment) {\n            this.addItem(item)\n            this.equip(item, true)\n        }\n        if (actor.class) this.setClass(actor.class)\n        this['execMethod']('onSet', [this], actor)\n        return actor\n    }\n}\n\napplyMixins(ClassManager, [ParameterManager, ItemManager])\n\nexport interface ClassManager extends ParameterManager, ItemManager {\n    name: string\n }", "import { Utils }  from '@rpgjs/common'\nimport { RpgPlayer } from './Player';\nimport { ItemFixture } from './ItemFixture';\nimport { ItemInstance } from '@rpgjs/database';\n\nconst { \n    arrayUniq,\n    applyMixins\n} = Utils\n\nexport class ElementManager extends ItemFixture {\n    _elementsEfficiency: { rate: number, element: any }[]\n    \n     /** \n     * Recovers the player's elements defense on inventory.  This list is generated from the `elementsDefense` property defined on the weapons or armors equipped.\n     * If several items have the same element, only the highest rate will be taken into account.\n     * \n     * ```ts\n     * import { Armor } from '@rpgjs/server'\n     * \n     * enum Elements {\n     *   Fire = 'fire'\n     * }\n     * \n     * @Armor({\n     *      name: 'Shield',\n     *      elementsDefense: [{ rate: 1, element: Elements.Fire }]\n     * })\n     * class Shield {}\n     * \n     * @Armor({\n     *      name: 'FireShield',\n     *      elementsDefense: [{ rate: 0.5, element: Elements.Fire }]\n     * })\n     * class FireShield {}\n     * \n     * player.addItem(Shield)\n     * player.addItem(FireShield)\n     * player.equip(Shield)\n     * player.equip(FireShield)\n     * \n     * console.log(player.elementsDefense) // [{ rate: 1, element: 'fire' }]\n     * ``` \n     * @title Get Elements Defense\n     * @prop {Array<{ rate: number, element: Element}>} player.elementsDefense\n     * @readonly\n     * @memberof ElementManager\n     * */\n    get elementsDefense(): { rate: number, element: any }[] {\n        return this.getFeature('elementsDefense', 'element')\n    }\n\n     /** \n     * Set or retrieves all the elements where the player is vulnerable or not. \n     * \n     * ```ts\n     * import { Class } from '@rpgjs/server'\n     * \n     * enum Elements {\n     *   Fire = 'fire',\n     *   Ice = 'ice'\n     * }\n     * \n     * @Class({\n     *      name: 'Fighter',\n     *      elementsEfficiency: [{ rate: 1, element: Elements.Fire }]\n     * })\n     * class Hero {}\n     * \n     * player.setClass(Hero)\n     * \n     * console.log(player.elementsEfficiency) // [{ rate: 1, element: 'fire' }]\n     * \n     * player.elementsEfficiency = [{ rate: 2, element: Elements.Ice }]\n     * \n     * console.log(player.elementsEfficiency) // [{ rate: 1, element: 'fire' }, { rate: 2, element: 'ice' }]\n     * ``` \n     * @title Set/Get Elements Efficiency\n     * @prop {Array<{ rate: number, element: Element}>} player.elementsEfficiency\n     * @memberof ElementManager\n     * */\n    get elementsEfficiency(): { rate: number, element: any }[] {\n        if (this._class) {\n            return <any>[...this._elementsEfficiency, ...this._class.elementsEfficiency]\n        }\n        return this._elementsEfficiency\n    }\n\n    set elementsEfficiency(val) {\n        this._elementsEfficiency = val\n    }\n\n    /** \n     * Retrieves a array of elements assigned to the player and the elements of the weapons / armor equipped\n     * \n     * ```ts\n     * console.log(player.elements)\n     * ``` \n     * @title Get Elements\n     * @prop {Array<Element>} player.elements\n     * @readonly\n     * @memberof ElementManager\n     * */\n    get elements(): {\n        rate: number,\n        element: string\n    }[] {\n        let elements: any = []\n        for (let item of this.equipments) {\n            if (item.elements) {\n                elements = [...elements, ...item.elements]\n            }\n        }\n        return arrayUniq(elements)\n    }\n\n    coefficientElements(otherPlayer: RpgPlayer): number {\n        const atkPlayerElements: any = otherPlayer.elements\n        const playerElements: any = this.elementsEfficiency\n        let coefficient = 1\n\n        for (let atkElement of atkPlayerElements) {\n            const elementPlayer = playerElements.find(el => el.element == atkElement.element)\n            const elementPlayerDef = this.elementsDefense.find(el => el.element == atkElement.element)\n            if (!elementPlayer) continue\n            const fn = this.getFormulas('coefficientElements')\n            if (!fn) {\n                return coefficient\n            }\n            coefficient += fn(atkElement, elementPlayer, elementPlayerDef || { rate: 0 })\n        }\n        return coefficient\n    }\n}\n\nexport interface ElementManager{ \n    equipments: ItemInstance[]\n    getFormulas: (name: string) => any, \n    _class: any\n}\n\n\napplyMixins(ElementManager, [ItemFixture])\n\nexport interface ElementManager extends ItemFixture { }", "import { RpgPlayer } from '../Player/Player'\nimport { EventEmitter } from '@rpgjs/common'\n\nexport class Gui extends EventEmitter {\n\n    private _close: Function = () => {}\n    private _blockPlayerInput: boolean = false\n\n    constructor(\n        public id: string,\n        protected player: RpgPlayer,\n    ) {\n        super()\n    }\n\n    open(data?, {\n        waitingAction = false,\n        blockPlayerInput = false\n    } = {}): Promise<any> {\n        return new Promise((resolve) => {\n            this.player.moving = false\n            this.player.emit('gui.open', {\n                guiId: this.id,\n                data\n            })\n            this._blockPlayerInput = blockPlayerInput\n            if (blockPlayerInput) {\n                this.player.canMove = false\n            }\n            if (!waitingAction) {\n                resolve(null)\n            }\n            else {\n                this._close = resolve\n            }\n        })\n    }\n\n    close(data?) {\n        this.player.emit('gui.exit', this.id)\n        if (this._blockPlayerInput) {\n            this.player.canMove = true\n        }\n        this._close(data)\n    }\n}", "import { Direction, LiteralDirection, RpgShape, Vector2d } from '@rpgjs/common'\nimport { Utils } from '@rpgjs/common'\nimport { Behavior, ClientMode, MoveMode, MoveTo, PositionXY, SocketEvents, SocketMethods, Tick } from '@rpgjs/types'\nimport { Observable, Subscription, takeUntil, Subject, tap, switchMap, of, from, debounceTime } from 'rxjs'\nimport { RpgServerEngine } from '../server'\nimport { RpgEvent, RpgPlayer } from './Player'\n\nconst {\n    arrayFlat,\n    random,\n    isFunction,\n    capitalize\n} = Utils\n\nfunction wait(sec: number) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, sec * 1000)\n    })\n}\n\ntype CallbackTileMove = (player: RpgPlayer, map) => Direction[]\ntype CallbackTurnMove = (player: RpgPlayer, map) => string\ntype Routes = (string | Promise<any> | Direction | Direction[] | Function)[]\n\nexport enum Frequency {\n    Lowest = 600,\n    Lower = 400,\n    Low = 200,\n    High = 100,\n    Higher = 50,\n    Highest = 25,\n    None = 0\n}\n\nexport enum Speed {\n    Slowest = 0.2,\n    Slower = 0.5,\n    Slow = 1,\n    Normal = 3,\n    Fast = 5,\n    Faster = 7,\n    Fastest = 10\n}\n\n/** \n* @title Move\n* @enum {Object}\n* \n* Move.right(repeat=1) | Movement of a number of pixels on the right\n* Move.left(repeat=1) | Movement of a number of pixels on the left \n* Move.up(repeat=1) | Movement of a number of pixels on the up\n* Move.down(repeat=1) | Movement of a number of pixels on the down\n* Move.random(repeat=1) | Movement of a number of pixels in a random direction\n* Move.towardPlayer(player, repeat=1) | Moves a number of pixels in the direction of the designated player\n* Move.awayFromPlayer(player, repeat=1) | Moves a number of pixels in the opposite direction of the designated player\n* Move.tileRight(repeat=1) | Movement of a number of tiles on the right\n* Move.tileLeft(repeat=1) | Movement of a number of tiles on the left\n* Move.tileUp(repeat=1) | Movement of a number of tiles on the up\n* Move.tileDown(repeat=1) | Movement of a number of tiles on the down\n* Move.tileRandom(repeat=1) | Movement of a number of tiles in a random direction\n* Move.tileTowardPlayer(player, repeat=1) | Moves a number of tiles in the direction of the designated player\n* Move.tileAwayFromPlayer(player, repeat=1) | Moves a number of tiles in the opposite direction of the designated player\n* Move.turnRight() | Turn to the right\n* Move.turnLeft() | Turn to the left\n* Move.turnUp() | Turn to the up\n* Move.turnDown() | Turn to the down\n* Move.turnRandom() | Turn to random direction\n* Move.turnAwayFromPlayer(player) | Turns in the opposite direction of the designated player\n* Move.turnTowardPlayer(player) | Turns in the direction of the designated player\n* @memberof Move\n* */\nclass MoveList {\n\n    repeatMove(direction: Direction, repeat: number): Direction[] {\n        return new Array(repeat).fill(direction)\n    }\n\n    private repeatTileMove(direction: string, repeat: number, propMap: string): CallbackTileMove {\n        return (player: RpgPlayer, map): Direction[] => {\n            const repeatTile = Math.floor(map[propMap] / player.speed) * repeat\n            return this[direction](repeatTile)\n        }\n    }\n\n    right(repeat: number = 1): Direction[] {\n        return this.repeatMove(Direction.Right, repeat)\n    }\n\n    left(repeat: number = 1): Direction[] {\n        return this.repeatMove(Direction.Left, repeat)\n    }\n\n    up(repeat: number = 1): Direction[] {\n        return this.repeatMove(Direction.Up, repeat)\n    }\n\n    down(repeat: number = 1): Direction[] {\n        return this.repeatMove(Direction.Down, repeat)\n    }\n\n    wait(sec: number): Promise<unknown> {\n        return wait(sec)\n    }\n\n    random(repeat: number = 1): Direction[] {\n        return new Array(repeat).fill(null).map(() => [\n            Direction.Right,\n            Direction.Left,\n            Direction.Up,\n            Direction.Down\n        ][random(0, 3)])\n    }\n\n    tileRight(repeat: number = 1): CallbackTileMove {\n        return this.repeatTileMove('right', repeat, 'tileWidth')\n    }\n\n    tileLeft(repeat: number = 1): CallbackTileMove {\n        return this.repeatTileMove('left', repeat, 'tileWidth')\n    }\n\n    tileUp(repeat: number = 1): CallbackTileMove {\n        return this.repeatTileMove('up', repeat, 'tileHeight')\n    }\n\n    tileDown(repeat: number = 1): CallbackTileMove {\n        return this.repeatTileMove('down', repeat, 'tileHeight')\n    }\n\n    tileRandom(repeat: number = 1): CallbackTileMove {\n        return (player: RpgPlayer, map): Direction[] => {\n            let directions: Direction[] = []\n            for (let i = 0; i < repeat; i++) {\n                const randFn: CallbackTileMove = [\n                    this.tileRight(),\n                    this.tileLeft(),\n                    this.tileUp(),\n                    this.tileDown()\n                ][random(0, 3)]\n                directions = [\n                    ...directions,\n                    ...randFn(player, map)\n                ]\n            }\n            return directions\n        }\n    }\n\n    private _awayFromPlayerDirection(player: RpgPlayer, otherPlayer: RpgPlayer): number {\n        const directionOtherPlayer = otherPlayer.getDirection()\n        let newDirection = 0\n        switch (directionOtherPlayer) {\n            case Direction.Left:\n            case Direction.Right:\n                if (otherPlayer.position.x > player.position.x) {\n                    newDirection = Direction.Left\n                }\n                else {\n                    newDirection = Direction.Right\n                }\n                break\n            case Direction.Up:\n            case Direction.Down:\n                if (otherPlayer.position.y > player.position.y) {\n                    newDirection = Direction.Up\n                }\n                else {\n                    newDirection = Direction.Down\n                }\n                break\n        }\n        return newDirection\n    }\n\n    private _towardPlayerDirection(player: RpgPlayer, otherPlayer: RpgPlayer): number {\n        const directionOtherPlayer = otherPlayer.getDirection()\n        let newDirection = 0\n        switch (directionOtherPlayer) {\n            case Direction.Left:\n            case Direction.Right:\n                if (otherPlayer.position.x > player.position.x) {\n                    newDirection = Direction.Right\n                }\n                else {\n                    newDirection = Direction.Left\n                }\n                break\n            case Direction.Up:\n            case Direction.Down:\n                if (otherPlayer.position.y > player.position.y) {\n                    newDirection = Direction.Down\n                }\n                else {\n                    newDirection = Direction.Up\n                }\n                break\n        }\n        return newDirection\n    }\n\n    private _awayFromPlayer({ isTile, typeMov }: { isTile: boolean, typeMov: string }, otherPlayer: RpgPlayer, repeat: number = 1) {\n        const method = (dir: number) => {\n            const direction: string = LiteralDirection[dir]\n            return this[isTile ? 'tile' + capitalize(direction) : direction](repeat)\n        }\n        return (player: RpgPlayer, map) => {\n            let newDirection = 0\n            switch (typeMov) {\n                case 'away':\n                    newDirection = this._awayFromPlayerDirection(player, otherPlayer)\n                    break;\n                case 'toward':\n                    newDirection = this._towardPlayerDirection(player, otherPlayer)\n                    break\n            }\n            let direction: any = method(newDirection)\n            if (isFunction(direction)) {\n                direction = direction(player, map)\n            }\n            return direction\n        }\n    }\n\n    towardPlayer(player: RpgPlayer, repeat: number = 1) {\n        return this._awayFromPlayer({ isTile: false, typeMov: 'toward' }, player, repeat)\n    }\n\n    tileTowardPlayer(player: RpgPlayer, repeat: number = 1) {\n        return this._awayFromPlayer({ isTile: true, typeMov: 'toward' }, player, repeat)\n    }\n\n    awayFromPlayer(player: RpgPlayer, repeat: number = 1): CallbackTileMove {\n        return this._awayFromPlayer({ isTile: false, typeMov: 'away' }, player, repeat)\n    }\n\n    tileAwayFromPlayer(player: RpgPlayer, repeat: number = 1): CallbackTileMove {\n        return this._awayFromPlayer({ isTile: true, typeMov: 'away' }, player, repeat)\n    }\n\n    turnLeft(): string {\n        return 'turn-' + Direction.Left\n    }\n\n    turnRight(): string {\n        return 'turn-' + Direction.Right\n    }\n\n    turnUp(): string {\n        return 'turn-' + Direction.Up\n    }\n\n    turnDown(): string {\n        return 'turn-' + Direction.Down\n    }\n\n    turnRandom(): string {\n        return [\n            this.turnRight(),\n            this.turnLeft(),\n            this.turnUp(),\n            this.turnDown()\n        ][random(0, 3)]\n    }\n\n    turnAwayFromPlayer(otherPlayer: RpgPlayer): CallbackTurnMove {\n        return (player: RpgPlayer) => {\n            const direction = this._awayFromPlayerDirection(player, otherPlayer)\n            return 'turn-' + direction\n        }\n    }\n\n    turnTowardPlayer(otherPlayer: RpgPlayer): CallbackTurnMove {\n        return (player: RpgPlayer) => {\n            const direction = this._towardPlayerDirection(player, otherPlayer)\n            return 'turn-' + direction\n        }\n    }\n}\n\nexport const Move = new MoveList()\n\nexport class MoveManager {\n    private movingSubscription: Subscription\n    private _infiniteRoutes: Routes\n    private _finishRoute: Function\n\n    /** \n     * Changes the player's speed\n     * \n     * ```ts\n     * player.speed = 1\n     * ```\n     * \n     * You can use Speed enum\n     * \n     * ```ts\n     * import { Speed } from '@rpgjs/server'\n     * player.speed = Speed.Slow\n     * ```\n     * \n     * @title Change Speed\n     * @prop {number} player.speed\n     * @enum {number}\n     * \n     * Speed.Slowest | 0.2\n     * Speed.Slower | 0.5\n     * Speed.Slow | 1\n     * Speed.Normal | 3\n     * Speed.Fast | 5\n     * Speed.Faster | 7\n     * Speed.Fastest | 10\n     * @default 3\n     * @memberof MoveManager\n     * */\n    speed: number\n\n    /** \n     * Blocks the movement. The player will not be able to move even if he presses the direction keys on the keyboard.\n     * \n     * ```ts\n     * player.canMove = false\n     * ```\n     * \n     * @title Block movement\n     * @prop {boolean} player.canMove\n     * @default true\n     * @memberof MoveManager\n     * */\n    canMove: boolean\n\n    /** \n    * The player passes through the other players (or vice versa). But the player does not go through the events.\n    * \n    * ```ts\n    * player.throughOtherPlayer = true\n    * ```\n    * \n    * @title Go through to other player\n    * @prop {boolean} player.throughOtherPlayer\n    * @default true\n    * @memberof MoveManager\n    * */\n    throughOtherPlayer: boolean\n\n    /** \n     * The player goes through the event or the other players (or vice versa)\n     * \n     * ```ts\n     * player.through = true\n     * ```\n     * \n     * @title Go through the player\n     * @prop {boolean} player.through\n     * @default false\n     * @memberof MoveManager\n     * */\n    through: boolean\n\n    /** \n     * The frequency allows to put a stop time between each movement in the array of the moveRoutes() method.\n     * The value represents a dwell time in milliseconds. The higher the value, the slower the frequency.\n     * \n     * ```ts\n     * player.frequency = 400\n     * ```\n     * \n     * You can use Frequency enum\n     * \n     * ```ts\n     * import { Frequency } from '@rpgjs/server'\n     * player.frequency = Frequency.Low\n     * ```\n     * \n     * @title Change Frequency\n     * @prop {number} player.speed\n     * @enum {number}\n     * \n     * Frequency.Lowest | 600\n     * Frequency.Lower | 400\n     * Frequency.Low | 200\n     * Frequency.High | 100\n     * Frequency.Higher | 50\n     * Frequency.Highest | 25\n     * Frequency.None | 0\n     * @default 0\n     * @memberof MoveManager\n     * */\n    frequency: number\n\n    /**\n     * Gives an itinerary. \n     * \n     * You can create your own motion function:\n     * \n     * ```ts\n     * import { Direction } from '@rpgjs/server'\n     * \n     * const customMove = () => {\n     *      return [Direction.Left, Direction.Up]\n     * }\n     * \n     * player.moveRoutes([ customMove() ])\n     * ```\n     * \n     * Your function can also return a function:\n     * \n     *  ```ts\n     * import { Direction, RpgPlayer } from '@rpgjs/server'\n     * \n     * // This function can be found in another file. By returning a function, you have access to the player who is making a move.\n     * const customMove = (otherPlayer: RpgPlayer) => {\n     *      return (player: RpgPlayer, map) => {\n     *          return otherPlayer.position.x > player.position.x ? Direction.Left : Direction.Right\n     *      }\n     * }\n     * \n     * player.moveRoutes([ customMove(otherPlayer) ])\n     * ```\n     * \n     * the function contains two parameters:\n     * \n     * - `player`: the player concerned by the movement\n     * - `map`: The information of the current map\n     * \n     * @title Give an itinerary\n     * @method player.moveRoutes(routes)\n     * @param {Array<Move>} routes\n     * @returns {Promise}\n     * @memberof MoveManager\n     * @example \n     * \n     * ```ts\n     * import { Move } from '@rpgjs/server'\n     * \n     * await player.moveRoutes([ Move.tileLeft(), Move.tileDown(2) ])\n     * // The path is over when the promise is resolved\n     * ```\n     */\n    moveRoutes(routes: Routes): Promise<boolean> {\n        let count = 0\n        let frequence = 0\n        this.breakRoutes() // break previous route\n        return new Promise(async (resolve) => {\n            this._finishRoute = resolve\n            routes = routes.map((route: any) => {\n                if (isFunction(route)) {\n                    const map = this.getCurrentMap()\n                    if (!map) {\n                        return undefined\n                    }\n                    return route.apply(route, [this, map])\n                }\n                return route\n            })\n            routes = arrayFlat(routes)\n            const move = (): Observable<any> => {\n                // If movement continues while the player no longer exists or is no longer on the map\n                if (!this) {\n                    return of(null)\n                }\n                // if map not exists\n                if (!this.getCurrentMap()) {\n                    return of(null)\n                }\n                if (count >= this['nbPixelInTile']) {\n                    if (frequence < this.frequency) {\n                        frequence++\n                        return of(null)\n                    }\n                }\n\n                frequence = 0\n                count++\n\n                const [route] = routes\n\n                if (route === undefined) {\n                    this.breakRoutes()\n                    return of(null)\n                }\n\n                let ob$ = new Observable()\n\n                switch (route) {\n                    case Direction.Left:\n                    case Direction.Down:\n                    case Direction.Right:\n                    case Direction.Up:\n                        ob$ = from(this.moveByDirection(route, 1))\n                        break\n                    case 'turn-' + Direction.Left:\n                        ob$ = of(this.changeDirection(Direction.Left))\n                        break\n                    case 'turn-' + Direction.Right:\n                        ob$ = of(this.changeDirection(Direction.Right))\n                        break\n                    case 'turn-' + Direction.Up:\n                        ob$ = of(this.changeDirection(Direction.Up))\n                        break\n                    case 'turn-' + Direction.Down:\n                        ob$ = of(this.changeDirection(Direction.Down))\n                        break\n                }\n\n                return ob$.pipe(\n                    tap(() => {\n                        routes.shift()\n                    })\n                )\n            }\n            this.movingSubscription = this.server.tick\n                .pipe(\n                    takeUntil(\n                        this._destroy$.pipe(\n                            tap(() => {\n                                this.breakRoutes(true)\n                            })\n                        )),\n                    switchMap(move)\n                )\n                .subscribe()\n        })\n    }\n\n    /**\n     * Giving a path that repeats itself in a loop to a character\n     * \n     * You can stop the movement at any time with `breakRoutes()` and replay it with `replayRoutes()`.\n     * \n     * @title Infinite Move Routes\n     * @method player.infiniteMoveRoute(routes)\n     * @param {Array<Move>} routes\n     * @returns {void}\n     * @memberof MoveManager\n     * @example \n     * \n     * ```ts\n     * import { Move } from '@rpgjs/server'\n     * \n     * player.infiniteMoveRoute([ Move.tileRandom() ])\n     * ```\n     */\n    infiniteMoveRoute(routes: Routes): void {\n        this._infiniteRoutes = routes\n\n        const move = (isBreaking: boolean) => {\n            if (isBreaking) return\n            this.moveRoutes(routes).then(move)\n        }\n\n        move(false)\n    }\n\n    /**\n     * Works only for infinite movements. You must first use the method `infiniteMoveRoute()`\n     * \n     * @title Stop an infinite movement\n     * @method player.breakRoutes(force=false)\n     * @param {boolean} [force] Forces the stop of the infinite movement\n     * @returns {void}\n     * @memberof MoveManager\n     * @example \n     * \n     * ```ts\n     * import { Move } from '@rpgjs/server'\n     * \n     * player.infiniteMoveRoute([ Move.tileRandom() ])\n     * player.breakRoutes(true)\n     * ```\n     */\n    breakRoutes(force: boolean = false): void {\n        if (this._finishRoute) {\n            this.movingSubscription?.unsubscribe()\n            this._finishRoute(force)\n        }\n    }\n\n    /**\n     * Works only for infinite movements. You must first use the method `infiniteMoveRoute()`\n     * If the road was stopped with `breakRoutes()`, you can restart it with this method\n     * \n     * @title Replay an infinite movement\n     * @method player.replayRoutes()\n     * @returns {void}\n     * @memberof MoveManager\n     * @example \n     * \n     * ```ts\n     * import { Move } from '@rpgjs/server'\n     * \n     * player.infiniteMoveRoute([ Move.tileRandom() ])\n     * player.breakRoutes(true)\n     * player.replayRoutes()\n     * ```\n     */\n    replayRoutes(): void {\n        if (this._infiniteRoutes) this.infiniteMoveRoute(this._infiniteRoutes)\n    }\n\n    /**\n     * Move the event to another event, a player, a shape or a specific position.\n     * The event will avoid obstacles, but you can tell if it is stuck or has completed its path\n     * \n     * @title Move To\n     * @method player.moveTo()\n     * @param {RpgPlayer|RpgEvent|RpgShape|Position} target the target\n     * @param {object} [options] - animate. Set a boolean to use default parameters\n     * @param {boolean} [options.infinite=false] - moves infinitely towards the target, you have to stop its movement manually with the method `stopMoveTo()`\n     * @param {() => void} [options.onComplete] - Callback when the event arrives at the destination\n     * @param {(duration:number) => void} [options.onStuck] - callback when the event is blocked against a wall. Duration gives you the duration (in frames) of the blocking time\n     * @returns {Observable<void>}\n     * @since 3.2.0\n     * @memberof MoveManager\n     * @example \n     * \n     * ```ts\n     * import { Move } from '@rpgjs/server'\n     * \n     * player.moveTo(otherPlayer).subscribe()\n     * ```\n     */\n    moveTo(event: RpgEvent, options?: MoveTo): Observable<void>\n    moveTo(player: RpgPlayer, options?: MoveTo): Observable<void>\n    moveTo(position: PositionXY, options?: MoveTo): Observable<void>\n    moveTo(shape: RpgShape, options?: MoveTo): Observable<void>\n    moveTo(position: RpgPlayer | RpgShape | PositionXY, options?: MoveTo): Observable<void> {\n        return this['_moveTo'](this.server.tick, position, options)\n    }\n\n    // TODO\n    setMoveMode(mode: MoveMode): void {\n        if (mode.checkCollision) this.checkCollision = mode.checkCollision\n        if (mode.clientMode) this.clientModeMove = mode.clientMode\n        if (mode.behavior) this.behavior = mode.behavior\n        this.emit(SocketEvents.CallMethod, {\n            objectId: this.id,\n            name: SocketMethods.ModeMove,\n            params: [mode]\n        })\n    }\n}\n\nexport interface MoveManager {\n    moveByDirection: (direction: Direction, deltaTimeInt: number) => Promise<boolean>\n    changeDirection: (direction: Direction) => boolean\n    getCurrentMap: any\n    checkCollision: boolean\n    clientModeMove: ClientMode\n    behavior: Behavior\n    emit(name: SocketEvents, params: any)\n    id: string\n    server: RpgServerEngine\n    position: Vector2d\n    _destroy$: Subject<void>\n}", "import { PrebuiltGui } from '@rpgjs/common'\nimport { Gui } from './Gui'\nimport { RpgPlayer } from '../Player/Player'\nimport { IGui } from '../Interfaces/Gui'\nimport { Move } from '../Player/MoveManager'\n\nexport enum DialogPosition {\n    Top = 'top',\n    Bottom = 'bottom',\n    Middle = 'middle'\n}\n\nexport type Choice = { text: string, value: any }\n\nexport interface DialogOptions {\n    choices?: Choice[],\n    position?: DialogPosition,\n    fullWidth?: boolean,\n    autoClose?: boolean,\n    tranparent?: boolean,\n    typewriterEffect?: boolean,\n    talkWith?: RpgPlayer\n}\n\nexport class DialogGui extends Gui implements IGui {\n    constructor(player: RpgPlayer) {\n        super(PrebuiltGui.Dialog, player)\n    }\n\n    openDialog(message: string, options: DialogOptions): Promise<any> {\n        if (!options.choices) options.choices = []\n        if (options.autoClose == undefined) options.autoClose = false\n        if (!options.position) options.position = DialogPosition.Bottom\n        if (options.fullWidth == undefined) options.fullWidth = true\n        if (options.typewriterEffect  == undefined) options.typewriterEffect = true\n        const event = options.talkWith\n        let memoryDir\n        if (event) {\n            memoryDir = event.direction\n            event.breakRoutes(true)\n            event.moveRoutes([ Move.turnTowardPlayer(this.player) ])\n        }\n        const data = {\n            autoClose: options.autoClose,\n            position: options.position,\n            fullWidth: options.fullWidth,\n            typewriterEffect: options.typewriterEffect,\n            // remove value property. It is not useful to know this on the client side.\n            choices: options.choices.map(choice => ({\n                text: choice.text\n            }))\n        }\n        return super.open({\n            message,\n            ...data\n        }, {\n            waitingAction: true,\n            blockPlayerInput: true\n        }).then((val: any) => {\n            if (event) {\n                event.replayRoutes()\n                event.direction = memoryDir\n            }\n            return val\n        })\n    }\n}", "import { PrebuiltGui } from '@rpgjs/common'\nimport { Gui } from './Gui'\nimport { RpgPlayer } from '../Player/Player'\nimport { IGui } from '../Interfaces/Gui'\n\nexport class MenuGui extends Gui implements IGui {\n    constructor(player: RpgPlayer) {\n        super(PrebuiltGui.MainMenu, player)\n    }\n\n    open() {\n        this.on('useItem', (id) => {\n            try {\n                this.player.useItem(id)\n                this.player.syncChanges()\n            }\n            catch (err: any) {\n                this.player.showNotification(err.msg)\n            }\n        })\n        return super.open('', {\n            waitingAction: true,\n            blockPlayerInput: true\n        })\n    }\n}", "import { PrebuiltGui } from '@rpgjs/common'\nimport { Gui } from './Gui'\nimport { RpgPlayer } from '../Player/Player'\nimport { IGui } from '../Interfaces/Gui'\n\nexport class ShopGui extends Gui implements IGui {\n    constructor(player: RpgPlayer) {\n        super(PrebuiltGui.Shop, player)\n    }\n\n    open(items: any[]) {\n        items = items.map(item => {\n            const it = new item()\n            return {\n                price: it.price,\n                name: it.name,\n                description: it.description,\n                id: it.id,\n                type: item.type\n            }\n        })\n        this.on('buyItem', ({ id, nb }) => {\n            try {\n                this.player.buyItem(id, nb)\n            }\n            catch (err) {\n                console.log(err)\n            }\n        })\n        this.on('sellItem', ({ id, nb }) => {\n            try {\n                this.player.sellItem(id, nb)\n            }\n            catch (err) {\n                console.log(err)\n            }\n        })\n        return super.open({ items }, {\n            waitingAction: true,\n            blockPlayerInput: true\n        })\n    }\n}", "import { PrebuiltGui } from '@rpgjs/common'\nimport { Gui } from './Gui'\nimport { RpgPlayer } from '../Player/Player'\nimport { IGui } from '../Interfaces/Gui'\n\nexport class NotificationGui extends Gui implements IGui {\n    constructor(player: RpgPlayer) {\n        super(PrebuiltGui.Notification, player)\n    }\n}", "import { Utils } from '@rpgjs/common'\nimport { RpgPlayer } from './Player'\nimport { Gui, DialogGui, MenuGui, ShopGui, NotificationGui } from '../Gui'\nimport { DialogOptions, Choice } from '../Gui/DialogGui'\n\nexport class GuiManager {\n\n    _gui: { [id: string]: Gui }\n\n    /**\n     * Show a text. This is a graphical interface already built. Opens the GUI named `rpg-dialog`\n     * \n     * ```ts\n     * player.showText('Hello World')\n     * ```\n     * \n     * The method returns a promise. It is resolved when the dialog box is closed.\n     * \n     * ```ts\n     * await player.showText('Hello World')\n     * // dialog box is closed, then ...\n     * ```\n     * \n     * **Option: position**\n     * \n     * You can define how the dialog box is displayed:\n     * - top\n     * - middle\n     * - bottom\n     * \n     * (bottom by default)\n     * \n     * ```ts\n     * player.showText('Hello World', {\n     *      position: 'top'\n     * })\n     * ```\n     * \n     * **Option: fullWidth**\n     * \n     * `boolean` (true by default)\n     * \n     * Indicate that the dialog box will take the full width of the screen.\n     * \n     * ```ts\n     * player.showText('Hello World', {\n     *      fullWidth: true\n     * })\n     * ```\n     * \n     * **Option: autoClose**\n     * \n     * `boolean` (false by default)\n     * \n     * If false, the user will have to press Enter to close the dialog box.\n     * \n     *  ```ts\n     * player.showText('Hello World', {\n     *      autoClose: true\n     * })\n     * ```\n     * \n     * **Option: typewriterEffect**\n     * \n     * `boolean` (true by default)\n     * \n     * Performs a typewriter effect\n     * \n     *  ```ts\n     * player.showText('Hello World', {\n     *      typewriterEffect: false\n     * })\n     * ```\n     * \n     * **Option: talkWith**\n     * \n     * `RpgPlayer` (nothing by default)\n     * \n     * If you specify the event or another player, the other player will stop his or her movement and look in the player's direction.\n     * \n     *  ```ts\n     * // Code in an event\n     * player.showText('Hello World', {\n     *      talkWith: this\n     * })\n     * ```\n     * \n     * @title Show Text \n     * @method player.showText(text,options)\n     * @param {string} text \n     * @param {object} [options] the different options, see usage below\n     * @returns {Promise}\n     * @memberof GuiManager\n     */\n    showText(msg: string, options: DialogOptions = {}): Promise<any> {\n        const gui = new DialogGui(<any>this)\n        this._gui[gui.id] = gui\n        return gui.openDialog(msg, options)\n    }\n\n    /**\n     * Shows a dialog box with a choice. Opens the GUI named `rpg-dialog`\n     * \n     * ```ts\n     * const choice = await player.showChoices('What color do you prefer?', [\n     *      { text: 'Black', value: 'black' },\n     *      { text: 'Rather the blue', value: 'blue' },\n     *      { text: 'I don\\'t have a preference!', value: 'none' }\n     * ])\n     * \n     * // If the player selects the first\n     * console.log(choice) // { text: 'Black', value: 'black' }\n     * ```\n     * \n     * @title Show Choices \n     * @method player.showChoices(text,choices)\n     * @param {string} text \n     * @param {Array<{ text: string, value: any }>} choices\n     * @param {object} [options] Same options as the openDialog method\n     * @returns {Promise<Choice | null>}\n     * @memberof GuiManager\n     */\n    showChoices(msg: string, choices: Choice[], options?: DialogOptions): Promise<Choice | null> {\n        return this\n            .showText(msg, {\n                choices,\n                ...options\n            })\n            .then((indexSelected: number) => {\n                if (!choices[indexSelected]) return null\n                return choices[indexSelected]\n            })\n    }\n\n    /**\n     * Displays a notification . Opens the GUI named `rpg-notification`\n     * \n     * @title Displays a notification\n     * @method player.showNotification()\n     * @param {string} message - The message to display in the notification\n     * @param {object} options - An object containing options for the notification\n     * @param {number} options.time - The time to display the notification for (in ms). Default: 2000ms\n     * @param {string} options.icon - The icon to display in the notification. Put the identifier of the spritesheet (defined on the client side)\n     * @param {string} options.sound - The sound to play when the notification is shown. Set the sound ID (defined on the client side)\n     * @returns {void}\n     * @memberof GuiManager\n     */\n    showNotification(message: string, options: { time?: number, icon?: string, sound?: string } = {}): Promise<any> {\n        const gui = new NotificationGui(<any>this)\n        this._gui[gui.id] = gui\n        const data = {\n            message,\n            ...options\n        }\n        return gui.open(data)\n    }\n\n    /**\n     * Calls main menu. Opens the GUI named `rpg-main-menu`\n     * \n     * @title Call Main Menu\n     * @method player.callMainMenu()\n     * @returns {void}\n     * @memberof GuiManager\n     */\n    callMainMenu() {\n        const gui = new MenuGui(<any>this)\n        this._gui[gui.id] = gui\n        return gui.open()\n    }\n\n    /**\n     * Calls shop menu. Opens the GUI named `rpg-shop`\n     * \n     * @title Call Shop Menu\n     * @method player.callShop()\n     * @returns {void}\n     * @memberof GuiManager\n     */\n    callShop(items: any[]) {\n        const gui = new ShopGui(<any>this)\n        this._gui[gui.id] = gui\n        return gui.open(items)\n    }\n\n    /**\n     * Call a custom Gui\n\n     * ```ts\n     * // Calls a client-side component, created with VueJS, named \"inn\".\n     * const gui = player.gui('inn')\n     * \n     *  // You can wait for actions on the menu. It only works if the menu is open.\n     * gui.on('accept', () => {\n     *      player.allRecovery()\n     * })\n     * \n     * // The GUI is opened by passing recoverable data on the client side.\n     * gui.open({ hello: 'world' })\n     * ```\n     * \n     * When opening the GUI, one can give options\n     * \n     * ```ts\n     * await gui.open({ hello: 'world' }, {\n     *      waitingAction: true,\n     *      blockPlayerInput: true\n     * })\n     * // After the GUI is closed\n     * ```\n     * \n     * - `blockPlayerInput`: while the GUI is open, the player can not move on the map\n     * - `waitingAction`: We explicitly wait until the GUI is closed for the promise to be resolved.\n     * \n     * @title Call custom GUI\n     * @method player.gui(guiId)\n     * @param {string} guiId\n     * @returns {Gui}\n     * @memberof GuiManager\n     */\n    gui(guiId: string) {\n        const gui = new Gui(guiId, <any>this)\n        this._gui[guiId] = gui\n        return gui\n    }\n\n    /**\n     * Closes the GUI and removes it from memory\n     * \n     * @title Close custom GUI\n     * @method player.removeGui(guiId,data)\n     * @param {string} guiId\n     * @param {object} [data] Passing data if you close the GUI \n     * @returns {Gui}\n     * @memberof GuiManager\n     */\n    removeGui(guiId: string, data?: any) {\n        if (this._gui[guiId]) {\n            this._gui[guiId].close(data)\n            delete this._gui[guiId]\n        }\n    }\n\n    private _attachedGui(players: RpgPlayer[] | RpgPlayer, display: boolean) {\n        if (!Utils.isArray(players)) {\n            players = [players] as RpgPlayer[]\n        }\n        this.emit('gui.tooltip', {\n            players: (players as RpgPlayer[]).map(player => player.id),\n            display\n        })\n    }\n\n    /** \n     * Display the GUI attached to the players\n     * \n     * If you don't specify the players as parameters, it will display the GUI of the instance \n     * But you can specify which GUIs to display by specifying the players as the first parameter\n     * \n     * @title View to GUI attached\n     * @method player.showAttachedGui(players?)\n     * @param {RpgPlayer[] | RpgPlayer} [players] The GUIs attached to the players to display\n     * @since 3.0.0-beta.5\n     * @example\n     * ```ts\n     * player.showAttachedGui()\n     * ```\n     * ```ts\n     * player.showAttachedGui(aPlayer)\n     * ```\n     * ```ts\n     * player.showAttachedGui([player1, player2])\n     * ```\n     * @memberof GuiManager\n     * */\n    showAttachedGui(players?: RpgPlayer[] | RpgPlayer) {\n        const _players = players || this\n        this._attachedGui(_players as RpgPlayer[], true)\n    }\n\n    /** \n     * Hide the GUI attached to the players\n     * \n     * @title Hide to GUI attached\n     * @method player.hideAttachedGui(players?)\n     * @param {RpgPlayer[] | RpgPlayer} [players] The GUIs attached to the players to hide\n     * @since 3.0.0-beta.5\n     * @example\n     * ```ts\n     * player.hideAttachedGui()\n     * ```\n     * ```ts\n     * player.hideAttachedGui(aPlayer)\n     * ```\n     * ```ts\n     * player.hideAttachedGui([player1, player2])\n     * ```\n     * @memberof GuiManager\n     * */\n    hideAttachedGui(players?: RpgPlayer[] | RpgPlayer) {\n        const _players = players || this\n        this._attachedGui(_players as RpgPlayer[], false)\n    }\n}\n\nexport interface GuiManager {\n    emit: any\n}", "export class VariableManager {\n    variables: Map<string, any>\n\n    /** \n     * Assign a variable to the player\n     * \n     * ```ts\n     * player.setVariable('OPEN_CHEST', true)\n     * ```\n     * \n     * @title Set variable\n     * @method player.setVariable(key,val)\n     * @param {string} key\n     * @param {any} val\n     * @returns {void}\n     * @memberof VariableManager\n     * */\n    setVariable(key: string, val) {\n        this.variables.set(key, val)\n    }\n\n    /** \n     * Get a variable\n     * \n     * ```ts\n     * const val = player.getVariable('OPEN_CHEST')\n     * ```\n     * \n     * @title Get variable\n     * @method player.setVariable(key,val)\n     * @param {string} key\n     * @returns {any} \n     * @memberof VariableManager\n     * */\n    getVariable(key: string) {\n        return this.variables.get(key)\n    }\n\n    /** \n     * Remove a variable\n     * \n     * ```ts\n     * player.removeVariable('OPEN_CHEST')\n     * ```\n     * \n     * @title Remove variable\n     * @method player.removeVariable(key)\n     * @param {string} key\n     * @returns {boolean} true if a variable existed and has been removed, or false if the variable does not exist.\n     * @memberof VariableManager\n     * */\n    removeVariable(key: string) {\n        return this.variables.delete(key)\n    }\n}", "import { Utils }  from '@rpgjs/common'\nimport { ParameterManager } from './ParameterManager'\nimport { RpgPlayer } from './Player'\nimport { \n    ATK,\n    PDEF,\n    SDEF\n} from '../presets'\nimport { Effect } from '@rpgjs/database'\nimport { ElementManager } from './ElementManager';\nimport { EffectManager } from './EffectManager';\nimport { RpgServerEngine } from '../server'\n\nconst { \n    applyMixins\n} = Utils\n\nexport class BattleManager {\n\n    /** \n     * Apply damage. Player will lose HP. the `attackerPlayer` parameter is the other player, the one who attacks.\n     * \n     * If you don't set the skill parameter, it will be a physical attack.\n     * The attack formula is already defined but you can customize it in the server options\n     * \n     * ```ts\n     * player.applyDamage(attackerPlayer) // returns { damage: number }\n     * ```\n     * \n     * @title Apply Damage\n     * @method player.applyDamage(attackerPlayer,skill)\n     * @param {RpgPlayer} attackerPlayer The attacking player\n     * @param {any} [skill]\n     * @returns {object} \n     * @memberof BattleManager\n     * */\n    applyDamage(attackerPlayer: RpgPlayer, skill?: any): { \n        damage: number, \n        critical: boolean, \n        elementVulnerable: boolean,\n        guard: boolean,\n        superGuard: boolean\n    } {\n        const getParam = (player: RpgPlayer) => {\n            const params = {}\n            this.parameters.forEach((val, key) => {\n                params[key] = player.param[key]\n            })\n            return {\n                [ATK]: player.atk,\n                [PDEF]: player.pdef,\n                [SDEF]: player.sdef,\n                ...params\n            }\n        }\n        let damage = 0, fn\n        let critical = false\n        let guard = false\n        let superGuard = false\n        let elementVulnerable = false\n        const paramA = getParam(attackerPlayer)\n        const paramB = getParam(<any>this)\n        if (skill) {\n            fn = this.getFormulas('damageSkill')\n            if (!fn) {\n                throw new Error('Skill Formulas not exists')\n            }\n            damage = fn(paramA, paramB, skill)\n        }\n        else {\n            fn = this.getFormulas('damagePhysic')\n            if (!fn) {\n                throw new Error('Physic Formulas not exists')\n            }\n            damage = fn(paramA, paramB)\n            const coef = this.coefficientElements(attackerPlayer)\n            if (coef >= 2) {\n                elementVulnerable = true\n            }\n            damage *= coef\n            fn = this.getFormulas('damageCritical')\n            if (fn) {\n                let newDamage = fn(damage, paramA, paramB)\n                if (damage != newDamage) {\n                    critical = true\n                }\n                damage = newDamage\n            }\n        }\n        if (this.hasEffect(Effect.GUARD)) {\n            fn = this.getFormulas('damageGuard')\n            if (fn) {\n                let newDamage = fn(damage, paramA, paramB)\n                if (damage != newDamage) {\n                    guard = true\n                }\n                damage = newDamage\n            }\n        }\n        if (this.hasEffect(Effect.SUPER_GUARD)) {\n            damage /= 4\n            superGuard = true\n        }\n        this.hp -= damage\n        return {\n            damage,\n            critical,\n            elementVulnerable,\n            guard,\n            superGuard\n        }\n    }\n    \n    getFormulas(name: string) {\n        return this.server.damageFormulas[name]\n    }\n}\n\napplyMixins(BattleManager, [ParameterManager, ElementManager, EffectManager])\n\nexport interface BattleManager extends ParameterManager, ElementManager, EffectManager {\n    name: string,\n    server: RpgServerEngine\n }", "import { Utils } from '@rpgjs/common'\nimport { BarComponentObject, ComponentObject, LayoutObject, LayoutOptions, TextComponentObject, LayoutPositionEnum, ShapeComponentObject, ImageComponentObject, TileComponentObject, DebugComponentObject, TextComponentStyleObject } from '@rpgjs/types'\n\nconst defaultStyle = (style: any) => ({\n    borderColor: '#000000',\n    borderWidth: 2,\n    bgColor: '#000000',\n    borderRadius: 5,\n    ...style\n})\n\nconst bar = (current: string, max: string, style?: BarComponentObject['value']['style'], text?: string | null): BarComponentObject => {\n    return {\n        id: 'bar',\n        value: {\n            current,\n            max,\n            text: text === null ? '' : text || '{$current}/{$max}',\n            style\n        }\n    }\n}\n\nexport const Components = {\n    /**\n     * Displays a bar\n     * \n     * Example:\n     * \n     * ```ts\n     * import { Components } from '@rpgjs/server'\n     * Components.bar('hp', 'param.maxHp', {\n     *    bgColor: '#ab0606'\n     * })\n     * ```\n     * \n     * For text, you can use the following variables:\n     * - {$current} current value\n     * - {$max} maximum value\n     * - {$percent} percentage\n     * \n     * Example:\n     * \n     * ```ts\n     * import { Components } from '@rpgjs/server'\n     * Components.bar('hp', 'param.maxHp', {\n     *   bgColor: '#ab0606'\n     * }, 'HP: {$current}/{$max}')\n     * ```\n     * \n     * and you can also use the variables of player:\n     * \n     * ```ts\n     * import { Components } from '@rpgjs/server'\n     * Components.bar('hp', 'param.maxHp', {\n     *  bgColor: '#ab0606'\n     * }, 'HP: {$current}/{$max} - {name}') // HP: 100/100 - John\n     * ```\n     * \n     * @title Bar Component\n     * @param {string} current Parameter that corresponds to the current value\n     * @param {string} max Parameter that corresponds to the maximum value\n     * @param {object} [style] style\n     * @param {string} [style.bgColor] background color. Hexadecimal format.\n     * @param {string} [style.fillColor] fill color. Hexadecimal format.\n     * @param {string} [style.borderColor] border color. Hexadecimal format.\n     * @param {number} [style.borderWidth] border width\n     * @param {number} [style.height] height\n     * @param {number} [style.width] width\n     * @param {number} [style.borderRadius] border radius\n     * @param {number} [style.opacity] opacity\n     * @param {string | null} [text] text above bar. if null, no text will be displayed. You can use the variables\n     * @returns {BarComponentObject}\n     * @memberof Components\n     * @since 3.3.0\n     */\n    bar,\n\n    /**\n     * Displays a life bar\n     * \n     * @title HP Bar Component\n     * @param {object} [style] style. See bar style (Components.bar())\n     * @param {string | null} [text] test above bar (Components.bar())\n     * @returns {BarComponentObject}\n     * @memberof Components\n     * @since 3.3.0\n     */\n    hpBar(style?: BarComponentObject['value']['style'], text?: string | null): BarComponentObject {\n        return bar('hp', 'param.maxHp', {\n            ...defaultStyle({\n                fillColor: '#ab0606'\n            }),\n            ...((style as any) || {})\n        }, text)\n    },\n\n     /**\n     * Displays a SP bar\n     * \n     * @title SP Bar Component\n     * @param {object} [style] style. See bar style (Components.bar())\n     * @param {string | null} [text] test above bar (Components.bar())\n     * @returns {BarComponentObject}\n     * @memberof Components\n     * @since 3.3.0\n     */\n    spBar(style?: BarComponentObject['value']['style'], text?: string | null): BarComponentObject {\n        return bar('sp', 'param.maxSp', {\n            ...defaultStyle({\n                fillColor: '#0fa38c'\n            }),\n            ...((style as any) || {}),\n        }, text)\n    },\n\n     /**\n     * Put on the text. You can read the content of a variable with {} format (see example below)\n     * \n     * Example:\n     * \n     * ```ts\n     * import { Components } from '@rpgjs/server'\n     * Components.text('Hello World')\n     * ```\n     * \n     * Example with variable:\n     * \n     * ```ts\n     * import { Components } from '@rpgjs/server'\n     * Components.text('{name}')\n     * ```\n     * \n     * Other example with position:\n     * \n     * ```ts\n     * import { Components } from '@rpgjs/server'\n     * Components.text('X: {position.x} Y: {position.y}')\n     * ```\n     * \n     * With style:\n     * \n     * ```ts\n     * import { Components } from '@rpgjs/server'\n     * Components.text('Hello World', {\n     *      fill: '#ffffff',\n     *      fontSize: 20,\n     *      fontFamily: 'Arial',\n     *      stroke: '#000000',\n     *      fontStyle: 'italic',\n     *      fontWeight: 'bold'\n     * })\n     * ```\n     * \n     * @title Text Component\n     * @param {string} value source\n     * @param {object} [style] style\n     * @param {string} [style.fill] color. Hexadecimal format.\n     * @param {number} [style.fontSize] font size\n     * @param {string} [style.fontFamily] font family\n     * @param {string} [style.stroke] stroke color. Hexadecimal format.\n     * @param {'normal' | 'italic' | 'oblique'} [style.fontStyle] font style\n     * @param {'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900'} [style.fontWeight] font weight\n     * @param {number} [style.opacity] opacity. Between 0 and 1\n     * @param {boolean} [style.wordWrap] word wrap\n     * @param {'left' | 'center' | 'right' | 'justify'} [style.align] align\n     * @returns {TextComponentObject}\n     * @memberof Components\n     * @since 3.3.0\n     */\n    text(value: string, style?: TextComponentStyleObject): TextComponentObject {\n        return {\n            id: 'text',\n            value: {\n                text: value,\n                style: {\n                    fill: '#ffffff',\n                    fontSize: 15,\n                    ...((style as any) || {})\n                }\n            }\n        }\n    },\n\n    /**\n     * Add a shape\n     * \n     * Example:\n     * \n     * ```ts\n     * import { Components } from '@rpgjs/server'\n     * Components.shape({\n     *      fill: '#ffffff',\n     *      type: 'circle',\n     *      radius: 10\n     * })\n     * ```\n     * \n     * You can use parameters:\n     * \n     * ```ts\n     * import { Components } from '@rpgjs/server'\n     * Components.shape({\n     *      fill: '#ffffff',\n     *      type: 'circle',\n     *      radius: 'hp'\n     * })\n     * ```\n     * \n     * Here, the radius will be the same as the hp value\n     * \n     * @title Shape Component\n     * @param {object} value \n     * @param {string} value.fill color. Hexadecimal format.\n     * @param {number | string} [value.opacity] opacity. Between 0 and 1\n     * @param {string} value.type type of shape. Can be 'circle' or 'rectangle', 'ellipse' or 'polygon', 'line' or 'rounded-rectangle'\n     * @param {number | string} [value.radius] if type is circle, radius of the circle\n     * @param {number | string} [value.width] if type is rectangle or ellipse, width of the rectangle\n     * @param {number | string} [value.height] if type is rectangle or ellipse, height of the rectangle\n     * @param {number | string} [value.x1] if type is line, x1 position of the line\n     * @param {number | string} [value.y1] if type is line, y1 position of the line\n     * @param {number | string} [value.x2] if type is line, x2 position of the line\n     * @param {number | string} [value.y2] if type is line, y2 position of the line\n     * @param {number[]} [value.points] if type is polygon, points of the polygon\n     * @param {object} [value.line] border style\n     * @param {string} [value.line.color] border color. Hexadecimal format.\n     * @param {number} [value.line.width] border width\n     * @param {number} [value.line.alpha] border opacity. Between 0 and 1\n     * @returns {ShapeComponentObject}\n     * @memberof Components\n     * @since 3.3.0\n     */\n    shape(value: ShapeComponentObject['value']): ShapeComponentObject {\n        return {\n            id: 'shape',\n            value\n        }\n    },\n\n    /**\n     * Put the link to an image or the identifier of an image (if the spritesheet exists)\n     * \n     * Example:\n     * \n     * ```ts\n     * import { Components } from '@rpgjs/server'\n     * Components.image('mygraphic.png')\n     * ```\n     * \n     * @title Image Component\n     * @param {string} value source\n     * @returns {ImageComponentObject}\n     * @memberof Components\n     * @since 3.3.0\n     */\n    image(value: string): ImageComponentObject {\n        return {\n            id: 'image',\n            value\n        }\n    },\n\n    /**\n     * Indicates the tile ID\n     * \n     * Example:\n     * \n     * ```ts\n     * import { Components } from '@rpgjs/server'\n     * Components.tile(3)\n     * ```\n     * \n     * @title Tile Component\n     * @param {number} value tile ID\n     * @returns {TileComponentObject}\n     * @memberof Components\n     * @since 3.3.0\n     */\n    tile(value: number): TileComponentObject {\n        return {\n            id: 'tile',\n            value\n        }\n    },\n    debug(): DebugComponentObject {\n        return {\n            id: 'debug',\n            value: ''\n        }\n    }\n}\n\nexport class ComponentManager {\n    layout: LayoutObject<any>\n\n    /**\n     * Give the spritesheet identifier\n     * \n     * Since version 3.0.0-rc, you can define several graphic elements. If you put a number, it represents the tile ID in the tileset\n     * \n     * Example 1:\n     * ```ts\n     * player.setGraphic(['body', 'shield'])\n     * ```\n     * \n     * Example 2:\n     * ```ts\n     * player.setGraphic(3) // Use tile #3\n     * ```\n     * \n     * > You must, on the client side, create the spritesheet in question. Guide: [Create Sprite](/guide/create-sprite.html)\n     * \n     * @title Set Graphic\n     * @method player.setGraphic(graphic)\n     * @param {string | number | (string | number)[]} graphic\n     * @returns {void}\n     * @memberof ComponentManager\n     */\n    setGraphic(graphic: string | number | (string | number)[]) {\n        const components = (Utils.isArray(graphic) ? graphic : [graphic]) as string[]\n        const col = [...components.map(value => ({ id: Utils.isString(value) ? 'graphic' : 'tile', value }))]\n        this.removeComponentById('center', 'graphic')\n        this.mergeComponent('center', col)\n    }\n\n    /**\n     * Delete components\n     * \n     * @title Remove Components\n     * @param {string} position Position of the components. Can be: `top`, `center`, `bottom`, `left`, `right`\n     * @memberof ComponentManager\n     * @since 3.3.0\n     */\n    removeComponents(position: LayoutPositionEnum) {\n        (this.layout[position] as any).lines = []\n    }\n\n    /**\n     * Delete components by id. \n     * \n     * @title Remove Component By Id\n     * @param {string} position Position of the components. Can be: `top`, `center`, `bottom`, `left`, `right`\n     * @param {string} id Id of the component\n     * @since 3.3.0\n     */\n    removeComponentById(\n        position: LayoutPositionEnum,\n        id: string\n    ) {\n        let lines = this.layout[position]?.lines || []\n        lines = lines.map(line => {\n            line.col = line.col.filter(c => c.id !== id)\n            return line\n        });\n        lines = lines.filter(line => line.col.length > 0);\n        (this.layout[position] as any).lines = lines\n    }\n\n    /**\n     * Merges components with existing components\n     * \n     * For use layout and options, see [setComponentsTop](/api/player.html#setcomponentstop)\n     * \n     * @title Merge Components\n     * @param {string} position Position of the components. Can be: `top`, `center`, `bottom`, `left`, `right`\n     * @param {Object} layout \n     * @param {Object} options \n     * @memberof ComponentManager\n     * @since 3.3.0\n     */\n    mergeComponent<T = any>(\n        position: LayoutPositionEnum,\n        layout: ComponentObject<T>[][] | ComponentObject<T>[] | ComponentObject<T>,\n        options: LayoutOptions = {}\n    ) {\n        if (!(layout instanceof Array)) {\n            layout = [layout]\n        }\n\n        this.layout[position] = {\n            lines: [\n                ...(this.layout[position]?.lines || []),\n                ...layout.map(col => {\n                    if (!Utils.isArray(col)) {\n                        col = [col]\n                    }\n                    return { col }\n                })\n            ],\n            ...options\n        }\n    }\n\n    private setComponents<P extends LayoutPositionEnum, T = any>(\n        position: P,\n        layout: ComponentObject<T>[][] | ComponentObject<T>[] | ComponentObject<T>,\n        options: LayoutOptions = {}\n    ) {\n        (this.layout[position] as any).lines = []\n        this.mergeComponent(position, layout, options)\n    }\n\n    /**\n     * Add components to the center of the graphic.\n     * \n     * View [setComponentsTop](/api/player.html#setcomponentstop) for more information\n     * \n     * > Be careful, because if you assign, it deletes the graphics and if the lines are superimposed (unlike the other locations)\n     * \n     * @title Set Components Center\n     * @method player.setComponentsCenter(layout,options)\n     * @param {Object} layout \n     * @param {Object} options \n     * @memberof ComponentManager\n     * @since 3.3.0\n     */\n    setComponentsCenter<T = any>(layout: ComponentObject<T>[][] | ComponentObject<T>[] | ComponentObject<T>, options: LayoutOptions = {}) {\n        this.setComponents<'center', T>('center', layout, options)\n    }\n\n    /**\n     * Add components to the top of the graphic. e.g. text, life bar etc. The block will be centred\n     * The first array corresponds to the rows, and the nested table to the array in the row\n     * \n     * Example:\n     * \n     * ```ts\n     * import { Components } from '@rpgjs/server'\n     * \n     * player.setComponentsTop([\n     *      [Components.text('Hello World')],\n     *      [Components.hpBar()]\n     * ]) // 2 lines with 1 component each\n     * ```\n     * \n     *  or\n     * \n     * ```ts\n     * import { Components } from '@rpgjs/server'\n     * \n     * player.setComponentsTop([\n     *      [Components.text('Hello World'), Components.hpBar()]\n     * ]) // 1 line with 2 components\n     * ```\n     * \n     * You can be faster if you only have lines\n     * \n     * ```ts\n     * player.setComponentsTop([\n     *      Components.text('Hello World'),\n     *      Components.hpBar()\n     * ]) // 2 lines with 1 component each\n     * ```\n     * \n     * or one component:\n     * \n     * ```ts\n     * player.setComponentsTop(Components.text('Hello World')) // 1 line with 1 component\n     * ```\n     * \n     * You can add options to manage the style\n     * \n     * ```ts\n     * player.setComponentsTop([\n     *      Components.text('Hello World'),\n     *      Components.hpBar()\n     * ], {\n     *      width: 100,\n     *      height: 20,\n     *      marginTop: 10,\n     * })\n     * ```\n     * \n     * @title Set Components Top\n     * @method player.setComponentsTop(layout,options)\n     * @param {ComponentObject[][] | ComponentObject[] | ComponentObject} layout Components\n     * @param {Object} [options = {}] Options\n     * @param {number} [options.width] Width of the block\n     * @param {number} [options.height = 20] Height of the block\n     * @param {number} [options.marginTop] Margin top\n     * @param {number} [options.marginBottom] Margin bottom\n     * @param {number} [options.marginLeft] Margin left\n     * @param {number} [options.marginRight] Margin right\n     * @memberof ComponentManager\n     * @since 3.3.0\n     */\n    setComponentsTop<T = any>(layout: ComponentObject<T>[][] | ComponentObject<T>[] | ComponentObject<T>, options: LayoutOptions = {}) {\n        this.setComponents<'top', T>('top', layout, options)\n    }\n\n    /**\n     * Add components to the bottom of the graphic.\n     * \n     * View [setComponentsTop](/api/player.html#setcomponentstop) for more information\n     * \n     * @title Set Components Bottom\n     * @method player.setComponentsBottom(layout,options)\n     * @param {Object} layout \n     * @param {Object} options \n     * @memberof ComponentManager\n     * @since 3.3.0\n     */\n    setComponentsBottom<T = any>(layout: ComponentObject<T>[][] | ComponentObject<T>[] | ComponentObject<T>, options: LayoutOptions = {}) {\n        this.setComponents<'bottom', T>('bottom', layout, options)\n    }\n\n    /**\n     * Add components to the left of the graphic.\n     * \n     * View [setComponentsTop](/api/player.html#setcomponentstop) for more information\n     * \n     * @title Set Components Left\n     * @method player.setComponentsLeft(layout,options)\n     * @param {Object} layout \n     * @param {Object} options \n     * @memberof ComponentManager\n     * @since 3.3.0\n     */\n    setComponentsLeft<T = any>(layout: ComponentObject<T>[][] | ComponentObject<T>[] | ComponentObject<T>, options: LayoutOptions = {}) {\n        this.setComponents<'left', T>('left', layout, options)\n    }\n\n    /**\n     * Add components to the right of the graphic.\n     * \n     * View [setComponentsTop](/api/player.html#setcomponentstop) for more information\n     * \n     * @title Set Components Right\n     * @method player.setComponentsRight(layout,options)\n     * @param {Object} layout \n     * @param {Object} options \n     * @memberof ComponentManager\n     * @since 3.3.0\n     */\n    setComponentsRight<T = any>(layout: ComponentObject<T>[][] | ComponentObject<T>[] | ComponentObject<T>, options: LayoutOptions = {}) {\n        this.setComponents<'right', T>('right', layout, options)\n    }\n}", "import { PlayerType } from \"@rpgjs/types\"\nimport { RpgEvent, RpgPlayer } from \"../Player/Player\"\nimport { RpgMap } from \"./Map\"\n\nexport type EventsList = {\n    [playerId: string]: RpgEvent\n}\n\nexport enum EventMode {\n    Shared = 'shared',\n    Scenario = 'scenario'\n}\n\n/**\n *   Please note that the event system can be on the player or on the card.\n * On player, it's Scenario mode\n * On-map: Shared mode\n * So this here is either RpgMap or RpgPlayer\n * You can check the mode with the mode cleanup on the retrieved event\n */\nexport class EventManager {\n    /** \n   * @title event list\n   * @prop { { [eventId: string]: RpgEvent } } [events]\n   * @memberof Map\n   * */\n    public events: EventsList\n\n    /**\n    * Get Event in current map\n    * @title Get Event\n    * @since 3.0.0-beta.7\n    * @method map.getEvent(eventId)\n    * @param {string} eventId Event Id\n    * @returns {RpgEvent | undefined}\n    * @memberof Map\n    */\n    getEvent<T extends RpgEvent>(eventId: string): T | undefined {\n        return this.events[eventId] as T\n    }\n\n    getEventByName<T extends RpgEvent>(eventName: string): T | undefined {\n        const events = Object.keys(this.events)\n        const key = events.find(key => this.events[key].name == eventName)\n        if (!key) return\n        return this.events[key] as T\n    }\n\n    /**\n    * Removes an event from the map. Returns false if the event is not found\n    * \n    * Deletion of an event forced to be performed at the end of several aynschronous notions\n    * \n    * @title Remove Event\n    * @since 3.0.0-beta.4\n    * @method map.removeEvent(eventId)\n    * @param {string} eventId Event Name\n    * @returns {boolean}\n    * @memberof Map\n    */\n    removeEvent(eventId: string): boolean {\n        if (!this.events[eventId]) return false\n        const mode = this.events[eventId].mode\n        let currentState\n        // Restores previous state \n        if (mode == EventMode.Scenario) {\n            currentState = this.getCurrentMap()?.$currentState().users?.[this.id]?.events?.[eventId] ?? {}\n        }\n        else {\n            currentState = this.$currentState().events?.[eventId] ?? {}\n        }\n        this.removeObject(this.events[eventId], mode)\n        delete this.events[eventId]\n        // Change the state of the packet that will be sent to the client, adding the deleted flag to indicate to the client that the event has been deleted.\n        if (mode == EventMode.Scenario) {\n            this.getCurrentMap()?.$setCurrentState(`users.${this.id}.events.${eventId}`, {\n                ...currentState,\n                deleted: true\n            })\n        }\n        else {\n            this.$setCurrentState(`events.${eventId}`, {\n                ...currentState,\n                deleted: true\n            })\n        }\n        return true\n    }\n\n    // @internal\n    removeObject(object: RpgPlayer | RpgEvent, mode: EventMode = EventMode.Shared) {\n        const map = this.getCurrentMap()\n        if (!map) return\n        map.getShapes().forEach(shape => shape.out(object))\n        const events: RpgPlayer[] = Object.values(map.game.world.getObjectsOfGroup(map.id, object))\n        for (let event of events) {\n            object.getShapes().forEach(shape => shape.out(event))\n            event.getShapes().forEach(shape => shape.out(object))\n        }\n        object._destroy$.next()\n        object._destroy$.complete()\n        // force RXJS, close subject. TODO: avoid this\n        if (object.type != PlayerType.Player) object._destroy$['_closed'] = true\n        map.grid.clearObjectInCells(object.id)\n        for (let playerId in map.players) {\n            if (object.id == playerId) continue\n            const otherPlayer = map.players[playerId]\n            if (otherPlayer.followingId == object.id) {\n                otherPlayer.cameraFollow(otherPlayer)\n            }\n        }\n        // last player before removed of this map \n        if (map.nbPlayers === 1 && object.type === PlayerType.Player) {\n            // clear cache for this map\n            map.remove(true)\n        }\n    }\n}\n\nexport interface EventManager {\n    getCurrentMap(): RpgMap | null\n    id: string\n    $setCurrentState: (path: string, value: any) => void;\n    $currentState(): any\n}", "import { InjectContext } from \"@rpgjs/common\";\n\nlet instanceContext: InjectContext | null = null\n\n/**\n * Dependency injection function for RPGJS server side.\n * \n * The server-side `inject` function is designed for retrieving instances of server-related classes in the RPGJS framework. \n * This function is crucial for accessing singleton instances of classes like `RpgServerEngine` on the server. It facilitates \n * a clean and efficient approach to handling dependencies within server modules, contributing to a more organized codebase.\n *\n * @template T The class type that you want to retrieve an instance of, specific to server-side modules.\n * @returns {T} Returns the singleton instance of the specified class, ensuring consistent server-side behavior and state management.\n * @since 4.2.0\n *\n * @example\n * ```ts\n * // Example of injecting the RpgServerEngine\n * import { inject, RpgServerEngine } from '@rpgjs/server'\n * const server = inject(RpgServerEngine)\n * ```\n */\nexport function inject<T>(service: new (...args: any[]) => T, args: any[] = []): T {\n    return instanceContext!.inject(service, args);\n}\n\nexport function setInject(context: InjectContext) {\n    instanceContext = context;\n}\n\nexport function clearInject() {\n    instanceContext = null\n}", "import { TiledMap } from '@rpgjs/tiled'\nimport { componentSchema, RpgPlayer } from '../Player/Player'\n\nexport interface MapOptions {\n    /** \n     * Map identifier. Allows to go to the map (for example with player.changeMap())\n     * \n     * @prop {string} [id]\n     * @memberof MapData\n     * */\n    id?: string,\n\n    /** \n    * the path to the .tmx file (Tiled Map Editor)\n    * \n    * Remember to use `require()` function\n    * \n    * ```ts\n    * import { MapData, RpgMap } from '@rpgjs/server'\n    * \n    * @MapData({\n    *      id: 'town',\n    *      file: require('./tmx/town.tmx')\n    * })\n    * class TownMap extends RpgMap { } \n    * ``` \n    * @prop {string} file\n    * @memberof MapData\n    * */\n    file: string | TiledMap,\n\n    /** \n     * The name of the map.\n     * @prop {string} [name]\n     * @memberof MapData\n     * */\n    name?: string,\n\n    /** \n    * Map events. This is an array containing `RpgEvent` classes. \n    * You can also give an object that will indicate the positions of the event on the map.\n    * \n    * ```ts\n    * import { MapData, RpgMap, EventData, RpgEvent } from '@rpgjs/server'\n    * \n    * @EventData({\n    *      name: 'Ev-1'\n    * })\n    * class NpcEvent extends RpgEvent { }\n    * \n    * @MapData({\n    *      id: 'medieval',\n    *      file: require('./tmx/town.tmx'),\n    *      events: [NpcEvent]\n    * })\n    * class TownMap extends RpgMap {}\n    * ```\n    * \n    * If the positions are not defined, the event will be placed on a Tiled Map Editor shape ([/guide/create-event.html#position-the-event-on-the-map](Guide)). Otherwise, it will be placed at `{x:0, y:0 }`\n    * \n    * You can give positions:\n    * \n    * ```ts\n    * events: [{ event: NpcEvent, x: 10, y: 30 }]\n    * ```\n    * \n    * @prop {Class of RpgEvent[] | { event: Class RpgEvent, x: number, y: number }} [events]\n    * @memberof MapData\n    * */\n    events?: { event: any, x: number, y: number }[] | any[],\n\n    /** \n     * The sounds that will be played when the map is open. Sounds must be defined on the client side. Then, put the name of the sound identifier\n     * \n     * So, it is possible to play several sounds (in loop or not) on the card. You can put a background music (BGM) and a background noise (BGS) for example\n     * \n     *  ```ts\n     * sounds: ['my-bgm', 'my-bgs']\n     * ```\n     * \n     * And client side:\n     * \n     * ```ts\n     * import { Sound } from '@rpgjs/client'\n     * \n     * @Sound({\n     *      sounds: {\n     *          'my-bgm': require('./assets/bgm.ogg'),\n     *          'my-bgs': require('./assets/bgs.ogg')\n     *      },\n     *      loop: true\n     * })\n     * export class Sounds {}\n     * ```\n     * \n     * See [https://docs.rpgjs.dev/classes/sound.html#properties](RpgSound Decorator)\n     * \n     * @prop {Array<string>} [sounds]\n     * @memberof MapData\n     * */\n    sounds?: string[]\n\n    /** \n     * Specify which properties will be synchronized with the client. On the client side, you can retrieve the values synchronized with the valueChanges property on the scene\n     * \n     * You must create the schema:\n     * \n     * ```ts\n     * import { MapData, RpgMap } from '@rpgjs/server'\n     * \n     * @MapData({\n     *      id: 'medieval',\n     *      file: require('./tmx/town.tmx'),\n     *      syncSchema: {\n     *          count: Number\n     *      }\n     * })\n     * export class TownMap extends RpgMap {\n     *      count: number = 0\n     * \n     *      onLoad() {}\n     * \n     *      onJoin() {\n     *          this.count++\n     *      }\n     * \n     *      onLeave(player) {\n     *          super.onLeave(player)\n     *          this.count--\n     *      }\n     * }\n     * \n     * ```\n     * \n     * If you want to change the scheme of players and events, consider overwriting the existing scheme\n     * \n     *  ```ts\n     * import { MapData, RpgMap, RpgPlayer } from '@rpgjs/server'\n     * \n     * \n     * declare module '@rpgjs/server' {\n     *  export interface RpgPlayer {\n     *      customProp: string\n     *  }\n     * }\n     * \n     * @MapData({\n     *      id: 'medieval',\n     *      file: require('./tmx/town.tmx'),\n     *      syncSchema: {\n     *          users: [\n     *              {\n     *                  customProp: String,\n     *                  ...RpgPlayer.schemas\n     *              }\n     *          ]\n     *      }\n     * })\n     * export class TownMap extends RpgMap {}\n     * ```\n     * \n     * The properties are called `users` and `events`. Their scheme is identical and defined in `RpgPlayer.schemas`. To write schematics, refer to the [documentation of the simple-room](https://github.com/RSamaium/simple-room) module\n     * \n     * @prop {object} [syncSchema]\n     * @memberof MapData\n     * */\n    syncSchema?: any\n\n    /** \n     * Decreases the RAM of the map. In this case, some instructions will be different.\n     * \n     * `map.getTileByIndex()` will not return all tiles of an index but only the tile of the highest layer\n     * \n     * > You can also use the `low-memory` property in Tiled maps\n     * \n     * @prop {boolean} [lowMemory=false]\n     * @since 3.1.0\n     * @memberof MapData\n     * */\n    lowMemory?: boolean\n}\n\nexport function MapData(options: MapOptions) {\n    return (target) => {\n        target.file = options.file\n        target.id = options.id\n        target.type = 'map'\n        target.prototype.name = options.name\n        target.prototype.file = options.file\n        target.prototype.id = options.id\n        target.prototype.sounds = options.sounds\n        target.prototype.lowMemory = options.lowMemory\n\n        target.prototype.$schema = {}\n\n        if (options.syncSchema) {\n            target.prototype.$schema = options.syncSchema\n        }\n        if (!target.prototype.$schema.shapes) {\n            target.prototype.$schema.shapes = [\n                {\n                    type: String,\n                    name: String,\n                    x: Number,\n                    y: Number,\n                    width: Number,\n                    height: Number,\n                    properties: {\n                        collision: Boolean\n                    },\n                    polygon: [{ x: Number, y: Number }],\n                    rotation: Number,\n                    components: [componentSchema]\n                }\n            ]\n        }\n        if (!target.prototype.$schema.users) {\n            target.prototype.$schema.users = [RpgPlayer.schemas]\n        }\n        if (!target.prototype.$schema.events) {\n            target.prototype.$schema.events = [RpgPlayer.schemas]\n        }\n\n        target.prototype._events = options.events\n    }\n}", "import { EventMode } from \"../Game/EventManager\"\n\nexport interface EventOptions {\n    /** \n     * The mode of the event, shared evening or scenario\n     * \n     * The scenario mode allows you to have events specific to the player. Thus, the graphics, the positions of the event will be different for each player. Beware of performance! The event is duplicated by each player.\n     * \n     * `shared` mode by default\n     * \n     * ```ts\n     * import { RpgEvent, EventData, RpgPlayer, EventMode } from '@rpgjs/server'\n     * @EventData({\n     *      name: 'EV-1',\n     *      mode: EventMode.Scenario // or EventMode.Shared\n     * })\n     * export class CharaEvent extends RpgEvent { }\n     * ```\n     * \n     * @prop {string} [mode] Either \"shared\" or \"scenario\".\n     * @memberof EventData\n     * */\n    mode?: EventMode,\n\n    width?: number,\n    height?: number,\n\n    /** \n     * The hitbox of the event. By default, this is the size of the tile of the map\n     * \n     * @prop { { width: number, height: number }} [hitbox]\n     * @memberof EventData\n     * */\n    hitbox?: {\n        width?: number,\n        height?: number\n    },\n\n    /** \n     * Name of the event. This is its identifier. it allows you to retrieve an event and place it on the map\n     * \n     * @prop {string} name\n     * @memberof EventData\n     * */\n    name: string\n}\n\nexport function EventData(options: EventOptions) {\n    return (target) => {\n        target.mode = options.mode || EventMode.Shared\n        target.width = options.width\n        target.height = options.height\n        target.hitbox = options.hitbox\n        target._name = options.name\n        target.prototype._name = options.name\n        target.prototype.mode = target.mode\n    }\n}", "import { RpgCommonMap, Utils, RpgShape, RpgCommonGame, AbstractObject } from '@rpgjs/common'\nimport { TiledParserFile, TiledParser, TiledTileset } from '@rpgjs/tiled'\nimport { EventData, EventOptions } from '../decorators/event'\nimport { RpgPlayer, RpgEvent, RpgClassEvent } from '../Player/Player'\nimport { Move } from '../Player/MoveManager'\nimport { RpgServerEngine } from '../server'\nimport { Observable } from 'rxjs'\nimport path from 'path'\nimport { HitBox, MovingHitbox, PlayerType, Position } from '@rpgjs/types'\nimport { World } from 'simple-room'\nimport { EventManager, EventMode } from './EventManager'\n\nexport type EventPosOption = {\n    x: number,\n    y: number,\n    z?: number,\n    event: EventOptions\n}\nexport type EventOption = EventPosOption | EventOptions\n\nexport type PlayersList = {\n    [eventId: string]: RpgEvent\n}\n\nexport type EventsList = {\n    [playerId: string]: RpgPlayer\n}\n\nclass AutoEvent extends RpgEvent {\n    static mode: EventMode\n    static hitbox: any = {}\n\n    onInit() {\n        const { graphic, direction, speed, frequency, move } = this.properties\n        if (graphic) {\n            this.setGraphic(graphic)\n        }\n        if (direction) {\n            this.changeDirection(direction)\n        }\n        if (speed) {\n            this.speed = speed\n        }\n        if (frequency) {\n            this.frequency = frequency\n        }\n        if (move == 'random') {\n            this.infiniteMoveRoute([Move.tileRandom()])\n        }\n    }\n\n    async onAction(player: RpgPlayer) {\n        const { text } = this.properties\n        if (text) {\n            await player.showText(text, {\n                talkWith: this\n            })\n        }\n    }\n}\n\nexport class RpgMap extends RpgCommonMap {\n\n    public _events: EventOption[]\n    public file: any\n\n    constructor(private _server: RpgServerEngine) {\n        super()\n        this.events = {}\n    }\n\n    // alias of users property in simple-room package\n    /**\n     * @title Players list\n     * @prop { { [playerId: string]: RpgPlayer } } [players]\n     * @readonly\n     * @memberof Map\n     */\n    get players(): PlayersList {\n        return this['users']\n    }\n\n    /**\n     * @title Number of players\n     * @prop {number} [nbPlayers]\n     * @readonly\n     * @memberof Map\n     */\n    get nbPlayers(): number {\n        return Object.keys(this.players).length\n    }\n\n    $additionalEmitProperties(player: RpgPlayer) {\n        const lastFramePositions: {\n            frame: number\n            position: unknown\n        } | undefined = player['_lastFramePositions']\n        let pos\n        let lastFrame\n        if (lastFramePositions) {\n            pos = lastFramePositions.position\n            lastFrame = lastFramePositions.frame\n        }\n        const data = { frame: lastFrame, pos }\n        return data\n    }\n\n    async load() {\n        if (RpgCommonMap.buffer.has(this.id)) {\n            return\n        }\n        const data = await this.parseTmx(this.file)\n        super.load(data)\n        this.getAllObjects().forEach(this.createShape.bind(this))\n        this.loadProperties((data as any).properties)\n        this._server.workers?.call('loadMap', {\n            id: this.id,\n            data\n        })\n        RpgCommonMap.buffer.set(this.id, this)\n        this.loadCommonEvents(this._server.inputOptions.events)\n        this.createDynamicEvent(this._events as EventPosOption[])\n        if (this.onLoad) this.onLoad()\n    }\n\n    /**\n     * Update the map with new data. Data can be a string (TMX content) or an object (parsed TMX content)\n     * New Map data will be sent to all players on the map\n     *\n     * @title Update map\n     * @method map.update(data)\n     * @since 4.0.0\n     * @returns {Promise<void>}\n     * @param {object | string} data\n     * @memberof Map\n     */\n    async update(data: object | string): Promise<void> {\n        let objectData\n        // Data is XML (TMX content)\n        if (typeof data == 'string') {\n            objectData = await this.parseTmx(data, this.file)\n        }\n        else {\n            objectData = data\n        }\n        super.load(objectData)\n        RpgCommonMap.buffer.set(this.id, this)\n        this.clearShapes()\n        this.getAllObjects().forEach(this.createShape.bind(this))\n        for (let playerId in this.players) {\n            const player = this.players[playerId]\n            player.emitSceneMap()\n        }\n    }\n\n    /**\n     * Update tileset with new data. Data can be a string (TSX content) or an object (TiledTileset)\n     * Cache will be removed for this tileset\n     * New tileset data will be sent to all players on the map\n     * Warning: tileset is not updated for all maps, only for the current map\n     * \n     * @title Update tileset\n     * @method map.updateTileset(data)\n     * @since 4.0.0\n     * @returns {<void>}\n     * @param {TiledTileset | string} data\n     * @memberof Map\n     */\n    updateTileset(data: TiledTileset | string) {\n        let objectData: TiledTileset\n        // Data is XML (TMX content)\n        if (typeof data == 'string') {\n            const parser = new TiledParser(data, this.file)\n            objectData = parser.parseTileset()\n        }\n        else {\n            objectData = data\n        }\n        this.removeCacheTileset(objectData.name)\n        this.update({\n            ...this.data,\n            tilesets: this.data.tilesets.map((tileset: any) => {\n                if (tileset.name == objectData.name) {\n                    objectData.firstgid = tileset.firstgid\n                    return objectData\n                }\n                return tileset\n            })\n        })\n    }\n\n    /**\n     * Remove the map from the server. If there are still players on the map, an error will be thrown\n     * Not delete the map file, only in memory\n     * \n     * @title Remove map\n     * @method map.remove()\n     * @since 4.0.0\n     * @returns {void}\n     * @throws {Error} If there are still players on the map\n     * @memberof Map\n     * */\n    remove(ignorePlayers = false): never | void {\n        const players = Object.values(this.players)\n        if (players.length > 0 && !ignorePlayers) {\n            throw new Error(`Cannot remove map ${this.id} because there are still players on it`)\n        }\n        for (let eventId in this.events) {\n            this.removeEvent(eventId)\n        }\n        RpgCommonMap.buffer.delete(this.id)\n        World.removeRoom(this.id)\n    }\n\n    private async parseTmx(file: string, relativePath: string = '') {\n        // @ts-ignore\n        const hasAssetsPath = !!this._server.envs.VITE_BUILT\n        const parser = new TiledParserFile(\n            file,\n            {\n                basePath: process.env.NODE_ENV == 'test' ? '.' : '',\n                staticDir: hasAssetsPath ? path.join(this._server.inputOptions.basePath, this._server.assetsPath) : '',\n                relativePath\n            }\n        )\n        const data = await parser.parseFilePromise({\n            getOnlyBasename: hasAssetsPath\n        })\n\n        return data\n    }\n\n    private loadProperties(properties: {\n        [key: string]: any\n    }) {\n        for (let key in properties) {\n            this[key] = properties[key]\n        }\n    }\n\n    get game(): RpgCommonGame {\n        return this._server.gameEngine\n    }\n\n    // Hook: called by simple-room package\n    onLeave(player: RpgPlayer) {\n        this.removeObject(player)\n    }\n\n    /**\n     * Loads common events onto the game map.\n     *\n     * @private\n     * @param {RpgClassEvent<RpgEvent>[]} commonEvents - An array of common events to load.\n     * @param {RpgPlayer} [player] - The player instance on which to create the dynamic events. If not provided, the function will use the current instance.\n     * @returns {void}\n     */\n    // @internal\n    loadCommonEvents(commonEvents: RpgClassEvent<RpgEvent>[], player?: RpgPlayer) {\n        let events: EventPosOption[] = []\n        this.getShapes().forEach(shape => {\n            const findEvent = commonEvents.find(event => event._name == shape.name)\n            if (!findEvent) return\n            const { x, y, } = shape.hitbox\n            events.push({\n                x,\n                y,\n                event: findEvent\n            })\n        });\n        if (player) {\n            player.createDynamicEvent(events, false)\n        }\n        else {\n            this.createDynamicEvent(events)\n        }\n\n    }\n\n    // TODO\n    autoLoadEvent() {\n        this.getShapes().forEach(shape => {\n            const { properties } = shape\n            const { x, y, pos, w, h } = shape.hitbox\n            if (shape.isEvent() && !this.events[shape.name]) {\n                const mode = properties.mode || EventMode.Shared\n                AutoEvent.prototype['_name'] = shape.name\n                AutoEvent.mode = mode\n                AutoEvent.hitbox = {\n                    width: 32,\n                    height: 16\n                }\n                const event = this.createEvent({\n                    x,\n                    y,\n                    event: AutoEvent\n                }, mode, shape)\n                if (event) this.events[shape.name] = event\n            }\n        })\n    }\n\n    /**\n     * Edit a tile on the map. All players on the map will see the modified tile\n     * \n     * \n     * @title Change Tile in map\n     * @since 3.0.0-beta.4\n     * @method map.setTile(x,y,layer,tileInfo)\n     * @param {number} x Position X\n     * @param {number} y Position Y\n     * @param {string | ((layer: any) => boolean)} layer Name of the layer where you want to put a tile. OYou can also put a function that will act as a filter. The first parameter is the layer and you return a boolean to indicate if you modify the tile of this layer or not\n     * @param {object} tileInfo Object with the following properties:\n     *  - {number} gid: The tile number in tileset (from 1)\n     *  - {object} properties Property of the tile. You own object. To set a collision, set the `collision:true` property\n     * @example\n     * ```ts\n     * map.setTile(15, 18, 'mylayer', { gid: 2 })\n     * ```\n     * @returns {void}\n     * @memberof Map\n     */\n    setTile(x: number, y: number, layerFilter: string | ((layer: any) => boolean), tileInfo: {\n        gid: number,\n        properties?: object\n    }): any {\n        const tiles = super.setTile(x, y, layerFilter, tileInfo)\n        const players: RpgPlayer[] = Object.values(this['users'])\n        for (let player of players) {\n            player.emit('changeTile', tiles)\n        }\n        return tiles\n    }\n\n    getEventShape(eventName: string): RpgShape | undefined {\n        return this.getShapes().find(shape => shape.name == eventName)\n    }\n\n    /**\n     * Dynamically create an event in Shared mode\n     * \n     * ```ts\n     * @EventData({\n     *  name: 'EV-1'\n     * })\n     * class MyEvent extends RpgEvent {\n     *  onAction() {\n     *      console.log('ok')\n     *  }\n     * } \n     *\n     * map.createDynamicEvent({\n     *      x: 100,\n     *      y: 100,\n     *      event: MyEvent\n     * })\n     * ```\n     * \n     * You can also put an array of objects to create several events at once\n     * \n     * @title Create Dynamic Event\n     * @since 3.0.0-beta.4\n     * @method map.createDynamicEvent(eventObj|eventObj[])\n     * @param { { x: number, y: number, z?: number, event: eventClass } } eventsList\n     * @returns { { [eventId: string]: RpgEvent } }\n     * @memberof Map\n     */\n    createDynamicEvent(eventsList: EventPosOption | EventPosOption[]): {\n        [eventId: string]: RpgEvent\n    } {\n        if (!eventsList) return {}\n        if (!Utils.isArray(eventsList)) {\n            eventsList = [eventsList as EventPosOption]\n        }\n        const events = this.createEvents(eventsList as EventPosOption[], EventMode.Shared)\n        let ret = {}\n        for (let key in events) {\n            this.events[key] = events[key] as any\n            this.events[key].updateInVirtualGrid()\n            this.events[key].execMethod('onInit')\n            // force to get Proxy object to sync with client\n            ret = { ...ret, [key]: this.events[key] }\n        }\n        return ret\n    }\n\n    createEvent(obj: EventPosOption, mode: EventMode, shape?: RpgShape): RpgEvent | null {\n        let event: any, position: Position | undefined\n\n        // We retrieve the information of the event ([Event] or [{event: Event, x: number, y: number}])\n        if (obj.x === undefined) {\n            event = obj\n        }\n        else {\n            event = obj.event\n            position = { x: obj.x, y: obj.y, z: obj.z ?? 0 }\n        }\n\n        if ('$decorator' in event) {\n            const options = event.$decorator\n            EventData(options)(event)\n        }\n\n        // The event is ignored if the mode is different.\n        if (event.mode != mode) {\n            return null\n        }\n\n        // Create an instance of RpgEvent and assign its options\n        const ev = this.game.addEvent<RpgEvent>(event)\n        const _shape = shape || this.getEventShape(ev.name)\n        ev.map = this.id\n        ev.width = event.width || this.tileWidth\n        ev.height = event.height || this.tileHeight\n        if (_shape && _shape.properties) ev.properties = _shape.properties\n        if (event.hitbox) ev.setHitbox(event.hitbox.width, event.hitbox.height)\n        ev.teleport(position || ev.name)\n        return ev\n    }\n\n    createEvents(eventsList: EventOption[], mode: EventMode): EventsList {\n        const events = {}\n\n        if (!eventsList) return events\n\n        for (let obj of eventsList) {\n            const ev = this.createEvent(obj as EventPosOption, mode)\n            if (ev) {\n                events[ev.id] = ev\n            }\n        }\n\n        return events\n    }\n\n    /**\n     * Allows to create a temporary hitbox on the map that can have a movement\nFor example, you can use it to explode a bomb and find all the affected players, or during a sword strike, you can create a moving hitbox and find the affected players again\n     * @title Create a temporary and moving hitbox\n     * @since 3.2.0\n     * @method map.createMovingHitbox(hitboxes,options)\n     * @param {Array<{ width: number, height: number, x: number, y: number }>} hitboxes Create several hitboxes that will give an effect of movement\n     * @param {object} [options]\n     * @param {speed} [options.speed=1] speed of movement (in frames)\n     * @returns {Observable<AbstractObject>} You find the methods of position and movement of an event\n     * @memberof Map\n     * @example\n     * \n     * ```ts\n     * // Two hitboxes that will be done very quickly\n     * map.createMovingHitbox(\n     *   [ \n     *      { x: 0, y: 0, width: 100, height: 100 },\n     *      { x: 20, y: 0, width: 100, height: 100 } \n     *   ]\n     * ).subscribe({\n     *      next(hitbox) {\n     *          console.log(hitbox.otherPlayersCollision)\n     *      },\n     *      complete() {\n     *          console.log('finish')\n     *      }\n     * })\n     * ```\n     */\n    createMovingHitbox(\n        hitboxes: Pick<HitBox, 'width' | 'height' | 'x' | 'y'>[],\n        options: MovingHitbox = {}): Observable<AbstractObject> {\n        return this._createMovingHitbox<RpgCommonGame>(\n            this.game,\n            this._server.tick as any,\n            this.id,\n            hitboxes,\n            options) as any\n    }\n\n    setSync(schema: any) {\n        return this.$setSchema(schema)\n    }\n\n    // Reflects itself. Just for compatibility with the EventManager class\n    getCurrentMap() {\n        return this\n    }\n}\n\nexport interface RpgMap extends EventManager {\n    sounds: string[]\n    $schema: any\n    $setSchema: (schema: any) => void\n    $patchSchema: (schema: any) => void\n    $snapshotUser: (userId: string) => any\n    onLoad()\n    $setCurrentState: (path: string, value: any) => void;\n    id: string\n}\n\nUtils.applyMixins(RpgMap, [\n    EventManager\n])", "import { RpgCommonWorldMaps, Utils } from '@rpgjs/common'\nimport { TiledWorld, TiledMap, TiledWorldMap } from '@rpgjs/tiled'\nimport { RpgClassMap, SceneMap } from '../Scenes/Map'\nimport { RpgMap } from './Map'\n\nexport type RpgTiledWorldMap = {\n    id?: string\n    fileName: string | TiledMap\n} & TiledWorldMap\n\nexport type RpgTiledWorld  = {\n    maps: RpgTiledWorldMap[]\n} & TiledWorld\n\nexport interface WorldMap extends RpgTiledWorld {\n    id?: string,\n    basePath?: string\n}\n\nexport class RpgWorldMaps extends RpgCommonWorldMaps {\n    load(world: WorldMap, sceneMap: SceneMap) {\n        for (let worldMap of world.maps) {\n            const { fileName } = worldMap\n            let id, map: RpgClassMap<RpgMap>\n            if (worldMap.id) {\n                id = worldMap.id\n            }\n            else if (Utils.isString(fileName)) {\n                id = Utils.extractId(fileName)\n            }\n            const create = () => sceneMap.createDynamicMap({\n                id,\n                file: world.basePath ? `${world.basePath}/${fileName}` : fileName\n            })\n            if (!id) {\n                map = create()\n            }\n            else {\n                map = sceneMap.getMapBydId(id) ?? create()\n            }\n            this.addMap(worldMap, map)\n        }\n        return this\n    }\n}", "\nimport { HookServer, RpgCommonMap, RpgPlugin, Utils } from '@rpgjs/common'\nimport { World } from 'simple-room'\nimport { isTiledFormat, TiledMap } from '@rpgjs/tiled'\nimport { MapOptions, MapData } from '../decorators/map'\nimport { RpgMap } from '../Game/Map'\nimport { RpgWorldMaps, WorldMap } from '../Game/WorldMaps'\nimport { RpgEvent, RpgPlayer } from '../Player/Player'\nimport { RpgServerEngine } from '../server'\nimport { inject } from '../inject'\n\nexport interface RpgClassMap<T> {\n    id?: string\n    file?: string\n    new(server: any): T,\n}\n\ntype SceneMapObject = {\n    maps: any[],\n    worldMaps: WorldMap[]\n    events: RpgEvent[]\n}\n\nexport class SceneMap {\n    static readonly id: string = 'map'\n\n    private maps: any[] = []\n    private mapsById: {\n        [mapId: string]: RpgClassMap<RpgMap>\n    } = {}\n    private worldMaps: Map<string, RpgWorldMaps> = new Map()\n    private server: RpgServerEngine = inject(RpgServerEngine)\n\n    constructor(sceneMapObject: SceneMapObject) {\n        const { maps, worldMaps, events } = sceneMapObject\n        this.maps = maps\n        this.mapsById = {}\n        RpgCommonMap.buffer.clear()\n        if (this.maps) {\n            for (let map of this.maps) {\n                this.createDynamicMap(map)\n            }\n        }\n        if (worldMaps) {\n            for (let worldMap of worldMaps) {\n                this.createDynamicWorldMaps(worldMap)\n            }\n        }\n    }\n\n    /**\n     * Returns an array of RpgClassMap objects that represent maps with static properties.\n     * \n     * @title Get maps\n     * @method sceneMap.getMaps()\n     * @returns {RpgClassMap<RpgMap>[]} Array of RpgClassMap objects.\n     * @since 4.0.0\n     * @example\n     * ```typescript\n     * const maps = scene.getMaps();\n     * console.log(maps);\n     * // Output: [\n     * // { file: 'maps/level1.tmx', id: 'level1', type: 'map' },\n     * // { file: 'maps/level2.tmx', id: 'level1', type: 'map' },\n     * // { file: 'maps/level3.tmx', id: 'level1', type: 'map' }\n     * // ]\n     * ```\n     * @memberof SceneMap\n     */\n    getMaps(): RpgClassMap<RpgMap>[] {\n        return Object.values(this.mapsById)\n    }\n\n    getMapBydId(id: string): RpgClassMap<RpgMap> | null {\n        let mapClass = this.mapsById[id]\n        if (!mapClass) {\n            return null\n        }\n        if (!Utils.isClass(mapClass)) mapClass = Utils.createConstructor<RpgClassMap<RpgMap>>(mapClass)\n        return mapClass\n    }\n\n    async loadMap(id: string): Promise<RpgMap | undefined> {\n        const mapClass = this.getMapBydId(id)\n\n        if (!mapClass) {\n            console.log(`Map ${id} not exists`)\n            return\n        }\n\n        let mapInstance\n\n        if (mapClass['buffer'].has(id)) {\n            return mapClass['buffer'].get(id)\n        }\n\n        if (RpgCommonMap.buffer.has(id)) {\n            mapInstance = RpgCommonMap.buffer.get(id)\n        }\n        else {\n            const room = new mapClass(this.server)\n            room.$schema.users = [\n                {\n                    ...RpgPlayer.schemas,\n                    ...this.server['playerProps']\n                }\n            ]\n            mapInstance = World.addRoom(id, room)\n            await mapInstance.load()\n        }\n\n        return mapInstance\n    }\n\n    /**\n    * Loads the content of a `.world` file from Tiled Map Editor into the map scene\n    * \n    * > Note, that if the map already exists (i.e. you have already defined an RpgMap), the world will retrieve the already existing map. Otherwise it will create a new map\n    * \n    * @title Create worlds dynamically\n    * @method sceneMap.createDynamicWorldMaps(world)\n    * @param {object} world \n    * object is \n    * ```ts\n    * {\n    *  id?: string\n    *  maps: {\n    *      id?: string\n    *      properties?: object\n    *      fileName: string;\n           height: number;\n           width: number;\n           x: number;\n           y: number;\n    *  }[],\n       onlyShowAdjacentMaps: boolean, // only for Tiled Map Editor\n       type: 'world' // only for Tiled Map Editor\n    * }\n    * ```\n    * \n    * @since 3.0.0-beta.8\n    * @memberof SceneMap\n    */\n    createDynamicWorldMaps(world: WorldMap): RpgWorldMaps {\n        world.id = world.id || Utils.generateUID()\n        const worldMap = new RpgWorldMaps(world.id).load(world, this)\n        this.worldMaps.set(world.id, worldMap)\n        return worldMap\n    }\n\n    /**\n     * Recover a world\n     * \n     * @title Recover a world\n     * @method sceneMap.getWorldMaps(id)\n     * @param {string} id world id \n     * @return { RpgWorldMaps | undefined }\n     * @since 3.0.0-beta.8\n     * @memberof SceneMap\n     */\n    getWorldMaps(id: string): RpgWorldMaps | undefined {\n        return this.worldMaps.get(id)\n    }\n\n    /**\n    * Delete a world\n    * \n    * @title Delete a world\n    * @method sceneMap.deleteWorldMaps(id)\n    * @param {string} id world id \n    * @since 3.0.0-beta.8\n    * @memberof SceneMap\n    */\n    deleteWorldMaps(id: string): void {\n        this.worldMaps.delete(id)\n    }\n\n    /**\n     * Create a dynamic map\n     * \n     * Since version 3.0.0-beta.8, you can just pass the path to the file. The identifier will then be the name of the file\n     * \n     * @method sceneMap.createDynamicMap(mapData)\n     * @title Create a dynamic map\n     * @param {object | RpgMap | string} mapData The same property as [@MapData decorator](https://docs.rpgjs.dev/classes/map.html#mapdata-decorator)\n     * @returns {RpgMap}\n     * @since 3.0.0-beta.4\n     * @memberof SceneMap\n     * @example\n     * ```ts\n     * sceneMap.createDynamicMap({\n     *      id: 'myid',\n     *      file: require('./tmx/mymap.tmx')\n     * })\n     * ```\n     * \n     * And later, on the player:\n     * \n     * ```ts\n     * player.changeMap('myid')\n     * ```\n     * \n     * --- \n     * \n     * since beta.8\n     * \n     * ```ts\n     * sceneMap.createDynamicMap(require('./tmx/mymap.tmx')) // id is \"mymap\"\n     * ```\n     */\n    createDynamicMap(mapData: MapOptions | string | RpgClassMap<RpgMap> | TiledMap): RpgClassMap<RpgMap> | never {\n        if (Utils.isString(mapData)) {\n            const id = Utils.extractId(mapData as string)\n            if (!id) {\n                throw new Error('Unable to extract the file identifier. Check that the file has only the following characters: [a-zA-Z0-9-_$!]+')\n            }\n            mapData = {\n                id: id[1],\n                file: mapData\n            } as MapOptions\n        }\n        if (isTiledFormat(mapData)) {\n            const tiledData = (mapData as TiledMap)\n            mapData = {\n                file: { ...tiledData }\n            } as MapOptions\n        }\n        if (!(mapData as MapOptions).id) (mapData as MapOptions).id = Utils.generateUID()\n        if (!Utils.isClass(mapData)) {\n            @MapData(mapData as MapOptions)\n            class DynamicMap extends RpgMap { }\n            mapData = DynamicMap\n        }\n        const map: RpgClassMap<RpgMap> = mapData as any\n        this.mapsById[map.id as string] = map\n        return map\n    }\n\n    async changeMap(\n        mapId: string,\n        player: RpgPlayer,\n        positions?: { x: number, y: number, z?: number } | string\n    ): Promise<RpgMap | null | boolean> {\n\n        const boolArray: boolean[] = await RpgPlugin.emit(HookServer.PlayerCanChangeMap, [player, this.getMapBydId(mapId)], true)\n\n        if (boolArray.some(el => el === false)) {\n            return null\n        }\n\n        // if just teleport, not change map\n        if (player.map === mapId) {\n            await player.teleport(positions || 'start')\n            return null\n        }\n\n        player.emit('preLoadScene', {\n            id: mapId\n        })\n\n        player.prevMap = player.map\n\n        if (player.prevMap) {\n            await player.execMethod('onLeaveMap', <any>[player.getCurrentMap()])\n            World.leaveRoom(player.prevMap, player.id)\n        }\n\n        player.map = mapId\n        player.events = {}\n        player.tmpPositions = positions as any\n\n        const scalabilityArray: boolean[] = await RpgPlugin.emit(HookServer.ScalabilityChangeServer, player)\n\n        if (scalabilityArray.some(el => el === true)) {\n            return true\n        }\n\n        player.tmpPositions = null\n\n        const mapInstance = await this.loadMap(mapId)\n\n        if (!mapInstance) return null\n\n        if (!player.height) player.height = mapInstance.tileHeight\n        if (!player.width) player.width = mapInstance.tileWidth\n        if (!player.hitbox.h) player.hitbox.h = mapInstance.tileHeight\n        if (!player.hitbox.w) player.hitbox.w = mapInstance.tileWidth\n\n        player.emitSceneMap()\n\n        // if room is removed after load map (for unit tests)\n        if (!World.getRoom(mapId)) {\n            return null\n        }\n\n        player.teleport(positions || 'start')\n\n        World.joinRoom(mapId, player.id)\n\n        player = World.getUser(player.id) as RpgPlayer\n\n        if (player) {\n            mapInstance.loadCommonEvents(this.server.inputOptions.events, player)\n            player.createDynamicEvent(<any>mapInstance._events, false)\n            await player.execMethod('onJoinMap', <any>[mapInstance])\n        }\n\n        return mapInstance\n    }\n}", "import { World } from 'simple-room'\nimport { RpgShape, Utils } from '@rpgjs/common'\nimport { RpgPlayer } from './Player/Player'\nimport { Observable } from 'rxjs'\n\nconst { isString } = Utils\n\nclass QueryClass {\n    /** \n     * Listen to the changes on all the rooms\n     * \n     * ```ts\n     * import { RpgWorld } from '@rpgjs/server'\n     * import { map } from 'rxjs/operators' // install rxjs\n     * \n     * RpgWorld.changes\n     *  .pipe(\n     *      map(rooms => rooms['mymap'])\n     *  )\n     *  .subscribe((room) => {\n     *      const users: any = Object.values(room.users)\n     *      console.log(users)\n     *  })\n     * ``` \n     * \n     * @title Subscribe to the world\n     * @prop {Observable} RpgWorld.changes\n     * @memberof RpgWorld\n     * */\n    get changes(): Observable<any> {\n        return World.changes.asObservable() as any\n    }\n\n    /**\n     * Retrieve a player according to his ID\n     * \n     * ```ts\n     * import { RpgWorld } from '@rpgjs/server'\n     * \n     * const player = RpgWorld.getPlayer(player) // player is RpgPlayer (player.id) or string (id)\n     * ```\n     * \n     * @title Get Player\n     * @method RpgWorld.getPlayer(player)\n     * @param {RpgPlayer | string} player identifier\n     * @returns {RpgPlayer}\n     * @memberof RpgWorld\n     */\n    getPlayer(player: RpgPlayer | string): RpgPlayer {\n        const id: any = isString(player) ? player : '' + (player as RpgPlayer).id\n        const _player: any = World.getUser(id)\n        return _player as RpgPlayer\n    }\n\n    /**\n     * Recover all the players of the game\n     * \n     * ```ts\n     * import { RpgWorld } from '@rpgjs/server'\n     * \n     * const players = RpgWorld.getPlayers()\n     * ```\n     * \n     * @title Get all Players\n     * @method RpgWorld.getPlayers()\n     * @returns {Array<RpgPlayer>}\n     * @memberof RpgWorld\n     */\n    getPlayers(): RpgPlayer[] {\n        const users: any = World.getUsers()\n        const array = Object.values(users) as RpgPlayer[]\n        return array.map((user: RpgPlayer) => this.getPlayer(user))\n    }\n\n    /**\n     * Recover all map objects: players and events. If you specify the `player` parameter, it also retrieves the events in scenario mode of the player in question\n     * \n     * ```ts\n     * import { RpgWorld } from '@rpgjs/server'\n     * \n     * const objects = RpgWorld.getObjectsOfMap('mapname')\n     * console.log(objects)\n     * ```\n     * \n     * Also retrieve events in Scenario mode:\n     * \n     * ```ts\n     * import { RpgWorld } from '@rpgjs/server'\n     * \n     * const objects = RpgWorld.getObjectsOfMap('mapname', 'playerid')\n     * ```\n     * \n     * @title Get all objects of map\n     * @method RpgWorld.getObjectsOfMap(map,playerId?)\n     * @param {string} map Map Name\n     * @param {RpgPlayer | string} playerId player identifier\n     * @returns {Array<RpgPlayer>}\n     * @memberof RpgWorld\n     */\n    getObjectsOfMap(map: string, playerId?: RpgPlayer | string): RpgPlayer[] {\n        return Object.values(this._getObjectsOfMap(map, playerId)) as RpgPlayer[]\n    }\n\n    _getObjectsOfMap(map: string, playerId?: RpgPlayer | string): { [id: string]: RpgPlayer } {\n        const room: any = World.getRoom(map)\n        let player: any = null\n        if (playerId) {\n            player = this.getPlayer(playerId)\n        }\n        return {\n            ...room.users,\n            ...room.events,\n            ...(player ? player.events : {})\n        }\n    }\n\n    /**\n     * Find all the shapes of the map\n     * \n     * ```ts\n     * import { RpgWorld } from '@rpgjs/server'\n     * \n     * const shapes = RpgWorld.getShapesOfMap('mapname')\n     * console.log(shapes)\n     * ```\n     * \n     * @title Get all shapes of map\n     * @method RpgWorld.getShapesOfMap(map)\n     * @param {string} map Map Name\n     * @returns {Array<RpgShape>}\n     * @memberof RpgWorld\n     */\n    getShapesOfMap(map: string): RpgShape[] {\n        return Object.values(this._getShapesOfMap(map))\n    }\n\n    _getShapesOfMap(map: string): { [id: string]: RpgShape } {\n        const room: any = World.getRoom(map)\n        return room.shapes\n    }\n\n    // TODO\n    getRooms<T>(): Map<string, T> {\n        return World.getRooms() as Map<string, T>\n    }\n\n    getRoom<T>(name: string): T {\n        return World.getRoom(name) as T\n    }\n\n    /**\n     * Recover all the players of a map\n     * \n     * ```ts\n     * import { RpgWorld } from '@rpgjs/server'\n     * \n     * const players = RpgWorld.getPlayersOfMap('mapname')\n     * ```\n     * \n     * @title Get all Players a map\n     * @method RpgWorld.getPlayersOfMap(map)\n     * @param {string} map Map Name\n     * @returns {Array<RpgPlayer>}\n     * @memberof RpgWorld\n     */\n    getPlayersOfMap(map: string): RpgPlayer[] {\n        const room: any = World.getRoom(map)\n        return Object.values(room.users) as RpgPlayer[]\n    }\n}\n\nexport const Query = new QueryClass()", "import { SceneMap } from './Scenes/Map';\nimport { RpgPlayer } from './Player/Player'\nimport { Query } from './Query'\nimport { DAMAGE_SKILL, DAMAGE_PHYSIC, DAMAGE_CRITICAL, COEFFICIENT_ELEMENTS } from './presets'\nimport { World, WorldClass, Transport } from 'simple-room'\nimport { Utils, RpgPlugin, Scheduler, HookServer, RpgCommonGame, DefaultInput } from '@rpgjs/common'\nimport { Observable } from 'rxjs';\nimport { Tick } from '@rpgjs/types';\nimport { Actor, Armor, Class, DatabaseTypes, Item, Skill, State, Weapon } from '@rpgjs/database';\nimport { inject } from './inject';\n\nexport class RpgServerEngine {\n\n    /**\n    * Express App Instance. If you have assigned this variable before starting the game, you can get the instance of Express\n    * \n    * @prop {Express App} [app]\n    * @memberof RpgServerEngine\n    */\n    app\n\n    /**\n     * List of the data\n     * \n     * @prop {object} [database]\n     * @memberof RpgServerEngine\n     */\n    public database: any = {}\n\n    /** \n     * retrieve the global configurations assigned at the entry point\n     * \n     * @prop {object} [globalConfig]\n     * @readonly\n     * @memberof RpgServerEngine\n     * */\n    public globalConfig: any = {}\n\n    /**\n     * Combat formulas\n     * \n     * @prop {object} [damageFormulas]\n     * @memberof RpgServerEngine\n     */\n    public damageFormulas: any = {}\n\n    public serverId: string = process.env.SERVER_ID || Utils.generateUID()\n\n    private scenes: Map<string, any> = new Map()\n    protected totalConnected: number = 0\n    private scheduler: Scheduler = new Scheduler()\n    private playerProps: any\n    public gameEngine: RpgCommonGame = inject(RpgCommonGame)\n\n    world: WorldClass = World\n    workers: any\n    envs: any = {}\n    io: any\n    inputOptions: any = {}\n\n    /**\n     * Combat formulas\n     * \n     * @prop {Socket Io Server} [io]\n     * @memberof RpgServerEngine\n     */\n    initialize(io, inputOptions) {\n        this.io = io\n        this.inputOptions = inputOptions\n        this.envs = inputOptions.envs || {}\n        if (this.inputOptions.workers) {\n            console.log('workers enabled')\n            this.workers = this.gameEngine.createWorkers(this.inputOptions.workers).load()\n        }\n    }\n\n    private async _init() {\n        this.damageFormulas = this.inputOptions.damageFormulas || {}\n        this.damageFormulas = {\n            damageSkill: DAMAGE_SKILL,\n            damagePhysic: DAMAGE_PHYSIC,\n            damageCritical: DAMAGE_CRITICAL,\n            coefficientElements: COEFFICIENT_ELEMENTS,\n            ...this.damageFormulas\n        }\n\n        this.globalConfig = this.inputOptions.globalConfig\n\n        if (!this.inputOptions.maps) this.inputOptions.maps = []\n        if (!this.inputOptions.events) this.inputOptions.events = []\n        if (!this.inputOptions.worldMaps) this.inputOptions.worldMaps = []\n        this.playerProps = this.inputOptions.playerProps\n\n        this.inputOptions.maps = [\n            ...Utils.arrayFlat(await RpgPlugin.emit(HookServer.AddMap, this.inputOptions.maps)) || [],\n            ...this.inputOptions.maps\n        ]\n\n        this.inputOptions.events = [\n            ...Utils.arrayFlat(await RpgPlugin.emit(HookServer.AddEvent, this.inputOptions.events)) || [],\n            ...this.inputOptions.events\n        ]\n\n        this.inputOptions.worldMaps = [\n            ...Utils.arrayFlat(await RpgPlugin.emit(HookServer.AddWorldMaps, this.inputOptions.worldMaps)) || [],\n            ...this.inputOptions.worldMaps\n        ]\n\n        this.globalConfig.inputs = {\n            ...DefaultInput,\n            ...(this.globalConfig.inputs || {})\n        }\n\n        if (!this.inputOptions.database) this.inputOptions.database = {}\n\n        /**\n         * data is array with object or array\n         */\n        const datas = await RpgPlugin.emit(HookServer.AddDatabase, this.inputOptions.database) || []\n\n        for (let element of datas) {\n            if (Array.isArray(element)) {\n                for (let data of element) {\n                    this.addInDatabase(data.id, data)\n                }\n            }\n            else {\n                for (let id in element) {\n                    this.addInDatabase(element[id].id ?? id, element[id])\n                }\n            }\n        }\n\n        this.loadScenes()\n    }\n\n    /**\n     * Adds data to the server's database (in RAM) for later use\n     * \n     * \n     * @method server.addInDatabase(id,data)\n     * @title Add in database\n     * @param {number} id resource id\n     * @param {class | object} dataClass A class representing the data. You can just add a object if you specify the type\n     * @enum {string} [type] The type of data\n     * \n     * item\n     * weapon\n     * armor\n     * skill\n     * class\n     * state\n     * actor\n     * @since 3.0.0-beta.4\n     * @example\n     * ```ts\n     * @Item({\n     *      name: 'Potion',\n     *      description: 'Gives 100 HP',\n     * })\n     * class MyItem() {}\n     * \n     * server.addInDatabase('dynamic_item', MyItem)\n     * ```\n     * \n     * or with an object\n     * \n     * ```ts\n     * server.addInDatabase('dynamic_item', {\n     *      name: 'Potion',\n     *      description: 'Gives 100 HP',\n     * }, 'item')\n     * ```\n     * \n     * @returns {void}\n     * @memberof RpgServerEngine\n     */\n    addInDatabase(id: string, dataClass: any, type?: DatabaseTypes) {\n        if (Utils.isClass(dataClass)) {\n            this.database[id] = dataClass\n            return\n        }\n        if (!type) {\n            throw new Error(`You must specify a type for the database ${id}`)\n        }\n        switch (type) {\n            case 'item':\n                @Item(dataClass) class ItemClass { }\n                this.database[id] = ItemClass\n                break;\n            case 'weapon':\n                @Weapon(dataClass) class WeaponClass { }\n                this.database[id] = WeaponClass\n                break;\n            case 'armor':\n                @Armor(dataClass) class ArmorClass { }\n                this.database[id] = ArmorClass\n                break;\n            case 'skill':\n                @Skill(dataClass) class SkillClass { }\n                this.database[id] = SkillClass\n                break;\n            case 'class':\n                @Class(dataClass) class ClassClass { }\n                this.database[id] = ClassClass\n                break;\n            case 'state':\n                @State(dataClass) class StateClass { }\n                this.database[id] = StateClass\n                break;\n            case 'actor':\n                @Actor(dataClass) class ActorClass { }\n                this.database[id] = ActorClass\n                break;\n        }\n    }\n\n    /**\n    * Start the RPG server\n    * \n    * @method server.start()\n    * @title Start Server\n    * @returns {void}\n    * @memberof RpgServerEngine\n    */\n    async start(inputOptions?, scheduler = true) {\n        if (inputOptions) this.inputOptions = inputOptions\n        await this._init()\n        this.tick.subscribe(({ timestamp, deltaTime }) => {\n            this.step(timestamp, deltaTime)\n        })\n        if (scheduler) this.scheduler.start({\n            fps: inputOptions?.fps || 60\n        })\n        this.gameEngine.start({\n            getObject(id) {\n                return Query.getPlayer(id)\n            },\n            getObjectsOfGroup(groupId: string, player: RpgPlayer) {\n                return Query._getObjectsOfMap(groupId, player)\n            },\n            getShapesOfGroup(map: string) {\n                return Query._getShapesOfMap(map)\n            }\n        })\n        //this.io.on('connection', this.onPlayerConnected.bind(this))\n        this.transport(this.io)\n        await RpgPlugin.emit(HookServer.Start, this)\n    }\n\n    private transport(io): Transport {\n        const timeoutDisconnect = this.globalConfig.timeoutDisconnect ?? 0\n        const auth = this.globalConfig.disableAuth ? () => Utils.generateUID() :\n            async (socket) => {\n                const val = await RpgPlugin.emit(HookServer.Auth, [this, socket], true)\n                if (val.length == 0) {\n                    return Utils.generateUID()\n                }\n                return val[val.length - 1]\n            }\n        const transport = new Transport(io, {\n            timeoutDisconnect,\n            auth\n        })\n        this.world.timeoutDisconnect = timeoutDisconnect\n        transport.onConnected(this.onPlayerConnected.bind(this))\n        transport.onDisconnected(this.onPlayerDisconnected.bind(this))\n        return transport\n    }\n\n    get tick(): Observable<Tick> {\n        return this.scheduler.tick as any\n    }\n\n    /**\n     * Sends all packages to clients. The sending is done automatically but you can decide to send yourself by calling this method (for example, for unit tests)\n     * \n     * @method server.send()\n     * @title Send All Packets\n     * @returns {void}\n     * @memberof RpgServerEngine\n     */\n    send(): Promise<void> {\n        return this.world.send()\n    }\n\n    private async updatePlayersMove(deltaTimeInt: number) {\n        const players = this.world.getUsers()\n        const obj: any = []\n        let p: Promise<RpgPlayer>[] = []\n        for (let playerId in players) {\n            const playerInstance = players[playerId]['proxy'] as RpgPlayer\n            if (!playerInstance) continue\n            const player = playerInstance.otherPossessedPlayer ?? playerInstance\n            if (player.pendingMove.length > 0) {\n                \n                const lastFrame = player.pendingMove[player.pendingMove.length - 1]\n                if (this.inputOptions.workers) obj.push(player.toObject())\n                else {\n                    p.push(this.gameEngine.processInput(player.playerId, this.globalConfig.inputs).then((val) => {\n                        player.pendingMove = []\n                        player.moving = false\n                        player._lastFramePositions = {\n                            frame: lastFrame.frame,\n                            position: { ...player.position }\n                        }\n                        return player\n                    }))\n                }\n            }\n        }\n        // TODO\n        if (this.inputOptions.workers) {\n            this.workers.call('movePlayers', obj).then((players) => {\n                for (let playerId in players) {\n                    const player = this.world.getUser(playerId) as RpgPlayer\n                    const data = players[playerId]\n                    if (player) {\n                        player.position = data.position\n                        player.direction = data.direction\n                    }\n                    RpgPlugin.emit('Server.onInput', [player, {\n                        input: data.direction,\n                        moving: true\n                    }], true)\n                }\n            })\n        }\n        return Promise.all(p)\n    }\n\n    nextTick(timestamp: number) {\n        this.scheduler.nextTick(timestamp)\n    }\n\n    step(t: number, dt: number) {\n        this.updatePlayersMove(1)\n        if (this.scheduler.frame % 4 === 0) {\n            this.send()\n        }\n        RpgPlugin.emit(HookServer.Step, this)\n    }\n\n    private loadScenes() {\n        this.scenes.set(SceneMap.id, new SceneMap(\n            {\n                maps: this.inputOptions.maps,\n                events: this.inputOptions.events,\n                worldMaps: this.inputOptions.worldMaps\n            }\n        ))\n    }\n\n    getScene<T>(name: string): T {\n        return this.scenes.get(name)\n    }\n\n    /**\n     * Return the scene that manages the maps of the game\n     * @prop {SceneMap} [sceneMap]\n     * @since 3.0.0-beta.4\n     * @memberof RpgServerEngine\n     */\n    get sceneMap(): SceneMap {\n        return this.getScene<SceneMap>(SceneMap.id)\n    }\n\n    get module() {\n        return RpgPlugin\n    }\n\n    get assetsPath(): string {\n        return this.envs?.['VITE_ASSETS_PATH'] || 'assets'\n    }\n\n    sendToPlayer(currentPlayer, eventName, data) {\n        currentPlayer._socket.emit(eventName, data)\n    }\n\n    private getPlayerBySession(session: string): RpgPlayer | null {\n        const users = this.world.getUsers<RpgPlayer>()\n        for (let userId in users) {\n            const user = users[userId]\n            if (user.session === session) {\n                return user\n            }\n        }\n        return null\n    }\n\n    private onPlayerConnected(socket, playerId: string) {\n        const existingUser = this.world.getUser<RpgPlayer>(playerId, false)\n\n        this.world.connectUser(socket, playerId)\n\n        let player: RpgPlayer\n\n        if (!existingUser) {\n            const { token } = socket.handshake.auth\n            player = new RpgPlayer(playerId)\n            player.session = token\n\n            this.world.setUser(player, socket)\n\n            player._init()\n\n            if (!token) {\n                const newToken = Utils.generateUID() + '-' + Utils.generateUID() + '-' + Utils.generateUID()\n                player.session = newToken\n            }\n\n            if (!token) {\n                player.execMethod('onConnected')\n            }\n            else {\n                RpgPlugin.emit(HookServer.ScalabilityPlayerConnected, player)\n            }\n        }\n        else {\n            player = existingUser\n            if (player.map) {\n                player.emit('preLoadScene', {\n                    reconnect: true,\n                    id: player.map\n                })\n                player.emitSceneMap()\n                this.world.joinRoom(player.map, playerId)\n            }\n        }\n\n        socket.emit('playerJoined', { playerId, session: player.session })\n\n        socket.on('move', (data: { input: string[], frame: number }) => {\n            if (!data?.input) return\n            if (!Array.isArray(data.input)) return\n            const controlPlayer = player.otherPossessedPlayer ?? player\n            if (!controlPlayer.canMove) {\n                return\n            }\n            for (let input of data.input) {\n                controlPlayer.pendingMove.push({\n                    input,\n                    frame: data.frame\n                })\n            }\n        })\n\n    }\n\n    private onPlayerDisconnected(playerId: string) {\n        const player: RpgPlayer = World.getUser(playerId) as RpgPlayer\n        player.execMethod('onDisconnected')\n        this.world.disconnectUser(playerId)\n    }\n\n    stop() {\n        this.scheduler.stop()\n    }\n}", "\nimport axios from 'axios'\nimport { Utils } from '@rpgjs/common'\nimport { RpgPlayer } from './Player/Player'\nimport { inject } from './inject'\nimport { RpgServerEngine } from './server'\n\ninterface MatchMakerPayload {\n    playerId: string\n    mapName: string\n}\n\nexport interface MatchMakerResponse {\n    url: string\n    port: number\n    serverId: string\n}\n\nexport interface MatchMakerOption {\n    endpoint?: string\n    headers?: any\n    callback?: (payload: MatchMakerPayload) => MatchMakerResponse\n}\n\nexport class RpgMatchMaker {\n    private endpoint?: string\n    private headers?: any\n    private callback?: (payload: MatchMakerPayload) => MatchMakerResponse\n\n    constructor(private options: MatchMakerOption) {\n        this.endpoint = options.endpoint\n        this.headers = options.headers\n        this.callback = options.callback\n    }\n\n    async getServer(player: RpgPlayer): Promise<MatchMakerResponse | null> {\n        const currentServerId = inject(RpgServerEngine).serverId\n        const payload: MatchMakerPayload = {\n            playerId: player.id,\n            mapName: player.map\n        }\n        let res = {} as MatchMakerResponse\n        if (this.callback) {\n            res = this.callback(payload)\n            if (Utils.isPromise(res)) {\n                res = await res\n            }\n        }\n        if (this.endpoint) {\n            try {\n                res = await axios.post<MatchMakerResponse>(this.endpoint, payload, {\n                    headers: this.headers\n                }).then(res => res.data)\n            }\n            catch (err) {\n                console.log('There is a problem with the MatchMaker webservice.')        \n                throw err\n            }\n        }\n        if (currentServerId == res.serverId) {\n            return null\n        }\n        return res\n    }\n}", "import { RpgCommonGame, HookServer, loadModules, ModuleType, GameSide, RpgPlugin, InjectContext } from '@rpgjs/common'\nimport { RpgServerEngine } from './server'\nimport { RpgPlayer } from './Player/Player'\nimport { RpgMatchMaker } from './MatchMaker'\nimport { inject, setInject } from './inject'\n\ninterface RpgServerEntryPointOptions {\n    /** \n    * Represents socket io but you can put something else (which is of the same scheme as socket io)\n    * \n    * @prop {SocketIO or other} io\n    * @memberof RpgServerEntryPoint\n    * */\n    io: any,\n    /** \n     * It allows you to know where the maps are located. Usually put `__dirname` for the current directory.\n     * \n     * ```ts\n     * basePath: __dirname\n     * ``` \n     * \n     * @prop {string} basePath\n     * @memberof RpgServerEntryPoint\n     * */\n    basePath: string\n\n    standalone?: boolean\n\n    /** \n   * The general configurations of the game.\n   * \n   * @prop {object} [globalConfig]\n   * @memberof RpgServerEntryPoint\n   * */\n    globalConfig?: any\n\n    workers?: any\n\n    envs?: object\n}\n\nexport default async function (modules: ModuleType[], options: RpgServerEntryPointOptions): Promise<RpgServerEngine> {\n    const context = new InjectContext()\n    setInject(context)\n\n    inject(RpgCommonGame, [GameSide.Server])\n\n    if (!options.globalConfig) options.globalConfig = {}\n\n    const relations = {\n        onConnected: HookServer.PlayerConnected,\n        onInput: HookServer.PlayerInput,\n        onJoinMap: HookServer.PlayerJoinMap,\n        onLeaveMap: HookServer.PlayerLeaveMap,\n        onLevelUp: HookServer.PlayerLevelUp,\n        onDead: HookServer.PlayerDead,\n        onDisconnected: HookServer.PlayerDisconnected,\n        onInShape: HookServer.PlayerInShape,\n        onOutShape: HookServer.PlayerOutShape,\n        onMove: HookServer.PlayerMove,\n        canChangeMap: HookServer.PlayerCanChangeMap\n    }\n\n    const relationsEngine = {\n        onStart: HookServer.Start,\n        onStep: HookServer.Step,\n        auth: HookServer.Auth\n    }\n\n    const { playerProps } = await loadModules(modules, {\n        side: 'server',\n        relations: {\n            player: relations,\n            engine: relationsEngine,\n            scalability: {\n                onConnected: HookServer.ScalabilityPlayerConnected,\n                doChangeServer: HookServer.ScalabilityChangeServer\n            }\n        }\n    }, (mod) => {\n        const { scalability } = mod\n        if (scalability) {\n            const { hooks, stateStore, matchMaker } = scalability\n            const matchMakerInstance = new RpgMatchMaker(matchMaker)\n            RpgPlugin.on(HookServer.Start, () => {\n                return stateStore.connect()\n            })\n            mod.scalability._hooks = {}\n            for (let hookName in hooks) {\n                let originalHook = mod.scalability.hooks[hookName]\n                mod.scalability._hooks[hookName] = function (player: RpgPlayer) {\n                    return originalHook(stateStore, matchMakerInstance, player)\n                }\n            }\n        }\n        return mod\n    })\n\n    const serverEngine = inject(RpgServerEngine, [\n        options.io, {\n            debug: {},\n            updateRate: 10,\n            stepRate: 60,\n            timeoutInterval: 0,\n            countConnections: false,\n            playerProps,\n            ...options\n        }\n    ])\n    return serverEngine\n}\n", "import { EventEmitter } from '@rpgjs/common'\nimport os from 'os'\n\nclass Monitor extends EventEmitter {\n    private monitors: Map<string, any> = new Map()\n    private lastTime: any\n    loopMs\n    totalConnected: number = 0\n\n    get status() {\n        return {\n            loop: this.loopMs,\n            totalConnected: this.totalConnected\n        }\n    }\n\n    getStatusOf(id) {\n        return this.monitors.get(id)\n    }\n\n    update(server) {\n        const { scheduler, options } = server\n        if (this.lastTime) {\n            const hrtime = process.hrtime(this.lastTime)\n            this.loopMs = hrtime[1] / 1e6\n        }\n        const period = scheduler.options.period\n        if (this.loopMs > period + 20) {\n            const { stepRate } = options\n            console.warn('%s - Warning Low FPS. %s players connected. Game Loop: %s FPS', new Date(), this.totalConnected, Math.round(stepRate / (this.loopMs / period)))\n        }\n        this.lastTime = process.hrtime()\n    }\n\n    addMonitor(socket) {\n        // TODO\n        /*\n        let bytesIn = 0 \n        let bytesOut = 0\n        const update = () => {\n            this.monitors.set(id, {\n                bytesIn: bytesIn.toFixed(2),\n                bytesOut: bytesOut.toFixed(2)\n            })\n        }\n        const id = socket.id\n        socket.use((packet, next) => {\n            const size = ('42'+JSON.stringify(packet)).length\n            bytesIn += size\n            update()\n            this.emit('update', this.monitors.get(id))\n            next()\n        })\n        socket._emit = socket.emit.bind(socket)\n        socket.emit = (name, data) => {\n            let size = 0\n            let obj = data\n            if (name == 'worldUpdate') {\n                obj = Object.assign({}, data)\n                size += Buffer.byteLength(obj.dataBuffer)\n                obj.dataBuffer = {_placeholder: true, num: 0}\n            }\n            size += `451-[\"${name},${JSON.stringify(obj)}\"]`.length\n            bytesOut += size\n            update()\n            return socket._emit(name, data) \n        }\n        */\n        this.totalConnected++\n    }\n\n    removeMonitor(id) {\n        this.monitors.delete(id)\n        this.totalConnected--\n    }\n}\n\nexport default new Monitor()"],
  "mappings": "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",
  "names": ["objectProto", "Symbol", "Uint8Array", "Map", "pairs", "isArray", "isFunction", "identity", "buffer", "map", "isArrayLike", "count", "merge", "obj", "msgpack", "UserState", "set", "get", "schema", "self", "key", "val", "path", "room", "Subscription", "empty", "timeout", "Subscriber", "ConsumerObserver", "SafeSubscriber", "Observable", "observable", "OperatorSubscriber", "err", "ConnectableObservable", "Observable", "timestamp", "Observable", "timestamp", "Subject", "observable", "Observable", "AnonymousSubject", "BehaviorSubject", "ReplaySubject", "last", "AsyncSubject", "Action", "delay", "timeout", "AsyncAction", "delay", "AsapAction", "delay", "Scheduler", "delay", "AsyncScheduler", "Scheduler", "AsapScheduler", "QueueAction", "delay", "QueueScheduler", "AnimationFrameAction", "delay", "AnimationFrameScheduler", "VirtualTimeScheduler", "VirtualAction", "delay", "Observable", "Observable", "process", "delay", "repeat", "delay", "delay", "Observable", "Observable", "iterator", "Observable", "iterator", "from", "of", "from", "Observable", "NotificationKind", "Notification", "of", "isArray", "Observable", "isArray", "TimeInterval", "interval", "_a", "_b", "user", "User", "merge", "merge", "merge", "ClassHooks", "merge", "merge", "merge", "merge", "merge", "Effect", "Efficiency", "applyMixins", "isString", "isString", "isInstanceOf", "applyMixins", "isArray", "isString", "isInstanceOf", "applyMixins", "applyMixins", "isString", "arrayUniq", "applyMixins", "arrayFlat", "random", "isFunction", "Frequency", "Speed", "repeat", "map", "count", "DialogPosition", "applyMixins", "max", "EventMode", "key", "map", "context", "isPromise", "applyMixins", "isString", "map", "merge", "applyMixins", "map", "map", "map", "isString", "map", "__decorate", "timestamp", "map", "players", "res", "context"]
}
