import { extensions as q, ExtensionType as J, SCALE_MODES as lt, Texture as O, groupD8 as I, DRAW_MODES as ht, Resource as ut, ALPHA_MODES as ft, Shader as dt, Program as ct, Matrix as mt, Geometry as pt, Buffer as tt, ObjectRenderer as Tt, utils as Et, BaseTexture as vt, WRAP_MODES as bt } from "@pixi/core";
import { Container as et, Bounds as gt } from "@pixi/display";
class B {
  /** @param renderer */
  constructor(t) {
    this.tileAnim = [0, 0], this.dontUseTransform = !1, this.renderer = t, this.tileAnim = [0, 0];
  }
  static registerExtension() {
    q.add({
      name: "tilemap",
      type: J.CanvasRendererPlugin,
      ref: B
    });
  }
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  static getInstance(t) {
    if (!t.plugins.tilemap)
      throw new Error("Extension not registered!");
    return t.plugins.tilemap;
  }
}
const m = {
  /** The default number of textures per tilemap in a tilemap composite. */
  TEXTURES_PER_TILEMAP: 16,
  /**
   * The width/height of each texture tile in a {@link TEXTILE_DIMEN}. This is 1024px by default.
   *
   * This should fit all tile base-textures; otherwise, {@link TextileResource} may fail to correctly
   * upload the textures togther in a tiled fashion.
   */
  TEXTILE_DIMEN: 1024,
  /**
   * The number of texture tiles per {@link TextileResource}.
   *
   * Texture tiling is disabled by default, and so this is set to `1` by default. If it is set to a
   * higher value, textures will be uploaded together in a tiled fashion.
   *
   * Since {@link TextileResource} is a dual-column format, this should be even for packing
   * efficiency. The optimal value is usually 4.
   */
  TEXTILE_UNITS: 1,
  /** The scaling mode of the combined texture tiling. */
  TEXTILE_SCALE_MODE: lt.LINEAR,
  /** This will enable 32-bit index buffers. It's useful when you have more than 16K tiles. */
  use32bitIndex: !1,
  /** Flags whether textiles should be cleared when each tile is uploaded. */
  DO_CLEAR: !0,
  // Backward compatibility
  get maxTextures() {
    return this.MAX_TEXTURES;
  },
  set maxTextures(o) {
    this.MAX_TEXTURES = o;
  },
  get boundSize() {
    return this.TEXTURE_TILE_DIMEN;
  },
  set boundSize(o) {
    this.TILE_TEXTURE_DIMEN = o;
  },
  get boundCountPerBuffer() {
    return this.TEXTILE_UNITS;
  },
  set boundCountPerBuffer(o) {
    this.TEXTILE_UNITS = o;
  }
}, xt = m;
var it = /* @__PURE__ */ ((o) => (o[o.U = 0] = "U", o[o.V = 1] = "V", o[o.X = 2] = "X", o[o.Y = 3] = "Y", o[o.TILE_WIDTH = 4] = "TILE_WIDTH", o[o.TILE_HEIGHT = 5] = "TILE_HEIGHT", o[o.ROTATE = 6] = "ROTATE", o[o.ANIM_X = 7] = "ANIM_X", o[o.ANIM_Y = 8] = "ANIM_Y", o[o.TEXTURE_INDEX = 9] = "TEXTURE_INDEX", o[o.ANIM_COUNT_X = 10] = "ANIM_COUNT_X", o[o.ANIM_COUNT_Y = 11] = "ANIM_COUNT_Y", o[o.ANIM_DIVISOR = 12] = "ANIM_DIVISOR", o[o.ALPHA = 13] = "ALPHA", o))(it || {});
const L = Object.keys(it).length / 2;
class k extends et {
  /**
   * @param tileset - The tileset to use for the tilemap. This can be reset later with {@link Tilemap.setTileset}. The
   *      base-textures in this array must not be duplicated.
   */
  constructor(t) {
    super(), this.shadowColor = new Float32Array([0, 0, 0, 0.5]), this._globalMat = null, this.tileAnim = null, this.modificationMarker = 0, this.offsetX = 0, this.offsetY = 0, this.compositeParent = !1, this.tilemapBounds = new gt(), this.hasAnimatedTile = !1, this.pointsBuf = [], this.renderCanvas = (e) => {
      const i = B.getInstance(e);
      if (i && !i.dontUseTransform) {
        const s = this.worldTransform;
        e.canvasContext.activeContext.setTransform(
          s.a,
          s.b,
          s.c,
          s.d,
          s.tx * e.resolution,
          s.ty * e.resolution
        );
      }
      this.renderCanvasCore(e);
    }, this.vbId = 0, this.vb = null, this.vbBuffer = null, this.vbArray = null, this.vbInts = null, this.setTileset(t);
  }
  /**
   * @returns The tileset of this tilemap.
   */
  getTileset() {
    return this.tileset;
  }
  /**
   * Define the tileset used by the tilemap.
   *
   * @param tileset - The list of textures to use in the tilemap. If a base-texture (not array) is passed, it will
   *  be wrapped into an array. This should not contain any duplicates.
   */
  setTileset(t = []) {
    Array.isArray(t) || (t = [t]);
    for (let e = 0; e < t.length; e++)
      t[e].baseTexture && (t[e] = t[e].baseTexture);
    return this.tileset = t, this;
  }
  /**  Clears all the tiles added into this tilemap. */
  clear() {
    return this.pointsBuf.length = 0, this.modificationMarker = 0, this.tilemapBounds.clear(), this.hasAnimatedTile = !1, this;
  }
  /**
   * Adds a tile that paints the given texture at (x, y).
   *
   * @param tileTexture - The tiling texture to render.
   * @param x - The local x-coordinate of the tile's position.
   * @param y - The local y-coordinate of the tile's position.
   * @param options - Additional tile options.
   * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.
   * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.
   * @param [options.tileWidth=texture.orig.width] - The local width of the tile.
   * @param [options.tileHeight=texture.orig.height] - The local height of the tile.
   * @param [options.animX=0] - For animated tiles, this is the "offset" along the x-axis for adjacent
   *      animation frame textures in the base-texture.
   * @param [options.animY=0] - For animated tiles, this is the "offset" along the y-axis for adjacent
   *      animation frames textures in the base-texture.
   * @param [options.rotate=0]
   * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures
   *      per row.
   * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures
   *      per column.
   * @param [options.animDivisor=1] - For animated tiles, this is the animation duration of each frame
   * @param [options.alpha=1] - Tile alpha
   * @return This tilemap, good for chaining.
   */
  tile(t, e, i, s = {}) {
    let a, u = -1;
    if (typeof t == "number")
      u = t, a = this.tileset[u];
    else {
      let b;
      typeof t == "string" ? b = O.from(t) : b = t;
      const X = this.tileset;
      for (let v = 0; v < X.length; v++)
        if (X[v] === b.castToBaseTexture()) {
          u = v;
          break;
        }
      "baseTexture" in b && (s.u = s.u ?? b.frame.x, s.v = s.v ?? b.frame.y, s.tileWidth = s.tileWidth ?? b.orig.width, s.tileHeight = s.tileHeight ?? b.orig.height), a = b.castToBaseTexture();
    }
    if (!a || u < 0)
      return console.error("The tile texture was not found in the tilemap tileset."), this;
    const {
      u: l = 0,
      v: h = 0,
      tileWidth: d = a.realWidth,
      tileHeight: f = a.realHeight,
      animX: p = 0,
      animY: r = 0,
      rotate: n = 0,
      animCountX: A = 1024,
      animCountY: w = 1024,
      animDivisor: C = 1,
      alpha: c = 1
    } = s, E = this.pointsBuf;
    return this.hasAnimatedTile = this.hasAnimatedTile || p > 0 || r > 0, E.push(l), E.push(h), E.push(e), E.push(i), E.push(d), E.push(f), E.push(n), E.push(p | 0), E.push(r | 0), E.push(u), E.push(A), E.push(w), E.push(C), E.push(c), this.tilemapBounds.addFramePad(e, i, e + d, i + f, 0, 0), this;
  }
  /** Changes the rotation of the last tile. */
  tileRotate(t) {
    const e = this.pointsBuf;
    e[e.length - (L - 9)] = t;
  }
  /** Changes the `animX`, `animCountX` of the last tile. */
  tileAnimX(t, e) {
    const i = this.pointsBuf;
    i[i.length - (L - 7)] = t, i[i.length - (L - 10)] = e;
  }
  /** Changes the `animY`, `animCountY` of the last tile. */
  tileAnimY(t, e) {
    const i = this.pointsBuf;
    i[i.length - (L - 8)] = t, i[i.length - (L - 11)] = e;
  }
  /** Changes the `animDivisor` value of the last tile. */
  tileAnimDivisor(t) {
    const e = this.pointsBuf;
    e[e.length - (L - 12)] = t;
  }
  tileAlpha(t) {
    const e = this.pointsBuf;
    e[e.length - (L - 13)] = t;
  }
  renderCanvasCore(t) {
    if (this.tileset.length === 0)
      return;
    const e = this.pointsBuf, i = this.tileAnim || t.plugins.tilemap && t.plugins.tilemap.tileAnim;
    t.canvasContext.activeContext.fillStyle = "#000000";
    for (let s = 0, a = e.length; s < a; s += L) {
      let u = e[
        s + 0
        /* U */
      ], l = e[
        s + 1
        /* V */
      ];
      const h = e[
        s + 2
        /* X */
      ], d = e[
        s + 3
        /* Y */
      ], f = e[
        s + 4
        /* TILE_WIDTH */
      ], p = e[
        s + 5
        /* TILE_HEIGHT */
      ];
      u += e[
        s + 7
        /* ANIM_X */
      ] * i[0], l += e[
        s + 8
        /* ANIM_Y */
      ] * i[1];
      const r = e[
        s + 9
        /* TEXTURE_INDEX */
      ], n = e[
        s + 13
        /* ALPHA */
      ];
      r >= 0 && this.tileset[r] ? (t.canvasContext.activeContext.globalAlpha = n, t.canvasContext.activeContext.drawImage(
        this.tileset[r].getDrawableSource(),
        u,
        l,
        f,
        p,
        h,
        d,
        f,
        p
      )) : (t.canvasContext.activeContext.globalAlpha = 0.5, t.canvasContext.activeContext.fillRect(h, d, f, p)), t.canvasContext.activeContext.globalAlpha = 1;
    }
  }
  destroyVb() {
    this.vb && (this.vb.destroy(), this.vb = null);
  }
  render(t) {
    const e = t.plugins.tilemap, i = e.getShader();
    t.batch.setObjectRenderer(e), this._globalMat = i.uniforms.projTransMatrix, t.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform), i.uniforms.shadowColor = this.shadowColor, i.uniforms.animationFrame = this.tileAnim || e.tileAnim, this.renderWebGLCore(t, e);
  }
  renderWebGLCore(t, e) {
    const i = this.pointsBuf;
    if (i.length === 0)
      return;
    const s = i.length / L, a = e.getShader(), u = this.tileset;
    if (u.length === 0)
      return;
    e.bindTileTextures(t, u), t.shader.bind(a, !1);
    let l = this.vb;
    l || (l = e.createVb(), this.vb = l, this.vbId = l.id, this.vbBuffer = null, this.modificationMarker = 0), e.checkIndexBuffer(s, l);
    const h = m.TEXTILE_UNITS, d = l.getBuffer("aVertexPosition"), f = s * l.vertPerQuad;
    if (f !== 0) {
      if (this.modificationMarker !== f) {
        this.modificationMarker = f;
        const p = l.stride * f;
        if (!this.vbBuffer || this.vbBuffer.byteLength < p) {
          let c = l.stride;
          for (; c < p; )
            c *= 2;
          this.vbBuffer = new ArrayBuffer(c), this.vbArray = new Float32Array(this.vbBuffer), this.vbInts = new Uint32Array(this.vbBuffer), d.update(this.vbBuffer);
        }
        const r = this.vbArray;
        let n = 0, A = 0, w = this.offsetX, C = this.offsetY;
        for (let c = 0; c < i.length; c += L) {
          if (this.compositeParent) {
            const M = i[
              c + 9
              /* TEXTURE_INDEX */
            ];
            h > 1 ? (A = M >> 2, w = this.offsetX * (M & 1), C = this.offsetY * (M >> 1 & 1)) : (A = M, w = 0, C = 0);
          }
          const b = i[
            c + 2
            /* X */
          ], X = i[
            c + 3
            /* Y */
          ], v = i[
            c + 4
            /* TILE_WIDTH */
          ], y = i[
            c + 5
            /* TILE_HEIGHT */
          ], g = i[
            c + 0
            /* U */
          ] + w, x = i[
            c + 1
            /* V */
          ] + C;
          let T = i[
            c + 6
            /* ROTATE */
          ];
          const rt = i[
            c + 7
            /* ANIM_X */
          ], nt = i[
            c + 8
            /* ANIM_Y */
          ], at = i[
            c + 10
            /* ANIM_COUNT_X */
          ] || 1024, ot = i[
            c + 11
            /* ANIM_COUNT_Y */
          ] || 1024, D = rt + at * 2048, S = nt + ot * 2048, F = i[
            c + 12
            /* ANIM_DIVISOR */
          ], Y = i[
            c + 13
            /* ALPHA */
          ];
          let P, H, U, W, V, j, G, z;
          if (T === 0)
            P = g, H = x, U = g + v, W = x, V = g + v, j = x + y, G = g, z = x + y;
          else {
            let M = v / 2, _ = y / 2;
            T % 4 !== 0 && (M = y / 2, _ = v / 2);
            const N = g + M, R = x + _;
            T = I.add(T, I.NW), P = N + M * I.uX(T), H = R + _ * I.uY(T), T = I.add(T, 2), U = N + M * I.uX(T), W = R + _ * I.uY(T), T = I.add(T, 2), V = N + M * I.uX(T), j = R + _ * I.uY(T), T = I.add(T, 2), G = N + M * I.uX(T), z = R + _ * I.uY(T);
          }
          r[n++] = b, r[n++] = X, r[n++] = P, r[n++] = H, r[n++] = g + 0.5, r[n++] = x + 0.5, r[n++] = g + v - 0.5, r[n++] = x + y - 0.5, r[n++] = D, r[n++] = S, r[n++] = A, r[n++] = F, r[n++] = Y, r[n++] = b + v, r[n++] = X, r[n++] = U, r[n++] = W, r[n++] = g + 0.5, r[n++] = x + 0.5, r[n++] = g + v - 0.5, r[n++] = x + y - 0.5, r[n++] = D, r[n++] = S, r[n++] = A, r[n++] = F, r[n++] = Y, r[n++] = b + v, r[n++] = X + y, r[n++] = V, r[n++] = j, r[n++] = g + 0.5, r[n++] = x + 0.5, r[n++] = g + v - 0.5, r[n++] = x + y - 0.5, r[n++] = D, r[n++] = S, r[n++] = A, r[n++] = F, r[n++] = Y, r[n++] = b, r[n++] = X + y, r[n++] = G, r[n++] = z, r[n++] = g + 0.5, r[n++] = x + 0.5, r[n++] = g + v - 0.5, r[n++] = x + y - 0.5, r[n++] = D, r[n++] = S, r[n++] = A, r[n++] = F, r[n++] = Y;
        }
        d.update(r);
      }
      t.geometry.bind(l, a), t.geometry.draw(ht.TRIANGLES, s * 6, 0);
    }
  }
  /**
   * @internal
   * @ignore
   */
  isModified(t) {
    return !!(this.modificationMarker !== this.pointsBuf.length || t && this.hasAnimatedTile);
  }
  /**
   * This will pull forward the modification marker.
   *
   * @internal
   * @ignore
   */
  clearModify() {
    this.modificationMarker = this.pointsBuf.length;
  }
  /** @override */
  _calculateBounds() {
    const { minX: t, minY: e, maxX: i, maxY: s } = this.tilemapBounds;
    this._bounds.addFrame(this.transform, t, e, i, s);
  }
  /** @override */
  getLocalBounds(t) {
    return this.children.length === 0 ? this.tilemapBounds.getRectangle(t) : super.getLocalBounds.call(this, t);
  }
  /** @override */
  destroy(t) {
    super.destroy(t), this.destroyVb();
  }
  /**
   * Deprecated signature for {@link Tilemap.tile tile}.
   *
   * @deprecated Since @pixi/tilemap 3.
   */
  addFrame(t, e, i, s, a) {
    return this.tile(
      t,
      e,
      i,
      {
        animX: s,
        animY: a
      }
    ), !0;
  }
  /**
   * Deprecated signature for {@link Tilemap.tile tile}.
   *
   * @deprecated Since @pixi/tilemap 3.
   */
  // eslint-disable-next-line max-params
  addRect(t, e, i, s, a, u, l, h = 0, d = 0, f = 0, p = 1024, r = 1024, n = 1, A = 1) {
    return this.tile(
      t,
      s,
      a,
      {
        u: e,
        v: i,
        tileWidth: u,
        tileHeight: l,
        animX: h,
        animY: d,
        rotate: f,
        animCountX: p,
        animCountY: r,
        animDivisor: n,
        alpha: A
      }
    );
  }
}
class Z extends et {
  /**
   * @param tileset - A list of tile base-textures that will be used to eagerly initialized the layered
   *  tilemaps. This is only an performance optimization, and using {@link CompositeTilemap.tile tile}
   *  will work equivalently.
   */
  constructor(t) {
    super(), this.tileAnim = null, this.lastModifiedTilemap = null, this.modificationMarker = 0, this.shadowColor = new Float32Array([0, 0, 0, 0.5]), this._globalMat = null, this.setBitmaps = this.tileset, this.tileset(t), this.texturesPerTilemap = m.TEXTURES_PER_TILEMAP;
  }
  /**
   * This will preinitialize the tilesets of the layered tilemaps.
   *
   * If used after a tilemap has been created (or a tile added), this will overwrite the tile textures of the
   * existing tilemaps. Passing the tileset to the constructor instead is the best practice.
   *
   * @param tileTextures - The list of tile textures that make up the tileset.
   */
  tileset(t) {
    t || (t = []);
    const e = this.texturesPerTilemap, i = this.children.length, s = Math.ceil(t.length / e);
    for (let a = 0; a < Math.min(i, s); a++)
      this.children[a].setTileset(
        t.slice(a * e, (a + 1) * e)
      );
    for (let a = i; a < s; a++) {
      const u = new k(t.slice(a * e, (a + 1) * e));
      u.compositeParent = !0, u.offsetX = m.TEXTILE_DIMEN, u.offsetY = m.TEXTILE_DIMEN, this.addChild(u);
    }
    return this;
  }
  /** Clears the tilemap composite. */
  clear() {
    for (let t = 0; t < this.children.length; t++)
      this.children[t].clear();
    return this.modificationMarker = 0, this;
  }
  /** Changes the rotation of the last added tile. */
  tileRotate(t) {
    return this.lastModifiedTilemap && this.lastModifiedTilemap.tileRotate(t), this;
  }
  /** Changes `animX`, `animCountX` of the last added tile. */
  tileAnimX(t, e) {
    return this.lastModifiedTilemap && this.lastModifiedTilemap.tileAnimX(t, e), this;
  }
  /** Changes `animY`, `animCountY` of the last added tile. */
  tileAnimY(t, e) {
    return this.lastModifiedTilemap && this.lastModifiedTilemap.tileAnimY(t, e), this;
  }
  /** Changes `tileAnimDivisor` value of the last added tile. */
  tileAnimDivisor(t) {
    return this.lastModifiedTilemap && this.lastModifiedTilemap.tileAnimDivisor(t), this;
  }
  /**
   * Adds a tile that paints the given tile texture at (x, y).
   *
   * @param tileTexture - The tile texture. You can pass an index into the composite tilemap as well.
   * @param x - The local x-coordinate of the tile's location.
   * @param y - The local y-coordinate of the tile's location.
   * @param options - Additional options to pass to {@link Tilemap.tile}.
   * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.
   * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.
   * @param [options.tileWidth=texture.orig.width] - The local width of the tile.
   * @param [options.tileHeight=texture.orig.height] - The local height of the tile.
   * @param [options.animX=0] - For animated tiles, this is the "offset" along the x-axis for adjacent
   *      animation frame textures in the base-texture.
   * @param [options.animY=0] - For animated tiles, this is the "offset" along the y-axis for adjacent
   *      animation frames textures in the base-texture.
   * @param [options.rotate=0]
   * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures
   *      per row.
   * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures
   *      per column.
   * @param [options.animDivisor=1] - For animated tiles, this is the animation duration each frame
   * @param [options.alpha=1] - Tile alpha
   * @return This tilemap, good for chaining.
   */
  tile(t, e, i, s = {}) {
    let a = null;
    const u = this.children;
    if (this.lastModifiedTilemap = null, typeof t == "number") {
      const l = t / this.texturesPerTilemap >> 0;
      let h = 0;
      if (a = u[l], a)
        h = t % this.texturesPerTilemap;
      else {
        if (a = u[0], !a)
          return this;
        h = 0;
      }
      a.tile(
        h,
        e,
        i,
        s
      );
    } else {
      typeof t == "string" && (t = O.from(t));
      for (let l = 0; l < u.length; l++) {
        const h = u[l], d = h.getTileset();
        for (let f = 0; f < d.length; f++)
          if (d[f] === t.baseTexture) {
            a = h;
            break;
          }
        if (a)
          break;
      }
      if (!a) {
        for (let l = u.length - 1; l >= 0; l--) {
          const h = u[l];
          if (h.getTileset().length < this.texturesPerTilemap) {
            a = h, h.getTileset().push(t.baseTexture);
            break;
          }
        }
        a || (a = new k(t.baseTexture), a.compositeParent = !0, a.offsetX = m.TEXTILE_DIMEN, a.offsetY = m.TEXTILE_DIMEN, this.addChild(a));
      }
      a.tile(
        t,
        e,
        i,
        s
      );
    }
    return this.lastModifiedTilemap = a, this;
  }
  renderCanvas(t) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
      return;
    const e = B.getInstance(t);
    if (e && !e.dontUseTransform) {
      const s = this.worldTransform;
      t.canvasContext.activeContext.setTransform(
        s.a,
        s.b,
        s.c,
        s.d,
        s.tx * t.resolution,
        s.ty * t.resolution
      );
    }
    const i = this.children;
    for (let s = 0; s < i.length; s++) {
      const a = i[s];
      a.tileAnim = this.tileAnim, a.renderCanvasCore(t);
    }
  }
  render(t) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
      return;
    const e = t.plugins.tilemap, i = e.getShader();
    t.batch.setObjectRenderer(e), this._globalMat = i.uniforms.projTransMatrix, t.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform), i.uniforms.shadowColor = this.shadowColor, i.uniforms.animationFrame = this.tileAnim || e.tileAnim, t.shader.bind(i, !1);
    const s = this.children;
    for (let a = 0; a < s.length; a++)
      s[a].renderWebGLCore(t, e);
  }
  /**
   * @internal
   * @ignore
   */
  isModified(t) {
    const e = this.children;
    if (this.modificationMarker !== e.length)
      return !0;
    for (let i = 0; i < e.length; i++)
      if (e[i].isModified(t))
        return !0;
    return !1;
  }
  /**
   * @internal
   * @ignore
   */
  clearModify() {
    const t = this.children;
    this.modificationMarker = t.length;
    for (let e = 0; e < t.length; e++)
      t[e].clearModify();
  }
  /**
   * @deprecated Since @pixi/tilemap 3.
   * @see CompositeTilemap.tile
   */
  addFrame(t, e, i, s, a, u, l, h, d) {
    return this.tile(
      t,
      e,
      i,
      {
        animX: s,
        animY: a,
        animCountX: u,
        animCountY: l,
        animDivisor: h,
        alpha: d
      }
    );
  }
  /**
   * @deprecated @pixi/tilemap 3
   * @see CompositeTilemap.tile
   */
  // eslint-disable-next-line max-params
  addRect(t, e, i, s, a, u, l, h, d, f, p, r) {
    const n = t / this.texturesPerTilemap >> 0, A = t % this.texturesPerTilemap;
    return this.children[n] && this.children[n].getTileset() ? (this.lastModifiedTilemap = this.children[n], this.lastModifiedTilemap.addRect(
      A,
      e,
      i,
      s,
      a,
      u,
      l,
      h,
      d,
      f,
      p,
      r
    )) : this.lastModifiedTilemap = null, this;
  }
  /**
   * @deprecated Since @pixi/tilemap 3.
   * @readonly
   * @see CompositeTilemap.texturesPerTilemap
   */
  get texPerChild() {
    return this.texturesPerTilemap;
  }
}
class $ extends ut {
  /**
  * @param options - This will default to the "settings" exported by @pixi/tilemap.
  * @param options.TEXTILE_DIMEN - The dimensions of each tile.
  * @param options.TEXTILE_UNITS - The number of texture tiles.
  */
  constructor(t = m) {
    super(
      t.TEXTILE_DIMEN * 2,
      t.TEXTILE_DIMEN * Math.ceil(t.TEXTILE_UNITS / 2)
    ), this.baseTexture = null, this._clearBuffer = null;
    const e = this.tiles = new Array(t.TEXTILE_UNITS);
    this.doClear = !!t.DO_CLEAR, this.tileDimen = t.TEXTILE_DIMEN;
    for (let i = 0; i < t.TEXTILE_UNITS; i++)
      e[i] = {
        dirtyId: 0,
        x: t.TEXTILE_DIMEN * (i & 1),
        y: t.TEXTILE_DIMEN * (i >> 1),
        baseTexture: O.WHITE.baseTexture
      };
  }
  /**
  * Sets the texture to be uploaded for the given tile.
  *
  * @param index - The index of the tile being set.
  * @param texture - The texture with the base-texture to upload.
  */
  tile(t, e) {
    const i = this.tiles[t];
    i.baseTexture !== e && (i.baseTexture = e, this.baseTexture.update(), this.tiles[t].dirtyId = this.baseTexture.dirtyId);
  }
  /** @override */
  bind(t) {
    if (this.baseTexture)
      throw new Error("Only one baseTexture is allowed for this resource!");
    this.baseTexture = t, super.bind(t);
  }
  /** @override */
  upload(t, e, i) {
    const { gl: s } = t, { width: a, height: u } = this;
    s.pixelStorei(
      s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
      e.alphaMode === void 0 || e.alphaMode === ft.UNPACK
    ), i.dirtyId < 0 && (i.width = a, i.height = u, s.texImage2D(
      e.target,
      0,
      e.format,
      a,
      u,
      0,
      e.format,
      e.type,
      null
    ));
    const l = this.doClear, h = this.tiles;
    l && !this._clearBuffer && (this._clearBuffer = new Uint8Array(m.TEXTILE_DIMEN * m.TEXTILE_DIMEN * 4));
    for (let d = 0; d < h.length; d++) {
      const f = h[d], p = f.baseTexture;
      if (i.dirtyId >= this.tiles[d].dirtyId)
        continue;
      const r = p.resource;
      !p.valid || !r || !r.source || (l && (p.width < this.tileDimen || p.height < this.tileDimen) && s.texSubImage2D(
        e.target,
        0,
        f.x,
        f.y,
        this.tileDimen,
        this.tileDimen,
        e.format,
        e.type,
        this._clearBuffer
      ), s.texSubImage2D(
        e.target,
        0,
        f.x,
        f.y,
        e.format,
        e.type,
        r.source
      ));
    }
    return !0;
  }
}
function It(o) {
  let t = "";
  t += `
`, t += `
`, t += "if(vTextureId <= -1.0) {", t += `
	color = shadowColor;`, t += `
}`;
  for (let e = 0; e < o; e++)
    t += `
else `, e < o - 1 && (t += `if(textureId == ${e}.0)`), t += `
{`, t += `
	color = texture2D(uSamplers[${e}], textureCoord * uSamplerSize[${e}]);`, t += `
}`;
  return t += `
`, t += `
`, t;
}
function At(o, t) {
  const e = [];
  for (let s = 0; s < t; s++)
    e[s] = s;
  o.uniforms.uSamplers = e;
  const i = [];
  for (let s = 0; s < t; s++)
    i.push(1 / 2048), i.push(1 / 2048);
  o.uniforms.uSamplerSize = i;
}
function Mt(o, t) {
  return t.replace(/%count%/gi, `${o}`).replace(/%forloop%/gi, It(o));
}
const yt = `#version 100
precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aFrame;
attribute vec2 aAnim;
attribute float aAnimDivisor;
attribute float aTextureId;
attribute float aAlpha;

uniform mat3 projTransMatrix;
uniform vec2 animationFrame;

varying vec2 vTextureCoord;
varying float vTextureId;
varying vec4 vFrame;
varying float vAlpha;

void main(void)
{
   gl_Position = vec4((projTransMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vec2 animCount = floor((aAnim + 0.5) / 2048.0);
   vec2 animFrameOffset = aAnim - animCount * 2048.0;
   vec2 currentFrame = floor(animationFrame / aAnimDivisor);
   vec2 animOffset = animFrameOffset * floor(mod(currentFrame + 0.5, animCount));

   vTextureCoord = aTextureCoord + animOffset;
   vFrame = aFrame + vec4(animOffset, animOffset);
   vTextureId = aTextureId;
   vAlpha = aAlpha;
}
`, Lt = `#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
varying vec2 vTextureCoord;
varying vec4 vFrame;
varying float vTextureId;
varying float vAlpha;
uniform vec4 shadowColor;
uniform sampler2D uSamplers[%count%];
uniform vec2 uSamplerSize[%count%];

void main(void)
{
   vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);
   float textureId = floor(vTextureId + 0.5);

   vec4 color;
   %forloop%
   gl_FragColor = color * vAlpha;
}
`;
class Q extends dt {
  constructor(t) {
    super(
      new ct(
        yt,
        Mt(t, Lt)
      ),
      {
        animationFrame: new Float32Array(2),
        uSamplers: [],
        uSamplerSize: [],
        projTransMatrix: new mt()
      }
    ), this.maxTextures = 0, this.maxTextures = t, At(this, this.maxTextures);
  }
}
class K extends pt {
  constructor() {
    super(), this.vertSize = 13, this.vertPerQuad = 4, this.stride = this.vertSize * 4, this.lastTimeAccess = 0;
    const t = this.buf = new tt(new Float32Array(2), !0, !1);
    this.addAttribute("aVertexPosition", t, 0, !1, 0, this.stride, 0).addAttribute("aTextureCoord", t, 0, !1, 0, this.stride, 2 * 4).addAttribute("aFrame", t, 0, !1, 0, this.stride, 4 * 4).addAttribute("aAnim", t, 0, !1, 0, this.stride, 8 * 4).addAttribute("aTextureId", t, 0, !1, 0, this.stride, 10 * 4).addAttribute("aAnimDivisor", t, 0, !1, 0, this.stride, 11 * 4).addAttribute("aAlpha", t, 0, !1, 0, this.stride, 12 * 4);
  }
}
class st extends Tt {
  /** @param renderer - The managing renderer */
  constructor(t) {
    super(t), this.tileAnim = [0, 0], this.ibLen = 0, this.indexBuffer = null, this.textiles = [], this.shader = new Q(m.TEXTURES_PER_TILEMAP), this.indexBuffer = new tt(void 0, !0, !0), this.checkIndexBuffer(2e3), this.makeTextiles();
  }
  /**
  * Binds the tile textures to the renderer, and updates the tilemap shader's `uSamplerSize` uniform.
  *
  * If {@link settings.TEXTILE_UNITS}
  *
  * @param renderer - The renderer to which the textures are to be bound.
  * @param textures - The tile textures being bound.
  */
  bindTileTextures(t, e) {
    const i = e.length, s = this.shader, a = m.TEXTURES_PER_TILEMAP, u = s.uniforms.uSamplerSize;
    if (!(i > m.TEXTILE_UNITS * a)) {
      if (m.TEXTILE_UNITS <= 1)
        for (let l = 0; l < e.length; l++) {
          const h = e[l];
          if (!h || !h.valid)
            return;
          t.texture.bind(e[l], l), u[l * 2] = 1 / e[l].realWidth, u[l * 2 + 1] = 1 / e[l].realHeight;
        }
      else {
        this.makeTextiles();
        const l = Math.ceil(i / m.TEXTILE_UNITS);
        for (let h = 0; h < i; h++) {
          const d = e[h];
          if (d && d.valid) {
            const f = Math.floor(h / m.TEXTILE_UNITS), p = h % m.TEXTILE_UNITS;
            this.textiles[f].tile(p, d);
          }
        }
        for (let h = 0; h < l; h++)
          t.texture.bind(this.textiles[h].baseTexture, h), u[h * 2] = 1 / this.textiles[h].width, u[h * 2 + 1] = 1 / this.textiles[h].baseTexture.height;
      }
      s.uniforms.uSamplerSize = u;
    }
  }
  start() {
  }
  /**
  * @internal
  * @ignore
  */
  createVb() {
    const t = new K();
    return t.addIndex(this.indexBuffer), t.lastTimeAccess = Date.now(), t;
  }
  /** @return The {@link TilemapShader} shader that this rendering pipeline is using. */
  getShader() {
    return this.shader;
  }
  destroy() {
    super.destroy(), this.shader = null;
  }
  // eslint-disable-next-line no-unused-vars
  checkIndexBuffer(t, e = null) {
    const i = t * 6;
    i <= this.ibLen || (this.ibLen = i, this.indexBuffer.update(Et.createIndicesForQuads(
      t,
      m.use32bitIndex ? new Uint32Array(t * 6) : void 0
    )));
  }
  /** Makes textile resources and initializes {@link TileRenderer.textiles}. */
  makeTextiles() {
    if (!(m.TEXTILE_UNITS <= 1))
      for (let t = 0; t < m.TEXTILE_UNITS; t++) {
        if (this.textiles[t])
          continue;
        const e = new $(), i = new vt(e);
        i.scaleMode = m.TEXTILE_SCALE_MODE, i.wrapMode = bt.CLAMP, this.textiles[t] = e;
      }
  }
}
const wt = {
  CanvasTileRenderer: B,
  CompositeRectTileLayer: Z,
  CompositeTilemap: Z,
  Constant: xt,
  TextileResource: $,
  MultiTextureResource: $,
  RectTileLayer: k,
  Tilemap: k,
  TilemapShader: Q,
  TilemapGeometry: K,
  RectTileShader: Q,
  RectTileGeom: K,
  TileRenderer: st
};
q.add({
  name: "tilemap",
  type: J.RendererPlugin,
  ref: st
});
export {
  B as CanvasTileRenderer,
  Z as CompositeRectTileLayer,
  Z as CompositeTilemap,
  xt as Constant,
  L as POINT_STRUCT_SIZE,
  k as RectTileLayer,
  $ as TextileResource,
  st as TileRenderer,
  k as Tilemap,
  K as TilemapGeometry,
  Q as TilemapShader,
  At as fillSamplers,
  Mt as generateFragmentSrc,
  wt as pixi_tilemap,
  m as settings
};
//# sourceMappingURL=pixi-tilemap.es.js.map
