{"version":3,"file":"pixi-tilemap.es.js","sources":["../src/CanvasTileRenderer.ts","../src/settings.ts","../src/Tilemap.ts","../src/CompositeTilemap.ts","../src/TextileResource.ts","../src/shaderGenerator.ts","../src/TilemapShader.ts","../src/TileRenderer.ts","../src/index.ts"],"sourcesContent":["import { extensions, ExtensionType, IRenderer } from '@pixi/core';\r\n\r\n/**\r\n * The renderer plugin for canvas. It isn't registered by default.\r\n *\r\n * ```\r\n * import { CanvasTileRenderer } from '@pixi/tilemap';\r\n * import { CanvasRenderer } from '@pixi/canvas-core';\r\n *\r\n * // You must register this yourself (optional). @pixi/tilemap doesn't do it to\r\n * // prevent a hard dependency on @pixi/canvas-core.\r\n * CanvasTileRenderer.registerExtension();\r\n * ```\r\n */\r\n// TODO: Move to @pixi/tilemap-canvas\r\nexport class CanvasTileRenderer\r\n{\r\n    /** The renderer */\r\n    renderer: IRenderer;\r\n\r\n    /** The global tile animation state */\r\n    tileAnim = [0, 0];\r\n\r\n    /** @deprecated */\r\n    dontUseTransform = false;\r\n\r\n    /** @param renderer */\r\n    constructor(renderer: IRenderer)\r\n    {\r\n        this.renderer = renderer;\r\n        this.tileAnim = [0, 0];\r\n    }\r\n\r\n    static registerExtension()\r\n    {\r\n        extensions.add({\r\n            name: 'tilemap',\r\n            type: ExtensionType.CanvasRendererPlugin,\r\n            ref: CanvasTileRenderer as any\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    static getInstance(renderer: any): CanvasTileRenderer\r\n    {\r\n        if (!renderer.plugins.tilemap)\r\n        {\r\n            throw new Error('Extension not registered!');\r\n        }\r\n\r\n        return renderer.plugins.tilemap;\r\n    }\r\n}\r\n","import { SCALE_MODES } from '@pixi/core';\r\n\r\n/**\r\n * These are additional @pixi/tilemap options.\r\n *\r\n * This settings should not be changed after the renderer has initialized; otherwise, the behavior\r\n * is undefined.\r\n */\r\nexport const settings = {\r\n    /** The default number of textures per tilemap in a tilemap composite. */\r\n    TEXTURES_PER_TILEMAP: 16,\r\n\r\n    /**\r\n     * The width/height of each texture tile in a {@link TEXTILE_DIMEN}. This is 1024px by default.\r\n     *\r\n     * This should fit all tile base-textures; otherwise, {@link TextileResource} may fail to correctly\r\n     * upload the textures togther in a tiled fashion.\r\n     */\r\n    TEXTILE_DIMEN: 1024,\r\n\r\n    /**\r\n     * The number of texture tiles per {@link TextileResource}.\r\n     *\r\n     * Texture tiling is disabled by default, and so this is set to `1` by default. If it is set to a\r\n     * higher value, textures will be uploaded together in a tiled fashion.\r\n     *\r\n     * Since {@link TextileResource} is a dual-column format, this should be even for packing\r\n     * efficiency. The optimal value is usually 4.\r\n     */\r\n    TEXTILE_UNITS: 1,\r\n\r\n    /** The scaling mode of the combined texture tiling. */\r\n    TEXTILE_SCALE_MODE: SCALE_MODES.LINEAR,\r\n\r\n    /** This will enable 32-bit index buffers. It's useful when you have more than 16K tiles. */\r\n    use32bitIndex: false,\r\n\r\n    /** Flags whether textiles should be cleared when each tile is uploaded. */\r\n    DO_CLEAR: true,\r\n\r\n    // Backward compatibility\r\n    get maxTextures(): number { return this.MAX_TEXTURES; },\r\n    set maxTextures(value: number) { this.MAX_TEXTURES = value; },\r\n\r\n    get boundSize(): number { return this.TEXTURE_TILE_DIMEN; },\r\n    set boundSize(value: number) { this.TILE_TEXTURE_DIMEN = value; },\r\n\r\n    get boundCountPerBuffer(): number { return this.TEXTILE_UNITS; },\r\n    set boundCountPerBuffer(value: number) { this.TEXTILE_UNITS = value; },\r\n};\r\n\r\n// @deprecated\r\nexport const Constant = settings;\r\n","/* eslint-disable no-unused-vars */\r\nimport { Container, Bounds } from '@pixi/display';\r\nimport { Texture, Renderer, Matrix, Rectangle, groupD8, DRAW_MODES } from '@pixi/core';\r\nimport { TileRenderer } from './TileRenderer';\r\nimport { settings } from './settings';\r\nimport { CanvasTileRenderer } from './CanvasTileRenderer';\r\n\r\nimport type { BaseTexture } from '@pixi/core';\r\nimport type { IDestroyOptions } from '@pixi/display';\r\nimport type { TilemapGeometry } from './TilemapShader';\r\n\r\nenum POINT_STRUCT\r\n    {\r\n    U,\r\n    V,\r\n    X,\r\n    Y,\r\n    TILE_WIDTH,\r\n    TILE_HEIGHT,\r\n    ROTATE,\r\n    ANIM_X,\r\n    ANIM_Y,\r\n    TEXTURE_INDEX,\r\n    ANIM_COUNT_X,\r\n    ANIM_COUNT_Y,\r\n    ANIM_DIVISOR,\r\n    ALPHA,\r\n}\r\n\r\nexport const POINT_STRUCT_SIZE = (Object.keys(POINT_STRUCT).length / 2);\r\n\r\n/**\r\n * A rectangular tilemap implementation that renders a predefined set of tile textures.\r\n *\r\n * The {@link Tilemap.tileset tileset} of a tilemap defines the list of base-textures that can be painted in the\r\n * tilemap. A texture is identified using its base-texture's index into the this list, i.e. changing the base-texture\r\n * at a given index in the tileset modifies the paint of all tiles pointing to that index.\r\n *\r\n * The size of the tileset is limited by the texture units supported by the client device. The minimum supported\r\n * value is 8, as defined by the WebGL 1 specification. `gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS`) can be used\r\n * to extract this limit. {@link CompositeTilemap} can be used to get around this limit by layering multiple tilemap\r\n * instances.\r\n *\r\n * @example\r\n * import { Tilemap } from '@pixi/tilemap';\r\n * import { Loader } from '@pixi/loaders';\r\n *\r\n * // Add the spritesheet into your loader!\r\n * Loader.shared.add('atlas', 'assets/atlas.json');\r\n *\r\n * // Make the tilemap once the tileset assets are available.\r\n * Loader.shared.load(function onTilesetLoaded()\r\n * {\r\n *      // The base-texture is shared between all the tile textures.\r\n *      const tilemap = new Tilemap([Texture.from('grass.png').baseTexture])\r\n *          .tile('grass.png', 0, 0)\r\n *          .tile('grass.png', 100, 100)\r\n *          .tile('brick_wall.png', 0, 100);\r\n * });\r\n */\r\nexport class Tilemap extends Container\r\n{\r\n    shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\r\n    _globalMat: Matrix = null;\r\n\r\n    /**\r\n     * The tile animation frame.\r\n     *\r\n     * @see CompositeTilemap.tileAnim\r\n     */\r\n    public tileAnim: [number, number] = null;\r\n\r\n    /**\r\n     * This is the last uploaded size of the tilemap geometry.\r\n     * @ignore\r\n     */\r\n    modificationMarker = 0;\r\n\r\n    /** @ignore */\r\n    offsetX = 0;\r\n\r\n    /** @ignore */\r\n    offsetY = 0;\r\n\r\n    /** @ignore */\r\n    compositeParent = false;\r\n\r\n    /**\r\n     * The list of base-textures being used in the tilemap.\r\n     *\r\n     * This should not be shuffled after tiles have been added into this tilemap. Usually, only tile textures\r\n     * should be added after tiles have been added into the map.\r\n     */\r\n    protected tileset: Array<BaseTexture>;\r\n\r\n    /**\r\n     * The local bounds of the tilemap itself. This does not include DisplayObject children.\r\n     */\r\n    protected readonly tilemapBounds = new Bounds();\r\n\r\n    /** Flags whether any animated tile was added. */\r\n    protected hasAnimatedTile = false;\r\n\r\n    /** The interleaved geometry of the tilemap. */\r\n    private pointsBuf: Array<number> = [];\r\n\r\n    /**\r\n     * @param tileset - The tileset to use for the tilemap. This can be reset later with {@link Tilemap.setTileset}. The\r\n     *      base-textures in this array must not be duplicated.\r\n     */\r\n    constructor(tileset: BaseTexture | Array<BaseTexture>)\r\n    {\r\n        super();\r\n        this.setTileset(tileset);\r\n    }\r\n\r\n    /**\r\n     * @returns The tileset of this tilemap.\r\n     */\r\n    getTileset(): Array<BaseTexture>\r\n    {\r\n        return this.tileset;\r\n    }\r\n\r\n    /**\r\n     * Define the tileset used by the tilemap.\r\n     *\r\n     * @param tileset - The list of textures to use in the tilemap. If a base-texture (not array) is passed, it will\r\n     *  be wrapped into an array. This should not contain any duplicates.\r\n     */\r\n    setTileset(tileset: BaseTexture | Array<BaseTexture> = []): this\r\n    {\r\n        if (!Array.isArray(tileset))\r\n        {\r\n            tileset = [tileset];\r\n        }\r\n        for (let i = 0; i < tileset.length; i++)\r\n        {\r\n            if ((tileset[i] as unknown as Texture).baseTexture)\r\n            {\r\n                tileset[i] = (tileset[i] as unknown as Texture).baseTexture;\r\n            }\r\n        }\r\n\r\n        this.tileset = tileset;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**  Clears all the tiles added into this tilemap. */\r\n    clear(): this\r\n    {\r\n        this.pointsBuf.length = 0;\r\n        this.modificationMarker = 0;\r\n        this.tilemapBounds.clear();\r\n        this.hasAnimatedTile = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a tile that paints the given texture at (x, y).\r\n     *\r\n     * @param tileTexture - The tiling texture to render.\r\n     * @param x - The local x-coordinate of the tile's position.\r\n     * @param y - The local y-coordinate of the tile's position.\r\n     * @param options - Additional tile options.\r\n     * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\r\n     * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\r\n     * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\r\n     * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\r\n     * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\r\n     *      animation frame textures in the base-texture.\r\n     * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\r\n     *      animation frames textures in the base-texture.\r\n     * @param [options.rotate=0]\r\n     * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per row.\r\n     * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per column.\r\n     * @param [options.animDivisor=1] - For animated tiles, this is the animation duration of each frame\r\n     * @param [options.alpha=1] - Tile alpha\r\n     * @return This tilemap, good for chaining.\r\n     */\r\n    tile(\r\n        tileTexture: number | string | Texture | BaseTexture,\r\n        x: number,\r\n        y: number,\r\n        options: {\r\n            u?: number,\r\n            v?: number,\r\n            tileWidth?: number,\r\n            tileHeight?: number,\r\n            animX?: number,\r\n            animY?: number,\r\n            rotate?: number,\r\n            animCountX?: number,\r\n            animCountY?: number,\r\n            animDivisor?: number,\r\n            alpha?: number,\r\n        } = {}\r\n    ): this\r\n    {\r\n        let baseTexture: BaseTexture;\r\n        let textureIndex = -1;\r\n\r\n        if (typeof tileTexture === 'number')\r\n        {\r\n            textureIndex = tileTexture;\r\n            baseTexture = this.tileset[textureIndex];\r\n        }\r\n        else\r\n        {\r\n            let texture: Texture | BaseTexture;\r\n\r\n            if (typeof tileTexture === 'string')\r\n            {\r\n                texture = Texture.from(tileTexture);\r\n            }\r\n            else\r\n            {\r\n                texture = tileTexture;\r\n            }\r\n\r\n            const textureList = this.tileset;\r\n\r\n            for (let i = 0; i < textureList.length; i++)\r\n            {\r\n                if (textureList[i] === texture.castToBaseTexture())\r\n                {\r\n                    textureIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if ('baseTexture' in texture)\r\n            {\r\n                options.u = options.u ?? texture.frame.x;\r\n                options.v = options.v ?? texture.frame.y;\r\n                options.tileWidth = options.tileWidth ?? texture.orig.width;\r\n                options.tileHeight = options.tileHeight ?? texture.orig.height;\r\n            }\r\n\r\n            baseTexture = texture.castToBaseTexture();\r\n        }\r\n\r\n        if (!baseTexture || textureIndex < 0)\r\n        {\r\n            console.error('The tile texture was not found in the tilemap tileset.');\r\n\r\n            return this;\r\n        }\r\n\r\n        const {\r\n            u = 0,\r\n            v = 0,\r\n            tileWidth = baseTexture.realWidth,\r\n            tileHeight = baseTexture.realHeight,\r\n            animX = 0,\r\n            animY = 0,\r\n            rotate = 0,\r\n            animCountX = 1024,\r\n            animCountY = 1024,\r\n            animDivisor = 1,\r\n            alpha = 1,\r\n        } = options;\r\n\r\n        const pb = this.pointsBuf;\r\n\r\n        this.hasAnimatedTile = this.hasAnimatedTile || animX > 0 || animY > 0;\r\n\r\n        pb.push(u);\r\n        pb.push(v);\r\n        pb.push(x);\r\n        pb.push(y);\r\n        pb.push(tileWidth);\r\n        pb.push(tileHeight);\r\n        pb.push(rotate);\r\n        pb.push(animX | 0);\r\n        pb.push(animY | 0);\r\n        pb.push(textureIndex);\r\n        pb.push(animCountX);\r\n        pb.push(animCountY);\r\n        pb.push(animDivisor);\r\n        pb.push(alpha);\r\n\r\n        this.tilemapBounds.addFramePad(x, y, x + tileWidth, y + tileHeight, 0, 0);\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes the rotation of the last tile. */\r\n    tileRotate(rotate: number): void\r\n    {\r\n        const pb = this.pointsBuf;\r\n\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.TEXTURE_INDEX)] = rotate;\r\n    }\r\n\r\n    /** Changes the `animX`, `animCountX` of the last tile. */\r\n    tileAnimX(offset: number, count: number): void\r\n    {\r\n        const pb = this.pointsBuf;\r\n\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_X)] = offset;\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_X)] = count;\r\n        // pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = duration;\r\n    }\r\n\r\n    /** Changes the `animY`, `animCountY` of the last tile. */\r\n    tileAnimY(offset: number, count: number): void\r\n    {\r\n        const pb = this.pointsBuf;\r\n\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_Y)] = offset;\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_Y)] = count;\r\n    }\r\n\r\n    /** Changes the `animDivisor` value of the last tile. */\r\n    tileAnimDivisor(divisor: number): void\r\n    {\r\n        const pb = this.pointsBuf;\r\n\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = divisor;\r\n    }\r\n\r\n    tileAlpha(alpha: number): void\r\n    {\r\n        const pb = this.pointsBuf;\r\n\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ALPHA)] = alpha;\r\n    }\r\n\r\n    renderCanvas = (renderer: any): void =>\r\n    {\r\n        const plugin = CanvasTileRenderer.getInstance(renderer);\r\n\r\n        if (plugin && !plugin.dontUseTransform)\r\n        {\r\n            const wt = this.worldTransform;\r\n\r\n            renderer.canvasContext.activeContext.setTransform(\r\n                wt.a,\r\n                wt.b,\r\n                wt.c,\r\n                wt.d,\r\n                wt.tx * renderer.resolution,\r\n                wt.ty * renderer.resolution\r\n            );\r\n        }\r\n\r\n        this.renderCanvasCore(renderer);\r\n    };\r\n\r\n    renderCanvasCore(renderer: any): void\r\n    {\r\n        if (this.tileset.length === 0) return;\r\n        const points = this.pointsBuf;\r\n        const tileAnim = this.tileAnim || (renderer.plugins.tilemap && renderer.plugins.tilemap.tileAnim);\r\n\r\n        renderer.canvasContext.activeContext.fillStyle = '#000000';\r\n        for (let i = 0, n = points.length; i < n; i += POINT_STRUCT_SIZE)\r\n        {\r\n            let x1 = points[i + POINT_STRUCT.U];\r\n            let y1 = points[i + POINT_STRUCT.V];\r\n            const x2 = points[i + POINT_STRUCT.X];\r\n            const y2 = points[i + POINT_STRUCT.Y];\r\n            const w = points[i + POINT_STRUCT.TILE_WIDTH];\r\n            const h = points[i + POINT_STRUCT.TILE_HEIGHT];\r\n\r\n            x1 += points[i + POINT_STRUCT.ANIM_X] * tileAnim[0];\r\n            y1 += points[i + POINT_STRUCT.ANIM_Y] * tileAnim[1];\r\n\r\n            const textureIndex = points[i + POINT_STRUCT.TEXTURE_INDEX];\r\n            const alpha = points[i + POINT_STRUCT.ALPHA];\r\n\r\n            // canvas does not work with rotate yet\r\n\r\n            if (textureIndex >= 0 && this.tileset[textureIndex])\r\n            {\r\n                renderer.canvasContext.activeContext.globalAlpha = alpha;\r\n                renderer.canvasContext.activeContext.drawImage(\r\n                    (this.tileset[textureIndex] as any).getDrawableSource(),\r\n                    x1, y1, w, h, x2, y2, w, h\r\n                );\r\n            }\r\n            else\r\n            {\r\n                renderer.canvasContext.activeContext.globalAlpha = 0.5;\r\n                renderer.canvasContext.activeContext.fillRect(x2, y2, w, h);\r\n            }\r\n            renderer.canvasContext.activeContext.globalAlpha = 1;\r\n        }\r\n    }\r\n\r\n    private vbId = 0;\r\n    private vb: TilemapGeometry = null;\r\n    private vbBuffer: ArrayBuffer = null;\r\n    private vbArray: Float32Array = null;\r\n    private vbInts: Uint32Array = null;\r\n\r\n    private destroyVb(): void\r\n    {\r\n        if (this.vb)\r\n        {\r\n            this.vb.destroy();\r\n            this.vb = null;\r\n        }\r\n    }\r\n\r\n    render(renderer: Renderer): void\r\n    {\r\n        const plugin = (renderer.plugins as any).tilemap;\r\n        const shader = plugin.getShader();\r\n\r\n        renderer.batch.setObjectRenderer(plugin);\r\n        this._globalMat = shader.uniforms.projTransMatrix;\r\n        renderer\r\n            .globalUniforms\r\n            .uniforms\r\n            .projectionMatrix\r\n            .copyTo(this._globalMat)\r\n            .append(this.worldTransform);\r\n\r\n        shader.uniforms.shadowColor = this.shadowColor;\r\n        shader.uniforms.animationFrame = this.tileAnim || plugin.tileAnim;\r\n\r\n        this.renderWebGLCore(renderer, plugin);\r\n    }\r\n\r\n    renderWebGLCore(renderer: Renderer, plugin: TileRenderer): void\r\n    {\r\n        const points = this.pointsBuf;\r\n\r\n        if (points.length === 0) return;\r\n        const rectsCount = points.length / POINT_STRUCT_SIZE;\r\n\r\n        const shader = plugin.getShader();\r\n        const textures = this.tileset;\r\n\r\n        if (textures.length === 0) return;\r\n\r\n        plugin.bindTileTextures(renderer, textures);\r\n        renderer.shader.bind(shader, false);\r\n\r\n        // lost context! recover!\r\n        let vb = this.vb;\r\n\r\n        if (!vb)\r\n        {\r\n            vb = plugin.createVb();\r\n            this.vb = vb;\r\n            this.vbId = (vb as any).id;\r\n            this.vbBuffer = null;\r\n            this.modificationMarker = 0;\r\n        }\r\n\r\n        plugin.checkIndexBuffer(rectsCount, vb);\r\n        const boundCountPerBuffer = settings.TEXTILE_UNITS;\r\n\r\n        const vertexBuf = vb.getBuffer('aVertexPosition');\r\n        // if layer was changed, re-upload vertices\r\n        const vertices = rectsCount * vb.vertPerQuad;\r\n\r\n        if (vertices === 0) return;\r\n        if (this.modificationMarker !== vertices)\r\n        {\r\n            this.modificationMarker = vertices;\r\n            const vs = vb.stride * vertices;\r\n\r\n            if (!this.vbBuffer || this.vbBuffer.byteLength < vs)\r\n            {\r\n                // !@#$ happens, need resize\r\n                let bk = vb.stride;\r\n\r\n                while (bk < vs)\r\n                {\r\n                    bk *= 2;\r\n                }\r\n                this.vbBuffer = new ArrayBuffer(bk);\r\n                this.vbArray = new Float32Array(this.vbBuffer);\r\n                this.vbInts = new Uint32Array(this.vbBuffer);\r\n                vertexBuf.update(this.vbBuffer);\r\n            }\r\n\r\n            const arr = this.vbArray;\r\n            // const ints = this.vbInts;\r\n            // upload vertices!\r\n            let sz = 0;\r\n            // let tint = 0xffffffff;\r\n            let textureId = 0;\r\n            let shiftU: number = this.offsetX;\r\n            let shiftV: number = this.offsetY;\r\n\r\n            // let tint = 0xffffffff;\r\n            // const tint = -1;\r\n\r\n            for (let i = 0; i < points.length; i += POINT_STRUCT_SIZE)\r\n            {\r\n                const eps = 0.5;\r\n\r\n                if (this.compositeParent)\r\n                {\r\n                    const textureIndex = points[i + POINT_STRUCT.TEXTURE_INDEX];\r\n\r\n                    if (boundCountPerBuffer > 1)\r\n                    {\r\n                        // TODO: what if its more than 4?\r\n                        textureId = (textureIndex >> 2);\r\n                        shiftU = this.offsetX * (textureIndex & 1);\r\n                        shiftV = this.offsetY * ((textureIndex >> 1) & 1);\r\n                    }\r\n                    else\r\n                    {\r\n                        textureId = textureIndex;\r\n                        shiftU = 0;\r\n                        shiftV = 0;\r\n                    }\r\n                }\r\n                const x = points[i + POINT_STRUCT.X];\r\n                const y = points[i + POINT_STRUCT.Y];\r\n                const w = points[i + POINT_STRUCT.TILE_WIDTH];\r\n                const h = points[i + POINT_STRUCT.TILE_HEIGHT];\r\n                const u = points[i + POINT_STRUCT.U] + shiftU;\r\n                const v = points[i + POINT_STRUCT.V] + shiftV;\r\n                let rotate = points[i + POINT_STRUCT.ROTATE];\r\n\r\n                const animX = points[i + POINT_STRUCT.ANIM_X];\r\n                const animY = points[i + POINT_STRUCT.ANIM_Y];\r\n                const animWidth = points[i + POINT_STRUCT.ANIM_COUNT_X] || 1024;\r\n                const animHeight = points[i + POINT_STRUCT.ANIM_COUNT_Y] || 1024;\r\n\r\n                const animXEncoded = animX + (animWidth * 2048);\r\n                const animYEncoded = animY + (animHeight * 2048);\r\n                const animDivisor = points[i + POINT_STRUCT.ANIM_DIVISOR];\r\n                const alpha = points[i + POINT_STRUCT.ALPHA];\r\n\r\n                let u0: number;\r\n                let v0: number; let u1: number;\r\n                let v1: number; let u2: number;\r\n                let v2: number; let u3: number;\r\n                let v3: number;\r\n\r\n                if (rotate === 0)\r\n                {\r\n                    u0 = u;\r\n                    v0 = v;\r\n                    u1 = u + w;\r\n                    v1 = v;\r\n                    u2 = u + w;\r\n                    v2 = v + h;\r\n                    u3 = u;\r\n                    v3 = v + h;\r\n                }\r\n                else\r\n                {\r\n                    let w2 = w / 2;\r\n                    let h2 = h / 2;\r\n\r\n                    if (rotate % 4 !== 0)\r\n                    {\r\n                        w2 = h / 2;\r\n                        h2 = w / 2;\r\n                    }\r\n                    const cX = u + w2;\r\n                    const cY = v + h2;\r\n\r\n                    rotate = groupD8.add(rotate, groupD8.NW);\r\n                    u0 = cX + (w2 * groupD8.uX(rotate));\r\n                    v0 = cY + (h2 * groupD8.uY(rotate));\r\n\r\n                    rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\r\n                    u1 = cX + (w2 * groupD8.uX(rotate));\r\n                    v1 = cY + (h2 * groupD8.uY(rotate));\r\n\r\n                    rotate = groupD8.add(rotate, 2);\r\n                    u2 = cX + (w2 * groupD8.uX(rotate));\r\n                    v2 = cY + (h2 * groupD8.uY(rotate));\r\n\r\n                    rotate = groupD8.add(rotate, 2);\r\n                    u3 = cX + (w2 * groupD8.uX(rotate));\r\n                    v3 = cY + (h2 * groupD8.uY(rotate));\r\n                }\r\n\r\n                arr[sz++] = x;\r\n                arr[sz++] = y;\r\n                arr[sz++] = u0;\r\n                arr[sz++] = v0;\r\n                arr[sz++] = u + eps;\r\n                arr[sz++] = v + eps;\r\n                arr[sz++] = u + w - eps;\r\n                arr[sz++] = v + h - eps;\r\n                arr[sz++] = animXEncoded;\r\n                arr[sz++] = animYEncoded;\r\n                arr[sz++] = textureId;\r\n                arr[sz++] = animDivisor;\r\n                arr[sz++] = alpha;\r\n\r\n                arr[sz++] = x + w;\r\n                arr[sz++] = y;\r\n                arr[sz++] = u1;\r\n                arr[sz++] = v1;\r\n                arr[sz++] = u + eps;\r\n                arr[sz++] = v + eps;\r\n                arr[sz++] = u + w - eps;\r\n                arr[sz++] = v + h - eps;\r\n                arr[sz++] = animXEncoded;\r\n                arr[sz++] = animYEncoded;\r\n                arr[sz++] = textureId;\r\n                arr[sz++] = animDivisor;\r\n                arr[sz++] = alpha;\r\n\r\n                arr[sz++] = x + w;\r\n                arr[sz++] = y + h;\r\n                arr[sz++] = u2;\r\n                arr[sz++] = v2;\r\n                arr[sz++] = u + eps;\r\n                arr[sz++] = v + eps;\r\n                arr[sz++] = u + w - eps;\r\n                arr[sz++] = v + h - eps;\r\n                arr[sz++] = animXEncoded;\r\n                arr[sz++] = animYEncoded;\r\n                arr[sz++] = textureId;\r\n                arr[sz++] = animDivisor;\r\n                arr[sz++] = alpha;\r\n\r\n                arr[sz++] = x;\r\n                arr[sz++] = y + h;\r\n                arr[sz++] = u3;\r\n                arr[sz++] = v3;\r\n                arr[sz++] = u + eps;\r\n                arr[sz++] = v + eps;\r\n                arr[sz++] = u + w - eps;\r\n                arr[sz++] = v + h - eps;\r\n                arr[sz++] = animXEncoded;\r\n                arr[sz++] = animYEncoded;\r\n                arr[sz++] = textureId;\r\n                arr[sz++] = animDivisor;\r\n                arr[sz++] = alpha;\r\n            }\r\n\r\n            vertexBuf.update(arr);\r\n        }\r\n\r\n        (renderer.geometry as any).bind(vb, shader);\r\n        renderer.geometry.draw(DRAW_MODES.TRIANGLES, rectsCount * 6, 0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @ignore\r\n     */\r\n    isModified(anim: boolean): boolean\r\n    {\r\n        if (this.modificationMarker !== this.pointsBuf.length\r\n            || (anim && this.hasAnimatedTile))\r\n        {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * This will pull forward the modification marker.\r\n     *\r\n     * @internal\r\n     * @ignore\r\n     */\r\n    clearModify(): void\r\n    {\r\n        this.modificationMarker = this.pointsBuf.length;\r\n    }\r\n\r\n    /** @override */\r\n    protected _calculateBounds(): void\r\n    {\r\n        const { minX, minY, maxX, maxY } = this.tilemapBounds;\r\n\r\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\r\n    }\r\n\r\n    /** @override */\r\n    public getLocalBounds(rect?: Rectangle): Rectangle\r\n    {\r\n        // we can do a fast local bounds if the sprite has no children!\r\n        if (this.children.length === 0)\r\n        {\r\n            return this.tilemapBounds.getRectangle(rect);\r\n        }\r\n\r\n        return super.getLocalBounds.call(this, rect);\r\n    }\r\n\r\n    /** @override */\r\n    destroy(options?: IDestroyOptions): void\r\n    {\r\n        super.destroy(options);\r\n        this.destroyVb();\r\n    }\r\n\r\n    /**\r\n     * Deprecated signature for {@link Tilemap.tile tile}.\r\n     *\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     */\r\n    addFrame(texture: Texture | string | number, x: number, y: number, animX: number, animY: number): boolean\r\n    {\r\n        this.tile(\r\n            texture,\r\n            x,\r\n            y,\r\n            {\r\n                animX,\r\n                animY,\r\n            }\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Deprecated signature for {@link Tilemap.tile tile}.\r\n     *\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     */\r\n    // eslint-disable-next-line max-params\r\n    addRect(\r\n        textureIndex: number,\r\n        u: number,\r\n        v: number,\r\n        x: number,\r\n        y: number,\r\n        tileWidth: number,\r\n        tileHeight: number,\r\n        animX = 0,\r\n        animY = 0,\r\n        rotate = 0,\r\n        animCountX = 1024,\r\n        animCountY = 1024,\r\n        animDivisor = 1,\r\n        alpha = 1,\r\n    ): this\r\n    {\r\n        return this.tile(\r\n            textureIndex,\r\n            x, y,\r\n            {\r\n                u, v, tileWidth, tileHeight, animX, animY, rotate, animCountX, animCountY, animDivisor, alpha\r\n            }\r\n        );\r\n    }\r\n}\r\n","import { Container } from '@pixi/display';\r\nimport { Texture, Renderer, BaseTexture, Matrix } from '@pixi/core';\r\nimport { Tilemap } from './Tilemap';\r\nimport { settings } from './settings';\r\nimport { CanvasTileRenderer } from './CanvasTileRenderer';\r\n\r\nimport type { TileRenderer } from './TileRenderer';\r\n\r\n/**\r\n * A tilemap composite that lazily builds tilesets layered into multiple tilemaps.\r\n *\r\n * The composite tileset is the concatenatation of the individual tilesets used in the tilemaps. You can\r\n * preinitialized it by passing a list of tile textures to the constructor. Otherwise, the composite tilemap\r\n * is lazily built as you add more tiles with newer tile textures. A new tilemap is created once the last\r\n * tilemap has reached its limit (as set by {@link CompositeTilemap.texturesPerTilemap texturesPerTilemap}).\r\n *\r\n * @example\r\n * import { Application } from '@pixi/app';\r\n * import { CompositeTilemap } from '@pixi/tilemap';\r\n * import { Loader } from '@pixi/loaders';\r\n *\r\n * // Setup view & stage.\r\n * const app = new Application();\r\n *\r\n * document.body.appendChild(app.renderer.view);\r\n * app.stage.interactive = true;\r\n *\r\n * // Global reference to the tilemap.\r\n * let globalTilemap: CompositeTilemap;\r\n *\r\n * // Load the tileset spritesheet!\r\n * Loader.shared.load('atlas.json');\r\n *\r\n * // Initialize the tilemap scene when the assets load.\r\n * Loader.shared.load(function onTilesetLoaded()\r\n * {\r\n *      const tilemap = new CompositeTilemap();\r\n *\r\n *      // Setup the game level with grass and dungeons!\r\n *      for (let x = 0; x < 10; x++)\r\n *      {\r\n *          for (let y = 0; y < 10; y++)\r\n *          {\r\n *              tilemap.tile(\r\n *                  x % 2 === 0 && (x === y || x + y === 10) ? 'dungeon.png' : 'grass.png',\r\n *                  x * 100,\r\n *                  y * 100,\r\n *              );\r\n *          }\r\n *      }\r\n *\r\n *      globalTilemap = app.stage.addChild(tilemap);\r\n * });\r\n *\r\n * // Show a bomb at a random location whenever the user clicks!\r\n * app.stage.on('click', function onClick()\r\n * {\r\n *      if (!globalTilemap) return;\r\n *\r\n *      const x = Math.floor(Math.random() * 10);\r\n *      const y = Math.floor(Math.random() * 10);\r\n *\r\n *      globalTilemap.tile('bomb.png', x * 100, y * 100);\r\n * });\r\n */\r\nexport class CompositeTilemap extends Container\r\n{\r\n    /** The hard limit on the number of tile textures used in each tilemap. */\r\n    public readonly texturesPerTilemap: number;\r\n\r\n    /**\r\n     * The animation frame vector.\r\n     *\r\n     * Animated tiles have four parameters - `animX`, `animY`, `animCountX`, `animCountY`. The textures\r\n     * of adjacent animation frames are at offset `animX` or `animY` of each other, with `animCountX` per\r\n     * row and `animCountY` per column.\r\n     *\r\n     * The animation frame vector specifies which animation frame texture to use. If the x/y coordinate is\r\n     * larger than the `animCountX` or `animCountY` for a specific tile, the modulus is taken.\r\n     */\r\n    public tileAnim: [number, number] = null;\r\n\r\n    /** The last modified tilemap. */\r\n    protected lastModifiedTilemap: Tilemap = null;\r\n\r\n    private modificationMarker = 0;\r\n    private shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\r\n    private _globalMat: Matrix = null;\r\n\r\n    /**\r\n     * @param tileset - A list of tile base-textures that will be used to eagerly initialized the layered\r\n     *  tilemaps. This is only an performance optimization, and using {@link CompositeTilemap.tile tile}\r\n     *  will work equivalently.\r\n     */\r\n    constructor(tileset?: Array<BaseTexture>)\r\n    {\r\n        super();\r\n\r\n        this.tileset(tileset);\r\n        this.texturesPerTilemap = settings.TEXTURES_PER_TILEMAP;\r\n    }\r\n\r\n    /**\r\n     * This will preinitialize the tilesets of the layered tilemaps.\r\n     *\r\n     * If used after a tilemap has been created (or a tile added), this will overwrite the tile textures of the\r\n     * existing tilemaps. Passing the tileset to the constructor instead is the best practice.\r\n     *\r\n     * @param tileTextures - The list of tile textures that make up the tileset.\r\n     */\r\n    tileset(tileTextures: Array<BaseTexture>): this\r\n    {\r\n        if (!tileTextures)\r\n        {\r\n            tileTextures = [];\r\n        }\r\n\r\n        const texPerChild = this.texturesPerTilemap;\r\n        const len1 = this.children.length;\r\n        const len2 = Math.ceil(tileTextures.length / texPerChild);\r\n\r\n        for (let i = 0; i < Math.min(len1, len2); i++)\r\n        {\r\n            (this.children[i] as Tilemap).setTileset(\r\n                tileTextures.slice(i * texPerChild, (i + 1) * texPerChild)\r\n            );\r\n        }\r\n        for (let i = len1; i < len2; i++)\r\n        {\r\n            const tilemap = new Tilemap(tileTextures.slice(i * texPerChild, (i + 1) * texPerChild));\r\n\r\n            tilemap.compositeParent = true;\r\n            tilemap.offsetX = settings.TEXTILE_DIMEN;\r\n            tilemap.offsetY = settings.TEXTILE_DIMEN;\r\n\r\n            // TODO: Don't use children\r\n            this.addChild(tilemap);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Clears the tilemap composite. */\r\n    clear(): this\r\n    {\r\n        for (let i = 0; i < this.children.length; i++)\r\n        {\r\n            (this.children[i] as Tilemap).clear();\r\n        }\r\n\r\n        this.modificationMarker = 0;\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes the rotation of the last added tile. */\r\n    tileRotate(rotate: number): this\r\n    {\r\n        if (this.lastModifiedTilemap)\r\n        {\r\n            this.lastModifiedTilemap.tileRotate(rotate);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes `animX`, `animCountX` of the last added tile. */\r\n    tileAnimX(offset: number, count: number): this\r\n    {\r\n        if (this.lastModifiedTilemap)\r\n        {\r\n            this.lastModifiedTilemap.tileAnimX(offset, count);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes `animY`, `animCountY` of the last added tile. */\r\n    tileAnimY(offset: number, count: number): this\r\n    {\r\n        if (this.lastModifiedTilemap)\r\n        {\r\n            this.lastModifiedTilemap.tileAnimY(offset, count);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes `tileAnimDivisor` value of the last added tile. */\r\n    tileAnimDivisor(divisor: number): this\r\n    {\r\n        if (this.lastModifiedTilemap)\r\n        {\r\n            this.lastModifiedTilemap.tileAnimDivisor(divisor);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a tile that paints the given tile texture at (x, y).\r\n     *\r\n     * @param tileTexture - The tile texture. You can pass an index into the composite tilemap as well.\r\n     * @param x - The local x-coordinate of the tile's location.\r\n     * @param y - The local y-coordinate of the tile's location.\r\n     * @param options - Additional options to pass to {@link Tilemap.tile}.\r\n     * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\r\n     * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\r\n     * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\r\n     * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\r\n     * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\r\n     *      animation frame textures in the base-texture.\r\n     * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\r\n     *      animation frames textures in the base-texture.\r\n     * @param [options.rotate=0]\r\n     * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per row.\r\n     * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per column.\r\n     * @param [options.animDivisor=1] - For animated tiles, this is the animation duration each frame\r\n     * @param [options.alpha=1] - Tile alpha\r\n     * @return This tilemap, good for chaining.\r\n     */\r\n    tile(\r\n        tileTexture: Texture | string | number,\r\n        x: number,\r\n        y: number,\r\n        options: {\r\n            u?: number,\r\n            v?: number,\r\n            tileWidth?: number,\r\n            tileHeight?: number,\r\n            animX?: number,\r\n            animY?: number,\r\n            rotate?: number,\r\n            animCountX?: number,\r\n            animCountY?: number,\r\n            animDivisor?: number,\r\n            alpha?: number,\r\n        } = {}\r\n    ): this\r\n    {\r\n        let tilemap: Tilemap = null;\r\n        const children = this.children;\r\n\r\n        this.lastModifiedTilemap = null;\r\n\r\n        if (typeof tileTexture === 'number')\r\n        {\r\n            const childIndex = tileTexture / this.texturesPerTilemap >> 0;\r\n            let tileIndex = 0;\r\n\r\n            tilemap = children[childIndex] as Tilemap;\r\n\r\n            if (!tilemap)\r\n            {\r\n                tilemap = children[0] as Tilemap;\r\n\r\n                // Silently fail if the tilemap doesn't exist\r\n                if (!tilemap) return this;\r\n\r\n                tileIndex = 0;\r\n            }\r\n            else\r\n            {\r\n                tileIndex = tileTexture % this.texturesPerTilemap;\r\n            }\r\n\r\n            tilemap.tile(\r\n                tileIndex,\r\n                x,\r\n                y,\r\n                options,\r\n            );\r\n        }\r\n        else\r\n        {\r\n            if (typeof tileTexture === 'string')\r\n            {\r\n                tileTexture = Texture.from(tileTexture);\r\n            }\r\n\r\n            // Probe all tilemaps to find which tileset contains the base-texture.\r\n            for (let i = 0; i < children.length; i++)\r\n            {\r\n                const child = children[i] as Tilemap;\r\n                const tex = child.getTileset();\r\n\r\n                for (let j = 0; j < tex.length; j++)\r\n                {\r\n                    if (tex[j] === tileTexture.baseTexture)\r\n                    {\r\n                        tilemap = child;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (tilemap)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // If no tileset contains the base-texture, attempt to add it.\r\n            if (!tilemap)\r\n            {\r\n                // Probe the tilemaps to find one below capacity. If so, add the texture into that tilemap.\r\n                for (let i = children.length - 1; i >= 0; i--)\r\n                {\r\n                    const child = children[i] as Tilemap;\r\n\r\n                    if (child.getTileset().length < this.texturesPerTilemap)\r\n                    {\r\n                        tilemap = child;\r\n                        child.getTileset().push(tileTexture.baseTexture);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // Otherwise, create a new tilemap initialized with that tile texture.\r\n                if (!tilemap)\r\n                {\r\n                    tilemap = new Tilemap(tileTexture.baseTexture);\r\n                    tilemap.compositeParent = true;\r\n                    tilemap.offsetX = settings.TEXTILE_DIMEN;\r\n                    tilemap.offsetY = settings.TEXTILE_DIMEN;\r\n\r\n                    this.addChild(tilemap);\r\n                }\r\n            }\r\n\r\n            tilemap.tile(\r\n                tileTexture,\r\n                x,\r\n                y,\r\n                options,\r\n            );\r\n        }\r\n\r\n        this.lastModifiedTilemap = tilemap;\r\n\r\n        return this;\r\n    }\r\n\r\n    renderCanvas(renderer: any): void\r\n    {\r\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\r\n        {\r\n            return;\r\n        }\r\n\r\n        const tilemapPlugin = CanvasTileRenderer.getInstance(renderer);\r\n\r\n        if (tilemapPlugin && !tilemapPlugin.dontUseTransform)\r\n        {\r\n            const wt = this.worldTransform;\r\n\r\n            renderer.canvasContext.activeContext.setTransform(\r\n                wt.a,\r\n                wt.b,\r\n                wt.c,\r\n                wt.d,\r\n                wt.tx * renderer.resolution,\r\n                wt.ty * renderer.resolution\r\n            );\r\n        }\r\n\r\n        const layers = this.children;\r\n\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            const layer = (layers[i] as Tilemap);\r\n\r\n            layer.tileAnim = this.tileAnim;\r\n            layer.renderCanvasCore(renderer);\r\n        }\r\n    }\r\n\r\n    render(renderer: Renderer): void\r\n    {\r\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\r\n        {\r\n            return;\r\n        }\r\n\r\n        const plugin = renderer.plugins.tilemap as TileRenderer;\r\n        const shader = plugin.getShader();\r\n\r\n        renderer.batch.setObjectRenderer(plugin);\r\n\r\n        // TODO: dont create new array, please\r\n        this._globalMat = shader.uniforms.projTransMatrix;\r\n        renderer.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform);\r\n        shader.uniforms.shadowColor = this.shadowColor;\r\n        shader.uniforms.animationFrame = this.tileAnim || plugin.tileAnim;\r\n\r\n        renderer.shader.bind(shader, false);\r\n\r\n        const layers = this.children;\r\n\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            (layers[i] as Tilemap).renderWebGLCore(renderer, plugin);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @ignore\r\n     */\r\n    isModified(anim: boolean): boolean\r\n    {\r\n        const layers = this.children;\r\n\r\n        if (this.modificationMarker !== layers.length)\r\n        {\r\n            return true;\r\n        }\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            if ((layers[i] as Tilemap).isModified(anim))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @ignore\r\n     */\r\n    clearModify(): void\r\n    {\r\n        const layers = this.children;\r\n\r\n        this.modificationMarker = layers.length;\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            (layers[i] as Tilemap).clearModify();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     * @see CompositeTilemap.tile\r\n     */\r\n    addFrame(\r\n        texture: Texture | string | number,\r\n        x: number,\r\n        y: number,\r\n        animX?: number,\r\n        animY?: number,\r\n        animWidth?: number,\r\n        animHeight?: number,\r\n        animDivisor?: number,\r\n        alpha?: number\r\n    ): this\r\n    {\r\n        return this.tile(\r\n            texture,\r\n            x, y,\r\n            {\r\n                animX,\r\n                animY,\r\n                animCountX: animWidth,\r\n                animCountY: animHeight,\r\n                animDivisor,\r\n                alpha\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @deprecated @pixi/tilemap 3\r\n     * @see CompositeTilemap.tile\r\n     */\r\n    // eslint-disable-next-line max-params\r\n    addRect(\r\n        textureIndex: number,\r\n        u: number,\r\n        v: number,\r\n        x: number,\r\n        y: number,\r\n        tileWidth: number,\r\n        tileHeight: number,\r\n        animX?: number,\r\n        animY?: number,\r\n        rotate?: number,\r\n        animWidth?: number,\r\n        animHeight?: number\r\n    ): this\r\n    {\r\n        const childIndex: number = textureIndex / this.texturesPerTilemap >> 0;\r\n        const textureId: number = textureIndex % this.texturesPerTilemap;\r\n\r\n        if (this.children[childIndex] && (this.children[childIndex] as Tilemap).getTileset())\r\n        {\r\n            this.lastModifiedTilemap = (this.children[childIndex] as Tilemap);\r\n            this.lastModifiedTilemap.addRect(\r\n                textureId, u, v, x, y, tileWidth, tileHeight, animX, animY, rotate, animWidth, animHeight\r\n            );\r\n        }\r\n        else\r\n        {\r\n            this.lastModifiedTilemap = null;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Alias for {@link CompositeTilemap.tileset tileset}.\r\n     *\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     */\r\n    setBitmaps = this.tileset;\r\n\r\n    /**\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     * @readonly\r\n     * @see CompositeTilemap.texturesPerTilemap\r\n     */\r\n    get texPerChild(): number { return this.texturesPerTilemap; }\r\n}\r\n","import { BaseTexture, Renderer, Resource, Texture, GLTexture, ALPHA_MODES } from '@pixi/core';\r\nimport { settings } from './settings';\r\n\r\nexport interface TextileOptions\r\n{\r\n    TEXTILE_DIMEN: number;\r\n    TEXTILE_UNITS: number;\r\n    DO_CLEAR?: boolean;\r\n}\r\n\r\ntype TextureTile = {\r\n    dirtyId: number;\r\n    x: number;\r\n    y: number;\r\n    baseTexture: BaseTexture;\r\n};\r\n\r\n// For some reason ESLint goes mad with indendation in this file ^&^\r\n/* eslint-disable indent */\r\n\r\n/**\r\n * This texture tiling resource can be used to upload multiple base-textures together.\r\n *\r\n * This resource combines multiple base-textures into a \"textile\". They're laid out in\r\n * a dual column format, placed in row-order order. The size of each tile is predefined,\r\n * and defaults to {@link settings.TEXTILE_DIMEN}. This means that each input base-texture\r\n * must is smaller than that along both its width and height.\r\n *\r\n * @see settings.TEXTILE_UNITS\r\n */\r\nexport class TextileResource extends Resource\r\n{\r\n    /** The base-texture that contains all the texture tiles. */\r\n    public baseTexture: BaseTexture = null;\r\n\r\n    private readonly doClear: boolean;\r\n    private readonly tileDimen: number;\r\n    private readonly tiles: Array<TextureTile>;\r\n\r\n    private _clearBuffer: Uint8Array = null;\r\n\r\n    /**\r\n\t * @param options - This will default to the \"settings\" exported by @pixi/tilemap.\r\n\t * @param options.TEXTILE_DIMEN - The dimensions of each tile.\r\n\t * @param options.TEXTILE_UNITS - The number of texture tiles.\r\n\t */\r\n    constructor(options: TextileOptions = settings)\r\n    {\r\n        super(\r\n            options.TEXTILE_DIMEN * 2,\r\n            options.TEXTILE_DIMEN * Math.ceil(options.TEXTILE_UNITS / 2),\r\n        );\r\n\r\n        const tiles: TextureTile[] = this.tiles = new Array(options.TEXTILE_UNITS);\r\n\r\n        this.doClear = !!options.DO_CLEAR;\r\n        this.tileDimen = options.TEXTILE_DIMEN;\r\n\r\n        for (let j = 0; j < options.TEXTILE_UNITS; j++)\r\n        {\r\n            tiles[j] = {\r\n                dirtyId: 0,\r\n                x: options.TEXTILE_DIMEN * (j & 1),\r\n                y: options.TEXTILE_DIMEN * (j >> 1),\r\n                baseTexture: Texture.WHITE.baseTexture,\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n\t * Sets the texture to be uploaded for the given tile.\r\n\t *\r\n\t * @param index - The index of the tile being set.\r\n\t * @param texture - The texture with the base-texture to upload.\r\n\t */\r\n    tile(index: number, texture: BaseTexture): void\r\n    {\r\n        const tile = this.tiles[index];\r\n\r\n        if (tile.baseTexture === texture)\r\n        {\r\n            return;\r\n        }\r\n\r\n        tile.baseTexture = texture;\r\n        this.baseTexture.update();\r\n\r\n        this.tiles[index].dirtyId = (this.baseTexture as any).dirtyId;\r\n    }\r\n\r\n    /** @override */\r\n    bind(baseTexture: BaseTexture): void\r\n    {\r\n        if (this.baseTexture)\r\n        {\r\n            throw new Error('Only one baseTexture is allowed for this resource!');\r\n        }\r\n\r\n        this.baseTexture = baseTexture;\r\n        super.bind(baseTexture);\r\n    }\r\n\r\n    /** @override */\r\n    upload(renderer: Renderer, texture: BaseTexture, glTexture: GLTexture): boolean\r\n    {\r\n        const { gl } = renderer;\r\n        const { width, height } = this;\r\n\r\n        gl.pixelStorei(\r\n            gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,\r\n            texture.alphaMode === undefined || texture.alphaMode === ALPHA_MODES.UNPACK\r\n        );\r\n\r\n        if (glTexture.dirtyId < 0)\r\n        {\r\n            (glTexture as any).width = width;\r\n            (glTexture as any).height = height;\r\n\r\n            gl.texImage2D(texture.target, 0,\r\n                texture.format,\r\n                width,\r\n                height,\r\n                0,\r\n                texture.format,\r\n                texture.type,\r\n                null);\r\n        }\r\n\r\n        const doClear = this.doClear;\r\n        const tiles = this.tiles;\r\n\r\n        if (doClear && !this._clearBuffer)\r\n        {\r\n            this._clearBuffer = new Uint8Array(settings.TEXTILE_DIMEN * settings.TEXTILE_DIMEN * 4);\r\n        }\r\n\r\n        for (let i = 0; i < tiles.length; i++)\r\n        {\r\n            const spr = tiles[i];\r\n            const tex = spr.baseTexture;\r\n\r\n            if (glTexture.dirtyId >= this.tiles[i].dirtyId)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            const res = tex.resource as any;\r\n\r\n            if (!tex.valid || !res || !res.source)\r\n            {\r\n                continue;\r\n            }\r\n            if (doClear && (tex.width < this.tileDimen || tex.height < this.tileDimen))\r\n            {\r\n                gl.texSubImage2D(texture.target, 0,\r\n                    spr.x,\r\n                    spr.y,\r\n                    this.tileDimen,\r\n                    this.tileDimen,\r\n                    texture.format,\r\n                    texture.type,\r\n                    this._clearBuffer);\r\n            }\r\n\r\n            gl.texSubImage2D(texture.target, 0,\r\n                spr.x,\r\n                spr.y,\r\n                texture.format,\r\n                texture.type,\r\n                res.source);\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n","import type { TilemapShader } from './TilemapShader';\r\n\r\n/**\r\n * This will generate fragment shader code that samples the correct texture into the \"color\" variable.\r\n *\r\n * @internal\r\n * @ignore\r\n * @param maxTextures - The texture array length in the shader's uniforms.\r\n */\r\nfunction generateSampleSrc(maxTextures: number): string\r\n{\r\n    let src = '';\r\n\r\n    src += '\\n';\r\n    src += '\\n';\r\n\r\n    src += 'if(vTextureId <= -1.0) {';\r\n    src += '\\n\\tcolor = shadowColor;';\r\n    src += '\\n}';\r\n\r\n    for (let i = 0; i < maxTextures; i++)\r\n    {\r\n        src += '\\nelse ';\r\n\r\n        if (i < maxTextures - 1)\r\n        {\r\n            src += `if(textureId == ${i}.0)`;\r\n        }\r\n\r\n        src += '\\n{';\r\n        src += `\\n\\tcolor = texture2D(uSamplers[${i}], textureCoord * uSamplerSize[${i}]);`;\r\n        src += '\\n}';\r\n    }\r\n\r\n    src += '\\n';\r\n    src += '\\n';\r\n\r\n    return src;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * @param shader\r\n * @param maxTextures\r\n */\r\nexport function fillSamplers(shader: TilemapShader, maxTextures: number): void\r\n{\r\n    const sampleValues: Array<number> = [];\r\n\r\n    for (let i = 0; i < maxTextures; i++)\r\n    {\r\n        sampleValues[i] = i;\r\n    }\r\n\r\n    shader.uniforms.uSamplers = sampleValues;\r\n\r\n    const samplerSize: Array<number> = [];\r\n\r\n    for (let i = 0; i < maxTextures; i++)\r\n    {\r\n        // These are overwritten by TileRenderer when textures actually bound.\r\n        samplerSize.push(1.0 / 2048);\r\n        samplerSize.push(1.0 / 2048);\r\n    }\r\n\r\n    shader.uniforms.uSamplerSize = samplerSize;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * @param maxTextures\r\n * @param fragmentSrc\r\n * @returns\r\n */\r\nexport function generateFragmentSrc(maxTextures: number, fragmentSrc: string): string\r\n{\r\n    return fragmentSrc.replace(/%count%/gi, `${maxTextures}`)\r\n        .replace(/%forloop%/gi, generateSampleSrc(maxTextures));\r\n}\r\n","// eslint-disable-next-line @typescript-eslint/triple-slash-reference, spaced-comment\r\n///<reference path=\"../global.d.ts\" />\r\n\r\nimport * as shaderGenerator from './shaderGenerator';\r\n\r\nconst tilemapVertexTemplateSrc = `#version 100\r\nprecision highp float;\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aFrame;\r\nattribute vec2 aAnim;\r\nattribute float aAnimDivisor;\r\nattribute float aTextureId;\r\nattribute float aAlpha;\r\n\r\nuniform mat3 projTransMatrix;\r\nuniform vec2 animationFrame;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying float vTextureId;\r\nvarying vec4 vFrame;\r\nvarying float vAlpha;\r\n\r\nvoid main(void)\r\n{\r\n   gl_Position = vec4((projTransMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n   vec2 animCount = floor((aAnim + 0.5) / 2048.0);\r\n   vec2 animFrameOffset = aAnim - animCount * 2048.0;\r\n   vec2 currentFrame = floor(animationFrame / aAnimDivisor);\r\n   vec2 animOffset = animFrameOffset * floor(mod(currentFrame + 0.5, animCount));\r\n\r\n   vTextureCoord = aTextureCoord + animOffset;\r\n   vFrame = aFrame + vec4(animOffset, animOffset);\r\n   vTextureId = aTextureId;\r\n   vAlpha = aAlpha;\r\n}\r\n`;\r\n\r\nconst tilemapFragmentTemplateSrc = `#version 100\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vFrame;\r\nvarying float vTextureId;\r\nvarying float vAlpha;\r\nuniform vec4 shadowColor;\r\nuniform sampler2D uSamplers[%count%];\r\nuniform vec2 uSamplerSize[%count%];\r\n\r\nvoid main(void)\r\n{\r\n   vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\r\n   float textureId = floor(vTextureId + 0.5);\r\n\r\n   vec4 color;\r\n   %forloop%\r\n   gl_FragColor = color * vAlpha;\r\n}\r\n`;\r\n\r\nimport { Buffer, Geometry, Shader, Program, Matrix } from '@pixi/core';\r\n\r\n// For some reason ESLint goes mad with indendation in this file ^&^\r\n/* eslint-disable no-mixed-spaces-and-tabs, indent */\r\n\r\nexport class TilemapShader extends Shader\r\n{\r\n    maxTextures = 0;\r\n\r\n    constructor(maxTextures: number)\r\n    {\r\n\t    super(\r\n\t        new Program(\r\n                tilemapVertexTemplateSrc,\r\n                shaderGenerator.generateFragmentSrc(maxTextures, tilemapFragmentTemplateSrc)\r\n            ),\r\n\t        {\r\n\t            animationFrame: new Float32Array(2),\r\n\t            uSamplers: [],\r\n\t            uSamplerSize: [],\r\n\t            projTransMatrix: new Matrix()\r\n\t        }\r\n\t    );\r\n\r\n\t    this.maxTextures = maxTextures;\r\n\t    shaderGenerator.fillSamplers(this, this.maxTextures);\r\n    }\r\n}\r\n\r\nexport class TilemapGeometry extends Geometry\r\n{\r\n    vertSize = 13;\r\n    vertPerQuad = 4;\r\n    stride = this.vertSize * 4;\r\n    lastTimeAccess = 0;\r\n\r\n    constructor()\r\n    {\r\n\t    super();\r\n\r\n\t    const buf = this.buf = new Buffer(new Float32Array(2), true, false);\r\n\r\n\t    this.addAttribute('aVertexPosition', buf, 0, false, 0, this.stride, 0)\r\n\t        .addAttribute('aTextureCoord', buf, 0, false, 0, this.stride, 2 * 4)\r\n\t        .addAttribute('aFrame', buf, 0, false, 0, this.stride, 4 * 4)\r\n\t        .addAttribute('aAnim', buf, 0, false, 0, this.stride, 8 * 4)\r\n\t        .addAttribute('aTextureId', buf, 0, false, 0, this.stride, 10 * 4)\r\n            .addAttribute('aAnimDivisor', buf, 0, false, 0, this.stride, 11 * 4)\r\n            .addAttribute('aAlpha', buf, 0, false, 0, this.stride, 12 * 4);\r\n    }\r\n\r\n    buf: Buffer;\r\n}\r\n","import { BaseTexture, Buffer, ObjectRenderer, Renderer, utils, WRAP_MODES } from '@pixi/core';\r\nimport { settings } from './settings';\r\nimport { TilemapGeometry, TilemapShader } from './TilemapShader';\r\nimport { TextileResource } from './TextileResource';\r\n\r\n// For some reason ESLint goes mad with indendation in this file ^&^\r\n/* eslint-disable no-mixed-spaces-and-tabs, indent */\r\n\r\n/**\r\n * Rendering helper pipeline for tilemaps. This plugin is registered automatically.\r\n */\r\nexport class TileRenderer extends ObjectRenderer\r\n{\r\n    /** The managing renderer */\r\n    public readonly renderer: Renderer;\r\n\r\n    /** The tile animation frame */\r\n    public tileAnim = [0, 0];\r\n\r\n    private ibLen = 0;// index buffer length\r\n\r\n    /** The index buffer for the tilemaps to share. */\r\n    private indexBuffer: Buffer = null;\r\n\r\n    /** The shader used to render tilemaps. */\r\n    private shader: TilemapShader;\r\n\r\n    /**\r\n\t * {@link TextileResource} instances used to upload textures batched in tiled groups. This is\r\n\t * used only if {@link settings.TEXTURES_PER_TILEMAP} is greater than 1.\r\n\t */\r\n    private textiles: Array<TextileResource> = [];\r\n\r\n    /** @param renderer - The managing renderer */\r\n    constructor(renderer: Renderer)\r\n    {\r\n\t    super(renderer);\r\n\r\n\t    this.shader = new TilemapShader(settings.TEXTURES_PER_TILEMAP);\r\n\t    this.indexBuffer = new Buffer(undefined, true, true);\r\n\t    this.checkIndexBuffer(2000);\r\n\t    this.makeTextiles();\r\n    }\r\n\r\n    /**\r\n\t * Binds the tile textures to the renderer, and updates the tilemap shader's `uSamplerSize` uniform.\r\n\t *\r\n\t * If {@link settings.TEXTILE_UNITS}\r\n\t *\r\n\t * @param renderer - The renderer to which the textures are to be bound.\r\n\t * @param textures - The tile textures being bound.\r\n\t */\r\n    bindTileTextures(renderer: Renderer, textures: Array<BaseTexture>): void\r\n    {\r\n\t    const len = textures.length;\r\n        const shader = this.shader;\r\n\t    const maxTextures = settings.TEXTURES_PER_TILEMAP;\r\n        const samplerSize: Array<number> = shader.uniforms.uSamplerSize;\r\n\r\n\t    if (len > settings.TEXTILE_UNITS * maxTextures)\r\n\t    {\r\n            // TODO: Show error message instead of silently failing!\r\n\t        return;\r\n\t    }\r\n\r\n        if (settings.TEXTILE_UNITS <= 1)\r\n\t    {\r\n            // Bind each texture directly & update samplerSize.\r\n            for (let i = 0; i < textures.length; i++)\r\n            {\r\n                const texture = textures[i];\r\n\r\n                if (!texture || !texture.valid)\r\n                {\r\n                    return;\r\n                }\r\n\r\n                renderer.texture.bind(textures[i], i);\r\n\r\n                samplerSize[i * 2] = 1.0 / textures[i].realWidth;\r\n                samplerSize[(i * 2) + 1] = 1.0 / textures[i].realHeight;\r\n            }\r\n\t    }\r\n        else\r\n        {\r\n            // Ensure we have enough textiles, in case settings.TEXTILE_UNITS was modified.\r\n            this.makeTextiles();\r\n\r\n            const usedTextiles = Math.ceil(len / settings.TEXTILE_UNITS);\r\n\r\n            // First ensure each textile has all tiles point to the right textures.\r\n            for (let i = 0; i < len; i++)\r\n            {\r\n                const texture = textures[i];\r\n\r\n                if (texture && texture.valid)\r\n                {\r\n                    const resourceIndex = Math.floor(i / settings.TEXTILE_UNITS);\r\n                    const tileIndex = i % settings.TEXTILE_UNITS;\r\n\r\n                    this.textiles[resourceIndex].tile(tileIndex, texture);\r\n                }\r\n            }\r\n\r\n            // Then bind the textiles + update samplerSize.\r\n            for (let i = 0; i < usedTextiles; i++)\r\n            {\r\n                renderer.texture.bind(this.textiles[i].baseTexture, i);\r\n\r\n                samplerSize[i * 2] = 1.0 / this.textiles[i].width;\r\n                samplerSize[(i * 2) + 1] = 1.0 / this.textiles[i].baseTexture.height;\r\n            }\r\n        }\r\n\r\n        shader.uniforms.uSamplerSize = samplerSize;\r\n    }\r\n\r\n    start(): void\r\n    {\r\n\t    // sorry, nothing\r\n    }\r\n\r\n    /**\r\n\t * @internal\r\n\t * @ignore\r\n\t */\r\n    createVb(): TilemapGeometry\r\n    {\r\n\t    const geom = new TilemapGeometry();\r\n\r\n\t    geom.addIndex(this.indexBuffer);\r\n\t    geom.lastTimeAccess = Date.now();\r\n\r\n\t    return geom;\r\n    }\r\n\r\n    /** @return The {@link TilemapShader} shader that this rendering pipeline is using. */\r\n    getShader(): TilemapShader { return this.shader; }\r\n\r\n    destroy(): void\r\n    {\r\n\t    super.destroy();\r\n\t    // this.rectShader.destroy();\r\n\t    this.shader = null;\r\n    }\r\n\r\n    // eslint-disable-next-line no-unused-vars\r\n    public checkIndexBuffer(size: number, _vb: TilemapGeometry = null): void\r\n    {\r\n\t    const totalIndices = size * 6;\r\n\r\n\t    if (totalIndices <= this.ibLen)\r\n\t    {\r\n\t        return;\r\n\t    }\r\n\r\n\t    let len = totalIndices;\r\n\r\n\t    while (len < totalIndices)\r\n\t    {\r\n\t        len <<= 1;\r\n\t    }\r\n\r\n\t    this.ibLen = totalIndices;\r\n\t    this.indexBuffer.update(utils.createIndicesForQuads(size,\r\n\t        settings.use32bitIndex ? new Uint32Array(size * 6) : undefined));\r\n\r\n\t    // \tTODO: create new index buffer instead?\r\n\t    // if (vb) {\r\n\t    // \tconst curIndex = vb.getIndex();\r\n\t    // \tif (curIndex !== this.indexBuffer && (curIndex.data as any).length < totalIndices) {\r\n\t    // \t\tthis.swapIndex(vb, this.indexBuffer);\r\n\t    // \t}\r\n\t    // }\r\n    }\r\n\r\n    /** Makes textile resources and initializes {@link TileRenderer.textiles}. */\r\n    private makeTextiles(): void\r\n    {\r\n\t    if (settings.TEXTILE_UNITS <= 1)\r\n\t    {\r\n\t        return;\r\n\t    }\r\n\r\n\t    for (let i = 0; i < settings.TEXTILE_UNITS; i++)\r\n\t    {\r\n            if (this.textiles[i]) continue;\r\n\r\n            const resource = new TextileResource();\r\n\t        const baseTex = new BaseTexture(resource);\r\n\r\n\t        baseTex.scaleMode = settings.TEXTILE_SCALE_MODE;\r\n\t        baseTex.wrapMode = WRAP_MODES.CLAMP;\r\n\r\n            this.textiles[i] = resource;\r\n\t    }\r\n    }\r\n}\r\n","import { CanvasTileRenderer } from './CanvasTileRenderer';\r\nimport { CompositeTilemap } from './CompositeTilemap';\r\nimport { Constant } from './settings';\r\nimport { TextileResource } from './TextileResource';\r\nimport { Tilemap } from './Tilemap';\r\nimport { TilemapShader, TilemapGeometry } from './TilemapShader';\r\nimport { TileRenderer } from './TileRenderer';\r\n\r\n// Prevent SCALE_MODES from becoming lazy import in Constant.ts - which causes a import() in the declaration file,\r\n// which causes API extractor to fail https://github.com/microsoft/rushstack/issues/2140\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, no-unused-vars\r\nimport { extensions, ExtensionType, SCALE_MODES } from '@pixi/core';\r\n\r\n// eslint-disable-next-line camelcase\r\nexport const pixi_tilemap = {\r\n    CanvasTileRenderer,\r\n    CompositeRectTileLayer: CompositeTilemap,\r\n    CompositeTilemap,\r\n    Constant,\r\n    TextileResource,\r\n    MultiTextureResource: TextileResource,\r\n    RectTileLayer: Tilemap,\r\n    Tilemap,\r\n    TilemapShader,\r\n    TilemapGeometry,\r\n    RectTileShader: TilemapShader,\r\n    RectTileGeom: TilemapGeometry,\r\n    TileRenderer,\r\n};\r\n\r\nexport * from './CanvasTileRenderer';\r\nexport * from './CompositeTilemap';\r\nexport * from './settings';\r\nexport * from './TextileResource';\r\nexport * from './Tilemap';\r\nexport * from './TilemapShader';\r\nexport * from './shaderGenerator';\r\nexport * from './TileRenderer';\r\n\r\nexport { CompositeTilemap as CompositeRectTileLayer } from './CompositeTilemap';\r\nexport { Tilemap as RectTileLayer } from './Tilemap';\r\n\r\nextensions.add({\r\n    name: 'tilemap',\r\n    type: ExtensionType.RendererPlugin,\r\n    ref: TileRenderer as any\r\n});\r\n"],"names":["CanvasTileRenderer","renderer","extensions","ExtensionType","settings","SCALE_MODES","value","Constant","POINT_STRUCT","POINT_STRUCT2","POINT_STRUCT_SIZE","Tilemap","Container","tileset","Bounds","plugin","wt","i","tileTexture","x","y","options","baseTexture","textureIndex","texture","Texture","textureList","u","v","tileWidth","tileHeight","animX","animY","rotate","animCountX","animCountY","animDivisor","alpha","pb","offset","count","divisor","points","tileAnim","n","x1","y1","x2","y2","w","h","shader","rectsCount","textures","vb","boundCountPerBuffer","vertexBuf","vertices","vs","bk","arr","sz","textureId","shiftU","shiftV","animWidth","animHeight","animXEncoded","animYEncoded","u0","v0","u1","v1","u2","v2","u3","v3","w2","h2","cX","cY","groupD8","DRAW_MODES","anim","minX","minY","maxX","maxY","rect","CompositeTilemap","tileTextures","texPerChild","len1","len2","tilemap","children","childIndex","tileIndex","child","tex","j","tilemapPlugin","layers","layer","TextileResource","Resource","tiles","index","tile","glTexture","gl","width","height","ALPHA_MODES","doClear","spr","res","generateSampleSrc","maxTextures","src","fillSamplers","sampleValues","samplerSize","generateFragmentSrc","fragmentSrc","tilemapVertexTemplateSrc","tilemapFragmentTemplateSrc","TilemapShader","Shader","Program","shaderGenerator.generateFragmentSrc","Matrix","shaderGenerator.fillSamplers","TilemapGeometry","Geometry","buf","Buffer","TileRenderer","ObjectRenderer","len","usedTextiles","resourceIndex","geom","size","_vb","totalIndices","utils","resource","baseTex","BaseTexture","WRAP_MODES","pixi_tilemap"],"mappings":";;AAeO,MAAMA,EACb;AAAA;AAAA,EAWI,YAAYC,GACZ;AAPW,SAAA,WAAA,CAAC,GAAG,CAAC,GAGG,KAAA,mBAAA,IAKf,KAAK,WAAWA,GACX,KAAA,WAAW,CAAC,GAAG,CAAC;AAAA,EACzB;AAAA,EAEA,OAAO,oBACP;AACI,IAAAC,EAAW,IAAI;AAAA,MACX,MAAM;AAAA,MACN,MAAMC,EAAc;AAAA,MACpB,KAAKH;AAAA,IAAA,CACR;AAAA,EACL;AAAA;AAAA,EAGA,OAAO,YAAYC,GACnB;AACQ,QAAA,CAACA,EAAS,QAAQ;AAEZ,YAAA,IAAI,MAAM,2BAA2B;AAG/C,WAAOA,EAAS,QAAQ;AAAA,EAC5B;AACJ;AC5CO,MAAMG,IAAW;AAAA;AAAA,EAEpB,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQtB,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWf,eAAe;AAAA;AAAA,EAGf,oBAAoBC,GAAY;AAAA;AAAA,EAGhC,eAAe;AAAA;AAAA,EAGf,UAAU;AAAA;AAAA,EAGV,IAAI,cAAsB;AAAE,WAAO,KAAK;AAAA,EAAc;AAAA,EACtD,IAAI,YAAYC,GAAe;AAAE,SAAK,eAAeA;AAAA,EAAO;AAAA,EAE5D,IAAI,YAAoB;AAAE,WAAO,KAAK;AAAA,EAAoB;AAAA,EAC1D,IAAI,UAAUA,GAAe;AAAE,SAAK,qBAAqBA;AAAA,EAAO;AAAA,EAEhE,IAAI,sBAA8B;AAAE,WAAO,KAAK;AAAA,EAAe;AAAA,EAC/D,IAAI,oBAAoBA,GAAe;AAAE,SAAK,gBAAgBA;AAAA,EAAO;AACzE,GAGaC,KAAWH;ACzCxB,IAAKI,uBAAAA,OAEDA,EAAAC,EAAA,IAAA,CAAA,IAAA,KACAD,EAAAC,EAAA,IAAA,CAAA,IAAA,KACAD,EAAAC,EAAA,IAAA,CAAA,IAAA,KACAD,EAAAC,EAAA,IAAA,CAAA,IAAA,KACAD,EAAAC,EAAA,aAAA,CAAA,IAAA,cACAD,EAAAC,EAAA,cAAA,CAAA,IAAA,eACAD,EAAAC,EAAA,SAAA,CAAA,IAAA,UACAD,EAAAC,EAAA,SAAA,CAAA,IAAA,UACAD,EAAAC,EAAA,SAAA,CAAA,IAAA,UACAD,EAAAC,EAAA,gBAAA,CAAA,IAAA,iBACAD,EAAAC,EAAA,eAAA,EAAA,IAAA,gBACAD,EAAAC,EAAA,eAAA,EAAA,IAAA,gBACAD,EAAAC,EAAA,eAAA,EAAA,IAAA,gBACAD,EAAAC,EAAA,QAAA,EAAA,IAAA,SAfCD,IAAAA,MAAA,CAAA,CAAA;AAkBE,MAAME,IAAqB,OAAO,KAAKF,EAAY,EAAE,SAAS;AA+B9D,MAAMG,UAAgBC,GAC7B;AAAA;AAAA;AAAA;AAAA;AAAA,EAiDI,YAAYC,GACZ;AACU,aAlDV,KAAA,cAAc,IAAI,aAAa,CAAC,GAAK,GAAK,GAAK,GAAG,CAAC,GAC9B,KAAA,aAAA,MAOrB,KAAO,WAA6B,MAMf,KAAA,qBAAA,GAGX,KAAA,UAAA,GAGA,KAAA,UAAA,GAGQ,KAAA,kBAAA,IAaC,KAAA,gBAAgB,IAAIC,MAGvC,KAAU,kBAAkB,IAG5B,KAAQ,YAA2B,IAqOnC,KAAA,eAAe,CAACb,MAChB;AACU,YAAAc,IAASf,EAAmB,YAAYC,CAAQ;AAElD,UAAAc,KAAU,CAACA,EAAO,kBACtB;AACI,cAAMC,IAAK,KAAK;AAEhB,QAAAf,EAAS,cAAc,cAAc;AAAA,UACjCe,EAAG;AAAA,UACHA,EAAG;AAAA,UACHA,EAAG;AAAA,UACHA,EAAG;AAAA,UACHA,EAAG,KAAKf,EAAS;AAAA,UACjBe,EAAG,KAAKf,EAAS;AAAA,QAAA;AAAA,MAEzB;AAEA,WAAK,iBAAiBA,CAAQ;AAAA,IAAA,GA4ClC,KAAQ,OAAO,GACf,KAAQ,KAAsB,MAC9B,KAAQ,WAAwB,MAChC,KAAQ,UAAwB,MAChC,KAAQ,SAAsB,MA9R1B,KAAK,WAAWY,CAAO;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,aACA;AACI,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,WAAWA,IAA4C,IACvD;AACI,IAAK,MAAM,QAAQA,CAAO,MAEtBA,IAAU,CAACA,CAAO;AAEtB,aAASI,IAAI,GAAGA,IAAIJ,EAAQ,QAAQI;AAE3B,MAAAJ,EAAQI,CAAC,EAAyB,gBAEnCJ,EAAQI,CAAC,IAAKJ,EAAQI,CAAC,EAAyB;AAIxD,gBAAK,UAAUJ,GAER;AAAA,EACX;AAAA;AAAA,EAGA,QACA;AACI,gBAAK,UAAU,SAAS,GACxB,KAAK,qBAAqB,GAC1B,KAAK,cAAc,SACnB,KAAK,kBAAkB,IAEhB;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0BA,KACIK,GACAC,GACAC,GACAC,IAYI,CAAA,GAER;AACQ,QAAAC,GACAC,IAAe;AAEf,QAAA,OAAOL,KAAgB;AAER,MAAAK,IAAAL,GACDI,IAAA,KAAK,QAAQC,CAAY;AAAA,SAG3C;AACQ,UAAAC;AAEA,MAAA,OAAON,KAAgB,WAEbM,IAAAC,EAAQ,KAAKP,CAAW,IAIxBM,IAAAN;AAGd,YAAMQ,IAAc,KAAK;AAEzB,eAAST,IAAI,GAAGA,IAAIS,EAAY,QAAQT;AAEpC,YAAIS,EAAYT,CAAC,MAAMO,EAAQ,qBAC/B;AACmB,UAAAD,IAAAN;AACf;AAAA,QACJ;AAGJ,MAAI,iBAAiBO,MAEjBH,EAAQ,IAAIA,EAAQ,KAAKG,EAAQ,MAAM,GACvCH,EAAQ,IAAIA,EAAQ,KAAKG,EAAQ,MAAM,GACvCH,EAAQ,YAAYA,EAAQ,aAAaG,EAAQ,KAAK,OACtDH,EAAQ,aAAaA,EAAQ,cAAcG,EAAQ,KAAK,SAG5DF,IAAcE,EAAQ;IAC1B;AAEI,QAAA,CAACF,KAAeC,IAAe;AAE/B,qBAAQ,MAAM,wDAAwD,GAE/D;AAGL,UAAA;AAAA,MACF,GAAAI,IAAI;AAAA,MACJ,GAAAC,IAAI;AAAA,MACJ,WAAAC,IAAYP,EAAY;AAAA,MACxB,YAAAQ,IAAaR,EAAY;AAAA,MACzB,OAAAS,IAAQ;AAAA,MACR,OAAAC,IAAQ;AAAA,MACR,QAAAC,IAAS;AAAA,MACT,YAAAC,IAAa;AAAA,MACb,YAAAC,IAAa;AAAA,MACb,aAAAC,IAAc;AAAA,MACd,OAAAC,IAAQ;AAAA,IACR,IAAAhB,GAEEiB,IAAK,KAAK;AAEhB,gBAAK,kBAAkB,KAAK,mBAAmBP,IAAQ,KAAKC,IAAQ,GAEpEM,EAAG,KAAKX,CAAC,GACTW,EAAG,KAAKV,CAAC,GACTU,EAAG,KAAKnB,CAAC,GACTmB,EAAG,KAAKlB,CAAC,GACTkB,EAAG,KAAKT,CAAS,GACjBS,EAAG,KAAKR,CAAU,GAClBQ,EAAG,KAAKL,CAAM,GACXK,EAAA,KAAKP,IAAQ,CAAC,GACdO,EAAA,KAAKN,IAAQ,CAAC,GACjBM,EAAG,KAAKf,CAAY,GACpBe,EAAG,KAAKJ,CAAU,GAClBI,EAAG,KAAKH,CAAU,GAClBG,EAAG,KAAKF,CAAW,GACnBE,EAAG,KAAKD,CAAK,GAER,KAAA,cAAc,YAAYlB,GAAGC,GAAGD,IAAIU,GAAWT,IAAIU,GAAY,GAAG,CAAC,GAEjE;AAAA,EACX;AAAA;AAAA,EAGA,WAAWG,GACX;AACI,UAAMK,IAAK,KAAK;AAEhB,IAAAA,EAAGA,EAAG,UAAU5B,IAAoB,EAA2B,IAAIuB;AAAA,EACvE;AAAA;AAAA,EAGA,UAAUM,GAAgBC,GAC1B;AACI,UAAMF,IAAK,KAAK;AAEhB,IAAAA,EAAGA,EAAG,UAAU5B,IAAoB,EAAoB,IAAI6B,GAC5DD,EAAGA,EAAG,UAAU5B,IAAoB,GAA0B,IAAI8B;AAAA,EAEtE;AAAA;AAAA,EAGA,UAAUD,GAAgBC,GAC1B;AACI,UAAMF,IAAK,KAAK;AAEhB,IAAAA,EAAGA,EAAG,UAAU5B,IAAoB,EAAoB,IAAI6B,GAC5DD,EAAGA,EAAG,UAAU5B,IAAoB,GAA0B,IAAI8B;AAAA,EACtE;AAAA;AAAA,EAGA,gBAAgBC,GAChB;AACI,UAAMH,IAAK,KAAK;AAEhB,IAAAA,EAAGA,EAAG,UAAU5B,IAAoB,GAA0B,IAAI+B;AAAA,EACtE;AAAA,EAEA,UAAUJ,GACV;AACI,UAAMC,IAAK,KAAK;AAEhB,IAAAA,EAAGA,EAAG,UAAU5B,IAAoB,GAAmB,IAAI2B;AAAA,EAC/D;AAAA,EAuBA,iBAAiBpC,GACjB;AACQ,QAAA,KAAK,QAAQ,WAAW;AAAG;AAC/B,UAAMyC,IAAS,KAAK,WACdC,IAAW,KAAK,YAAa1C,EAAS,QAAQ,WAAWA,EAAS,QAAQ,QAAQ;AAE/E,IAAAA,EAAA,cAAc,cAAc,YAAY;AACxC,aAAAgB,IAAI,GAAG2B,IAAIF,EAAO,QAAQzB,IAAI2B,GAAG3B,KAAKP,GAC/C;AACQ,UAAAmC,IAAKH;AAAA,QAAOzB,IAAI;AAAA;AAAA,MAAc,GAC9B6B,IAAKJ;AAAA,QAAOzB,IAAI;AAAA;AAAA,MAAc;AAC5B,YAAA8B,IAAKL;AAAA,QAAOzB,IAAI;AAAA;AAAA,MAAc,GAC9B+B,IAAKN;AAAA,QAAOzB,IAAI;AAAA;AAAA,MAAc,GAC9BgC,IAAIP;AAAA,QAAOzB,IAAI;AAAA;AAAA,MAAuB,GACtCiC,IAAIR;AAAA,QAAOzB,IAAI;AAAA;AAAA,MAAwB;AAE7C,MAAA4B,KAAMH;AAAA,QAAOzB,IAAI;AAAA;AAAA,MAAmB,IAAI0B,EAAS,CAAC,GAClDG,KAAMJ;AAAA,QAAOzB,IAAI;AAAA;AAAA,MAAmB,IAAI0B,EAAS,CAAC;AAE5C,YAAApB,IAAemB;AAAA,QAAOzB,IAAI;AAAA;AAAA,MAA0B,GACpDoB,IAAQK;AAAA,QAAOzB,IAAI;AAAA;AAAA,MAAkB;AAI3C,MAAIM,KAAgB,KAAK,KAAK,QAAQA,CAAY,KAErCtB,EAAA,cAAc,cAAc,cAAcoC,GACnDpC,EAAS,cAAc,cAAc;AAAA,QAChC,KAAK,QAAQsB,CAAY,EAAU,kBAAkB;AAAA,QACtDsB;AAAA,QAAIC;AAAA,QAAIG;AAAA,QAAGC;AAAA,QAAGH;AAAA,QAAIC;AAAA,QAAIC;AAAA,QAAGC;AAAA,MAAA,MAKpBjD,EAAA,cAAc,cAAc,cAAc,KACnDA,EAAS,cAAc,cAAc,SAAS8C,GAAIC,GAAIC,GAAGC,CAAC,IAErDjD,EAAA,cAAc,cAAc,cAAc;AAAA,IACvD;AAAA,EACJ;AAAA,EAQQ,YACR;AACI,IAAI,KAAK,OAEL,KAAK,GAAG,WACR,KAAK,KAAK;AAAA,EAElB;AAAA,EAEA,OAAOA,GACP;AACU,UAAAc,IAAUd,EAAS,QAAgB,SACnCkD,IAASpC,EAAO;AAEb,IAAAd,EAAA,MAAM,kBAAkBc,CAAM,GAClC,KAAA,aAAaoC,EAAO,SAAS,iBAE7BlD,EAAA,eACA,SACA,iBACA,OAAO,KAAK,UAAU,EACtB,OAAO,KAAK,cAAc,GAExBkD,EAAA,SAAS,cAAc,KAAK,aACnCA,EAAO,SAAS,iBAAiB,KAAK,YAAYpC,EAAO,UAEpD,KAAA,gBAAgBd,GAAUc,CAAM;AAAA,EACzC;AAAA,EAEA,gBAAgBd,GAAoBc,GACpC;AACI,UAAM2B,IAAS,KAAK;AAEpB,QAAIA,EAAO,WAAW;AAAG;AACnB,UAAAU,IAAaV,EAAO,SAAShC,GAE7ByC,IAASpC,EAAO,aAChBsC,IAAW,KAAK;AAEtB,QAAIA,EAAS,WAAW;AAAG;AAEpB,IAAAtC,EAAA,iBAAiBd,GAAUoD,CAAQ,GACjCpD,EAAA,OAAO,KAAKkD,GAAQ,EAAK;AAGlC,QAAIG,IAAK,KAAK;AAEd,IAAKA,MAEDA,IAAKvC,EAAO,YACZ,KAAK,KAAKuC,GACV,KAAK,OAAQA,EAAW,IACxB,KAAK,WAAW,MAChB,KAAK,qBAAqB,IAGvBvC,EAAA,iBAAiBqC,GAAYE,CAAE;AACtC,UAAMC,IAAsBnD,EAAS,eAE/BoD,IAAYF,EAAG,UAAU,iBAAiB,GAE1CG,IAAWL,IAAaE,EAAG;AAEjC,QAAIG,MAAa,GACb;AAAA,UAAA,KAAK,uBAAuBA,GAChC;AACI,aAAK,qBAAqBA;AACpB,cAAAC,IAAKJ,EAAG,SAASG;AAEvB,YAAI,CAAC,KAAK,YAAY,KAAK,SAAS,aAAaC,GACjD;AAEI,cAAIC,IAAKL,EAAG;AAEZ,iBAAOK,IAAKD;AAEF,YAAAC,KAAA;AAEL,eAAA,WAAW,IAAI,YAAYA,CAAE,GAClC,KAAK,UAAU,IAAI,aAAa,KAAK,QAAQ,GAC7C,KAAK,SAAS,IAAI,YAAY,KAAK,QAAQ,GACjCH,EAAA,OAAO,KAAK,QAAQ;AAAA,QAClC;AAEA,cAAMI,IAAM,KAAK;AAGjB,YAAIC,IAAK,GAELC,IAAY,GACZC,IAAiB,KAAK,SACtBC,IAAiB,KAAK;AAK1B,iBAAS/C,IAAI,GAAGA,IAAIyB,EAAO,QAAQzB,KAAKP,GACxC;AAGI,cAAI,KAAK,iBACT;AACU,kBAAAa,IAAemB;AAAA,cAAOzB,IAAI;AAAA;AAAA,YAA0B;AAE1D,YAAIsC,IAAsB,KAGtBO,IAAavC,KAAgB,GACpBwC,IAAA,KAAK,WAAWxC,IAAe,IAC/ByC,IAAA,KAAK,WAAYzC,KAAgB,IAAK,OAInCuC,IAAAvC,GACHwC,IAAA,GACAC,IAAA;AAAA,UAEjB;AACM,gBAAA7C,IAAIuB;AAAA,YAAOzB,IAAI;AAAA;AAAA,UAAc,GAC7BG,IAAIsB;AAAA,YAAOzB,IAAI;AAAA;AAAA,UAAc,GAC7BgC,IAAIP;AAAA,YAAOzB,IAAI;AAAA;AAAA,UAAuB,GACtCiC,IAAIR;AAAA,YAAOzB,IAAI;AAAA;AAAA,UAAwB,GACvCU,IAAIe;AAAA,YAAOzB,IAAI;AAAA;AAAA,UAAA,IAAkB8C,GACjCnC,IAAIc;AAAA,YAAOzB,IAAI;AAAA;AAAA,UAAA,IAAkB+C;AACnC,cAAA/B,IAASS;AAAA,YAAOzB,IAAI;AAAA;AAAA,UAAmB;AAErC,gBAAAc,KAAQW;AAAA,YAAOzB,IAAI;AAAA;AAAA,UAAmB,GACtCe,KAAQU;AAAA,YAAOzB,IAAI;AAAA;AAAA,UAAmB,GACtCgD,KAAYvB;AAAA,YAAOzB,IAAI;AAAA;AAAA,UAAA,KAA8B,MACrDiD,KAAaxB;AAAA,YAAOzB,IAAI;AAAA;AAAA,UAAA,KAA8B,MAEtDkD,IAAepC,KAASkC,KAAY,MACpCG,IAAepC,KAASkC,KAAa,MACrC9B,IAAcM;AAAA,YAAOzB,IAAI;AAAA;AAAA,UAAyB,GAClDoB,IAAQK;AAAA,YAAOzB,IAAI;AAAA;AAAA,UAAkB;AAEvC,cAAAoD,GACAC,GAAgBC,GAChBC,GAAgBC,GAChBC,GAAgBC,GAChBC;AAEJ,cAAI3C,MAAW;AAEN,YAAAoC,IAAA1C,GACA2C,IAAA1C,GACL2C,IAAK5C,IAAIsB,GACJuB,IAAA5C,GACL6C,IAAK9C,IAAIsB,GACTyB,IAAK9C,IAAIsB,GACJyB,IAAAhD,GACLiD,IAAKhD,IAAIsB;AAAA,eAGb;AACI,gBAAI2B,IAAK5B,IAAI,GACT6B,IAAK5B,IAAI;AAET,YAAAjB,IAAS,MAAM,MAEf4C,IAAK3B,IAAI,GACT4B,IAAK7B,IAAI;AAEb,kBAAM8B,IAAKpD,IAAIkD,GACTG,IAAKpD,IAAIkD;AAEf,YAAA7C,IAASgD,EAAQ,IAAIhD,GAAQgD,EAAQ,EAAE,GACvCZ,IAAKU,IAAMF,IAAKI,EAAQ,GAAGhD,CAAM,GACjCqC,IAAKU,IAAMF,IAAKG,EAAQ,GAAGhD,CAAM,GAExBA,IAAAgD,EAAQ,IAAIhD,GAAQ,CAAC,GAC9BsC,IAAKQ,IAAMF,IAAKI,EAAQ,GAAGhD,CAAM,GACjCuC,IAAKQ,IAAMF,IAAKG,EAAQ,GAAGhD,CAAM,GAExBA,IAAAgD,EAAQ,IAAIhD,GAAQ,CAAC,GAC9BwC,IAAKM,IAAMF,IAAKI,EAAQ,GAAGhD,CAAM,GACjCyC,IAAKM,IAAMF,IAAKG,EAAQ,GAAGhD,CAAM,GAExBA,IAAAgD,EAAQ,IAAIhD,GAAQ,CAAC,GAC9B0C,IAAKI,IAAMF,IAAKI,EAAQ,GAAGhD,CAAM,GACjC2C,IAAKI,IAAMF,IAAKG,EAAQ,GAAGhD,CAAM;AAAA,UACrC;AAEA,UAAA2B,EAAIC,GAAI,IAAI1C,GACZyC,EAAIC,GAAI,IAAIzC,GACZwC,EAAIC,GAAI,IAAIQ,GACZT,EAAIC,GAAI,IAAIS,GACRV,EAAAC,GAAI,IAAIlC,IAAI,KACZiC,EAAAC,GAAI,IAAIjC,IAAI,KACZgC,EAAAC,GAAI,IAAIlC,IAAIsB,IAAI,KAChBW,EAAAC,GAAI,IAAIjC,IAAIsB,IAAI,KACpBU,EAAIC,GAAI,IAAIM,GACZP,EAAIC,GAAI,IAAIO,GACZR,EAAIC,GAAI,IAAIC,GACZF,EAAIC,GAAI,IAAIzB,GACZwB,EAAIC,GAAI,IAAIxB,GAERuB,EAAAC,GAAI,IAAI1C,IAAI8B,GAChBW,EAAIC,GAAI,IAAIzC,GACZwC,EAAIC,GAAI,IAAIU,GACZX,EAAIC,GAAI,IAAIW,GACRZ,EAAAC,GAAI,IAAIlC,IAAI,KACZiC,EAAAC,GAAI,IAAIjC,IAAI,KACZgC,EAAAC,GAAI,IAAIlC,IAAIsB,IAAI,KAChBW,EAAAC,GAAI,IAAIjC,IAAIsB,IAAI,KACpBU,EAAIC,GAAI,IAAIM,GACZP,EAAIC,GAAI,IAAIO,GACZR,EAAIC,GAAI,IAAIC,GACZF,EAAIC,GAAI,IAAIzB,GACZwB,EAAIC,GAAI,IAAIxB,GAERuB,EAAAC,GAAI,IAAI1C,IAAI8B,GACZW,EAAAC,GAAI,IAAIzC,IAAI8B,GAChBU,EAAIC,GAAI,IAAIY,GACZb,EAAIC,GAAI,IAAIa,GACRd,EAAAC,GAAI,IAAIlC,IAAI,KACZiC,EAAAC,GAAI,IAAIjC,IAAI,KACZgC,EAAAC,GAAI,IAAIlC,IAAIsB,IAAI,KAChBW,EAAAC,GAAI,IAAIjC,IAAIsB,IAAI,KACpBU,EAAIC,GAAI,IAAIM,GACZP,EAAIC,GAAI,IAAIO,GACZR,EAAIC,GAAI,IAAIC,GACZF,EAAIC,GAAI,IAAIzB,GACZwB,EAAIC,GAAI,IAAIxB,GAEZuB,EAAIC,GAAI,IAAI1C,GACRyC,EAAAC,GAAI,IAAIzC,IAAI8B,GAChBU,EAAIC,GAAI,IAAIc,GACZf,EAAIC,GAAI,IAAIe,GACRhB,EAAAC,GAAI,IAAIlC,IAAI,KACZiC,EAAAC,GAAI,IAAIjC,IAAI,KACZgC,EAAAC,GAAI,IAAIlC,IAAIsB,IAAI,KAChBW,EAAAC,GAAI,IAAIjC,IAAIsB,IAAI,KACpBU,EAAIC,GAAI,IAAIM,GACZP,EAAIC,GAAI,IAAIO,GACZR,EAAIC,GAAI,IAAIC,GACZF,EAAIC,GAAI,IAAIzB,GACZwB,EAAIC,GAAI,IAAIxB;AAAA,QAChB;AAEA,QAAAmB,EAAU,OAAOI,CAAG;AAAA,MACxB;AAEC,MAAA3D,EAAS,SAAiB,KAAKqD,GAAIH,CAAM,GAC1ClD,EAAS,SAAS,KAAKiF,GAAW,WAAW9B,IAAa,GAAG,CAAC;AAAA;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAW+B,GACX;AACI,WAAI,QAAK,uBAAuB,KAAK,UAAU,UACvCA,KAAQ,KAAK;AAAA,EAMzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,cACA;AACS,SAAA,qBAAqB,KAAK,UAAU;AAAA,EAC7C;AAAA;AAAA,EAGU,mBACV;AACI,UAAM,EAAE,MAAAC,GAAM,MAAAC,GAAM,MAAAC,GAAM,MAAAC,MAAS,KAAK;AAExC,SAAK,QAAQ,SAAS,KAAK,WAAWH,GAAMC,GAAMC,GAAMC,CAAI;AAAA,EAChE;AAAA;AAAA,EAGO,eAAeC,GACtB;AAEQ,WAAA,KAAK,SAAS,WAAW,IAElB,KAAK,cAAc,aAAaA,CAAI,IAGxC,MAAM,eAAe,KAAK,MAAMA,CAAI;AAAA,EAC/C;AAAA;AAAA,EAGA,QAAQnE,GACR;AACI,UAAM,QAAQA,CAAO,GACrB,KAAK,UAAU;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAASG,GAAoCL,GAAWC,GAAWW,GAAeC,GAClF;AACS,gBAAA;AAAA,MACDR;AAAA,MACAL;AAAA,MACAC;AAAA,MACA;AAAA,QACI,OAAAW;AAAA,QACA,OAAAC;AAAA,MACJ;AAAA,IAAA,GAGG;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,QACIT,GACAI,GACAC,GACAT,GACAC,GACAS,GACAC,GACAC,IAAQ,GACRC,IAAQ,GACRC,IAAS,GACTC,IAAa,MACbC,IAAa,MACbC,IAAc,GACdC,IAAQ,GAEZ;AACI,WAAO,KAAK;AAAA,MACRd;AAAA,MACAJ;AAAA,MAAGC;AAAA,MACH;AAAA,QACI,GAAAO;AAAA,QAAG,GAAAC;AAAA,QAAG,WAAAC;AAAA,QAAW,YAAAC;AAAA,QAAY,OAAAC;AAAA,QAAO,OAAAC;AAAA,QAAO,QAAAC;AAAA,QAAQ,YAAAC;AAAA,QAAY,YAAAC;AAAA,QAAY,aAAAC;AAAA,QAAa,OAAAC;AAAA,MAC5F;AAAA,IAAA;AAAA,EAER;AACJ;AC/qBO,MAAMoD,UAAyB7E,GACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4BI,YAAYC,GACZ;AACU,aAhBV,KAAO,WAA6B,MAGpC,KAAU,sBAA+B,MAEzC,KAAQ,qBAAqB,GACrB,KAAA,cAAc,IAAI,aAAa,CAAC,GAAK,GAAK,GAAK,GAAG,CAAC,GAC3D,KAAQ,aAAqB,MA8a7B,KAAA,aAAa,KAAK,SAnad,KAAK,QAAQA,CAAO,GACpB,KAAK,qBAAqBT,EAAS;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,QAAQsF,GACR;AACI,IAAKA,MAEDA,IAAe,CAAA;AAGnB,UAAMC,IAAc,KAAK,oBACnBC,IAAO,KAAK,SAAS,QACrBC,IAAO,KAAK,KAAKH,EAAa,SAASC,CAAW;AAE/C,aAAA1E,IAAI,GAAGA,IAAI,KAAK,IAAI2E,GAAMC,CAAI,GAAG5E;AAErC,WAAK,SAASA,CAAC,EAAc;AAAA,QAC1ByE,EAAa,MAAMzE,IAAI0E,IAAc1E,IAAI,KAAK0E,CAAW;AAAA,MAAA;AAGjE,aAAS1E,IAAI2E,GAAM3E,IAAI4E,GAAM5E,KAC7B;AACU,YAAA6E,IAAU,IAAInF,EAAQ+E,EAAa,MAAMzE,IAAI0E,IAAc1E,IAAI,KAAK0E,CAAW,CAAC;AAEtF,MAAAG,EAAQ,kBAAkB,IAC1BA,EAAQ,UAAU1F,EAAS,eAC3B0F,EAAQ,UAAU1F,EAAS,eAG3B,KAAK,SAAS0F,CAAO;AAAA,IACzB;AAEO,WAAA;AAAA,EACX;AAAA;AAAA,EAGA,QACA;AACI,aAAS7E,IAAI,GAAGA,IAAI,KAAK,SAAS,QAAQA;AAErC,WAAK,SAASA,CAAC,EAAc,MAAM;AAGxC,gBAAK,qBAAqB,GAEnB;AAAA,EACX;AAAA;AAAA,EAGA,WAAWgB,GACX;AACI,WAAI,KAAK,uBAEA,KAAA,oBAAoB,WAAWA,CAAM,GAGvC;AAAA,EACX;AAAA;AAAA,EAGA,UAAUM,GAAgBC,GAC1B;AACI,WAAI,KAAK,uBAEA,KAAA,oBAAoB,UAAUD,GAAQC,CAAK,GAG7C;AAAA,EACX;AAAA;AAAA,EAGA,UAAUD,GAAgBC,GAC1B;AACI,WAAI,KAAK,uBAEA,KAAA,oBAAoB,UAAUD,GAAQC,CAAK,GAG7C;AAAA,EACX;AAAA;AAAA,EAGA,gBAAgBC,GAChB;AACI,WAAI,KAAK,uBAEA,KAAA,oBAAoB,gBAAgBA,CAAO,GAG7C;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0BA,KACIvB,GACAC,GACAC,GACAC,IAYI,CAAA,GAER;AACI,QAAIyE,IAAmB;AACvB,UAAMC,IAAW,KAAK;AAIlB,QAFJ,KAAK,sBAAsB,MAEvB,OAAO7E,KAAgB,UAC3B;AACU,YAAA8E,IAAa9E,IAAc,KAAK,sBAAsB;AAC5D,UAAI+E,IAAY;AAIhB,UAFAH,IAAUC,EAASC,CAAU,GAExBF;AAWD,QAAAG,IAAY/E,IAAc,KAAK;AAAA,WAVnC;AAII,YAHA4E,IAAUC,EAAS,CAAC,GAGhB,CAACD;AAAgB,iBAAA;AAET,QAAAG,IAAA;AAAA,MAAA;AAOR,MAAAH,EAAA;AAAA,QACJG;AAAA,QACA9E;AAAA,QACAC;AAAA,QACAC;AAAA,MAAA;AAAA,IACJ,OAGJ;AACQ,MAAA,OAAOH,KAAgB,aAETA,IAAAO,EAAQ,KAAKP,CAAW;AAI1C,eAASD,IAAI,GAAGA,IAAI8E,EAAS,QAAQ9E,KACrC;AACU,cAAAiF,IAAQH,EAAS9E,CAAC,GAClBkF,IAAMD,EAAM;AAElB,iBAASE,IAAI,GAAGA,IAAID,EAAI,QAAQC;AAE5B,cAAID,EAAIC,CAAC,MAAMlF,EAAY,aAC3B;AACc,YAAA4E,IAAAI;AACV;AAAA,UACJ;AAGJ,YAAIJ;AAEA;AAAA,MAER;AAGA,UAAI,CAACA,GACL;AAEI,iBAAS7E,IAAI8E,EAAS,SAAS,GAAG9E,KAAK,GAAGA,KAC1C;AACU,gBAAAiF,IAAQH,EAAS9E,CAAC;AAExB,cAAIiF,EAAM,WAAA,EAAa,SAAS,KAAK,oBACrC;AACc,YAAAJ,IAAAI,GACVA,EAAM,WAAW,EAAE,KAAKhF,EAAY,WAAW;AAC/C;AAAA,UACJ;AAAA,QACJ;AAGA,QAAK4E,MAESA,IAAA,IAAInF,EAAQO,EAAY,WAAW,GAC7C4E,EAAQ,kBAAkB,IAC1BA,EAAQ,UAAU1F,EAAS,eAC3B0F,EAAQ,UAAU1F,EAAS,eAE3B,KAAK,SAAS0F,CAAO;AAAA,MAE7B;AAEQ,MAAAA,EAAA;AAAA,QACJ5E;AAAA,QACAC;AAAA,QACAC;AAAA,QACAC;AAAA,MAAA;AAAA,IAER;AAEA,gBAAK,sBAAsByE,GAEpB;AAAA,EACX;AAAA,EAEA,aAAa7F,GACb;AACQ,QAAA,CAAC,KAAK,WAAW,KAAK,cAAc,KAAK,CAAC,KAAK;AAE/C;AAGE,UAAAoG,IAAgBrG,EAAmB,YAAYC,CAAQ;AAEzD,QAAAoG,KAAiB,CAACA,EAAc,kBACpC;AACI,YAAMrF,IAAK,KAAK;AAEhB,MAAAf,EAAS,cAAc,cAAc;AAAA,QACjCe,EAAG;AAAA,QACHA,EAAG;AAAA,QACHA,EAAG;AAAA,QACHA,EAAG;AAAA,QACHA,EAAG,KAAKf,EAAS;AAAA,QACjBe,EAAG,KAAKf,EAAS;AAAA,MAAA;AAAA,IAEzB;AAEA,UAAMqG,IAAS,KAAK;AAEpB,aAASrF,IAAI,GAAGA,IAAIqF,EAAO,QAAQrF,KACnC;AACU,YAAAsF,IAASD,EAAOrF,CAAC;AAEvB,MAAAsF,EAAM,WAAW,KAAK,UACtBA,EAAM,iBAAiBtG,CAAQ;AAAA,IACnC;AAAA,EACJ;AAAA,EAEA,OAAOA,GACP;AACQ,QAAA,CAAC,KAAK,WAAW,KAAK,cAAc,KAAK,CAAC,KAAK;AAE/C;AAGE,UAAAc,IAASd,EAAS,QAAQ,SAC1BkD,IAASpC,EAAO;AAEb,IAAAd,EAAA,MAAM,kBAAkBc,CAAM,GAGlC,KAAA,aAAaoC,EAAO,SAAS,iBACzBlD,EAAA,eAAe,SAAS,iBAAiB,OAAO,KAAK,UAAU,EAAE,OAAO,KAAK,cAAc,GAC7FkD,EAAA,SAAS,cAAc,KAAK,aACnCA,EAAO,SAAS,iBAAiB,KAAK,YAAYpC,EAAO,UAEhDd,EAAA,OAAO,KAAKkD,GAAQ,EAAK;AAElC,UAAMmD,IAAS,KAAK;AAEpB,aAASrF,IAAI,GAAGA,IAAIqF,EAAO,QAAQrF;AAE9B,MAAAqF,EAAOrF,CAAC,EAAc,gBAAgBhB,GAAUc,CAAM;AAAA,EAE/D;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAWoE,GACX;AACI,UAAMmB,IAAS,KAAK;AAEhB,QAAA,KAAK,uBAAuBA,EAAO;AAE5B,aAAA;AAEX,aAAS,IAAI,GAAG,IAAIA,EAAO,QAAQ;AAE/B,UAAKA,EAAO,CAAC,EAAc,WAAWnB,CAAI;AAE/B,eAAA;AAIR,WAAA;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,cACA;AACI,UAAMmB,IAAS,KAAK;AAEpB,SAAK,qBAAqBA,EAAO;AACjC,aAASrF,IAAI,GAAGA,IAAIqF,EAAO,QAAQrF;AAE9B,MAAAqF,EAAOrF,CAAC,EAAc;EAE/B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SACIO,GACAL,GACAC,GACAW,GACAC,GACAiC,GACAC,GACA9B,GACAC,GAEJ;AACI,WAAO,KAAK;AAAA,MACRb;AAAA,MACAL;AAAA,MAAGC;AAAA,MACH;AAAA,QACI,OAAAW;AAAA,QACA,OAAAC;AAAA,QACA,YAAYiC;AAAA,QACZ,YAAYC;AAAA,QACZ,aAAA9B;AAAA,QACA,OAAAC;AAAA,MACJ;AAAA,IAAA;AAAA,EAER;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QACId,GACAI,GACAC,GACAT,GACAC,GACAS,GACAC,GACAC,GACAC,GACAC,GACAgC,GACAC,GAEJ;AACU,UAAA8B,IAAqBzE,IAAe,KAAK,sBAAsB,GAC/DuC,IAAoBvC,IAAe,KAAK;AAE1C,WAAA,KAAK,SAASyE,CAAU,KAAM,KAAK,SAASA,CAAU,EAAc,gBAE/D,KAAA,sBAAuB,KAAK,SAASA,CAAU,GACpD,KAAK,oBAAoB;AAAA,MACrBlC;AAAA,MAAWnC;AAAA,MAAGC;AAAA,MAAGT;AAAA,MAAGC;AAAA,MAAGS;AAAA,MAAWC;AAAA,MAAYC;AAAA,MAAOC;AAAA,MAAOC;AAAA,MAAQgC;AAAA,MAAWC;AAAA,IAAA,KAKnF,KAAK,sBAAsB,MAGxB;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,IAAI,cAAsB;AAAE,WAAO,KAAK;AAAA,EAAoB;AAChE;AC/eO,MAAMsC,UAAwBC,GACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeI,YAAYpF,IAA0BjB,GACtC;AACI;AAAA,MACIiB,EAAQ,gBAAgB;AAAA,MACxBA,EAAQ,gBAAgB,KAAK,KAAKA,EAAQ,gBAAgB,CAAC;AAAA,IAAA,GAjBnE,KAAO,cAA2B,MAMlC,KAAQ,eAA2B;AAc/B,UAAMqF,IAAuB,KAAK,QAAQ,IAAI,MAAMrF,EAAQ,aAAa;AAEpE,SAAA,UAAU,CAAC,CAACA,EAAQ,UACzB,KAAK,YAAYA,EAAQ;AAEzB,aAAS+E,IAAI,GAAGA,IAAI/E,EAAQ,eAAe+E;AAEvC,MAAAM,EAAMN,CAAC,IAAI;AAAA,QACP,SAAS;AAAA,QACT,GAAG/E,EAAQ,iBAAiB+E,IAAI;AAAA,QAChC,GAAG/E,EAAQ,iBAAiB+E,KAAK;AAAA,QACjC,aAAa3E,EAAQ,MAAM;AAAA,MAAA;AAAA,EAGvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,KAAKkF,GAAenF,GACpB;AACU,UAAAoF,IAAO,KAAK,MAAMD,CAAK;AAEzB,IAAAC,EAAK,gBAAgBpF,MAKzBoF,EAAK,cAAcpF,GACnB,KAAK,YAAY,UAEjB,KAAK,MAAMmF,CAAK,EAAE,UAAW,KAAK,YAAoB;AAAA,EAC1D;AAAA;AAAA,EAGA,KAAKrF,GACL;AACI,QAAI,KAAK;AAEC,YAAA,IAAI,MAAM,oDAAoD;AAGxE,SAAK,cAAcA,GACnB,MAAM,KAAKA,CAAW;AAAA,EAC1B;AAAA;AAAA,EAGA,OAAOrB,GAAoBuB,GAAsBqF,GACjD;AACU,UAAA,EAAE,IAAAC,EAAO,IAAA7G,GACT,EAAE,OAAA8G,GAAO,QAAAC,EAAW,IAAA;AAEvB,IAAAF,EAAA;AAAA,MACCA,EAAG;AAAA,MACHtF,EAAQ,cAAc,UAAaA,EAAQ,cAAcyF,GAAY;AAAA,IAAA,GAGrEJ,EAAU,UAAU,MAEnBA,EAAkB,QAAQE,GAC1BF,EAAkB,SAASG,GAEzBF,EAAA;AAAA,MAAWtF,EAAQ;AAAA,MAAQ;AAAA,MAC1BA,EAAQ;AAAA,MACRuF;AAAA,MACAC;AAAA,MACA;AAAA,MACAxF,EAAQ;AAAA,MACRA,EAAQ;AAAA,MACR;AAAA,IAAA;AAGR,UAAM0F,IAAU,KAAK,SACfR,IAAQ,KAAK;AAEf,IAAAQ,KAAW,CAAC,KAAK,iBAEjB,KAAK,eAAe,IAAI,WAAW9G,EAAS,gBAAgBA,EAAS,gBAAgB,CAAC;AAG1F,aAASa,IAAI,GAAGA,IAAIyF,EAAM,QAAQzF,KAClC;AACU,YAAAkG,IAAMT,EAAMzF,CAAC,GACbkF,IAAMgB,EAAI;AAEhB,UAAIN,EAAU,WAAW,KAAK,MAAM5F,CAAC,EAAE;AAEnC;AAGJ,YAAMmG,IAAMjB,EAAI;AAEhB,MAAI,CAACA,EAAI,SAAS,CAACiB,KAAO,CAACA,EAAI,WAI3BF,MAAYf,EAAI,QAAQ,KAAK,aAAaA,EAAI,SAAS,KAAK,cAEzDW,EAAA;AAAA,QAActF,EAAQ;AAAA,QAAQ;AAAA,QAC7B2F,EAAI;AAAA,QACJA,EAAI;AAAA,QACJ,KAAK;AAAA,QACL,KAAK;AAAA,QACL3F,EAAQ;AAAA,QACRA,EAAQ;AAAA,QACR,KAAK;AAAA,MAAA,GAGVsF,EAAA;AAAA,QAActF,EAAQ;AAAA,QAAQ;AAAA,QAC7B2F,EAAI;AAAA,QACJA,EAAI;AAAA,QACJ3F,EAAQ;AAAA,QACRA,EAAQ;AAAA,QACR4F,EAAI;AAAA,MAAA;AAAA,IACZ;AAEO,WAAA;AAAA,EACX;AACJ;ACrKA,SAASC,GAAkBC,GAC3B;AACI,MAAIC,IAAM;AAEH,EAAAA,KAAA;AAAA,GACAA,KAAA;AAAA,GAEAA,KAAA,4BACAA,KAAA;AAAA,wBACAA,KAAA;AAAA;AAEP,WAAStG,IAAI,GAAGA,IAAIqG,GAAarG;AAEtB,IAAAsG,KAAA;AAAA,QAEHtG,IAAIqG,IAAc,MAElBC,KAAO,mBAAmBtG,SAGvBsG,KAAA;AAAA,IACAA,KAAA;AAAA,+BAAmCtG,mCAAmCA,QACtEsG,KAAA;AAAA;AAGJ,SAAAA,KAAA;AAAA,GACAA,KAAA;AAAA,GAEAA;AACX;AAQgB,SAAAC,GAAarE,GAAuBmE,GACpD;AACI,QAAMG,IAA8B,CAAA;AAEpC,WAASxG,IAAI,GAAGA,IAAIqG,GAAarG;AAE7B,IAAAwG,EAAaxG,CAAC,IAAIA;AAGtB,EAAAkC,EAAO,SAAS,YAAYsE;AAE5B,QAAMC,IAA6B,CAAA;AAEnC,WAASzG,IAAI,GAAGA,IAAIqG,GAAarG;AAGjB,IAAAyG,EAAA,KAAK,IAAM,IAAI,GACfA,EAAA,KAAK,IAAM,IAAI;AAG/B,EAAAvE,EAAO,SAAS,eAAeuE;AACnC;AASgB,SAAAC,GAAoBL,GAAqBM,GACzD;AACW,SAAAA,EAAY,QAAQ,aAAa,GAAGN,GAAa,EACnD,QAAQ,eAAeD,GAAkBC,CAAW,CAAC;AAC9D;AC3EA,MAAMO,KAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAiC3BC,KAA6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8B5B,MAAMC,UAAsBC,GACnC;AAAA,EAGI,YAAYV,GACZ;AACC;AAAA,MACI,IAAIW;AAAA,QACGJ;AAAA,QACAK,GAAoCZ,GAAaQ,EAA0B;AAAA,MAC/E;AAAA,MACH;AAAA,QACI,gBAAgB,IAAI,aAAa,CAAC;AAAA,QAClC,WAAW,CAAC;AAAA,QACZ,cAAc,CAAC;AAAA,QACf,iBAAiB,IAAIK,GAAO;AAAA,MAChC;AAAA,IAAA,GAdS,KAAA,cAAA,GAiBb,KAAK,cAAcb,GACHc,GAAa,MAAM,KAAK,WAAW;AAAA,EACpD;AACJ;AAEO,MAAMC,UAAwBC,GACrC;AAAA,EAMI,cACA;AACO,aAPI,KAAA,WAAA,IACG,KAAA,cAAA,GACd,KAAA,SAAS,KAAK,WAAW,GACR,KAAA,iBAAA;AAMV,UAAAC,IAAM,KAAK,MAAM,IAAIC,GAAO,IAAI,aAAa,CAAC,GAAG,IAAM,EAAK;AAElE,SAAK,aAAa,mBAAmBD,GAAK,GAAG,IAAO,GAAG,KAAK,QAAQ,CAAC,EAChE,aAAa,iBAAiBA,GAAK,GAAG,IAAO,GAAG,KAAK,QAAQ,IAAI,CAAC,EAClE,aAAa,UAAUA,GAAK,GAAG,IAAO,GAAG,KAAK,QAAQ,IAAI,CAAC,EAC3D,aAAa,SAASA,GAAK,GAAG,IAAO,GAAG,KAAK,QAAQ,IAAI,CAAC,EAC1D,aAAa,cAAcA,GAAK,GAAG,IAAO,GAAG,KAAK,QAAQ,KAAK,CAAC,EAC7D,aAAa,gBAAgBA,GAAK,GAAG,IAAO,GAAG,KAAK,QAAQ,KAAK,CAAC,EAClE,aAAa,UAAUA,GAAK,GAAG,IAAO,GAAG,KAAK,QAAQ,KAAK,CAAC;AAAA,EACrE;AAGJ;ACxGO,MAAME,WAAqBC,GAClC;AAAA;AAAA,EAsBI,YAAYzI,GACZ;AACC,UAAMA,CAAQ,GAnBR,KAAA,WAAW,CAAC,GAAG,CAAC,GAEvB,KAAQ,QAAQ,GAGhB,KAAQ,cAAsB,MAS9B,KAAQ,WAAmC,IAO1C,KAAK,SAAS,IAAI8H,EAAc3H,EAAS,oBAAoB,GAC7D,KAAK,cAAc,IAAIoI,GAAO,QAAW,IAAM,EAAI,GACnD,KAAK,iBAAiB,GAAI,GAC1B,KAAK,aAAa;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,iBAAiBvI,GAAoBoD,GACrC;AACC,UAAMsF,IAAMtF,EAAS,QACZF,IAAS,KAAK,QACjBmE,IAAclH,EAAS,sBACpBsH,IAA6BvE,EAAO,SAAS;AAElD,QAAA,EAAAwF,IAAMvI,EAAS,gBAAgBkH,IAM5B;AAAA,UAAAlH,EAAS,iBAAiB;AAG1B,iBAASa,IAAI,GAAGA,IAAIoC,EAAS,QAAQpC,KACrC;AACU,gBAAAO,IAAU6B,EAASpC,CAAC;AAE1B,cAAI,CAACO,KAAW,CAACA,EAAQ;AAErB;AAGJ,UAAAvB,EAAS,QAAQ,KAAKoD,EAASpC,CAAC,GAAGA,CAAC,GAEpCyG,EAAYzG,IAAI,CAAC,IAAI,IAAMoC,EAASpC,CAAC,EAAE,WACvCyG,EAAazG,IAAI,IAAK,CAAC,IAAI,IAAMoC,EAASpC,CAAC,EAAE;AAAA,QACjD;AAAA,WAGJ;AAEI,aAAK,aAAa;AAElB,cAAM2H,IAAe,KAAK,KAAKD,IAAMvI,EAAS,aAAa;AAG3D,iBAASa,IAAI,GAAGA,IAAI0H,GAAK1H,KACzB;AACU,gBAAAO,IAAU6B,EAASpC,CAAC;AAEtB,cAAAO,KAAWA,EAAQ,OACvB;AACI,kBAAMqH,IAAgB,KAAK,MAAM5H,IAAIb,EAAS,aAAa,GACrD6F,IAAYhF,IAAIb,EAAS;AAE/B,iBAAK,SAASyI,CAAa,EAAE,KAAK5C,GAAWzE,CAAO;AAAA,UACxD;AAAA,QACJ;AAGA,iBAASP,IAAI,GAAGA,IAAI2H,GAAc3H;AAE9B,UAAAhB,EAAS,QAAQ,KAAK,KAAK,SAASgB,CAAC,EAAE,aAAaA,CAAC,GAErDyG,EAAYzG,IAAI,CAAC,IAAI,IAAM,KAAK,SAASA,CAAC,EAAE,OAC/ByG,EAAAzG,IAAI,IAAK,CAAC,IAAI,IAAM,KAAK,SAASA,CAAC,EAAE,YAAY;AAAA,MAEtE;AAEA,MAAAkC,EAAO,SAAS,eAAeuE;AAAA;AAAA,EACnC;AAAA,EAEA,QACA;AAAA,EAEA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WACA;AACO,UAAAoB,IAAO,IAAIT;AAEZ,WAAAS,EAAA,SAAS,KAAK,WAAW,GACzBA,EAAA,iBAAiB,KAAK,OAEpBA;AAAA,EACR;AAAA;AAAA,EAGA,YAA2B;AAAE,WAAO,KAAK;AAAA,EAAQ;AAAA,EAEjD,UACA;AACC,UAAM,QAAQ,GAEd,KAAK,SAAS;AAAA,EACf;AAAA;AAAA,EAGO,iBAAiBC,GAAcC,IAAuB,MAC7D;AACC,UAAMC,IAAeF,IAAO;AAExB,IAAAE,KAAgB,KAAK,UAYzB,KAAK,QAAQA,GACR,KAAA,YAAY,OAAOC,GAAM;AAAA,MAAsBH;AAAA,MAChD3I,EAAS,gBAAgB,IAAI,YAAY2I,IAAO,CAAC,IAAI;AAAA,IAAA,CAAU;AAAA,EASpE;AAAA;AAAA,EAGQ,eACR;AACK,QAAA,EAAA3I,EAAS,iBAAiB;AAK9B,eAASa,IAAI,GAAGA,IAAIb,EAAS,eAAea,KAC5C;AACW,YAAA,KAAK,SAASA,CAAC;AAAG;AAEhB,cAAAkI,IAAW,IAAI3C,KAClB4C,IAAU,IAAIC,GAAYF,CAAQ;AAExC,QAAAC,EAAQ,YAAYhJ,EAAS,oBAC7BgJ,EAAQ,WAAWE,GAAW,OAEtB,KAAA,SAASrI,CAAC,IAAIkI;AAAA,MAC1B;AAAA,EACD;AACJ;ACvLO,MAAMI,KAAe;AAAA,EACxB,oBAAAvJ;AAAA,EACA,wBAAwByF;AAAA,EACxB,kBAAAA;AAAA,EACA,UAAAlF;AAAA,EACA,iBAAAiG;AAAA,EACA,sBAAsBA;AAAA,EACtB,eAAe7F;AAAA,EACf,SAAAA;AAAA,EACA,eAAAoH;AAAA,EACA,iBAAAM;AAAA,EACA,gBAAgBN;AAAA,EAChB,cAAcM;AAAA,EACd,cAAAI;AACJ;AAcAvI,EAAW,IAAI;AAAA,EACX,MAAM;AAAA,EACN,MAAMC,EAAc;AAAA,EACpB,KAAKsI;AACT,CAAC;"}