(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.RpgCommon = {}));
})(this, function(exports2) {
  "use strict";
  function random(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
  }
  function isBrowser() {
    return typeof window !== "undefined";
  }
  function isFunction$2(val) {
    return {}.toString.call(val) === "[object Function]";
  }
  function isClass(func) {
    return typeof func === "function";
  }
  function isPromise$1(val) {
    return isInstanceOf(val, Promise);
  }
  function isArray$2(val) {
    return isInstanceOf(val, Array);
  }
  function isObject$1(val) {
    return typeof val == "object" && val != null && !isArray$2(val);
  }
  function isString$1(val) {
    return typeof val == "string";
  }
  function isInstanceOf(val, _class) {
    return val instanceof _class;
  }
  function arrayUniq(array) {
    return [...new Set(array)];
  }
  function arrayFlat(array) {
    return array.reduce((acc, val) => acc.concat(val), []);
  }
  function intersection([start1, end1], [start2, end2]) {
    return start1 >= start2 && start1 <= end2 || start2 >= start1 && start2 < end1;
  }
  function capitalize(s) {
    if (typeof s !== "string")
      return "";
    return s.charAt(0).toUpperCase() + s.slice(1);
  }
  function camelToKebab(str) {
    return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  function arrayEquals(a, b) {
    return a.length === b.length && a.every((v2, i) => v2 === b[i]);
  }
  function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach((baseCtor) => {
      Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
        const baseCtorName = Object.getOwnPropertyDescriptor(baseCtor.prototype, name);
        if (!baseCtorName) {
          return;
        }
        Object.defineProperty(derivedCtor.prototype, name, baseCtorName);
      });
    });
  }
  function generateUID() {
    let firstPart = Math.random() * 46656 | 0;
    let secondPart = Math.random() * 46656 | 0;
    firstPart = ("000" + firstPart.toString(36)).slice(-3);
    secondPart = ("000" + secondPart.toString(36)).slice(-3);
    return firstPart + secondPart;
  }
  function createConstructor(...propNames) {
    return class {
      constructor(...propValues) {
        propNames.forEach((name, idx) => {
          this[name] = propValues[idx];
        });
      }
    };
  }
  function sharedArrayBuffer() {
    let buffer2;
    if (typeof SharedArrayBuffer != "undefined") {
      buffer2 = SharedArrayBuffer;
    } else {
      buffer2 = ArrayBuffer;
    }
    return buffer2;
  }
  function toRadians(angle) {
    return angle * (Math.PI / 180);
  }
  function hexaToNumber(hexa) {
    let val = hexa.replace("#", "");
    let alpha = 1;
    if (val.length === 3) {
      val = val.split("").map((v2) => v2 + v2).join("");
    }
    if (val.length === 8) {
      alpha = parseInt(val.substring(0, 2), 16) / 255;
      val = val.substring(2);
    }
    return {
      value: parseInt(val, 16),
      alpha
    };
  }
  function extractId(path) {
    const id = path.match(/([a-zA-Z0-9-_$!]+)\.[a-z0-9]+$/i);
    if (!id)
      return null;
    return id[1];
  }
  function basename(path) {
    return path.substring(path.lastIndexOf("/") + 1);
  }
  function fps2ms(fps) {
    return 1e3 / fps;
  }
  function preciseNow() {
    return typeof performance !== "undefined" ? performance.now() : Date.now();
  }
  function round(num, decimals = 100) {
    return Math.round(num * decimals) / decimals;
  }
  function set(obj, path, value, onlyPlainObject = false) {
    if (Object(obj) !== obj)
      return obj;
    if (!Array.isArray(path))
      path = path.toString().match(/[^.[\]]+/g) || [];
    path.slice(0, -1).reduce(
      (a, c, i) => (
        // Iterate all of them except the last one
        Object(a[c]) === a[c] ? a[c] : a[c] = Math.abs(path[i + 1]) >> 0 === +path[i + 1] ? onlyPlainObject ? {} : [] : {}
      ),
      // No: assign a new plain object
      obj
    )[path[path.length - 1]] = value;
    return obj;
  }
  function elementToPositionAbsolute(element) {
    element.style.position = "absolute";
    element.style.top = "0";
    element.style.left = "0";
    element.style.right = "0";
    element.style.bottom = "0";
    element.style.width = "100%";
    element.style.height = "100%";
  }
  const Utils = {
    random,
    isBrowser,
    isPromise: isPromise$1,
    isArray: isArray$2,
    isObject: isObject$1,
    isString: isString$1,
    isFunction: isFunction$2,
    isClass,
    isInstanceOf,
    arrayUniq,
    arrayFlat,
    arrayEquals,
    intersection,
    applyMixins,
    capitalize,
    sharedArrayBuffer,
    generateUID,
    createConstructor,
    toRadians,
    extractId,
    basename,
    fps2ms,
    preciseNow,
    hexaToNumber,
    set,
    round,
    camelToKebab,
    elementToPositionAbsolute
  };
  const Utils$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    applyMixins,
    arrayEquals,
    arrayFlat,
    arrayUniq,
    basename,
    camelToKebab,
    capitalize,
    createConstructor,
    default: Utils,
    elementToPositionAbsolute,
    extractId,
    fps2ms,
    generateUID,
    hexaToNumber,
    intersection,
    isArray: isArray$2,
    isBrowser,
    isClass,
    isFunction: isFunction$2,
    isInstanceOf,
    isObject: isObject$1,
    isPromise: isPromise$1,
    isString: isString$1,
    preciseNow,
    random,
    round,
    set,
    sharedArrayBuffer,
    toRadians
  }, Symbol.toStringTag, { value: "Module" }));
  var HitType;
  (function(HitType2) {
    HitType2["Box"] = "box";
    HitType2["Circle"] = "circle";
    HitType2["Polygon"] = "polygon";
  })(HitType || (HitType = {}));
  var MoveClientMode;
  (function(MoveClientMode2) {
    MoveClientMode2[MoveClientMode2["Disabled"] = 0] = "Disabled";
    MoveClientMode2[MoveClientMode2["ByDirection"] = 1] = "ByDirection";
    MoveClientMode2[MoveClientMode2["Drag"] = 2] = "Drag";
  })(MoveClientMode || (MoveClientMode = {}));
  var Behavior;
  (function(Behavior2) {
    Behavior2[Behavior2["Direction"] = 0] = "Direction";
    Behavior2[Behavior2["Target"] = 1] = "Target";
  })(Behavior || (Behavior = {}));
  exports2.Direction = void 0;
  (function(Direction) {
    Direction[Direction["Up"] = 1] = "Up";
    Direction[Direction["Down"] = 3] = "Down";
    Direction[Direction["Left"] = 4] = "Left";
    Direction[Direction["Right"] = 2] = "Right";
    Direction[Direction["UpRight"] = 1.5] = "UpRight";
    Direction[Direction["DownRight"] = 2.5] = "DownRight";
    Direction[Direction["DownLeft"] = 3.5] = "DownLeft";
    Direction[Direction["UpLeft"] = 2.5] = "UpLeft";
  })(exports2.Direction || (exports2.Direction = {}));
  var PlayerType;
  (function(PlayerType2) {
    PlayerType2["Player"] = "player";
    PlayerType2["Event"] = "event";
    PlayerType2["Shape"] = "shape";
  })(PlayerType || (PlayerType = {}));
  var SocketMethods;
  (function(SocketMethods2) {
    SocketMethods2["CameraFollow"] = "cameraFollow";
    SocketMethods2["ShowAnimation"] = "showAnimation";
    SocketMethods2["PlaySound"] = "playSound";
    SocketMethods2["ModeMove"] = "modeMove";
  })(SocketMethods || (SocketMethods = {}));
  var SocketEvents;
  (function(SocketEvents2) {
    SocketEvents2["CallMethod"] = "callMethod";
    SocketEvents2["GameReload"] = "gameReload";
    SocketEvents2["ChangeServer"] = "changeServer";
    SocketEvents2["LoadScene"] = "loadScene";
  })(SocketEvents || (SocketEvents = {}));
  exports2.Control = void 0;
  (function(Control) {
    Control["Action"] = "action";
    Control["Attack"] = "attack";
    Control["Defense"] = "defense";
    Control["Skill"] = "skill";
    Control["Back"] = "back";
    Control[Control["Up"] = 1] = "Up";
    Control[Control["Down"] = 3] = "Down";
    Control[Control["Right"] = 2] = "Right";
    Control[Control["Left"] = 4] = "Left";
  })(exports2.Control || (exports2.Control = {}));
  exports2.Input = void 0;
  (function(Input) {
    Input["Break"] = "break";
    Input["Backspace"] = "backspace";
    Input["Tab"] = "tab";
    Input["Clear"] = "clear";
    Input["Enter"] = "enter";
    Input["Shift"] = "shift";
    Input["Ctrl"] = "ctrl";
    Input["Alt"] = "alt";
    Input["Pause"] = "pause/break";
    Input["CapsLock"] = "caps lock";
    Input["Escape"] = "escape";
    Input["Conversion"] = "conversion";
    Input["NonConversion"] = "non-conversion";
    Input["Space"] = "space";
    Input["PageUp"] = "page up";
    Input["PageDown"] = "page down";
    Input["End"] = "end";
    Input["Home"] = "home";
    Input[Input["Left"] = 4] = "Left";
    Input[Input["Up"] = 1] = "Up";
    Input[Input["Right"] = 2] = "Right";
    Input[Input["Down"] = 3] = "Down";
    Input["Select"] = "select";
    Input["Print"] = "print";
    Input["Execute"] = "execute";
    Input["PrintScreen"] = "Print Screen";
    Input["Insert"] = "insert";
    Input["Delete"] = "delete";
    Input["Zero"] = "0";
    Input["One"] = "1";
    Input["Two"] = "2";
    Input["Three"] = "3";
    Input["Four"] = "4";
    Input["Five"] = "5";
    Input["Six"] = "6";
    Input["Seven"] = "7";
    Input["Height"] = "8";
    Input["Nine"] = "9";
    Input["Equal"] = "=";
    Input["Semicolon"] = "semicolon (firefox), equals";
    Input["LessThan"] = "<";
    Input["Equals"] = "equals (firefox)";
    Input["Beta"] = "ÃŸ";
    Input["At"] = "@";
    Input["A"] = "a";
    Input["B"] = "b";
    Input["C"] = "c";
    Input["D"] = "d";
    Input["E"] = "e";
    Input["F"] = "f";
    Input["G"] = "g";
    Input["H"] = "h";
    Input["I"] = "i";
    Input["J"] = "j";
    Input["K"] = "k";
    Input["L"] = "l";
    Input["M"] = "m";
    Input["N"] = "n";
    Input["O"] = "o";
    Input["P"] = "p";
    Input["Q"] = "q";
    Input["R"] = "r";
    Input["S"] = "s";
    Input["T"] = "t";
    Input["U"] = "u";
    Input["V"] = "v";
    Input["W"] = "w";
    Input["X"] = "x";
    Input["Y"] = "y";
    Input["Z"] = "z";
    Input["SearchKey"] = "Windows Key / Left âŒ˜ / Chromebook Search key";
    Input["NumPad0"] = "numpad 0";
    Input["NumPad1"] = "numpad 1";
    Input["NumPad2"] = "numpad 2";
    Input["NumPad3"] = "numpad 3";
    Input["NumPad4"] = "numpad 4";
    Input["NumPad5"] = "numpad 5";
    Input["NumPad6"] = "numpad 6";
    Input["NumPad7"] = "numpad 7";
    Input["NumPad8"] = "numpad 8";
    Input["NumPad9"] = "numpad 9";
    Input["Multiply"] = "multiply";
    Input["Add"] = "add";
    Input["Subtract"] = "subtract";
    Input["DecimalPoint"] = "decimal point";
    Input["Divide"] = "divide";
    Input["F1"] = "f1";
    Input["F2"] = "f2";
    Input["F3"] = "f3";
    Input["F4"] = "f4";
    Input["F5"] = "f5";
    Input["F6"] = "f6";
    Input["F7"] = "f7";
    Input["F8"] = "f8";
    Input["F9"] = "f9";
    Input["F10"] = "f10";
    Input["F11"] = "f11";
    Input["F12"] = "f12";
    Input["F13"] = "f13";
    Input["F14"] = "f14";
    Input["F15"] = "f15";
    Input["F16"] = "f16";
    Input["F17"] = "f17";
    Input["F18"] = "f18";
    Input["F19"] = "f19";
    Input["F20"] = "f20";
    Input["F21"] = "f21";
    Input["F22"] = "f22";
    Input["F23"] = "f23";
    Input["F24"] = "f24";
    Input["NumLock"] = "num lock";
    Input["ScrollLock"] = "scroll lock";
    Input["CircumflexAccent"] = "^";
    Input["ExclamationMark"] = "!";
    Input["Hash"] = "#";
    Input["Dollar"] = "$";
    Input["AccentU"] = "Ã¹";
    Input["PageBackward"] = "page backward";
    Input["PageForWard"] = "page forward";
    Input["Star"] = "*";
    Input["DecreaseVolume"] = "decrease volume level";
    Input["IncreaseVolume"] = "increase volume level";
    Input["Next"] = "next";
    Input["Previous"] = "previous";
    Input["Stop"] = "stop";
    Input["PlayPause"] = "play/pause";
    Input["Email"] = "e-mail";
    Input["SemiColon"] = "semi-colon / Ã±";
    Input["EqualSign"] = "equal sign";
    Input["Comma"] = "comma";
    Input["Dash"] = "dash";
    Input["FowardSlach"] = "forward slash / Ã§";
    Input["GraveAccent"] = "grave accent / Ã± / Ã¦";
    Input["OpenBracket"] = "open bracket";
    Input["BackSlach"] = "back slash";
    Input["CloseBracket"] = "close bracket / Ã¥";
    Input["SingleQuote"] = "single quote / Ã¸";
    Input["BackQuote"] = "`";
    Input["Altgr"] = "altgr";
  })(exports2.Input || (exports2.Input = {}));
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getAugmentedNamespace(n) {
    if (n.__esModule)
      return n;
    var f = n.default;
    if (typeof f == "function") {
      var a = function a2() {
        if (this instanceof a2) {
          var args = [null];
          args.push.apply(args, arguments);
          var Ctor = Function.bind.apply(f, args);
          return new Ctor();
        }
        return f.apply(this, arguments);
      };
      a.prototype = f.prototype;
    } else
      a = {};
    Object.defineProperty(a, "__esModule", {
      value: true
    });
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  }
  var SATExports = {};
  var SAT = {
    get exports() {
      return SATExports;
    },
    set exports(v2) {
      SATExports = v2;
    }
  };
  (function(module2, exports3) {
    /** @preserve SAT.js - Version 0.9.0 - Copyright 2012 - 2021 - Jim Riecken <jimr@jimr.ca> - released under the MIT License. https://github.com/jriecken/sat-js */
    (function(root, factory) {
      {
        module2["exports"] = factory();
      }
    })(commonjsGlobal, function() {
      var SAT2 = {};
      function Vector(x, y) {
        this["x"] = x || 0;
        this["y"] = y || 0;
      }
      SAT2["Vector"] = Vector;
      SAT2["V"] = Vector;
      Vector.prototype["copy"] = Vector.prototype.copy = function(other) {
        this["x"] = other["x"];
        this["y"] = other["y"];
        return this;
      };
      Vector.prototype["clone"] = Vector.prototype.clone = function() {
        return new Vector(this["x"], this["y"]);
      };
      Vector.prototype["perp"] = Vector.prototype.perp = function() {
        var x = this["x"];
        this["x"] = this["y"];
        this["y"] = -x;
        return this;
      };
      Vector.prototype["rotate"] = Vector.prototype.rotate = function(angle) {
        var x = this["x"];
        var y = this["y"];
        this["x"] = x * Math.cos(angle) - y * Math.sin(angle);
        this["y"] = x * Math.sin(angle) + y * Math.cos(angle);
        return this;
      };
      Vector.prototype["reverse"] = Vector.prototype.reverse = function() {
        this["x"] = -this["x"];
        this["y"] = -this["y"];
        return this;
      };
      Vector.prototype["normalize"] = Vector.prototype.normalize = function() {
        var d = this.len();
        if (d > 0) {
          this["x"] = this["x"] / d;
          this["y"] = this["y"] / d;
        }
        return this;
      };
      Vector.prototype["add"] = Vector.prototype.add = function(other) {
        this["x"] += other["x"];
        this["y"] += other["y"];
        return this;
      };
      Vector.prototype["sub"] = Vector.prototype.sub = function(other) {
        this["x"] -= other["x"];
        this["y"] -= other["y"];
        return this;
      };
      Vector.prototype["scale"] = Vector.prototype.scale = function(x, y) {
        this["x"] *= x;
        this["y"] *= typeof y != "undefined" ? y : x;
        return this;
      };
      Vector.prototype["project"] = Vector.prototype.project = function(other) {
        var amt = this.dot(other) / other.len2();
        this["x"] = amt * other["x"];
        this["y"] = amt * other["y"];
        return this;
      };
      Vector.prototype["projectN"] = Vector.prototype.projectN = function(other) {
        var amt = this.dot(other);
        this["x"] = amt * other["x"];
        this["y"] = amt * other["y"];
        return this;
      };
      Vector.prototype["reflect"] = Vector.prototype.reflect = function(axis) {
        var x = this["x"];
        var y = this["y"];
        this.project(axis).scale(2);
        this["x"] -= x;
        this["y"] -= y;
        return this;
      };
      Vector.prototype["reflectN"] = Vector.prototype.reflectN = function(axis) {
        var x = this["x"];
        var y = this["y"];
        this.projectN(axis).scale(2);
        this["x"] -= x;
        this["y"] -= y;
        return this;
      };
      Vector.prototype["dot"] = Vector.prototype.dot = function(other) {
        return this["x"] * other["x"] + this["y"] * other["y"];
      };
      Vector.prototype["len2"] = Vector.prototype.len2 = function() {
        return this.dot(this);
      };
      Vector.prototype["len"] = Vector.prototype.len = function() {
        return Math.sqrt(this.len2());
      };
      function Circle(pos, r) {
        this["pos"] = pos || new Vector();
        this["r"] = r || 0;
        this["offset"] = new Vector();
      }
      SAT2["Circle"] = Circle;
      Circle.prototype["getAABBAsBox"] = Circle.prototype.getAABBAsBox = function() {
        var r = this["r"];
        var corner = this["pos"].clone().add(this["offset"]).sub(new Vector(r, r));
        return new Box(corner, r * 2, r * 2);
      };
      Circle.prototype["getAABB"] = Circle.prototype.getAABB = function() {
        return this.getAABBAsBox().toPolygon();
      };
      Circle.prototype["setOffset"] = Circle.prototype.setOffset = function(offset) {
        this["offset"] = offset;
        return this;
      };
      function Polygon(pos, points) {
        this["pos"] = pos || new Vector();
        this["angle"] = 0;
        this["offset"] = new Vector();
        this.setPoints(points || []);
      }
      SAT2["Polygon"] = Polygon;
      Polygon.prototype["setPoints"] = Polygon.prototype.setPoints = function(points) {
        var lengthChanged = !this["points"] || this["points"].length !== points.length;
        if (lengthChanged) {
          var i2;
          var calcPoints = this["calcPoints"] = [];
          var edges = this["edges"] = [];
          var normals = this["normals"] = [];
          for (i2 = 0; i2 < points.length; i2++) {
            var p1 = points[i2];
            var p2 = i2 < points.length - 1 ? points[i2 + 1] : points[0];
            if (p1 !== p2 && p1.x === p2.x && p1.y === p2.y) {
              points.splice(i2, 1);
              i2 -= 1;
              continue;
            }
            calcPoints.push(new Vector());
            edges.push(new Vector());
            normals.push(new Vector());
          }
        }
        this["points"] = points;
        this._recalc();
        return this;
      };
      Polygon.prototype["setAngle"] = Polygon.prototype.setAngle = function(angle) {
        this["angle"] = angle;
        this._recalc();
        return this;
      };
      Polygon.prototype["setOffset"] = Polygon.prototype.setOffset = function(offset) {
        this["offset"] = offset;
        this._recalc();
        return this;
      };
      Polygon.prototype["rotate"] = Polygon.prototype.rotate = function(angle) {
        var points = this["points"];
        var len = points.length;
        for (var i2 = 0; i2 < len; i2++) {
          points[i2].rotate(angle);
        }
        this._recalc();
        return this;
      };
      Polygon.prototype["translate"] = Polygon.prototype.translate = function(x, y) {
        var points = this["points"];
        var len = points.length;
        for (var i2 = 0; i2 < len; i2++) {
          points[i2]["x"] += x;
          points[i2]["y"] += y;
        }
        this._recalc();
        return this;
      };
      Polygon.prototype._recalc = function() {
        var calcPoints = this["calcPoints"];
        var edges = this["edges"];
        var normals = this["normals"];
        var points = this["points"];
        var offset = this["offset"];
        var angle = this["angle"];
        var len = points.length;
        var i2;
        for (i2 = 0; i2 < len; i2++) {
          var calcPoint = calcPoints[i2].copy(points[i2]);
          calcPoint["x"] += offset["x"];
          calcPoint["y"] += offset["y"];
          if (angle !== 0) {
            calcPoint.rotate(angle);
          }
        }
        for (i2 = 0; i2 < len; i2++) {
          var p1 = calcPoints[i2];
          var p2 = i2 < len - 1 ? calcPoints[i2 + 1] : calcPoints[0];
          var e = edges[i2].copy(p2).sub(p1);
          normals[i2].copy(e).perp().normalize();
        }
        return this;
      };
      Polygon.prototype["getAABBAsBox"] = Polygon.prototype.getAABBAsBox = function() {
        var points = this["calcPoints"];
        var len = points.length;
        var xMin = points[0]["x"];
        var yMin = points[0]["y"];
        var xMax = points[0]["x"];
        var yMax = points[0]["y"];
        for (var i2 = 1; i2 < len; i2++) {
          var point = points[i2];
          if (point["x"] < xMin) {
            xMin = point["x"];
          } else if (point["x"] > xMax) {
            xMax = point["x"];
          }
          if (point["y"] < yMin) {
            yMin = point["y"];
          } else if (point["y"] > yMax) {
            yMax = point["y"];
          }
        }
        return new Box(this["pos"].clone().add(new Vector(xMin, yMin)), xMax - xMin, yMax - yMin);
      };
      Polygon.prototype["getAABB"] = Polygon.prototype.getAABB = function() {
        return this.getAABBAsBox().toPolygon();
      };
      Polygon.prototype["getCentroid"] = Polygon.prototype.getCentroid = function() {
        var points = this["calcPoints"];
        var len = points.length;
        var cx = 0;
        var cy = 0;
        var ar = 0;
        for (var i2 = 0; i2 < len; i2++) {
          var p1 = points[i2];
          var p2 = i2 === len - 1 ? points[0] : points[i2 + 1];
          var a = p1["x"] * p2["y"] - p2["x"] * p1["y"];
          cx += (p1["x"] + p2["x"]) * a;
          cy += (p1["y"] + p2["y"]) * a;
          ar += a;
        }
        ar = ar * 3;
        cx = cx / ar;
        cy = cy / ar;
        return new Vector(cx, cy);
      };
      function Box(pos, w, h) {
        this["pos"] = pos || new Vector();
        this["w"] = w || 0;
        this["h"] = h || 0;
      }
      SAT2["Box"] = Box;
      Box.prototype["toPolygon"] = Box.prototype.toPolygon = function() {
        var pos = this["pos"];
        var w = this["w"];
        var h = this["h"];
        return new Polygon(new Vector(pos["x"], pos["y"]), [
          new Vector(),
          new Vector(w, 0),
          new Vector(w, h),
          new Vector(0, h)
        ]);
      };
      function Response() {
        this["a"] = null;
        this["b"] = null;
        this["overlapN"] = new Vector();
        this["overlapV"] = new Vector();
        this.clear();
      }
      SAT2["Response"] = Response;
      Response.prototype["clear"] = Response.prototype.clear = function() {
        this["aInB"] = true;
        this["bInA"] = true;
        this["overlap"] = Number.MAX_VALUE;
        return this;
      };
      var T_VECTORS = [];
      for (var i = 0; i < 10; i++) {
        T_VECTORS.push(new Vector());
      }
      var T_ARRAYS = [];
      for (var i = 0; i < 5; i++) {
        T_ARRAYS.push([]);
      }
      var T_RESPONSE = new Response();
      var TEST_POINT = new Box(new Vector(), 1e-6, 1e-6).toPolygon();
      function flattenPointsOn(points, normal, result) {
        var min = Number.MAX_VALUE;
        var max = -Number.MAX_VALUE;
        var len = points.length;
        for (var i2 = 0; i2 < len; i2++) {
          var dot = points[i2].dot(normal);
          if (dot < min) {
            min = dot;
          }
          if (dot > max) {
            max = dot;
          }
        }
        result[0] = min;
        result[1] = max;
      }
      function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {
        var rangeA = T_ARRAYS.pop();
        var rangeB = T_ARRAYS.pop();
        var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);
        var projectedOffset = offsetV.dot(axis);
        flattenPointsOn(aPoints, axis, rangeA);
        flattenPointsOn(bPoints, axis, rangeB);
        rangeB[0] += projectedOffset;
        rangeB[1] += projectedOffset;
        if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {
          T_VECTORS.push(offsetV);
          T_ARRAYS.push(rangeA);
          T_ARRAYS.push(rangeB);
          return true;
        }
        if (response) {
          var overlap = 0;
          if (rangeA[0] < rangeB[0]) {
            response["aInB"] = false;
            if (rangeA[1] < rangeB[1]) {
              overlap = rangeA[1] - rangeB[0];
              response["bInA"] = false;
            } else {
              var option1 = rangeA[1] - rangeB[0];
              var option2 = rangeB[1] - rangeA[0];
              overlap = option1 < option2 ? option1 : -option2;
            }
          } else {
            response["bInA"] = false;
            if (rangeA[1] > rangeB[1]) {
              overlap = rangeA[0] - rangeB[1];
              response["aInB"] = false;
            } else {
              var option1 = rangeA[1] - rangeB[0];
              var option2 = rangeB[1] - rangeA[0];
              overlap = option1 < option2 ? option1 : -option2;
            }
          }
          var absOverlap = Math.abs(overlap);
          if (absOverlap < response["overlap"]) {
            response["overlap"] = absOverlap;
            response["overlapN"].copy(axis);
            if (overlap < 0) {
              response["overlapN"].reverse();
            }
          }
        }
        T_VECTORS.push(offsetV);
        T_ARRAYS.push(rangeA);
        T_ARRAYS.push(rangeB);
        return false;
      }
      SAT2["isSeparatingAxis"] = isSeparatingAxis;
      function voronoiRegion(line, point) {
        var len2 = line.len2();
        var dp = point.dot(line);
        if (dp < 0) {
          return LEFT_VORONOI_REGION;
        } else if (dp > len2) {
          return RIGHT_VORONOI_REGION;
        } else {
          return MIDDLE_VORONOI_REGION;
        }
      }
      var LEFT_VORONOI_REGION = -1;
      var MIDDLE_VORONOI_REGION = 0;
      var RIGHT_VORONOI_REGION = 1;
      function pointInCircle(p, c) {
        var differenceV = T_VECTORS.pop().copy(p).sub(c["pos"]).sub(c["offset"]);
        var radiusSq = c["r"] * c["r"];
        var distanceSq = differenceV.len2();
        T_VECTORS.push(differenceV);
        return distanceSq <= radiusSq;
      }
      SAT2["pointInCircle"] = pointInCircle;
      function pointInPolygon(p, poly) {
        TEST_POINT["pos"].copy(p);
        T_RESPONSE.clear();
        var result = testPolygonPolygon(TEST_POINT, poly, T_RESPONSE);
        if (result) {
          result = T_RESPONSE["aInB"];
        }
        return result;
      }
      SAT2["pointInPolygon"] = pointInPolygon;
      function testCircleCircle(a, b, response) {
        var differenceV = T_VECTORS.pop().copy(b["pos"]).add(b["offset"]).sub(a["pos"]).sub(a["offset"]);
        var totalRadius = a["r"] + b["r"];
        var totalRadiusSq = totalRadius * totalRadius;
        var distanceSq = differenceV.len2();
        if (distanceSq > totalRadiusSq) {
          T_VECTORS.push(differenceV);
          return false;
        }
        if (response) {
          var dist = Math.sqrt(distanceSq);
          response["a"] = a;
          response["b"] = b;
          response["overlap"] = totalRadius - dist;
          response["overlapN"].copy(differenceV.normalize());
          response["overlapV"].copy(differenceV).scale(response["overlap"]);
          response["aInB"] = a["r"] <= b["r"] && dist <= b["r"] - a["r"];
          response["bInA"] = b["r"] <= a["r"] && dist <= a["r"] - b["r"];
        }
        T_VECTORS.push(differenceV);
        return true;
      }
      SAT2["testCircleCircle"] = testCircleCircle;
      function testPolygonCircle(polygon, circle, response) {
        var circlePos = T_VECTORS.pop().copy(circle["pos"]).add(circle["offset"]).sub(polygon["pos"]);
        var radius = circle["r"];
        var radius2 = radius * radius;
        var points = polygon["calcPoints"];
        var len = points.length;
        var edge = T_VECTORS.pop();
        var point = T_VECTORS.pop();
        for (var i2 = 0; i2 < len; i2++) {
          var next = i2 === len - 1 ? 0 : i2 + 1;
          var prev = i2 === 0 ? len - 1 : i2 - 1;
          var overlap = 0;
          var overlapN = null;
          edge.copy(polygon["edges"][i2]);
          point.copy(circlePos).sub(points[i2]);
          if (response && point.len2() > radius2) {
            response["aInB"] = false;
          }
          var region = voronoiRegion(edge, point);
          if (region === LEFT_VORONOI_REGION) {
            edge.copy(polygon["edges"][prev]);
            var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);
            region = voronoiRegion(edge, point2);
            if (region === RIGHT_VORONOI_REGION) {
              var dist = point.len();
              if (dist > radius) {
                T_VECTORS.push(circlePos);
                T_VECTORS.push(edge);
                T_VECTORS.push(point);
                T_VECTORS.push(point2);
                return false;
              } else if (response) {
                response["bInA"] = false;
                overlapN = point.normalize();
                overlap = radius - dist;
              }
            }
            T_VECTORS.push(point2);
          } else if (region === RIGHT_VORONOI_REGION) {
            edge.copy(polygon["edges"][next]);
            point.copy(circlePos).sub(points[next]);
            region = voronoiRegion(edge, point);
            if (region === LEFT_VORONOI_REGION) {
              var dist = point.len();
              if (dist > radius) {
                T_VECTORS.push(circlePos);
                T_VECTORS.push(edge);
                T_VECTORS.push(point);
                return false;
              } else if (response) {
                response["bInA"] = false;
                overlapN = point.normalize();
                overlap = radius - dist;
              }
            }
          } else {
            var normal = edge.perp().normalize();
            var dist = point.dot(normal);
            var distAbs = Math.abs(dist);
            if (dist > 0 && distAbs > radius) {
              T_VECTORS.push(circlePos);
              T_VECTORS.push(normal);
              T_VECTORS.push(point);
              return false;
            } else if (response) {
              overlapN = normal;
              overlap = radius - dist;
              if (dist >= 0 || overlap < 2 * radius) {
                response["bInA"] = false;
              }
            }
          }
          if (overlapN && response && Math.abs(overlap) < Math.abs(response["overlap"])) {
            response["overlap"] = overlap;
            response["overlapN"].copy(overlapN);
          }
        }
        if (response) {
          response["a"] = polygon;
          response["b"] = circle;
          response["overlapV"].copy(response["overlapN"]).scale(response["overlap"]);
        }
        T_VECTORS.push(circlePos);
        T_VECTORS.push(edge);
        T_VECTORS.push(point);
        return true;
      }
      SAT2["testPolygonCircle"] = testPolygonCircle;
      function testCirclePolygon(circle, polygon, response) {
        var result = testPolygonCircle(polygon, circle, response);
        if (result && response) {
          var a = response["a"];
          var aInB = response["aInB"];
          response["overlapN"].reverse();
          response["overlapV"].reverse();
          response["a"] = response["b"];
          response["b"] = a;
          response["aInB"] = response["bInA"];
          response["bInA"] = aInB;
        }
        return result;
      }
      SAT2["testCirclePolygon"] = testCirclePolygon;
      function testPolygonPolygon(a, b, response) {
        var aPoints = a["calcPoints"];
        var aLen = aPoints.length;
        var bPoints = b["calcPoints"];
        var bLen = bPoints.length;
        for (var i2 = 0; i2 < aLen; i2++) {
          if (isSeparatingAxis(a["pos"], b["pos"], aPoints, bPoints, a["normals"][i2], response)) {
            return false;
          }
        }
        for (var i2 = 0; i2 < bLen; i2++) {
          if (isSeparatingAxis(a["pos"], b["pos"], aPoints, bPoints, b["normals"][i2], response)) {
            return false;
          }
        }
        if (response) {
          response["a"] = a;
          response["b"] = b;
          response["overlapV"].copy(response["overlapN"]).scale(response["overlap"]);
        }
        return true;
      }
      SAT2["testPolygonPolygon"] = testPolygonPolygon;
      return SAT2;
    });
  })(SAT);
  class HitClass {
    createObjectHitbox(x, y, z, w, h) {
      return new SATExports.Box(new SATExports.Vector(x, y - z), w, h);
    }
    getHitbox(obj, offset) {
      let hitbox, type;
      if (!offset)
        offset = {
          x: 0,
          y: 0
        };
      const x = obj.x + offset.x;
      const y = obj.y + offset.y;
      if ("ellipse" in obj || obj.type == HitType.Circle) {
        type = HitType.Circle;
        const radius = obj.width / 2;
        hitbox = new SATExports.Circle(new SATExports.Vector(x + radius, y + radius), radius);
      } else if ("polygon" in obj) {
        type = HitType.Polygon;
        hitbox = new SATExports.Polygon(new SATExports.Vector(x, y), obj.polygon.map((pos) => new SATExports.Vector(+pos.x, +pos.y)));
      } else if (!("polygon" in obj) && "width" in obj && "height" in obj) {
        type = HitType.Box;
        hitbox = new SATExports.Box(new SATExports.Vector(x, y), obj.width, obj.height);
      } else {
        hitbox = new SATExports.Vector(x, y);
        type = obj.type;
      }
      return {
        hitbox,
        type,
        name: obj.name
      };
    }
    testPolyCollision(type, hit1, hit2) {
      let collided = false;
      if (type == HitType.Box) {
        if (hit1.pos.x <= hit2.pos.x + hit2.w && hit1.pos.x + hit1.w >= hit2.pos.x && hit1.pos.y <= hit2.pos.y + hit2.h && hit1.h + hit1.pos.y >= hit2.pos.y) {
          return true;
        }
        return false;
      }
      if (isInstanceOf(hit1, SATExports.Box))
        hit1 = hit1.toPolygon();
      if (isInstanceOf(hit2, SATExports.Box))
        hit2 = hit2.toPolygon();
      switch (type) {
        case HitType.Circle:
          collided = SATExports.testPolygonCircle(hit1, hit2);
          break;
        case HitType.Polygon:
          collided = SATExports.testPolygonPolygon(hit1, hit2);
          break;
      }
      return collided;
    }
  }
  const Hit = new HitClass();
  var TiledLayerType;
  (function(TiledLayerType2) {
    TiledLayerType2["Tile"] = "tilelayer";
    TiledLayerType2["ObjectGroup"] = "objectgroup";
    TiledLayerType2["Image"] = "imagelayer";
    TiledLayerType2["Group"] = "group";
  })(TiledLayerType || (TiledLayerType = {}));
  var sax = {};
  var domain;
  function EventHandlers() {
  }
  EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
  function EventEmitter$1() {
    EventEmitter$1.init.call(this);
  }
  EventEmitter$1.EventEmitter = EventEmitter$1;
  EventEmitter$1.usingDomains = false;
  EventEmitter$1.prototype.domain = void 0;
  EventEmitter$1.prototype._events = void 0;
  EventEmitter$1.prototype._maxListeners = void 0;
  EventEmitter$1.defaultMaxListeners = 10;
  EventEmitter$1.init = function() {
    this.domain = null;
    if (EventEmitter$1.usingDomains) {
      if (domain.active)
        ;
    }
    if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  EventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || isNaN(n))
      throw new TypeError('"n" argument must be a positive number');
    this._maxListeners = n;
    return this;
  };
  function $getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter$1.defaultMaxListeners;
    return that._maxListeners;
  }
  EventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {
    return $getMaxListeners(this);
  };
  function emitNone(handler, isFn, self2) {
    if (isFn)
      handler.call(self2);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self2);
    }
  }
  function emitOne(handler, isFn, self2, arg1) {
    if (isFn)
      handler.call(self2, arg1);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self2, arg1);
    }
  }
  function emitTwo(handler, isFn, self2, arg1, arg2) {
    if (isFn)
      handler.call(self2, arg1, arg2);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self2, arg1, arg2);
    }
  }
  function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
    if (isFn)
      handler.call(self2, arg1, arg2, arg3);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self2, arg1, arg2, arg3);
    }
  }
  function emitMany(handler, isFn, self2, args) {
    if (isFn)
      handler.apply(self2, args);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].apply(self2, args);
    }
  }
  EventEmitter$1.prototype.emit = function emit2(type) {
    var er, handler, len, args, i, events, domain2;
    var doError = type === "error";
    events = this._events;
    if (events)
      doError = doError && events.error == null;
    else if (!doError)
      return false;
    domain2 = this.domain;
    if (doError) {
      er = arguments[1];
      if (domain2) {
        if (!er)
          er = new Error('Uncaught, unspecified "error" event');
        er.domainEmitter = this;
        er.domain = domain2;
        er.domainThrown = false;
        domain2.emit("error", er);
      } else if (er instanceof Error) {
        throw er;
      } else {
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
        err.context = er;
        throw err;
      }
      return false;
    }
    handler = events[type];
    if (!handler)
      return false;
    var isFn = typeof handler === "function";
    len = arguments.length;
    switch (len) {
      case 1:
        emitNone(handler, isFn, this);
        break;
      case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;
      case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;
      case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
      default:
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        emitMany(handler, isFn, this, args);
    }
    return true;
  };
  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    if (typeof listener !== "function")
      throw new TypeError('"listener" argument must be a function');
    events = target._events;
    if (!events) {
      events = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      if (events.newListener) {
        target.emit(
          "newListener",
          type,
          listener.listener ? listener.listener : listener
        );
        events = target._events;
      }
      existing = events[type];
    }
    if (!existing) {
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      } else {
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      }
      if (!existing.warned) {
        m = $getMaxListeners(target);
        if (m && m > 0 && existing.length > m) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          emitWarning(w);
        }
      }
    }
    return target;
  }
  function emitWarning(e) {
    typeof console.warn === "function" ? console.warn(e) : console.log(e);
  }
  EventEmitter$1.prototype.addListener = function addListener2(type, listener) {
    return _addListener(this, type, listener, false);
  };
  EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
  EventEmitter$1.prototype.prependListener = function prependListener2(type, listener) {
    return _addListener(this, type, listener, true);
  };
  function _onceWrap(target, type, listener) {
    var fired = false;
    function g() {
      target.removeListener(type, g);
      if (!fired) {
        fired = true;
        listener.apply(target, arguments);
      }
    }
    g.listener = listener;
    return g;
  }
  EventEmitter$1.prototype.once = function once2(type, listener) {
    if (typeof listener !== "function")
      throw new TypeError('"listener" argument must be a function');
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };
  EventEmitter$1.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    if (typeof listener !== "function")
      throw new TypeError('"listener" argument must be a function');
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  };
  EventEmitter$1.prototype.removeListener = function removeListener2(type, listener) {
    var list, events, position, i, originalListener;
    if (typeof listener !== "function")
      throw new TypeError('"listener" argument must be a function');
    events = this._events;
    if (!events)
      return this;
    list = events[type];
    if (!list)
      return this;
    if (list === listener || list.listener && list.listener === listener) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else {
        delete events[type];
        if (events.removeListener)
          this.emit("removeListener", type, list.listener || listener);
      }
    } else if (typeof list !== "function") {
      position = -1;
      for (i = list.length; i-- > 0; ) {
        if (list[i] === listener || list[i].listener && list[i].listener === listener) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }
      if (position < 0)
        return this;
      if (list.length === 1) {
        list[0] = void 0;
        if (--this._eventsCount === 0) {
          this._events = new EventHandlers();
          return this;
        } else {
          delete events[type];
        }
      } else {
        spliceOne(list, position);
      }
      if (events.removeListener)
        this.emit("removeListener", type, originalListener || listener);
    }
    return this;
  };
  EventEmitter$1.prototype.removeAllListeners = function removeAllListeners2(type) {
    var listeners, events;
    events = this._events;
    if (!events)
      return this;
    if (!events.removeListener) {
      if (arguments.length === 0) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      } else if (events[type]) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else
          delete events[type];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys2 = Object.keys(events);
      for (var i = 0, key; i < keys2.length; ++i) {
        key = keys2[i];
        if (key === "removeListener")
          continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners("removeListener");
      this._events = new EventHandlers();
      this._eventsCount = 0;
      return this;
    }
    listeners = events[type];
    if (typeof listeners === "function") {
      this.removeListener(type, listeners);
    } else if (listeners) {
      do {
        this.removeListener(type, listeners[listeners.length - 1]);
      } while (listeners[0]);
    }
    return this;
  };
  EventEmitter$1.prototype.listeners = function listeners(type) {
    var evlistener;
    var ret;
    var events = this._events;
    if (!events)
      ret = [];
    else {
      evlistener = events[type];
      if (!evlistener)
        ret = [];
      else if (typeof evlistener === "function")
        ret = [evlistener.listener || evlistener];
      else
        ret = unwrapListeners(evlistener);
    }
    return ret;
  };
  EventEmitter$1.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") {
      return emitter.listenerCount(type);
    } else {
      return listenerCount$1.call(emitter, type);
    }
  };
  EventEmitter$1.prototype.listenerCount = listenerCount$1;
  function listenerCount$1(type) {
    var events = this._events;
    if (events) {
      var evlistener = events[type];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }
    return 0;
  }
  EventEmitter$1.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };
  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
      list[i] = list[k];
    list.pop();
  }
  function arrayClone(arr, i) {
    var copy = new Array(i);
    while (i--)
      copy[i] = arr[i];
    return copy;
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;
  if (typeof global.setTimeout === "function") {
    cachedSetTimeout = setTimeout;
  }
  if (typeof global.clearTimeout === "function") {
    cachedClearTimeout = clearTimeout;
  }
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e2) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e2) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  }
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  var title = "browser";
  var platform = "browser";
  var browser = true;
  var env = {};
  var argv = [];
  var version = "";
  var versions = {};
  var release = {};
  var config$1 = {};
  function noop$1() {
  }
  var on = noop$1;
  var addListener = noop$1;
  var once = noop$1;
  var off = noop$1;
  var removeListener = noop$1;
  var removeAllListeners = noop$1;
  var emit = noop$1;
  function binding(name) {
    throw new Error("process.binding is not supported");
  }
  function cwd() {
    return "/";
  }
  function chdir(dir) {
    throw new Error("process.chdir is not supported");
  }
  function umask() {
    return 0;
  }
  var performance$1 = global.performance || {};
  var performanceNow = performance$1.now || performance$1.mozNow || performance$1.msNow || performance$1.oNow || performance$1.webkitNow || function() {
    return (/* @__PURE__ */ new Date()).getTime();
  };
  function hrtime(previousTimestamp) {
    var clocktime = performanceNow.call(performance$1) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds, nanoseconds];
  }
  var startTime = /* @__PURE__ */ new Date();
  function uptime() {
    var currentTime = /* @__PURE__ */ new Date();
    var dif = currentTime - startTime;
    return dif / 1e3;
  }
  var browser$1 = {
    nextTick,
    title,
    browser,
    env,
    argv,
    version,
    versions,
    on,
    addListener,
    once,
    off,
    removeListener,
    removeAllListeners,
    emit,
    binding,
    cwd,
    chdir,
    umask,
    hrtime,
    platform,
    release,
    config: config$1,
    uptime
  };
  var inherits;
  if (typeof Object.create === "function") {
    inherits = function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    inherits = function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  const inherits$1 = inherits;
  var formatRegExp = /%[sdj%]/g;
  function format(f) {
    if (!isString(f)) {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }
      return objects.join(" ");
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x2) {
      if (x2 === "%%")
        return "%";
      if (i >= len)
        return x2;
      switch (x2) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return "[Circular]";
          }
        default:
          return x2;
      }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += " " + x;
      } else {
        str += " " + inspect(x);
      }
    }
    return str;
  }
  function deprecate(fn, msg) {
    if (isUndefined(global.process)) {
      return function() {
        return deprecate(fn, msg).apply(this, arguments);
      };
    }
    if (browser$1.noDeprecation === true) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (browser$1.throwDeprecation) {
          throw new Error(msg);
        } else if (browser$1.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  }
  var debugs = {};
  var debugEnviron;
  function debuglog(set2) {
    if (isUndefined(debugEnviron))
      debugEnviron = {}.NODE_DEBUG || "";
    set2 = set2.toUpperCase();
    if (!debugs[set2]) {
      if (new RegExp("\\b" + set2 + "\\b", "i").test(debugEnviron)) {
        var pid = 0;
        debugs[set2] = function() {
          var msg = format.apply(null, arguments);
          console.error("%s %d: %s", set2, pid, msg);
        };
      } else {
        debugs[set2] = function() {
        };
      }
    }
    return debugs[set2];
  }
  function inspect(obj, opts) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3)
      ctx.depth = arguments[2];
    if (arguments.length >= 4)
      ctx.colors = arguments[3];
    if (isBoolean(opts)) {
      ctx.showHidden = opts;
    } else if (opts) {
      _extend(ctx, opts);
    }
    if (isUndefined(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined(ctx.depth))
      ctx.depth = 2;
    if (isUndefined(ctx.colors))
      ctx.colors = false;
    if (isUndefined(ctx.customInspect))
      ctx.customInspect = true;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  inspect.colors = {
    "bold": [1, 22],
    "italic": [3, 23],
    "underline": [4, 24],
    "inverse": [7, 27],
    "white": [37, 39],
    "grey": [90, 39],
    "black": [30, 39],
    "blue": [34, 39],
    "cyan": [36, 39],
    "green": [32, 39],
    "magenta": [35, 39],
    "red": [31, 39],
    "yellow": [33, 39]
  };
  inspect.styles = {
    "special": "cyan",
    "number": "yellow",
    "boolean": "yellow",
    "undefined": "grey",
    "null": "bold",
    "string": "green",
    "date": "magenta",
    // "name": intentionally not styling
    "regexp": "red"
  };
  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];
    if (style) {
      return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
    } else {
      return str;
    }
  }
  function stylizeNoColor(str, styleType) {
    return str;
  }
  function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
      hash[val] = true;
    });
    return hash;
  }
  function formatValue(ctx, value, recurseTimes) {
    if (ctx.customInspect && value && isFunction$1(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }
    var keys2 = Object.keys(value);
    var visibleKeys = arrayToHash(keys2);
    if (ctx.showHidden) {
      keys2 = Object.getOwnPropertyNames(value);
    }
    if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
      return formatError(value);
    }
    if (keys2.length === 0) {
      if (isFunction$1(value)) {
        var name = value.name ? ": " + value.name : "";
        return ctx.stylize("[Function" + name + "]", "special");
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), "date");
      }
      if (isError(value)) {
        return formatError(value);
      }
    }
    var base = "", array = false, braces = ["{", "}"];
    if (isArray$1(value)) {
      array = true;
      braces = ["[", "]"];
    }
    if (isFunction$1(value)) {
      var n = value.name ? ": " + value.name : "";
      base = " [Function" + n + "]";
    }
    if (isRegExp(value)) {
      base = " " + RegExp.prototype.toString.call(value);
    }
    if (isDate(value)) {
      base = " " + Date.prototype.toUTCString.call(value);
    }
    if (isError(value)) {
      base = " " + formatError(value);
    }
    if (keys2.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }
    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      } else {
        return ctx.stylize("[Object]", "special");
      }
    }
    ctx.seen.push(value);
    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
    } else {
      output = keys2.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }
  function formatPrimitive(ctx, value) {
    if (isUndefined(value))
      return ctx.stylize("undefined", "undefined");
    if (isString(value)) {
      var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber(value))
      return ctx.stylize("" + value, "number");
    if (isBoolean(value))
      return ctx.stylize("" + value, "boolean");
    if (isNull(value))
      return ctx.stylize("null", "null");
  }
  function formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
  }
  function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
    var output = [];
    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty(value, String(i))) {
        output.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          String(i),
          true
        ));
      } else {
        output.push("");
      }
    }
    keys2.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          key,
          true
        ));
      }
    });
    return output;
  }
  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize("[Getter/Setter]", "special");
      } else {
        str = ctx.stylize("[Getter]", "special");
      }
    } else {
      if (desc.set) {
        str = ctx.stylize("[Setter]", "special");
      }
    }
    if (!hasOwnProperty(visibleKeys, key)) {
      name = "[" + key + "]";
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf("\n") > -1) {
          if (array) {
            str = str.split("\n").map(function(line) {
              return "  " + line;
            }).join("\n").substr(2);
          } else {
            str = "\n" + str.split("\n").map(function(line) {
              return "   " + line;
            }).join("\n");
          }
        }
      } else {
        str = ctx.stylize("[Circular]", "special");
      }
    }
    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify("" + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, "name");
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, "string");
      }
    }
    return name + ": " + str;
  }
  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function(prev, cur) {
      if (cur.indexOf("\n") >= 0)
        ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length > 60) {
      return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    }
    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
  }
  function isArray$1(ar) {
    return Array.isArray(ar);
  }
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  function isNull(arg) {
    return arg === null;
  }
  function isNumber(arg) {
    return typeof arg === "number";
  }
  function isString(arg) {
    return typeof arg === "string";
  }
  function isUndefined(arg) {
    return arg === void 0;
  }
  function isRegExp(re) {
    return isObject(re) && objectToString(re) === "[object RegExp]";
  }
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  function isDate(d) {
    return isObject(d) && objectToString(d) === "[object Date]";
  }
  function isError(e) {
    return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
  }
  function isFunction$1(arg) {
    return typeof arg === "function";
  }
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  function _extend(origin, add) {
    if (!add || !isObject(add))
      return origin;
    var keys2 = Object.keys(add);
    var i = keys2.length;
    while (i--) {
      origin[keys2[i]] = add[keys2[i]];
    }
    return origin;
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var inited = false;
  function init() {
    inited = true;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
  }
  function toByteArray(b64) {
    if (!inited) {
      init();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
    arr = new Arr(len * 3 / 4 - placeHolders);
    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;
    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = tmp >> 16 & 255;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[L++] = tmp & 255;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var output = "";
    var parts = [];
    var maxChunkLength = 16383;
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[tmp << 4 & 63];
      output += "==";
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[tmp >> 4 & 63];
      output += lookup[tmp << 2 & 63];
      output += "=";
    }
    parts.push(output);
    return parts.join("");
  }
  function read(buffer2, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer2[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  }
  function write(buffer2, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer2[offset + i - d] |= s * 128;
  }
  var toString = {}.toString;
  var isArray = Array.isArray || function(arr) {
    return toString.call(arr) == "[object Array]";
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  var INSPECT_MAX_BYTES = 50;
  Buffer$1.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== void 0 ? global.TYPED_ARRAY_SUPPORT : true;
  kMaxLength();
  function kMaxLength() {
    return Buffer$1.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function createBuffer(that, length) {
    if (kMaxLength() < length) {
      throw new RangeError("Invalid typed array length");
    }
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      that = new Uint8Array(length);
      that.__proto__ = Buffer$1.prototype;
    } else {
      if (that === null) {
        that = new Buffer$1(length);
      }
      that.length = length;
    }
    return that;
  }
  function Buffer$1(arg, encodingOrOffset, length) {
    if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
      return new Buffer$1(arg, encodingOrOffset, length);
    }
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new Error(
          "If encoding is specified then the first argument must be a string"
        );
      }
      return allocUnsafe(this, arg);
    }
    return from$1(this, arg, encodingOrOffset, length);
  }
  Buffer$1.poolSize = 8192;
  Buffer$1._augment = function(arr) {
    arr.__proto__ = Buffer$1.prototype;
    return arr;
  };
  function from$1(that, value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length);
    }
    if (typeof value === "string") {
      return fromString(that, value, encodingOrOffset);
    }
    return fromObject(that, value);
  }
  Buffer$1.from = function(value, encodingOrOffset, length) {
    return from$1(null, value, encodingOrOffset, length);
  };
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    Buffer$1.prototype.__proto__ = Uint8Array.prototype;
    Buffer$1.__proto__ = Uint8Array;
  }
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }
  function alloc(that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
    }
    return createBuffer(that, size);
  }
  Buffer$1.alloc = function(size, fill, encoding) {
    return alloc(null, size, fill, encoding);
  };
  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that;
  }
  Buffer$1.allocUnsafe = function(size) {
    return allocUnsafe(null, size);
  };
  Buffer$1.allocUnsafeSlow = function(size) {
    return allocUnsafe(null, size);
  };
  function fromString(that, string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer$1.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }
    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);
    var actual = that.write(string, encoding);
    if (actual !== length) {
      that = that.slice(0, actual);
    }
    return that;
  }
  function fromArrayLike$1(that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array, byteOffset, length) {
    array.byteLength;
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError("'offset' is out of bounds");
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError("'length' is out of bounds");
    }
    if (byteOffset === void 0 && length === void 0) {
      array = new Uint8Array(array);
    } else if (length === void 0) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      that = array;
      that.__proto__ = Buffer$1.prototype;
    } else {
      that = fromArrayLike$1(that, array);
    }
    return that;
  }
  function fromObject(that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);
      if (that.length === 0) {
        return that;
      }
      obj.copy(that, 0, 0, len);
      return that;
    }
    if (obj) {
      if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
        if (typeof obj.length !== "number" || isnan(obj.length)) {
          return createBuffer(that, 0);
        }
        return fromArrayLike$1(that, obj);
      }
      if (obj.type === "Buffer" && isArray(obj.data)) {
        return fromArrayLike$1(that, obj.data);
      }
    }
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
    }
    return length | 0;
  }
  Buffer$1.isBuffer = isBuffer;
  function internalIsBuffer(b) {
    return !!(b != null && b._isBuffer);
  }
  Buffer$1.compare = function compare(a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError("Arguments must be Buffers");
    }
    if (a === b)
      return 0;
    var x = a.length;
    var y = b.length;
    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer$1.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer$1.concat = function concat(list, length) {
    if (!isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer$1.alloc(0);
    }
    var i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    var buffer2 = Buffer$1.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      buf.copy(buffer2, pos);
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength(string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length;
    }
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      string = "" + string;
    }
    var len = string.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
        case void 0:
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string).length;
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer$1.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer$1.prototype._isBuffer = true;
  function swap$1(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  Buffer$1.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i = 0; i < len; i += 2) {
      swap$1(this, i, i + 1);
    }
    return this;
  };
  Buffer$1.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i = 0; i < len; i += 4) {
      swap$1(this, i, i + 3);
      swap$1(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer$1.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i = 0; i < len; i += 8) {
      swap$1(this, i, i + 7);
      swap$1(this, i + 1, i + 6);
      swap$1(this, i + 2, i + 5);
      swap$1(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer$1.prototype.toString = function toString2() {
    var length = this.length | 0;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer$1.prototype.equals = function equals(b) {
    if (!internalIsBuffer(b))
      throw new TypeError("Argument must be a Buffer");
    if (this === b)
      return true;
    return Buffer$1.compare(this, b) === 0;
  };
  Buffer$1.prototype.inspect = function inspect2() {
    var str = "";
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
      if (this.length > max)
        str += " ... ";
    }
    return "<Buffer " + str + ">";
  };
  Buffer$1.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError("Argument must be a Buffer");
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (isNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer$1.from(val, encoding);
    }
    if (internalIsBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (Buffer$1.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read2(arr, i + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer$1.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer$1.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer$1.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new TypeError("Invalid hex string");
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed))
        return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer$1.prototype.write = function write2(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    var remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
          return asciiWrite(this, string, offset, length);
        case "latin1":
        case "binary":
          return latin1Write(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer$1.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf);
    } else {
      return fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = "";
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer$1.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf;
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer$1.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer$1(sliceLen, void 0);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer$1.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength2 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer$1.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    var val = this[offset + --byteLength2];
    var mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer$1.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer$1.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer$1.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer$1.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer$1.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer$1.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength2 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer$1.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    var i = byteLength2;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer$1.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer$1.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer$1.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer$1.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer$1.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer$1.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4);
  };
  Buffer$1.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4);
  };
  Buffer$1.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8);
  };
  Buffer$1.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer$1.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 255;
    while (++i < byteLength2 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer$1.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    var i = byteLength2 - 1;
    var mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer$1.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    this[offset] = value & 255;
    return offset + 1;
  };
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 65535 + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  Buffer$1.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer$1.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 4294967295 + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
    }
  }
  Buffer$1.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer$1.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  Buffer$1.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer$1.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    var i = byteLength2 - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer$1.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer$1.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer$1.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  Buffer$1.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer$1.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer$1.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer$1.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer$1.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer$1.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer$1.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("sourceStart out of bounds");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    var i;
    if (this === target && start < targetStart && targetStart < end) {
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1e3 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }
    return len;
  };
  Buffer$1.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer$1.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
    } else if (typeof val === "number") {
      val = val & 255;
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    var i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer$1(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, "");
  }
  function toHex(n) {
    if (n < 16)
      return "0" + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length)
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isnan(val) {
    return val !== val;
  }
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
  }
  function isFastBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  }
  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
  }
  function BufferList() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  BufferList.prototype.push = function(v2) {
    var entry = { data: v2, next: null };
    if (this.length > 0)
      this.tail.next = entry;
    else
      this.head = entry;
    this.tail = entry;
    ++this.length;
  };
  BufferList.prototype.unshift = function(v2) {
    var entry = { data: v2, next: this.head };
    if (this.length === 0)
      this.tail = entry;
    this.head = entry;
    ++this.length;
  };
  BufferList.prototype.shift = function() {
    if (this.length === 0)
      return;
    var ret = this.head.data;
    if (this.length === 1)
      this.head = this.tail = null;
    else
      this.head = this.head.next;
    --this.length;
    return ret;
  };
  BufferList.prototype.clear = function() {
    this.head = this.tail = null;
    this.length = 0;
  };
  BufferList.prototype.join = function(s) {
    if (this.length === 0)
      return "";
    var p = this.head;
    var ret = "" + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }
    return ret;
  };
  BufferList.prototype.concat = function(n) {
    if (this.length === 0)
      return Buffer$1.alloc(0);
    if (this.length === 1)
      return this.head.data;
    var ret = Buffer$1.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      p.data.copy(ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };
  var isBufferEncoding = Buffer$1.isEncoding || function(encoding) {
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function assertEncoding(encoding) {
    if (encoding && !isBufferEncoding(encoding)) {
      throw new Error("Unknown encoding: " + encoding);
    }
  }
  function StringDecoder(encoding) {
    this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
    assertEncoding(encoding);
    switch (this.encoding) {
      case "utf8":
        this.surrogateSize = 3;
        break;
      case "ucs2":
      case "utf16le":
        this.surrogateSize = 2;
        this.detectIncompleteChar = utf16DetectIncompleteChar;
        break;
      case "base64":
        this.surrogateSize = 3;
        this.detectIncompleteChar = base64DetectIncompleteChar;
        break;
      default:
        this.write = passThroughWrite;
        return;
    }
    this.charBuffer = new Buffer$1(6);
    this.charReceived = 0;
    this.charLength = 0;
  }
  StringDecoder.prototype.write = function(buffer2) {
    var charStr = "";
    while (this.charLength) {
      var available = buffer2.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer2.length;
      buffer2.copy(this.charBuffer, this.charReceived, 0, available);
      this.charReceived += available;
      if (this.charReceived < this.charLength) {
        return "";
      }
      buffer2 = buffer2.slice(available, buffer2.length);
      charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
      var charCode = charStr.charCodeAt(charStr.length - 1);
      if (charCode >= 55296 && charCode <= 56319) {
        this.charLength += this.surrogateSize;
        charStr = "";
        continue;
      }
      this.charReceived = this.charLength = 0;
      if (buffer2.length === 0) {
        return charStr;
      }
      break;
    }
    this.detectIncompleteChar(buffer2);
    var end = buffer2.length;
    if (this.charLength) {
      buffer2.copy(this.charBuffer, 0, buffer2.length - this.charReceived, end);
      end -= this.charReceived;
    }
    charStr += buffer2.toString(this.encoding, 0, end);
    var end = charStr.length - 1;
    var charCode = charStr.charCodeAt(end);
    if (charCode >= 55296 && charCode <= 56319) {
      var size = this.surrogateSize;
      this.charLength += size;
      this.charReceived += size;
      this.charBuffer.copy(this.charBuffer, size, 0, size);
      buffer2.copy(this.charBuffer, 0, 0, size);
      return charStr.substring(0, end);
    }
    return charStr;
  };
  StringDecoder.prototype.detectIncompleteChar = function(buffer2) {
    var i = buffer2.length >= 3 ? 3 : buffer2.length;
    for (; i > 0; i--) {
      var c = buffer2[buffer2.length - i];
      if (i == 1 && c >> 5 == 6) {
        this.charLength = 2;
        break;
      }
      if (i <= 2 && c >> 4 == 14) {
        this.charLength = 3;
        break;
      }
      if (i <= 3 && c >> 3 == 30) {
        this.charLength = 4;
        break;
      }
    }
    this.charReceived = i;
  };
  StringDecoder.prototype.end = function(buffer2) {
    var res = "";
    if (buffer2 && buffer2.length)
      res = this.write(buffer2);
    if (this.charReceived) {
      var cr = this.charReceived;
      var buf = this.charBuffer;
      var enc = this.encoding;
      res += buf.slice(0, cr).toString(enc);
    }
    return res;
  };
  function passThroughWrite(buffer2) {
    return buffer2.toString(this.encoding);
  }
  function utf16DetectIncompleteChar(buffer2) {
    this.charReceived = buffer2.length % 2;
    this.charLength = this.charReceived ? 2 : 0;
  }
  function base64DetectIncompleteChar(buffer2) {
    this.charReceived = buffer2.length % 3;
    this.charLength = this.charReceived ? 3 : 0;
  }
  const stringDecoder = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    StringDecoder
  }, Symbol.toStringTag, { value: "Module" }));
  Readable.ReadableState = ReadableState;
  var debug = debuglog("stream");
  inherits$1(Readable, EventEmitter$1);
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") {
      return emitter.prependListener(event, fn);
    } else {
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
  }
  function listenerCount(emitter, type) {
    return emitter.listeners(type).length;
  }
  function ReadableState(options, stream2) {
    options = options || {};
    this.objectMode = !!options.objectMode;
    if (stream2 instanceof Duplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
    this.highWaterMark = ~~this.highWaterMark;
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.ranOut = false;
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options && typeof options.read === "function")
      this._read = options.read;
    EventEmitter$1.call(this);
  }
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    if (!state.objectMode && typeof chunk === "string") {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = "";
      }
    }
    return readableAddChunk(this, state, chunk, encoding, false);
  };
  Readable.prototype.unshift = function(chunk) {
    var state = this._readableState;
    return readableAddChunk(this, state, chunk, "", true);
  };
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  function readableAddChunk(stream2, state, chunk, encoding, addToFront) {
    var er = chunkInvalid(state, chunk);
    if (er) {
      stream2.emit("error", er);
    } else if (chunk === null) {
      state.reading = false;
      onEofChunk(stream2, state);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (state.ended && !addToFront) {
        var e = new Error("stream.push() after EOF");
        stream2.emit("error", e);
      } else if (state.endEmitted && addToFront) {
        var _e = new Error("stream.unshift() after end event");
        stream2.emit("error", _e);
      } else {
        var skipAdd;
        if (state.decoder && !addToFront && !encoding) {
          chunk = state.decoder.write(chunk);
          skipAdd = !state.objectMode && chunk.length === 0;
        }
        if (!addToFront)
          state.reading = false;
        if (!skipAdd) {
          if (state.flowing && state.length === 0 && !state.sync) {
            stream2.emit("data", chunk);
            stream2.read(0);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
            if (state.needReadable)
              emitReadable(stream2);
          }
        }
        maybeReadMore(stream2, state);
      }
    } else if (!addToFront) {
      state.reading = false;
    }
    return needMoreData(state);
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable.prototype.setEncoding = function(enc) {
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function chunkInvalid(state, chunk) {
    var er = null;
    if (!Buffer.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function onEofChunk(stream2, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream2);
  }
  function emitReadable(stream2) {
    var state = stream2._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        nextTick(emitReadable_, stream2);
      else
        emitReadable_(stream2);
    }
  }
  function emitReadable_(stream2) {
    debug("emit readable");
    stream2.emit("readable");
    flow(stream2);
  }
  function maybeReadMore(stream2, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      nextTick(maybeReadMore_, stream2, state);
    }
  }
  function maybeReadMore_(stream2, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug("maybeReadMore read 0");
      stream2.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = !pipeOpts || pipeOpts.end !== false;
    var endFn = doEnd ? onend2 : cleanup;
    if (state.endEmitted)
      nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable) {
      debug("onunpipe");
      if (readable === src) {
        cleanup();
      }
    }
    function onend2() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend2);
      src.removeListener("end", cleanup);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (listenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && src.listeners("data").length) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var _i = 0; _i < len; _i++) {
        dests[_i].emit("unpipe", this);
      }
      return this;
    }
    var i = indexOf(state.pipes, dest);
    if (i === -1)
      return this;
    state.pipes.splice(i, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = EventEmitter$1.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream2, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      nextTick(resume_, stream2, state);
    }
  }
  function resume_(stream2, state) {
    if (!state.reading) {
      debug("resume read 0");
      stream2.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream2.emit("resume");
    flow(stream2);
    if (state.flowing && !state.reading)
      stream2.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream2) {
    var state = stream2._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream2.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream2) {
    var state = this._readableState;
    var paused = false;
    var self2 = this;
    stream2.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          self2.push(chunk);
      }
      self2.push(null);
    });
    stream2.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = self2.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = function(method2) {
          return function() {
            return stream2[method2].apply(stream2, arguments);
          };
        }(i);
      }
    }
    var events = ["error", "close", "destroy", "pause", "resume"];
    forEach(events, function(ev) {
      stream2.on(ev, self2.emit.bind(self2, ev));
    });
    self2._read = function(n) {
      debug("wrapped _read", n);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return self2;
  };
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream2) {
    var state = stream2._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      nextTick(endReadableNT, state, stream2);
    }
  }
  function endReadableNT(state, stream2) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
    }
  }
  function forEach(xs, f) {
    for (var i = 0, l = xs.length; i < l; i++) {
      f(xs[i], i);
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
  Writable.WritableState = WritableState;
  inherits$1(Writable, EventEmitter$1);
  function nop() {
  }
  function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
  }
  function WritableState(options, stream2) {
    Object.defineProperty(this, "buffer", {
      get: deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
    });
    options = options || {};
    this.objectMode = !!options.objectMode;
    if (stream2 instanceof Duplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
    this.highWaterMark = ~~this.highWaterMark;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function writableStateGetBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  function Writable(options) {
    if (!(this instanceof Writable) && !(this instanceof Duplex))
      return new Writable(options);
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
    }
    EventEmitter$1.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream2, cb) {
    var er = new Error("write after end");
    stream2.emit("error", er);
    nextTick(cb, er);
  }
  function validChunk(stream2, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (!Buffer$1.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream2.emit("error", er);
      nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (Buffer$1.isBuffer(chunk))
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer$1.from(chunk, encoding);
    }
    return chunk;
  }
  function writeOrBuffer(stream2, state, chunk, encoding, cb) {
    chunk = decodeChunk(state, chunk, encoding);
    if (Buffer$1.isBuffer(chunk))
      encoding = "buffer";
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream2._writev(chunk, state.onwrite);
    else
      stream2._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream2, state, sync, er, cb) {
    --state.pendingcb;
    if (sync)
      nextTick(cb, er);
    else
      cb(er);
    stream2._writableState.errorEmitted = true;
    stream2.emit("error", er);
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state = stream2._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream2, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream2, state);
      }
      if (sync) {
        nextTick(afterWrite, stream2, state, finished, cb);
      } else {
        afterWrite(stream2, state, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream2, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream2, state);
  }
  function onwriteDrain(stream2, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer2 = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      while (entry) {
        buffer2[count] = entry;
        entry = entry.next;
        count += 1;
      }
      doWrite(stream2, state, true, state.length, buffer2, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream2, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequestCount = 0;
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending && !state.finished)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function prefinish(stream2, state) {
    if (!state.prefinished) {
      state.prefinished = true;
      stream2.emit("prefinish");
    }
  }
  function finishMaybe(stream2, state) {
    var need = needFinish(state);
    if (need) {
      if (state.pendingcb === 0) {
        prefinish(stream2, state);
        state.finished = true;
        stream2.emit("finish");
      } else {
        prefinish(stream2, state);
      }
    }
    return need;
  }
  function endWritable(stream2, state, cb) {
    state.ending = true;
    finishMaybe(stream2, state);
    if (cb) {
      if (state.finished)
        nextTick(cb);
      else
        stream2.once("finish", cb);
    }
    state.ended = true;
    stream2.writable = false;
  }
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function(err) {
      var entry = _this.entry;
      _this.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = _this;
      } else {
        state.corkedRequestsFree = _this;
      }
    };
  }
  inherits$1(Duplex, Readable);
  var keys = Object.keys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method])
      Duplex.prototype[method] = Writable.prototype[method];
  }
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  inherits$1(Transform, Duplex);
  function TransformState(stream2) {
    this.afterTransform = function(er, data) {
      return afterTransform(stream2, er, data);
    };
    this.needTransform = false;
    this.transforming = false;
    this.writecb = null;
    this.writechunk = null;
    this.writeencoding = null;
  }
  function afterTransform(stream2, er, data) {
    var ts = stream2._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb)
      return stream2.emit("error", new Error("no writecb in Transform class"));
    ts.writechunk = null;
    ts.writecb = null;
    if (data !== null && data !== void 0)
      stream2.push(data);
    cb(er);
    var rs = stream2._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      stream2._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = new TransformState(this);
    var stream2 = this;
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.once("prefinish", function() {
      if (typeof this._flush === "function")
        this._flush(function(er) {
          done(stream2, er);
        });
      else
        done(stream2);
    });
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("Not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  function done(stream2, er) {
    if (er)
      return stream2.emit("error", er);
    var ws = stream2._writableState;
    var ts = stream2._transformState;
    if (ws.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (ts.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream2.push(null);
  }
  inherits$1(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  inherits$1(Stream, EventEmitter$1);
  Stream.Readable = Readable;
  Stream.Writable = Writable;
  Stream.Duplex = Duplex;
  Stream.Transform = Transform;
  Stream.PassThrough = PassThrough;
  Stream.Stream = Stream;
  function Stream() {
    EventEmitter$1.call(this);
  }
  Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend2);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend2() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      if (typeof dest.destroy === "function")
        dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EventEmitter$1.listenerCount(this, "error") === 0) {
        throw er;
      }
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend2);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  const stream = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Duplex,
    PassThrough,
    Readable,
    Stream,
    Transform,
    Writable,
    default: Stream
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(stream);
  const require$$1 = /* @__PURE__ */ getAugmentedNamespace(stringDecoder);
  (function(exports3) {
    (function(sax2) {
      sax2.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax2.SAXParser = SAXParser;
      sax2.SAXStream = SAXStream;
      sax2.createStream = createStream;
      sax2.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax2.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit2(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o)
            if (o.hasOwnProperty(i))
              a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax2.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write: write2,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream2;
      try {
        Stream2 = require$$0.Stream;
      } catch (ex) {
        Stream2 = function() {
        };
      }
      var streamWraps = sax2.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream2.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream2.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require$$1.StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream2.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax2.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax2.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax2.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax2.ENTITIES).forEach(function(key) {
        var e = sax2.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax2.ENTITIES[key] = s2;
      });
      for (var s in sax2.STATE) {
        sax2.STATE[sax2.STATE[s]] = s;
      }
      S = sax2.STATE;
      function emit2(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode)
          closeText(parser);
        emit2(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
          emit2(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim)
          text = text.trim();
        if (opt.normalize)
          text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit2(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit2(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict)
          parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0)
          parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write2(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c))
                ;
              else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") {
                parser.state = S.DOCTYPE;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer2;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer2 = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer2 = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer2 = "attribValue";
                  break;
              }
              if (c === ";") {
                parser[buffer2] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer2] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(exports3);
  })(sax);
  class TiledProperties {
    constructor(data) {
      this.properties = {};
      this.properties = (data == null ? void 0 : data.properties) ?? {};
    }
    getProperty(name, defaultValue) {
      const val = this.properties[name];
      if (val === void 0) {
        return defaultValue;
      }
      return val;
    }
    hasProperty(name) {
      return !!this.properties[name];
    }
    setProperty(name, value) {
      this.properties[name] = value;
    }
    getType() {
      return this.class || this["type"];
    }
  }
  const FLIPPED_HORIZONTALLY_FLAG = 2147483648;
  const FLIPPED_VERTICALLY_FLAG = 1073741824;
  const FLIPPED_DIAGONALLY_FLAG = 536870912;
  const ROTATED_HEXAGONAL_120_FLAG = 268435456;
  class TileGid extends TiledProperties {
    constructor(obj) {
      super(obj);
      this.obj = obj;
      this._gid = obj == null ? void 0 : obj.gid;
    }
    static getRealGid(gid) {
      return gid & ~(FLIPPED_HORIZONTALLY_FLAG | FLIPPED_VERTICALLY_FLAG | FLIPPED_DIAGONALLY_FLAG | ROTATED_HEXAGONAL_120_FLAG);
    }
    get horizontalFlip() {
      return !!(this._gid & FLIPPED_HORIZONTALLY_FLAG);
    }
    get verticalFlip() {
      return !!(this._gid & FLIPPED_VERTICALLY_FLAG);
    }
    get diagonalFlip() {
      return !!(this._gid & FLIPPED_DIAGONALLY_FLAG);
    }
    get rotatedHex120() {
      return !!(this._gid & ROTATED_HEXAGONAL_120_FLAG);
    }
    get gid() {
      return TileGid.getRealGid(this._gid);
    }
    set gid(val) {
      this._gid = val;
    }
  }
  class Tile extends TileGid {
    constructor(tile) {
      super(tile);
      this.tile = tile;
      Reflect.deleteProperty(tile, "gid");
      Object.assign(this, tile);
    }
  }
  class TiledObjectClass extends TileGid {
    constructor(object) {
      super(object);
      this.layerName = "";
      Object.assign(this, object);
      if (object == null ? void 0 : object.gid) {
        this.y -= this.height;
      }
    }
  }
  class Layer extends TiledProperties {
    get size() {
      return this.data.length;
    }
    constructor(layer, tilesets, parent) {
      super(layer);
      this.tilesets = tilesets;
      this.parent = parent;
      this.cacheTiles = false;
      this.tiles = [];
      Object.assign(this, layer);
      this.mapObjects();
      this.mergePropertiesWithParent();
      this.cacheTiles = this.getProperty("cache-tiles", false);
      if (this.cacheTiles)
        this.propertiesTiles();
    }
    createTile(gid, tileIndex, layerIndex) {
      if (gid == 0) {
        return;
      }
      const realGid = TileGid.getRealGid(gid);
      const tileset = Layer.findTileSet(realGid, this.tilesets);
      if (!tileset) {
        return void 0;
      }
      const tile = tileset.getTile(realGid - tileset.firstgid);
      if (tile) {
        return new Tile({
          ...tile.tile,
          gid,
          index: tileIndex,
          layerIndex
        });
      }
      return new Tile({
        gid,
        index: tileIndex,
        layerIndex
      });
    }
    mergePropertiesWithParent() {
      const parent = this.getLayerParent();
      if (!this.properties)
        this.properties = {};
      if (!parent)
        return;
      for (let key in parent.properties) {
        const val = parent.properties[key];
        const valChild = this.properties[key];
        if (valChild === void 0) {
          this.properties[key] = val;
        } else {
          if (key == "z") {
            this.properties[key] += val;
          } else {
            continue;
          }
        }
      }
      this.opacity = Math.round((parent.opacity ?? 1) * (this.opacity ?? 1) * 100) / 100;
      this.offsetx = (parent.offsetx ?? 0) + (this.offsetx ?? 0);
      this.offsety = (parent.offsety ?? 0) + (this.offsety ?? 0);
      this.locked = parent.locked ?? false;
    }
    propertiesTiles() {
      if (!this.data)
        return;
      const data = this.data;
      for (let i = 0; i < data.length; i++) {
        const id = data[i];
        this.tiles.push(this.createTile(id, i));
      }
    }
    mapObjects() {
      if (this.objects) {
        this.objects = this.objects.map((object) => {
          const obj = new TiledObjectClass(object);
          obj.layerName = this.name;
          return obj;
        });
      }
    }
    getTileByIndex(tileIndex) {
      if (this.cacheTiles) {
        return this.tiles[tileIndex];
      }
      return this.createTile(this.data[tileIndex], tileIndex);
    }
    static findTileSet(gid, tileSets) {
      let tileset;
      for (let i = tileSets.length - 1; i >= 0; i--) {
        tileset = tileSets[i];
        if (tileset.firstgid && tileset.firstgid <= gid) {
          break;
        }
      }
      return tileset;
    }
    getLayerParent() {
      return this.parent;
    }
    tilesForEach(cb) {
      for (let i = 0; i < this.data.length; i++) {
        if (this.cacheTiles) {
          cb(this.tiles[i], i);
          continue;
        }
        cb(this.createTile(this.data[i], i), i);
      }
    }
    setData(tileIndex, gid) {
      this.data[tileIndex] = gid;
    }
  }
  class Tileset extends TiledProperties {
    constructor(tileset) {
      super(tileset);
      this.tileset = tileset;
      this.cacheTileId = /* @__PURE__ */ new Map();
      Object.assign(this, tileset);
      this.margin = this.margin ?? 0;
      this.spacing = this.spacing ?? 0;
      for (let tile of tileset.tiles) {
        this.addTile(tile);
      }
      Reflect.deleteProperty(this, "tiles");
    }
    addTile(tileObj) {
      const tile = new Tile(tileObj);
      this.cacheTileId.set(tile.id, tile);
      return tile;
    }
    getTile(id) {
      return this.cacheTileId.get(+id);
    }
  }
  let bufferTilesets = {};
  class MapClass extends TiledProperties {
    constructor(map2) {
      super(map2 ?? {});
      this.tilesets = [];
      this.layers = [];
      this.tmpLayers = [];
      this.tilesIndex = {};
      this.allocateMemory = 0;
      this.lowMemory = false;
      if (map2)
        this.load(map2);
    }
    load(map2) {
      Object.assign(this, map2);
      if (this.hasProperty("low-memory")) {
        this.lowMemory = this.getProperty("low-memory", false);
      }
      this.tmpLayers = [];
      this.mapTilesets();
      this.mapLayers(this.layers);
      this.layers = [...this.tmpLayers];
      Reflect.deleteProperty(this, "tmpLayers");
      this.setTilesIndex();
      this.data = map2;
    }
    /**
     * @title Width of the map in pixels
     * @prop {number} [widthPx]
     * @readonly
     * @memberof Map
     * @memberof RpgSceneMap
     * */
    get widthPx() {
      return this.width * this.tilewidth;
    }
    /**
    * @title Height of the map in pixels
    * @prop {number} [heightPx]
    * @readonly
    * @memberof Map
    * @memberof RpgSceneMap
    * */
    get heightPx() {
      return this.height * this.tileheight;
    }
    /**
     * @title The depth of the map in pixels (this is the height of a tile ;))
     * @prop {number} map.zTileHeight
     * @readonly
     * @memberof Map
     * @memberof RpgSceneMap
     * */
    get zTileHeight() {
      return this.tileheight;
    }
    /**
     * Find a layer by name. Returns `undefined` is the layer is not found
      * @title Get Layer by name
     * @method map.getLayerByName(name)
     * @param {string} name layer name
     * @returns {LayerInfo | undefined}
     * @example
     *  ```ts
     *  const tiles = map.getLayerByName(0, 0)
     *  ```
     * @memberof Map
     * @memberof RpgSceneMap
     */
    getLayerByName(name) {
      return this.layers.find((layer) => layer.name == name);
    }
    /**
    * Get the tile index on the tileset
    *
    * @title Get index of tile
    * @method map.getTileIndex(x,y)
    * @param {number} x Position X
    * @param {number} x Position Y
    * @returns {number}
    * @memberof Map
    * @memberof RpgSceneMap
    */
    getTileIndex(x, y, [z] = [0]) {
      return this.width * Math.floor((y - z) / this.tileheight) + Math.floor(x / this.tilewidth);
    }
    getTilePosition(index) {
      return {
        y: Math.floor(index / this.width) * this.tileheight,
        x: index % this.width * this.tilewidth
      };
    }
    /**
     * Find the point of origin (top left) of a tile. Of course, its position depends on the size of the tile
      * @title Get origin position of tile
     * @method map.getTileOriginPosition(x,y)
     * @param {number} x Position X
     * @param {number} x Position Y
     * @returns { {x: number, y: number }}
     * @example
     *  ```ts
     *  // If the size of a tile is 32x32px
     *  const position = map.getTileOriginPosition(35, 12)
     *  console.log(position) // { x: 32, y: 0 }
     *  ```
     * @memberof Map
     * @memberof RpgSceneMap
     */
    getTileOriginPosition(x, y) {
      return {
        x: Math.floor(x / this.tilewidth) * this.tilewidth,
        y: Math.floor(y / this.tileheight) * this.tileheight
      };
    }
    /**
    * Recover tiles according to a position
     * @title Get tile by position
    * @method map.getTileByPosition(x,y)
    * @param {number} x Position X
    * @param {number} x Position Y
    * @returns {TileInfo}
    * @example
    *  ```ts
    *  const tiles = map.getTileByPosition(0, 0)
    *  ```
    * @memberof Map
    * @memberof RpgSceneMap
    */
    getTileByPosition(x, y, z = [0, 0], options = {}) {
      const tileIndex = this.getTileIndex(x, y, [z[0]]);
      return this.getTileByIndex(tileIndex, z, options);
    }
    /**
     * Retrieves tiles according to its index
      * @title Get tile by index
     * @method map.getTileByIndex(tileIndex)
     * @param {number} tileIndex tile index
     * @returns {TileInfo}
     * @example
     *  ```ts
     *  const index = map.getTileIndex(0, 0)
     *  const tiles = map.getTileByIndex(index)
     *  ```
     * @memberof Map
     * @memberof RpgSceneMap
     */
    getTileByIndex(tileIndex, zPlayer = [0, 0], options = {
      populateTiles: true
    }) {
      const zA = Math.floor(zPlayer[0] / this.zTileHeight);
      Math.floor(zPlayer[1] / this.zTileHeight);
      const level = this.tilesIndex[zA];
      const obj = {
        tiles: [],
        hasCollision: true,
        isOverlay: false,
        objectGroups: [],
        tileIndex
      };
      if (!level) {
        return obj;
      }
      const [layer] = this.layers;
      const getTileByPointer = (pointer = 0) => {
        const pos = tileIndex * this.realAllocateMemory + pointer;
        const gid = level[pos];
        if (gid === 0) {
          return obj;
        }
        const tile2 = layer.createTile(gid, tileIndex, level[pos + 1]);
        if (tile2)
          obj.tiles.push(tile2);
      };
      if (options.populateTiles) {
        for (let i = 0; i < this.realAllocateMemory; i += 2) {
          getTileByPointer(i);
        }
      } else {
        getTileByPointer();
      }
      const [tile] = obj.tiles;
      if (tile) {
        obj.hasCollision = tile.getProperty("collision", false);
        obj.objectGroups = tile.objects ?? [];
      }
      return obj;
    }
    getAllObjects() {
      return this.layers.reduce((prev, current) => {
        if (!current.objects)
          return prev;
        return prev.concat(...current.objects);
      }, []);
    }
    getData() {
      return {
        ...this.data,
        layers: this.layers
      };
    }
    setTile(x, y, layerFilter, tileInfo) {
      if (this.lowMemory) {
        throw "Impossible to change a tile with the lowMemory option";
      }
      const tileIndex = this.getTileIndex(x, y);
      let fnFilter;
      let tilesEdited = {};
      if (typeof layerFilter == "string") {
        fnFilter = (layer) => layer.name == layerFilter;
      } else {
        fnFilter = layerFilter;
      }
      for (let i = 0; i < this.layers.length; i++) {
        const layer = this.layers[i];
        if (!fnFilter(layer))
          continue;
        let tile;
        const oldTile = this.getTileByIndex(tileIndex);
        if (tileInfo.gid) {
          tile = layer.createTile(tileInfo.gid, tileIndex);
        }
        if (!tile)
          continue;
        for (let key in tileInfo) {
          if (key == "gid")
            continue;
          tile[key] = tileInfo[key];
        }
        tilesEdited[layer.name] = {
          gid: tile.gid,
          properties: tile.properties
        };
        this.setTileIndex(layer, oldTile.tiles[0], tile, tileIndex, i);
        layer.setData(tileIndex, tile.gid);
      }
      return {
        x,
        y,
        tiles: tilesEdited
      };
    }
    removeCacheTileset(name) {
      delete bufferTilesets[name];
    }
    clearCacheTilesets() {
      bufferTilesets = {};
    }
    mapTilesets() {
      this.tilesets = this.tilesets.map((tileset) => {
        if (bufferTilesets[tileset.name]) {
          const instance = bufferTilesets[tileset.name];
          instance.firstgid = tileset.firstgid;
          return instance;
        }
        const _tileset = new Tileset(tileset);
        bufferTilesets[_tileset.name] = _tileset;
        return _tileset;
      });
    }
    mapLayers(layers = [], parent) {
      for (let layer of layers) {
        const layerInstance = new Layer(layer, this.tilesets, parent);
        this.tmpLayers.push(layerInstance);
        if (layer.layers) {
          this.mapLayers(layer.layers, layerInstance);
        }
      }
      if (this.lowMemory)
        this.allocateMemory = 1;
      if (!this.allocateMemory)
        this.allocateMemory = this.layers.length;
    }
    setTileIndex(layer, oldTile, newTile, tileIndex, layerIndex) {
      const startPos = tileIndex * this.realAllocateMemory;
      let pointer = startPos + this.realAllocateMemory - 2;
      const zLayer = layer.getProperty("z", 0);
      const zTile = oldTile.getProperty("z", 0);
      let z = zLayer + zTile;
      while (pointer >= startPos) {
        const zlayer = this.tilesIndex[z];
        if (zlayer[pointer] === oldTile.gid && zlayer[pointer + 1] === layerIndex) {
          this.tilesIndex[z][pointer] = newTile.gid;
        }
        pointer -= 2;
      }
    }
    /**
     * We multiply by 2 because 2 entries are stored for a tile: its GID and the Layer Index
     *
     * Example If I have 3 layers, The array will have the following form
     *
     * [
     *  GID of Layer 3,
     *  Layer Index of Layer 3,
     *  GID of Layer 2,
     *  Layer Index of Layer 2,
     *  GID of Layer 1,
     *  Layer Index of Layer 1,
     * ... others tiles
     * ]
     *
     * The size in memory of the map is therefore:
     *
     * `(map width * map height * number of layers * 4) bytes`
     *
     * > We multiply by 4, because an element takes 2 bytes and has 2 elements for a tile is 4 bytes in all
     *
     * Example (a 100x100 map with 5 layers)
     *
     * `100 * 100 * 5 * 4 = 200000 bytes = ~195 Kb`
     *
     * If we define on lowMemory then the calculation is the following
     *
     * `(map width * map height * 4) bytes`
     *
     * Example
     *
     * `100 * 100 * 4 = 40000 bytes = ~39 Kb`
     */
    get realAllocateMemory() {
      return this.allocateMemory * 2;
    }
    /**
     * We keep each tile in memory classified by z value. The values are ordered from the end to the beginning so that the first element of the array (when retrieved with getTileByIndex() is the tile on the highest layer. This way, the tile search is very fast for collisions
     *
     */
    addTileIndex(layer, tile, tileIndex, layerIndex) {
      if (!tile || tile && tile.gid == 0) {
        return;
      }
      const zLayer = layer.getProperty("z", 0);
      const zTile = tile.getProperty("z", 0);
      let z = zLayer + zTile;
      if (!this.tilesIndex[z]) {
        const buffer2 = new ArrayBuffer(layer.size * this.realAllocateMemory * 2);
        this.tilesIndex[z] = new Uint16Array(buffer2);
      }
      const startPos = tileIndex * this.realAllocateMemory;
      let pointer = startPos + this.realAllocateMemory - 2;
      while (this.tilesIndex[z][pointer] !== 0 && pointer > startPos) {
        pointer -= 2;
      }
      this.tilesIndex[z][pointer] = tile.gid;
      this.tilesIndex[z][pointer + 1] = layerIndex;
      this.tilesIndex[z][startPos] = tile.gid;
      this.tilesIndex[z][startPos + 1] = layerIndex;
    }
    setTilesIndex() {
      for (let i = 0; i < this.layers.length; i++) {
        const layer = this.layers[i];
        if (layer.type != TiledLayerType.Tile) {
          continue;
        }
        layer.tilesForEach((tile, index) => {
          this.addTileIndex(layer, tile, index, i);
        });
      }
    }
  }
  class Vector2d {
    constructor(x, y, z = 0) {
      this.x = x;
      this.y = y;
      this.z = z;
    }
    set(vector) {
      this.x = vector.x;
      this.y = vector.y;
      this.z = vector.z;
      return this;
    }
    add(vector) {
      this.x += vector.x;
      this.y += vector.y;
      return this;
    }
    subtract(vector) {
      this.x -= vector.x;
      this.y -= vector.y;
      return this;
    }
    multiply(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    }
    divide(scalar) {
      this.x /= scalar;
      this.y /= scalar;
      return this;
    }
    distanceWith(vector) {
      const dx = this.x - vector.x;
      const dy = this.y - vector.y;
      return Math.sqrt(dx ** 2 + dy ** 2);
    }
    magnitude() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    copy() {
      return new Vector2d(this.x, this.y, this.z);
    }
    normalize() {
      return this.divide(this.magnitude());
    }
    isEqual(vector) {
      return this.x === vector.x && this.y === vector.y && this.z === vector.z;
    }
    hasDifferentValues(vector) {
      return this.x !== vector.x || this.y !== vector.y || this.z !== vector.z;
    }
  }
  class Vector2dZero extends Vector2d {
    constructor() {
      super(0, 0);
    }
  }
  var ShapePositioning = /* @__PURE__ */ ((ShapePositioning2) => {
    ShapePositioning2["Default"] = "default";
    ShapePositioning2["Center"] = "center";
    return ShapePositioning2;
  })(ShapePositioning || {});
  class RpgShape extends TiledObjectClass {
    constructor(obj) {
      super();
      this.type = HitType.Box;
      this.class = "";
      this.name = "";
      this.playersIn = {};
      this.clientContainer = null;
      this.positioning = "default";
      this.components = [];
      Reflect.deleteProperty(obj, "id");
      this.set(obj);
    }
    setPos(type, val) {
      if (!this.hitbox.pos)
        return;
      if (this.isShapePosition()) {
        this.hitbox[type] = val;
      } else {
        this.hitbox.pos[type] = val;
      }
    }
    get hasCollision() {
      return this.getProperty("collision", false);
    }
    // alias
    get id() {
      return this.name;
    }
    get hitbox() {
      if (this.fixEvent) {
        this._hitbox.pos.x = this.fixEvent.position.x;
        this._hitbox.pos.y = this.fixEvent.position.y;
        switch (this.positioning) {
          case "center":
            this._hitbox.pos.x -= this._hitbox.w / 2 - this.fixEvent.hitbox.w / 2;
            this._hitbox.pos.y -= this._hitbox.h / 2 - this.fixEvent.hitbox.h / 2;
            break;
        }
      }
      return this._hitbox;
    }
    set hitbox(val) {
      this._hitbox = val;
    }
    /**
    * Get/Set width
    * @title width
    * @prop { number } width
    * @since 3.0.0-beta.5
    * @memberof Shape
    */
    get width() {
      return this.hitbox.w || 0;
    }
    set width(val) {
      this.setPos("w", val);
    }
    /**
    * Get/Set height
    * @title height
    * @prop { number } height
    * @since 3.0.0-beta.5
    * @memberof Shape
    */
    get height() {
      return this.hitbox.h || 0;
    }
    set height(val) {
      this.setPos("h", val);
    }
    /**
    * Get/Set x
    * @title x
    * @prop { number } x
    * @memberof Shape
    */
    get x() {
      return this.hitbox.x || this.hitbox.pos.x;
    }
    set x(val) {
      this.setPos("x", val);
    }
    get z() {
      return this.getProperty("z");
    }
    /**
    * Get/Set y
    * @title y
    * @prop { number } y
    * @memberof Shape
    */
    get y() {
      return this.hitbox.y || this.hitbox.pos.y;
    }
    set y(val) {
      this.setPos("y", val);
    }
    get position() {
      return new Vector2d(this.x, this.y, this.z);
    }
    /**
        * Get/Set properties
    
        * @title Properties
        * @prop { object } Properties
        * @memberof Shape
        */
    isEvent() {
      return this.type == PlayerType.Event;
    }
    set(obj) {
      const hit = Hit.getHitbox(obj);
      Object.assign(this, hit);
      const objClone = {
        ...obj
      };
      ["width", "height", "x", "y"].forEach((prop) => Reflect.deleteProperty(objClone, prop));
      Object.assign(this, objClone);
      const findPoint = (prop, isMin) => {
        return this.hitbox.points.sort((a, b) => isMin ? a[prop] - b[prop] : b[prop] - a[prop])[0][prop];
      };
      if (this.type == HitType.Polygon) {
        this.hitbox.minX = findPoint("x", true);
        this.hitbox.maxX = findPoint("x", false);
        this.hitbox.minY = findPoint("y", true);
        this.hitbox.maxY = findPoint("y", false);
      }
      this.positioning = obj.positioning;
      this.fixEvent = obj.fixEvent;
      this.setComponent();
    }
    setComponent() {
      const color = this.getProperty("color");
      const image = this.getProperty("image");
      if (color) {
        this.components = [{
          id: "shape",
          value: {
            fill: color
          }
        }];
        return;
      }
      if (image) {
        this.components = [{
          id: "image",
          value: image
        }];
        return;
      }
      if (this.text) {
        this.components = [{
          id: "text",
          value: this.text.text
        }];
        return;
      }
      if (this.gid) {
        this.components = [{
          id: "tile",
          value: this.gid
        }];
        return;
      }
    }
    getType() {
      return this.class || this.type;
    }
    async in(player) {
      var _a;
      if (!this.playerIsIn(player)) {
        this.playersIn[player.id] = true;
        player.inShapes[this.name] = this;
        await player.execMethod("onInShape", [this]);
        await ((_a = this.fixEvent) == null ? void 0 : _a.execMethod("onDetectInShape", [player, this], this.fixEvent));
        await player.execMethod("onIn", [player], this);
        return true;
      }
      return false;
    }
    async out(player) {
      var _a;
      if (this.playerIsIn(player)) {
        delete this.playersIn[player.id];
        delete player.inShapes[this.name];
        await player.execMethod("onOutShape", [this]);
        await ((_a = this.fixEvent) == null ? void 0 : _a.execMethod("onDetectOutShape", [player, this], this.fixEvent));
        await player.execMethod("onOut", [player], this);
        return true;
      }
      return false;
    }
    /**
     * Whether the player is in this shape
     * 
     * @title Player is in this shape ?
     * @method shape.playerIsIn(player)
     * @returns {boolean}
     * @memberof Shape
     */
    playerIsIn(player) {
      return !!this.playersIn[player.id];
    }
    isShapePosition() {
      return this.type !== HitType.Box && this.type !== HitType.Circle && this.type !== HitType.Polygon;
    }
    /**
      * Recover the player with the shape. You must have used the `attachShape()` method on the player
      * 
      * @title Get Player Owner
      * @method shape.getPlayerOwner()
      * @returns {RpgPlayer | undefined}
      * @memberof Shape
      */
    getPlayerOwner() {
      return this.fixEvent;
    }
    /**
     * We get the rectangle of a shape (box, circle and polygon). We use in the grid system to recover a shape.
     * Generally we add a margin (size of a tile) to detect if the player enters or leaves a shape
     * @param margin 
     * @returns { minX: number, minY: number, maxX: number, maxY: number }
     */
    getSizeBox(margin = 0) {
      if (this.type == HitType.Circle) {
        const radius = this.hitbox.r;
        return {
          minX: this.x - radius - margin,
          maxX: this.x + radius + margin,
          minY: this.y - radius - margin,
          maxY: this.y + radius + margin
        };
      }
      if (this.type == HitType.Polygon) {
        return {
          minX: this.x + this.hitbox.minX - margin,
          maxX: this.x + this.hitbox.maxX + margin,
          minY: this.y + this.hitbox.minY - margin,
          maxY: this.y + this.hitbox.maxY + margin
        };
      }
      return {
        minX: this.x - margin,
        maxX: this.x + this.width + margin,
        minY: this.y - margin,
        maxY: this.y + this.height + margin
      };
    }
  }
  class VirtualGrid {
    constructor(nbCellWidth, cellWidth, cellHeight) {
      this.nbCellWidth = nbCellWidth;
      this.cellWidth = cellWidth;
      this.cellHeight = cellHeight;
      this.cells = /* @__PURE__ */ new Map();
      this.inverseCells = /* @__PURE__ */ new Map();
    }
    zoom(nbCell) {
      this.nbCellWidth = Math.ceil(this.nbCellWidth / nbCell);
      this.cellWidth *= nbCell;
      this.cellHeight *= nbCell;
      return this;
    }
    getCellIndex(x, y) {
      return this.nbCellWidth * Math.floor(y / this.cellHeight) + Math.floor(x / this.cellWidth);
    }
    getCells(box, cb) {
      const {
        minX,
        minY,
        maxX,
        maxY
      } = box;
      const topLeft = this.getCellIndex(minX, minY);
      const topRight = this.getCellIndex(maxX, minY);
      const bottomLeft = this.getCellIndex(minX, maxY);
      const nbLines = (bottomLeft - topLeft) / this.nbCellWidth + 1;
      for (let j = 0; j < nbLines; j++) {
        for (let i = topLeft; i <= topRight; i++) {
          const index = i + j * this.nbCellWidth;
          cb(index);
        }
      }
    }
    getObjectsByBox(box) {
      let objects = [];
      this.getCells(box, (index) => {
        objects = [...objects, ...this.cells.get(index) || []];
      });
      return new Set(objects);
    }
    getObjectsById(id) {
      let objects = [];
      const cells = this.inverseCells.get(id);
      cells == null ? void 0 : cells.forEach((index) => {
        objects = [...objects, ...this.cells.get(index) || []];
      });
      return new Set(objects);
    }
    clearObjectInCells(id) {
      var _a;
      if (this.inverseCells.has(id)) {
        (_a = this.inverseCells.get(id)) == null ? void 0 : _a.forEach((cellIndex) => {
          var _a2;
          (_a2 = this.cells.get(cellIndex)) == null ? void 0 : _a2.delete(id);
        });
        this.inverseCells.delete(id);
      }
    }
    insertInCells(id, box) {
      this.clearObjectInCells(id);
      const cells = /* @__PURE__ */ new Set();
      this.getCells(box, (index) => {
        var _a;
        cells.add(index);
        const memoryCells = this.cells.get(index);
        if (!memoryCells) {
          this.cells.set(index, /* @__PURE__ */ new Set());
        }
        (_a = this.cells.get(index)) == null ? void 0 : _a.add(id);
      });
      this.inverseCells.set(id, cells);
    }
  }
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v2) {
        return step([n, v2]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from2, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from2.length, ar; i < l; i++) {
        if (ar || !(i in from2)) {
          if (!ar)
            ar = Array.prototype.slice.call(from2, 0, i);
          ar[i] = from2[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from2));
  }
  function __await(v2) {
    return this instanceof __await ? (this.v = v2, this) : new __await(v2);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v2) {
          return new Promise(function(a, b) {
            q.push([n, v2, a, b]) > 1 || resume2(n, v2);
          });
        };
    }
    function resume2(n, v2) {
      try {
        step(g[n](v2));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume2("next", value);
    }
    function reject(value) {
      resume2("throw", value);
    }
    function settle(f, v2) {
      if (f(v2), q.shift(), q.length)
        resume2(q[0][0], q[0][1]);
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v2) {
        return new Promise(function(resolve, reject) {
          v2 = o[n](v2), settle(resolve, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve, reject, d, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve({ value: v3, done: d });
      }, reject);
    }
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function createErrorClass(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }
  var UnsubscriptionError = createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors) {
      _super(this);
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
        return i + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
    };
  });
  function arrRemove(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }
  var Subscription = function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a, e_2, _b;
      var errors;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                  _a.call(_parentage_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors = e instanceof UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors = errors !== null && errors !== void 0 ? errors : [];
                if (err instanceof UnsubscriptionError) {
                  errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                _b.call(_finalizers_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError(errors);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function() {
      var empty = new Subscription2();
      empty.closed = true;
      return empty;
    }();
    return Subscription2;
  }();
  var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
  }
  function execFinalizer(finalizer) {
    if (isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }
  var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };
  var timeoutProvider = {
    setTimeout: function(handler, timeout) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = timeoutProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
    },
    clearTimeout: function(handle) {
      var delegate = timeoutProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: void 0
  };
  function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function() {
      {
        throw err;
      }
    });
  }
  function noop() {
  }
  function errorContext(cb) {
    {
      cb();
    }
  }
  var Subscriber = function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber2.create = function(next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };
    Subscriber2.prototype.next = function(value) {
      if (this.isStopped)
        ;
      else {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (this.isStopped)
        ;
      else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped)
        ;
      else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  }(Subscription);
  var _bind = Function.prototype.bind;
  function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
  }
  var ConsumerObserver = function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError(error);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber = function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
          error: error !== null && error !== void 0 ? error : void 0,
          complete: complete !== null && complete !== void 0 ? complete : void 0
        };
      } else {
        var context_1;
        if (_this && config.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind(observerOrNext.next, context_1),
            error: observerOrNext.error && bind(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber);
  function handleUnhandledError(error) {
    {
      reportUnhandledError(error);
    }
  }
  function defaultErrorHandler(err) {
    throw err;
  }
  var EMPTY_OBSERVER = {
    closed: true,
    next: noop,
    error: defaultErrorHandler,
    complete: noop
  };
  var observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
  function identity(x) {
    return x;
  }
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }
  var Observable = function() {
    function Observable2(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable2 = new Observable2();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
      errorContext(function() {
        var _a = _this, operator = _a.operator, source = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscriber = new SafeSubscriber({
          next: function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var _a;
      return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable2.prototype[observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value;
        _this.subscribe(function(x) {
          return value = x;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve(value);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver(value) {
    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
  }
  function hasLift(source) {
    return isFunction(source === null || source === void 0 ? void 0 : source.lift);
  }
  function operate(init2) {
    return function(source) {
      if (hasLift(source)) {
        return source.lift(function(liftedSource) {
          try {
            return init2(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  }
  var OperatorSubscriber = function(_super) {
    __extends(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value) {
        try {
          onNext(value);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err) {
        try {
          onError(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber2.prototype.unsubscribe = function() {
      var _a;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
      }
    };
    return OperatorSubscriber2;
  }(Subscriber);
  var ObjectUnsubscribedError = createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });
  var Subject = function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
    };
    Subject2.prototype.next = function(value) {
      var _this = this;
      errorContext(function() {
        var e_1, _a;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
              var observer = _c.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err) {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function() {
        var _a;
        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
      if (hasError || isStopped) {
        return EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription(function() {
        _this.currentObservers = null;
        arrRemove(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable2 = new Observable();
      observable2.source = this;
      return observable2;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable);
  var AnonymousSubject = function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject2.prototype.error = function(err) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a, _b;
      return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject);
  var BehaviorSubject = function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  }(Subject);
  var isArrayLike = function(x) {
    return x && typeof x.length === "number" && typeof x !== "function";
  };
  function isPromise(value) {
    return isFunction(value === null || value === void 0 ? void 0 : value.then);
  }
  function isInteropObservable(input) {
    return isFunction(input[observable]);
  }
  function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
  }
  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  var iterator = getSymbolIterator();
  function isIterable(input) {
    return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
  }
  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a, value, done2;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            reader = readableStream.getReader();
            _b.label = 1;
          case 1:
            _b.trys.push([1, , 9, 10]);
            _b.label = 2;
          case 2:
            return [4, __await(reader.read())];
          case 3:
            _a = _b.sent(), value = _a.value, done2 = _a.done;
            if (!done2)
              return [3, 5];
            return [4, __await(void 0)];
          case 4:
            return [2, _b.sent()];
          case 5:
            return [4, __await(value)];
          case 6:
            return [4, _b.sent()];
          case 7:
            _b.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }
  function isReadableStreamLike(obj) {
    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
  }
  function innerFrom(input) {
    if (input instanceof Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw createInvalidObservableTypeError(input);
  }
  function fromInteropObservable(obj) {
    return new Observable(function(subscriber) {
      var obs = obj[observable]();
      if (isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  function fromArrayLike(array) {
    return new Observable(function(subscriber) {
      for (var i = 0; i < array.length && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }
      subscriber.complete();
    });
  }
  function fromPromise(promise) {
    return new Observable(function(subscriber) {
      promise.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError);
    });
  }
  function fromIterable(iterable) {
    return new Observable(function(subscriber) {
      var e_1, _a;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
            _a.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  function fromAsyncIterable(asyncIterable) {
    return new Observable(function(subscriber) {
      process(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  }
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
  }
  function process(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter(this, void 0, void 0, function() {
      var value, e_2_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
              return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
              return [3, 8];
            return [4, _a.call(asyncIterable_1)];
          case 7:
            _b.sent();
            _b.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2)
              throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }
  function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === void 0) {
      delay = 0;
    }
    if (repeat === void 0) {
      repeat = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat) {
        parentSubscription.add(this.schedule(null, delay));
      } else {
        this.unsubscribe();
      }
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
      return scheduleSubscription;
    }
  }
  function observeOn(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return operate(function(source, subscriber) {
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.next(value);
        }, delay);
      }, function() {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay);
      }, function(err) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.error(err);
        }, delay);
      }));
    });
  }
  function subscribeOn(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return operate(function(source, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source.subscribe(subscriber);
      }, delay));
    });
  }
  function scheduleObservable(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }
  function schedulePromise(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }
  function scheduleArray(input, scheduler) {
    return new Observable(function(subscriber) {
      var i = 0;
      return scheduler.schedule(function() {
        if (i === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }
  function scheduleIterable(input, scheduler) {
    return new Observable(function(subscriber) {
      var iterator$1;
      executeSchedule(subscriber, scheduler, function() {
        iterator$1 = input[iterator]();
        executeSchedule(subscriber, scheduler, function() {
          var _a;
          var value;
          var done2;
          try {
            _a = iterator$1.next(), value = _a.value, done2 = _a.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done2) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function() {
        return isFunction(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return();
      };
    });
  }
  function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable(function(subscriber) {
      executeSchedule(subscriber, scheduler, function() {
        var iterator2 = input[Symbol.asyncIterator]();
        executeSchedule(subscriber, scheduler, function() {
          iterator2.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }
  function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
  }
  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable(input)) {
        return scheduleObservable(input, scheduler);
      }
      if (isArrayLike(input)) {
        return scheduleArray(input, scheduler);
      }
      if (isPromise(input)) {
        return schedulePromise(input, scheduler);
      }
      if (isAsyncIterable(input)) {
        return scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable(input)) {
        return scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike(input)) {
        return scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw createInvalidObservableTypeError(input);
  }
  function from(input, scheduler) {
    return scheduler ? scheduled(input, scheduler) : innerFrom(input);
  }
  function map(project, thisArg) {
    return operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(project.call(thisArg, value, index++));
      }));
    });
  }
  function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer2 = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      if (isComplete && !buffer2.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function(value) {
      return active < concurrent ? doInnerSub(value) : buffer2.push(value);
    };
    var doInnerSub = function(value) {
      expand && subscriber.next(value);
      active++;
      var innerComplete = false;
      innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
        onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
        if (expand) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, void 0, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function() {
              var bufferedValue = buffer2.shift();
              if (innerSubScheduler) {
                executeSchedule(subscriber, innerSubScheduler, function() {
                  return doInnerSub(bufferedValue);
                });
              } else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer2.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    };
    source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
      additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
    };
  }
  function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    if (isFunction(resultSelector)) {
      return mergeMap(function(a, i) {
        return map(function(b, ii) {
          return resultSelector(a, b, i, ii);
        })(innerFrom(project(a, i)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return operate(function(source, subscriber) {
      return mergeInternals(source, subscriber, project, concurrent);
    });
  }
  function filter(predicate, thisArg) {
    return operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        return predicate.call(thisArg, value, index++) && subscriber.next(value);
      }));
    });
  }
  function takeUntil(notifier) {
    return operate(function(source, subscriber) {
      innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
        return subscriber.complete();
      }, noop));
      !subscriber.closed && source.subscribe(subscriber);
    });
  }
  function tap(observerOrNext, error, complete) {
    var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
    return tapObserver ? operate(function(source, subscriber) {
      var _a;
      (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
      var isUnsub = true;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var _a2;
        (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
        subscriber.next(value);
      }, function() {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        subscriber.complete();
      }, function(err) {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
        subscriber.error(err);
      }, function() {
        var _a2, _b;
        if (isUnsub) {
          (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        }
        (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
      }));
    }) : identity;
  }
  const buffer = /* @__PURE__ */ new Map();
  const bufferClient = /* @__PURE__ */ new Map();
  class RpgCommonMap extends MapClass {
    constructor() {
      super(...arguments);
      this.shapes = {};
    }
    get tileWidth() {
      return this.tilewidth;
    }
    get tileHeight() {
      return this.tileheight;
    }
    /** 
     * Retrieves the X position of the map in the world (0 if no world assigned)
     * 
     * @title World X Position
     * @prop {number} [worldX]
     * @readonly
     * @since 3.0.0-beta.8
     * @memberof Map
     * */
    get worldX() {
      var _a, _b;
      return ((_b = (_a = this.getInWorldMaps()) == null ? void 0 : _a.getMapInfo(this.id)) == null ? void 0 : _b.x) || 0;
    }
    /** 
     * Retrieves the Y position of the map in the world (0 if no world assigned)
     * 
     * @title World Y Position
     * @prop {number} [worldY]
     * @readonly
     * @since 3.0.0-beta.8
     * @memberof Map
     * */
    get worldY() {
      var _a, _b;
      return ((_b = (_a = this.getInWorldMaps()) == null ? void 0 : _a.getMapInfo(this.id)) == null ? void 0 : _b.y) || 0;
    }
    /**
     * Memorize the maps so you don't have to make a new request or open a file each time you load a map
     */
    static get buffer() {
      return buffer;
    }
    /**
     * In RPG mode, to avoid confusion with buffer, we have a new variable to memorize the maps
     */
    static get bufferClient() {
      return bufferClient;
    }
    load(data) {
      super.load(data);
      this.gridTiles = new VirtualGrid(this.width, this.tileWidth, this.tileHeight);
      this.grid = new VirtualGrid(this.width, this.tileWidth, this.tileHeight).zoom(10);
      this.gridShapes = new VirtualGrid(this.width, this.tileWidth, this.tileHeight).zoom(20);
    }
    /**
     * Create a shape dynamically on the map
     * 
     * Object:
     *  - (number) x: Position X
     *  - (number) y: Position Y
     *  - (number) width: Width
     *  - (number) height: Height
     *  - (object) properties (optionnal): 
     *      - (number) z: Position Z
     *      - (hexadecimal) color: Color (shared with client)
     *      - (boolean) collision
     *      - You can your own properties
     * 
     * @title Create Shape
     * @since 3.0.0-beta.3
     * @method map.createShape(obj)
     * @param {object} obj
     * @returns {RpgShape}
     * @memberof Map
     */
    createShape(obj) {
      const id = obj.name = obj.name || generateUID();
      const shape = new RpgShape(obj);
      this.shapes[id] = shape;
      if (!shape.isShapePosition()) {
        this.gridShapes.insertInCells(id, shape.getSizeBox(this.tileWidth));
      }
      return this.shapes[id];
    }
    /**
     * Delete a shape
     * 
     * @title Delete Shape
     * @method map.removeShape(name)
     * @param {string} name Name of shape
     * @returns {void}
     * @memberof Map
     */
    removeShape(name) {
      delete this.shapes[name];
    }
    clearShapes() {
      this.shapes = {};
    }
    /**
     * Return all shapes on the map
     * 
     * @title Get Shapes
     * @method map.getShapes()
     * @returns {RpgShape[]}
     * @memberof Map
     * @memberof RpgSceneMap
     */
    getShapes() {
      return Object.values(this.shapes);
    }
    /**
     * Returns a shape by its name. Returns undefined is nothing is found
     * 
     * @title Get Shape by name
     * @method map.getShape(name)
     * @param {string} name Name of shape
     * @returns {RpgShape[] | undefined}
     * @memberof Map
     * @memberof RpgSceneMap
     */
    getShape(name) {
      return this.getShapes().find((shape) => shape.name == name);
    }
    getPositionByShape(filter2) {
      const startsFind = this.getShapes().filter(filter2);
      if (startsFind.length) {
        const start = startsFind[random(0, startsFind.length - 1)];
        return {
          x: start.hitbox.x,
          y: start.hitbox.y,
          z: start.properties.z * this.zTileHeight || 0
        };
      }
      return null;
    }
    /**
     * Get tile and verify collision with hitbox
     * @param hitbox 
     * @param x 
     * @param y 
     * @param z 
     * @returns TileInfo
     */
    getTile(hitbox, x, y, z = [0, 0]) {
      const tile = {
        ...this.getTileByPosition(x, y, z)
      };
      const tilePos = this.getTileOriginPosition(x, y);
      if (tile.objectGroups) {
        for (let object of tile.objectGroups) {
          const hit = Hit.getHitbox(object, {
            x: tilePos.x,
            y: tilePos.y
          });
          if (hit.type) {
            const collided = Hit.testPolyCollision(hit.type, hit.hitbox, hitbox);
            if (collided) {
              tile.hasCollision = true;
            }
          }
        }
      }
      return tile;
    }
    /**
         * Assign the map to a world
    
         * @title Assign the map to a world
         * @method map.setInWorldMaps(name)
         * @param {RpgWorldMaps} worldMap world maps
         * @since 3.0.0-beta.8
         * @memberof Map
         */
    setInWorldMaps(worldMap) {
      this.worldMapParent = worldMap;
    }
    /**
     * Remove this map from the world
     * @title Remove this map from the world
     * @method map.removeFromWorldMaps()
     * @returns {boolean | undefined}
     * @since 3.0.0-beta.8
     * @memberof Map
     */
    removeFromWorldMaps() {
      var _a;
      return (_a = this.worldMapParent) == null ? void 0 : _a.removeMap(this.id);
    }
    /**
         * Recover the world attached to this map (`undefined` if no world attached)
    
         * @title Get attached World
         * @method map.getInWorldMaps()
         * @return {RpgCommonWorldMaps | undefined}
         * @since 3.0.0-beta.8
         * @memberof Map
         */
    getInWorldMaps() {
      return this.worldMapParent;
    }
    boundingMap(nextPosition, hitbox) {
      let bounding = false;
      if (nextPosition.x < 0) {
        nextPosition.x = 0;
        bounding = true;
      } else if (nextPosition.y < 0) {
        nextPosition.y = 0;
        bounding = true;
      } else if (nextPosition.x > this.widthPx - hitbox.w) {
        nextPosition.x = this.widthPx - hitbox.w;
        bounding = true;
      } else if (nextPosition.y > this.heightPx - hitbox.h) {
        nextPosition.y = this.heightPx - hitbox.h;
        bounding = true;
      }
      return {
        bounding,
        nextPosition
      };
    }
    _createMovingHitbox(gameEngine, tick$, mapId, hitboxes, options = {}) {
      const object = new AbstractObject(gameEngine, Utils.generateUID());
      object.disableVirtualGrid = true;
      object.map = mapId;
      object.speed = options.speed ?? 1;
      let i = 0;
      let frame = 0;
      const destroyHitbox$ = new Subject();
      return tick$.pipe(takeUntil(destroyHitbox$), filter(() => {
        frame++;
        return frame % object.speed == 0;
      }), map(() => {
        const hitbox = hitboxes[i];
        if (!hitbox) {
          destroyHitbox$.next(object);
          destroyHitbox$.complete();
          return object;
        }
        object.position.x = hitbox.x;
        object.position.y = hitbox.y;
        object.setHitbox(hitbox.width, hitbox.height);
        i++;
        return object;
      }), mergeMap((object2) => from(object2.isCollided(object2.position, {
        allSearch: true
      }))), map(() => object));
    }
  }
  class EventEmitter {
    constructor() {
      this.listeners = {};
      this.listenersOnce = {};
    }
    has(name) {
      return !!this.listeners[name] || !!this.listenersOnce[name];
    }
    once(name, cb) {
      this.listenersOnce[name] = cb;
      return this;
    }
    on(name, cb) {
      if (!this.listeners[name])
        this.listeners[name] = [];
      this.listeners[name].push(cb);
      return this;
    }
    emit(name, data, rest = false) {
      const ret = [];
      if (this.listeners[name]) {
        for (let listener of this.listeners[name]) {
          if (rest)
            ret.push(listener(...data));
          else
            ret.push(listener(data));
        }
      }
      if (this.listenersOnce[name]) {
        if (rest)
          ret.push(this.listenersOnce[name](...data));
        else
          ret.push(this.listenersOnce[name](data));
      }
      return Promise.all(ret.map((val) => {
        if (!isPromise$1(val)) {
          return Promise.resolve(val);
        }
        return val;
      }));
    }
    off(name, listener) {
      if (!listener) {
        delete this.listeners[name];
        delete this.listenersOnce[name];
        return;
      }
      if (this.listeners[name]) {
        const index = this.listeners[name].indexOf(listener);
        if (index !== -1) {
          this.listeners[name].splice(index, 1);
        }
      }
    }
    clear() {
      this.listeners = {};
      this.listenersOnce = {};
    }
  }
  var HookServer = /* @__PURE__ */ ((HookServer2) => {
    HookServer2["Start"] = "Server.Start";
    HookServer2["Step"] = "Server.Step";
    HookServer2["Auth"] = "Server.Auth";
    HookServer2["PlayerConnected"] = "Server.onConnected";
    HookServer2["PlayerDisconnected"] = "Server.onDisconnected";
    HookServer2["AddMap"] = "Server.AddMap";
    HookServer2["AddEvent"] = "Server.AddEvent";
    HookServer2["AddWorldMaps"] = "Server.AddWorldMaps";
    HookServer2["AddDatabase"] = "Server.AddDatabase";
    HookServer2["PlayerInput"] = "Server.onInput";
    HookServer2["PlayerJoinMap"] = "Server.onJoinMap";
    HookServer2["PlayerLeaveMap"] = "Server.onLeaveMap";
    HookServer2["PlayerLevelUp"] = "Server.onLevelUp";
    HookServer2["PlayerDead"] = "Server.onDead";
    HookServer2["PlayerInShape"] = "Server.onInShape";
    HookServer2["PlayerOutShape"] = "Server.onOutShape";
    HookServer2["PlayerMove"] = "Server.PlayerMove";
    HookServer2["PlayerCanChangeMap"] = "Server.PlayerCanChangeMap";
    HookServer2["ScalabilityPlayerConnected"] = "Server.ScalabilityPlayerConnected";
    HookServer2["ScalabilityChangeServer"] = "Server.ScalabilityChangeServer";
    return HookServer2;
  })(HookServer || {});
  var HookClient = /* @__PURE__ */ ((HookClient2) => {
    HookClient2["Start"] = "Client.Start";
    HookClient2["Step"] = "Client.Step";
    HookClient2["Connected"] = "Client.Connected";
    HookClient2["Disconnect"] = "Client.Disconnect";
    HookClient2["ConnectedError"] = "Client.ConnectedError";
    HookClient2["AddSpriteSheet"] = "Client.AddSpriteSheet";
    HookClient2["AddGui"] = "Client.AddGui";
    HookClient2["AddSound"] = "Client.AddSound";
    HookClient2["SendInput"] = "Client.SendInput";
    HookClient2["BeforeSceneLoading"] = "Client.BeforeSceneLoading";
    HookClient2["AfterSceneLoading"] = "Client.AfterSceneLoading";
    HookClient2["SceneMapLoading"] = "Client.SceneMapLoading";
    HookClient2["SceneAddSprite"] = "Client.SceneAddSprite";
    HookClient2["SceneOnChanges"] = "Client.SceneOnChanges";
    HookClient2["SceneDraw"] = "Client.SceneDraw";
    HookClient2["SceneRemoveSprite"] = "Client.SceneRemoveSprite";
    HookClient2["AddSprite"] = "Client.AddSprite";
    HookClient2["RemoveSprite"] = "Client.RemoveSprite";
    HookClient2["UpdateSprite"] = "Client.UpdateSprite";
    HookClient2["ChangesSprite"] = "Client.ChangesSprite";
    HookClient2["WindowResize"] = "Client.WindowResize";
    HookClient2["SpriteMove"] = "Client.SpriteMove";
    return HookClient2;
  })(HookClient || {});
  class PluginSystem extends EventEmitter {
    constructor() {
      super(...arguments);
      this.customHooks = {};
    }
    customHookExists(name) {
      return this.customHooks[name];
    }
    loadPlugins(plugins, shared, type) {
      if (!plugins)
        return;
      for (let plugin of plugins) {
        if (!plugin)
          continue;
        let plug = [];
        if (!isArray$2(plugin)) {
          plug = [plugin];
        } else {
          plug = plugin;
        }
        const [side, options] = plug;
        if (!side[type])
          continue;
        side[type]({
          RpgPlugin,
          ...shared
        }, options);
      }
    }
    loadServerPlugins(plugins, shared) {
      this.loadPlugins(plugins, shared, "server");
    }
    loadClientPlugins(plugins, shared) {
      this.loadPlugins(plugins, shared, "client");
    }
  }
  const RpgPlugin = new PluginSystem();
  class GameWorker {
    constructor(options = {}) {
      this.options = options;
    }
    load() {
      return this;
    }
    call(methodName, data) {
      return this.pool.exec(methodName, [data]);
    }
  }
  var GameSide = /* @__PURE__ */ ((GameSide2) => {
    GameSide2["Server"] = "server";
    GameSide2["Client"] = "client";
    GameSide2["Worker"] = "worker";
    return GameSide2;
  })(GameSide || {});
  class RpgCommonGame extends EventEmitter {
    initialize(side) {
      this.side = side;
      this.events = {};
    }
    get isWorker() {
      return this.side == "worker";
    }
    start(world) {
      this.world = world;
    }
    createWorkers(options) {
      return new GameWorker(options);
    }
    addObject(_class, playerId) {
      let event;
      if (!playerId)
        playerId = generateUID();
      if (isClass(_class)) {
        if (this.side == "client") {
          event = new _class(this, playerId);
        } else {
          event = new _class(playerId);
        }
      } else {
        event = _class;
      }
      return event;
    }
    addPlayer(playerClass, playerId) {
      const player = this.addObject(playerClass, playerId);
      return player;
    }
    addEvent(eventClass, eventId) {
      const event = this.addObject(eventClass, eventId);
      return event;
    }
    addShape(obj) {
      const id = obj.name = obj.name || generateUID();
      const shape = new RpgShape(obj);
      shape.name = id;
      return shape;
    }
    async processInput(playerId, controls) {
      const player = this.world.getObject(playerId);
      const inputs = [];
      if (!player)
        return {
          player,
          inputs
        };
      while (player.pendingMove.length > 0) {
        const inputData = player.pendingMove.shift();
        let {
          input,
          deltaTimeInt
        } = inputData;
        let moving = false;
        if (controls && controls[input]) {
          const control = controls[input];
          const now = Date.now();
          const inputTime = player.inputsTimestamp[input] || 0;
          if (inputTime >= now) {
            continue;
          }
          if (control.delay) {
            let duration;
            let otherControls = [];
            if (typeof control.delay == "number") {
              duration = control.delay;
            } else {
              duration = control.delay.duration;
              if (control.delay.otherControls) {
                otherControls = control.delay.otherControls;
              }
            }
            player.inputsTimestamp[input] = now + duration;
            for (let control2 of otherControls) {
              player.inputsTimestamp[control2] = now + duration;
            }
          }
        }
        if (input == exports2.Control.Action) {
          await player.triggerCollisionWith(RpgCommonPlayer.ACTIONS.ACTION);
        } else if (input == exports2.Direction.Left || input == exports2.Direction.Right || input == exports2.Direction.Up || input == exports2.Direction.Down) {
          player.moving = true;
          moving = true;
          await player.moveByDirection(+input, deltaTimeInt || 1);
        }
        if (this.side == "server") {
          await RpgPlugin.emit("Server.onInput", [player, {
            ...inputData,
            moving
          }], true);
        }
        inputs.push(input);
      }
      return {
        player,
        inputs
      };
    }
  }
  const ACTIONS = {
    IDLE: 0,
    RUN: 1,
    ACTION: 2
  };
  class AbstractObject {
    constructor(gameEngine, playerId) {
      this.gameEngine = gameEngine;
      this.playerId = playerId;
      this.map = "";
      this.height = 0;
      this.width = 0;
      this.direction = 3;
      this.moving = false;
      this.checkCollision = true;
      this.clientModeMove = MoveClientMode.ByDirection;
      this.behavior = Behavior.Direction;
      this.inShapes = {};
      this.disableVirtualGrid = false;
      this.shapes = [];
      this.collisionWith = [];
      this._collisionWithTiles = [];
      this._collisionWithShapes = [];
      this.destroyMove$ = new Subject();
      this._destroy$ = new Subject();
      this._hitboxPos = new SATExports.Vector(0, 0);
      this.setHitbox(this.width, this.height);
      this.position = {
        x: 0,
        y: 0,
        z: 0
      };
    }
    static get ACTIONS() {
      return ACTIONS;
    }
    get id() {
      return this.playerId;
    }
    set id(str) {
      this.playerId = str;
    }
    updateInVirtualGrid() {
      const map2 = this.mapInstance;
      if (map2 && !this.disableVirtualGrid) {
        map2.grid.insertInCells(this.id, this.getSizeMaxShape());
      }
    }
    get canMove() {
      return this.clientModeMove == MoveClientMode.ByDirection;
    }
    set canMove(val) {
      this.clientModeMove = val ? MoveClientMode.ByDirection : MoveClientMode.Disabled;
    }
    /**
     * Get/Set position x, y and z of player
     * 
     * z is the depth layer. By default, its value is 0. Collisions and overlays will be performed with other objects on the same z-position. 
     * 
     * @title Get/Set position
     * @prop { { x: number, y: number, z: number } } position
     * @memberof Player
     */
    set position(val) {
      if (this.isDestroyed)
        return;
      const {
        x,
        y,
        z
      } = val;
      if (!isInstanceOf(val, Vector2d)) {
        val = new Vector2d(x, y, z);
      }
      this._hitboxPos.x = x;
      this._hitboxPos.y = y;
      this._hitboxPos.z = z;
      this.updateInVirtualGrid();
      this._position = new Proxy(val, {
        get: (target, prop) => target[prop],
        set: (target, prop, value) => {
          this._hitboxPos[prop] = value;
          target[prop] = value;
          this.updateInVirtualGrid();
          return true;
        }
      });
    }
    get position() {
      return this._position;
    }
    get worldPositionX() {
      let x = this.position.x;
      if (this.mapInstance) {
        x += this.mapInstance.worldX;
      }
      return x;
    }
    get worldPositionY() {
      let y = this.position.y;
      if (this.mapInstance) {
        y += this.mapInstance.worldY;
      }
      return y;
    }
    set posX(val) {
      this.position.x = val;
    }
    set posY(val) {
      this.position.y = val;
    }
    set posZ(val) {
      this.position.z = val;
    }
    /** @internal */
    get mapInstance() {
      if (this.gameEngine.side == GameSide.Client) {
        return RpgCommonMap.bufferClient.get(this.map);
      }
      return RpgCommonMap.buffer.get(this.map);
    }
    /**
    * 
    * Recovers all the colliding shapes of the current player 
    * 
    * @title Get Collision of shapes
    * @since 3.2.0
    * @readonly
    * @prop { RpgShape[] } shapes
    * @memberof Player
    * @memberof RpgSpriteLogic
    */
    get shapesCollision() {
      return this._collisionWithShapes;
    }
    /**
    * 
    * Recovers all the colliding tiles of the current player 
    * 
    * @title Get Collision of tiles
    * @since 3.0.0-beta.4
    * @readonly
    * @prop { TileInfo[] } tiles
    * @memberof Player
    * @memberof RpgSpriteLogic
    */
    get tilesCollision() {
      return this._collisionWithTiles;
    }
    /**
     * 
     * Recovers all other players and events colliding with the current player's hitbox
     * 
     * @title Get Collision of other players/events
     * @since 3.0.0-beta.4
     * @readonly
     * @prop { (RpgPlayer | RpgEvent)[] } otherPlayersCollision
     * @memberof Player
     * @memberof RpgSpriteLogic
     */
    get otherPlayersCollision() {
      return this.collisionWith;
    }
    /**
     * Define the size of the player. You can set the hitbox for collisions
     * 
     * ```ts
     * player.setSizes({
     *      width: 32,
     *      height: 32
     * })
     * ```
     * 
     * and with hitbox:
     * 
     *  ```ts
     * player.setSizes({
     *      width: 32,
     *      height: 32,
     *      hitbox: {
     *          width: 20,
     *          height: 20
     *      }
     * })
     * ```
     * 
     * @title Set Sizes
     * @method player.setSizes(key,value)
     * @param { { width: number, height: number, hitbox?: { width: number, height: number } } } obj
     * @deprecated
     * @returns {void}
     * @memberof Player
     */
    setSizes(obj) {
      this.width = obj.width;
      this.height = obj.height;
      if (obj.hitbox) {
        this.hitbox = new SATExports.Box(this._hitboxPos, obj.hitbox.width, obj.hitbox.height);
      }
    }
    /**
     * Define the hitbox of the player.
     * 
     * ```ts
     * player.setHitbox(20, 20)
     * ```
     * 
     * @title Set Hitbox
     * @method player.setHitbox(width,height)
     * @param {number} width
     * @param {number} height
     * @returns {void}
     * @memberof Player
     */
    setHitbox(width, height) {
      const map2 = this.mapInstance;
      if (map2) {
        this.width = map2.tileWidth;
        this.height = map2.tileHeight;
      }
      this.hitbox = new SATExports.Box(this._hitboxPos, width, height);
      this.wHitbox = width;
      this.hHitbox = height;
      this.updateInVirtualGrid();
    }
    set wHitbox(val) {
      this.hitbox.w = val;
    }
    set hHitbox(val) {
      this.hitbox.h = val;
    }
    get wHitbox() {
      return this.hitbox.w;
    }
    get hHitbox() {
      return this.hitbox.h;
    }
    directionToAngle(direction) {
      const angle = (direction < 2 ? +direction + 2 : direction - 2) * 90;
      return toRadians(angle);
    }
    /** @internal */
    defineNextPosition(direction, deltaTimeInt) {
      const angle = this.directionToAngle(direction);
      const computePosition = (prop) => {
        return this.position[prop] + this.speed * deltaTimeInt * (Math.round(Math[prop == "x" ? "cos" : "sin"](angle) * 100) / 100);
      };
      const x = this.speed < 1 ? computePosition("x") : round(computePosition("x"));
      const y = this.speed < 1 ? computePosition("y") : round(computePosition("y"));
      return new Vector2d(x, y, ~~this.position.z);
    }
    /** @internal */
    setPosition({
      x,
      y,
      tileX,
      tileY
    }, move = true) {
      const {
        tileWidth,
        tileHeight
      } = this.mapInstance;
      if (x !== void 0)
        this.posX = x;
      if (y !== void 0)
        this.posY = y;
      if (tileX !== void 0)
        this.posX = tileX * tileWidth;
      if (tileY !== void 0)
        this.posY = tileY * tileHeight;
    }
    /** @internal */
    async triggerCollisionWith(type) {
      let doChanges = false;
      for (let collisionWith of this.collisionWith) {
        if (collisionWith.isDestroyed)
          continue;
        if (collisionWith instanceof RpgShape) {
          const goMap = collisionWith.getProperty("go-map");
          if (goMap && "changeMap" in this)
            await this.changeMap(goMap);
        } else {
          if (type == AbstractObject.ACTIONS.ACTION) {
            if ("onAction" in collisionWith) {
              await collisionWith.execMethod("onAction", [this]);
              doChanges = true;
            }
          } else if ("onPlayerTouch" in collisionWith) {
            await collisionWith.execMethod("onPlayerTouch", [this]);
            doChanges = true;
          }
        }
      }
      if (this.syncChanges && doChanges)
        this.syncChanges();
    }
    /** @internal */
    zCollision(other) {
      const z = this.position.z;
      const otherZ = other.position.z;
      return intersection([z, z + this.height], [otherZ, otherZ + other.height]);
    }
    /** @internal */
    moveByDirection(direction, deltaTimeInt) {
      const nextPosition = this.defineNextPosition(direction, deltaTimeInt);
      return this.move(nextPosition);
    }
    /**
     * Retrieves a tile and checks if the player has a collision
     * 
     * ```ts
     * const tileInfo = player.getTile(20, 30)
     * console.log(tileInfo)
     * ```
     * 
     * Example of returns: 
     * 
     * ```ts
     *   {
     *       tiles: [
     *           {
     *               id: 0,
     *               terrain: [],
     *               probability: null,
     *               properties: [Object],
     *               animations: [],
     *               objectGroups: [],
     *               image: null,
     *               gid: 1
     *           }
     *       ],
     *       hasCollision: false,
     *       isOverlay: undefined,
     *       objectGroups: [],
     *       isClimbable: undefined,
     *       tileIndex: 93
     *   }
     * ```
     * 
     * @title Get Tile
     * @since 3.0.0-beta.4
     * @method player.getTile(x,y,z?)
     * @param {number} x
     * @param {number} y
     * @param {number} [z]
     * @returns {object}
     * @memberof Player
     * @memberof RpgSpriteLogic
     */
    getTile(x, y, z = 0, hitbox) {
      const map2 = this.mapInstance;
      return map2.getTile(hitbox || this.hitbox, x, y, [z, this.height]);
    }
    async collisionObjects(playerSizeBox, hitbox, triggers) {
      const map2 = this.mapInstance;
      if (!map2)
        return true;
      const events = this.gameEngine.world.getObjectsOfGroup(this.map, this);
      const objects = map2.grid.getObjectsByBox(playerSizeBox);
      let boolFound = false;
      for (let objectId of objects) {
        if (!events[objectId])
          continue;
        const event = events[objectId]["object"] || events[objectId];
        if (event.id == this.id)
          continue;
        if (!this.zCollision(event))
          continue;
        const collided = Hit.testPolyCollision(HitType.Box, hitbox, event.hitbox);
        for (let shape of this.shapes) {
          await this.collisionWithShape(shape, event);
        }
        for (let shape of event.shapes) {
          await event.collisionWithShape(shape, this);
        }
        if (triggers == null ? void 0 : triggers.near)
          triggers.near(event);
        if (collided) {
          this.collisionWith.push(event);
          this.triggerCollisionWith();
          let throughOtherPlayer = false;
          if (event.type == PlayerType.Player && this.type == PlayerType.Player) {
            if (!(event.throughOtherPlayer || this.throughOtherPlayer)) {
              boolFound = true;
              if (!(triggers == null ? void 0 : triggers.allSearch))
                return true;
            } else {
              throughOtherPlayer = true;
            }
          }
          if (!throughOtherPlayer && !(event.through || this.through)) {
            boolFound = true;
            if (!(triggers == null ? void 0 : triggers.allSearch))
              return true;
          }
        }
        if (boolFound) {
          if (triggers == null ? void 0 : triggers.collision)
            triggers.collision(event);
        }
      }
      return boolFound;
    }
    /** @internal */
    async collisionWithShape(shape, player, nextPosition) {
      const collision = shape.hasCollision;
      const z = shape.z;
      if (shape.isShapePosition())
        return false;
      if (z !== void 0 && !this.zCollision({
        position: {
          z
        },
        height: this.mapInstance.zTileHeight
      })) {
        return false;
      }
      let position;
      let {
        hitbox
      } = player;
      if (nextPosition) {
        position = nextPosition.copy();
      } else {
        position = player.position.copy();
      }
      const hitboxObj = Hit.createObjectHitbox(position.x, position.y, position.z, hitbox.w, hitbox.h);
      let collided = Hit.testPolyCollision(shape.type, hitboxObj, shape.hitbox);
      const playerPositionSaved = player.position.copy();
      const verifyIfPositionChanged = () => {
        if (this.position.z != playerPositionSaved.z && nextPosition) {
          nextPosition.z = this.position.z;
        }
        if (this.position.x != playerPositionSaved.x || this.position.y != playerPositionSaved.y) {
          return true;
        }
      };
      if (collided) {
        this._collisionWithShapes.push(shape);
        if (!collision)
          await shape.in(player);
        if (verifyIfPositionChanged() === true)
          return true;
        this.triggerCollisionWith();
        if (collision)
          return true;
      } else {
        await shape.out(player);
        if (verifyIfPositionChanged() === true)
          return true;
      }
      return false;
    }
    async collisionShapes(playerSizeBox, nextPosition, triggers) {
      const map2 = this.mapInstance;
      if (!map2)
        return false;
      const shapes = this.gameEngine.world.getShapesOfGroup(this.map);
      const shapesInGrid = this.gameEngine.side == GameSide.Client ? new Set(Object.keys(shapes)) : map2.gridShapes.getObjectsByBox(playerSizeBox);
      let boolFound = false;
      for (let shapeId of shapesInGrid) {
        const shape = shapes[shapeId]["object"] || shapes[shapeId];
        if (triggers == null ? void 0 : triggers.near)
          triggers.near(shape);
        const bool = await this.collisionWithShape(shape, this, nextPosition);
        if (bool) {
          if (triggers == null ? void 0 : triggers.collision)
            triggers.collision(shape);
          boolFound = true;
          if (!(triggers == null ? void 0 : triggers.allSearch))
            return true;
        }
      }
      return boolFound;
    }
    async computeNextPositionByTarget(nextPosition, target) {
      const pullDistance = target.distanceWith(nextPosition);
      if (pullDistance <= this.speed) {
        return nextPosition.set(target);
      }
      const pull = target.copy().subtract(nextPosition).multiply(1 / pullDistance);
      const totalPush = new Vector2dZero();
      let contenders = 0;
      const hitbox = Hit.createObjectHitbox(nextPosition.x, nextPosition.y, nextPosition.z, this.hitbox.w, this.hitbox.h);
      const createObstacle = function(x, y, radius) {
        const obstacle = new Vector2d(x, y);
        let push = nextPosition.copy().subtract(obstacle);
        let distance = nextPosition.distanceWith(obstacle) - radius - radius;
        if (distance < radius * 2 * 10) {
          ++contenders;
          if (distance < 1e-4)
            distance = 1e-4;
          let weight = 1 / distance;
          totalPush.add(push.multiply(weight));
        }
        return obstacle;
      };
      const area = this.mapInstance.tileheight * 2;
      this.mapInstance.gridTiles.getCells({
        minX: nextPosition.x - area,
        maxX: nextPosition.x + area,
        minY: nextPosition.y - area,
        maxY: nextPosition.y + area
      }, (index) => {
        if (index < 0)
          return;
        const pos = this.mapInstance.getTilePosition(index);
        const hitbox2 = Hit.createObjectHitbox(pos.x, pos.y, nextPosition.z, this.hitbox.w, this.hitbox.h);
        const radius = this.mapInstance.tilewidth / 2;
        const tile = this.getTile(pos.x, pos.y, nextPosition.z, hitbox2);
        if (tile.hasCollision) {
          createObstacle(pos.x, pos.y, radius);
        }
      });
      const playerSizeBox = this.getSizeMaxShape(nextPosition.x, nextPosition.y);
      await this.collisionObjects(playerSizeBox, hitbox, {
        collision: (event) => {
          const {
            x,
            y
          } = event.position;
          createObstacle(x, y, event.hitbox.w);
        },
        allSearch: true
      });
      await this.collisionShapes(playerSizeBox, nextPosition, {
        collision: (shape) => {
          const {
            x,
            y
          } = shape.position;
          createObstacle(x, y, shape.hitbox.w);
        },
        allSearch: true
      });
      pull.multiply(Math.max(1, 4 * contenders)).add(totalPush).normalize();
      return nextPosition.add(pull.multiply(this.speed));
    }
    async isCollided(nextPosition, options = {}) {
      var _a;
      this.collisionWith = [];
      this._collisionWithTiles = [];
      const prevMapId = this.map;
      const hitbox = Hit.createObjectHitbox(nextPosition.x, nextPosition.y, 0, this.hitbox.w, this.hitbox.h);
      const boundingMap = (_a = this.mapInstance) == null ? void 0 : _a.boundingMap(nextPosition, this.hitbox);
      let collided = false;
      if (boundingMap == null ? void 0 : boundingMap.bounding) {
        this.position.set(nextPosition);
        if (!options.allSearch)
          return true;
        else
          collided = true;
      }
      const tileCollision = (x, y) => {
        const tile = this.getTile(x, y, nextPosition.z, hitbox);
        if (tile.hasCollision) {
          this._collisionWithTiles.push(tile);
          return true;
        }
        return false;
      };
      if (tileCollision(nextPosition.x, nextPosition.y) || tileCollision(nextPosition.x + this.hitbox.w, nextPosition.y) || tileCollision(nextPosition.x, nextPosition.y + this.hitbox.h) || tileCollision(nextPosition.x + this.hitbox.w, nextPosition.y + this.hitbox.h)) {
        if (!options.allSearch)
          return true;
        else
          collided = true;
      }
      if (this.autoChangeMap && this.type == PlayerType.Player) {
        const changeMap = await this.autoChangeMap(nextPosition);
        if (changeMap) {
          return true;
        }
      }
      const playerSizeBox = this.getSizeMaxShape(nextPosition.x, nextPosition.y);
      if (await this.collisionObjects(playerSizeBox, hitbox, options)) {
        if (!options.allSearch)
          return true;
        else
          collided = true;
      }
      if (await this.collisionShapes(playerSizeBox, nextPosition, options)) {
        if (!options.allSearch)
          return true;
        else
          collided = true;
      }
      if (prevMapId != this.map) {
        return true;
      }
      return collided;
    }
    /**
     * Attach a shape to the player (and allow interaction with it)
     * 
     * ```ts
     * import { ShapePositioning } from '@rpgjs/server'
     * 
     * player.attachShape({
     *      width: 100,
     *      height: 100,
     *      positioning: ShapePositioning.Center
     * })
     * ```
     * 
     * @title Attach Shape
     * @method player.attachShape(parameters)
     * @param { { width: number, height: number, positioning?, name?, properties?: object } } obj
     * - positioning: Indicate where the shape is placed.
     * - properties: An object in order to retrieve information when interacting with the shape
     * - name: The name of the shape
     * @since 3.0.0-beta.3
     * @returns {RpgShape}
     * @memberof Player
     */
    attachShape(obj) {
      obj.name = obj.name || generateUID();
      const shape = new RpgShape({
        ...obj,
        fixEvent: this
      });
      this.shapes.push(shape);
      return shape;
    }
    /**
     * Returns all shapes assigned to this player
     * 
     * @title Get Shapes
     * @method player.getShapes()
     * @returns {RpgShape[]}
     * @since 3.0.0-beta.3
     * @memberof Player
     * @memberof RpgSpriteLogic
     */
    getShapes() {
      return this.shapes;
    }
    autoChangeDirection(nextPosition) {
      const {
        x,
        y
      } = this.position;
      const {
        x: nx,
        y: ny
      } = nextPosition;
      const diff = Math.abs(x - nx) > Math.abs(y - ny);
      if (diff) {
        if (nx > x) {
          this.changeDirection(exports2.Direction.Right);
        } else {
          this.changeDirection(exports2.Direction.Left);
        }
      } else {
        if (ny > y) {
          this.changeDirection(exports2.Direction.Down);
        } else {
          this.changeDirection(exports2.Direction.Up);
        }
      }
    }
    // @internal
    /**
     * We need to know if the event is deleted. Because when the event is deleted, you don't update the positions and you don't send the positions back to the client.
     */
    get isDestroyed() {
      return !!this._destroy$["_closed"];
    }
    /**
    * Stops the movement of the player who moves towards his target
    * 
    * @title Stop Move To
    * @method player.stopMoveTo()
    * @returns {void}
    * @since 3.2.0
    * @memberof MoveManager
    */
    stopMoveTo() {
      if (this.destroyMove$.closed)
        return;
      this.moving = false;
      this.destroyMove$.next(true);
      this.destroyMove$.unsubscribe();
    }
    _lookToward(player, otherPlayer) {
      const {
        x,
        y
      } = player;
      const {
        x: ox,
        y: oy
      } = otherPlayer;
      const dx = ox - x;
      const dy = oy - y;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 0) {
          return exports2.Direction.Right;
        } else {
          return exports2.Direction.Left;
        }
      } else {
        if (dy > 0) {
          return exports2.Direction.Down;
        } else {
          return exports2.Direction.Up;
        }
      }
    }
    _moveTo(tick$, positionTarget, options = {}) {
      let i = 0;
      let count = 0;
      const lastPositions = [];
      this.stopMoveTo();
      this.moving = true;
      this.destroyMove$ = new Subject();
      const {
        infinite,
        onStuck,
        onComplete
      } = options;
      const getPosition = () => {
        let pos;
        if ("x" in positionTarget) {
          pos = new Vector2d(positionTarget.x, positionTarget.y);
        } else {
          pos = positionTarget.position;
        }
        return pos;
      };
      return tick$.pipe(takeUntil(this.destroyMove$), takeUntil(this._destroy$), mergeMap(() => from(this.computeNextPositionByTarget(this.position.copy(), getPosition()))), filter(() => {
        return this.isDestroyed === false;
      }), map((position) => {
        this.autoChangeDirection(position);
        return this.position.set(position);
      }), tap((position) => {
        lastPositions[i] = position.copy();
        i++;
        count++;
        if (i >= 3) {
          i = 0;
        }
        if (lastPositions[2] && (lastPositions[0].isEqual(lastPositions[2]) || lastPositions[1].isEqual(lastPositions[2]) || lastPositions[0].isEqual(lastPositions[1]))) {
          this.direction = this._lookToward(this.position, getPosition());
          onStuck == null ? void 0 : onStuck(count);
          this.moving = false;
        } else if (this.position.isEqual(getPosition())) {
          onComplete == null ? void 0 : onComplete();
          if (!infinite) {
            this.stopMoveTo();
          }
        } else {
          count = 0;
          this.moving = true;
        }
      }));
    }
    /** @internal */
    async move(nextPosition) {
      this.autoChangeDirection(nextPosition);
      const notCollided = !await this.isCollided(nextPosition);
      if ((notCollided || !this.checkCollision) && !this.isDestroyed) {
        this.position = nextPosition.copy();
        await RpgPlugin.emit(HookServer.PlayerMove, this);
      }
      return true;
    }
    /**
     * Retrieves all shapes where the player is located
     * 
     * @title Get In-Shapes
     * @method player.getInShapes()
     * @returns {RpgShape[]}
     * @since 3.0.0-beta.3
     * @memberof Player
     */
    getInShapes() {
      return Object.values(this.inShapes);
    }
    /**
    * Get the current direction.
    * 
    * ```ts
    * player.getDirection()
    * ```
    * 
    * @title Get Direction
    * @method player.getDirection()
    * @returns {Direction | number} direction
    * @memberof Player
    */
    getDirection(direction) {
      return direction || this.direction;
    }
    /**
    * Changes the player's direction
    * 
    * ```ts
    * import { Direction } from '@rpgjs/server'
    * 
    * player.changeDirection(Direction.Left)
    * ```
    * 
    * @title Change direction
    * @method player.changeDirection(direction)
    * @param {Direction} direction
    * @enum {string}
    * 
    * Direction.Left | left
    * Direction.Right | right
    * Direction.Up | up
    * Direction.Down | down
    * @returns {boolean} the direction has changed
    * @memberof Player
    */
    changeDirection(direction) {
      const dir = +this.getDirection(direction);
      if (dir === void 0)
        return false;
      this.direction = dir;
      return true;
    }
    /**
     * Gets the necessary number of pixels to allow the player to cross a tile. 
     * This is the ratio between the height or width of the tile and the speed of the player.
     */
    get nbPixelInTile() {
      const direction = this.getDirection();
      switch (direction) {
        case exports2.Direction.Down:
        case exports2.Direction.Up:
          return Math.floor(this.mapInstance.tileHeight / this.speed);
        case exports2.Direction.Left:
        case exports2.Direction.Right:
          return Math.floor(this.mapInstance.tileWidth / this.speed);
        default:
          return NaN;
      }
    }
    getSizeMaxShape(x, y) {
      const _x = x || this.position.x;
      const _y = y || this.position.y;
      let minX = _x;
      let minY = _y;
      let maxX = _x + this.wHitbox;
      let maxY = _y + this.hHitbox;
      const shapes = this.getShapes();
      for (let shape of shapes) {
        if (shape.x < minX)
          minX = shape.x;
        if (shape.y < minY)
          minY = shape.y;
        const shapeMaxX = shape.x + shape.width;
        const shapeMaxY = shape.y + shape.height;
        if (shapeMaxX > maxX)
          maxX = shapeMaxX;
        if (shapeMaxY > maxY)
          maxY = shapeMaxY;
      }
      return {
        minX,
        minY,
        maxX,
        maxY
      };
    }
    /** @internal */
    async execMethod(methodName, methodData, instance) {
    }
  }
  const LiteralDirection = {
    1: "up",
    2: "right",
    3: "down",
    4: "left"
  };
  class RpgCommonPlayer extends AbstractObject {
    constructor() {
      super(...arguments);
      this.events = [];
      this.layerName = "";
      this.data = {};
      this.pendingMove = [];
      this.inputsTimestamp = {};
    }
  }
  class RpgCommonEvent extends RpgCommonPlayer {
  }
  var PrebuiltGui = /* @__PURE__ */ ((PrebuiltGui2) => {
    PrebuiltGui2["Dialog"] = "rpg-dialog";
    PrebuiltGui2["MainMenu"] = "rpg-main-menu";
    PrebuiltGui2["Shop"] = "rpg-shop";
    PrebuiltGui2["Disconnect"] = "rpg-disconnect";
    PrebuiltGui2["Gameover"] = "rpg-gameover";
    PrebuiltGui2["Save"] = "rpg-save";
    PrebuiltGui2["Controls"] = "rpg-controls";
    PrebuiltGui2["Notification"] = "rpg-notification";
    return PrebuiltGui2;
  })(PrebuiltGui || {});
  class MockIo {
    constructor() {
      this.events = /* @__PURE__ */ new Map();
    }
    on(name, value) {
      this.events.set(name, value);
    }
    off(name) {
      this.events.delete(name);
    }
    once(name, value) {
      this.on(name, value);
    }
    _trigger(name, data, client) {
      const fn = this.events.get(name);
      if (fn)
        fn(data, client);
    }
  }
  class MockSocket {
    constructor(io2, handshake) {
      this.io = io2;
      this.handshake = handshake;
      this.id = "" + Math.random();
    }
    on(name, value) {
      this.io.on(name, value, this.id);
      return this;
    }
    once(name, value) {
      this.io.once(name, value, this.id);
      return this;
    }
    emit(name, data) {
      this.io.emit(name, data, this.id);
    }
    removeAllListeners(name) {
      return this.off(name);
    }
    off(name) {
      this.io.off(name, this.id);
    }
  }
  class MockClientIo extends MockIo {
    constructor() {
      super(...arguments);
      this.id = "";
    }
    connection(handshake) {
      serverIo.connection(this, handshake);
      this._trigger("connect", void 0);
      return this;
    }
    emit(name, data) {
      serverIo._trigger(name, data, this);
      return this;
    }
    disconnect() {
      this.emit("disconnect", void 0);
    }
  }
  class MockServerIo extends MockIo {
    constructor() {
      super(...arguments);
      this.clients = /* @__PURE__ */ new Map();
    }
    connection(client, handshake) {
      const socket = new MockSocket(this, handshake);
      this.clients.set(socket.id, client);
      client.id = socket.id;
      this._trigger("connection", socket);
    }
    emit(name, data, id) {
      var _a;
      (_a = this.clients.get(id)) == null ? void 0 : _a._trigger(name, data);
    }
    clear() {
      this.clients.clear();
    }
  }
  const serverIo = new MockServerIo();
  const ClientIo = MockClientIo;
  const io = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    ClientIo,
    serverIo
  }, Symbol.toStringTag, { value: "Module" }));
  class Scheduler extends EventEmitter {
    constructor() {
      super(...arguments);
      this.fps = 60;
      this.deltaTime = 0;
      this.frame = 0;
      this.timestamp = 0;
      this.requestedDelay = 0;
      this.lastTimestamp = 0;
      this._tick = new BehaviorSubject({
        timestamp: 0,
        deltaTime: 0,
        frame: 0,
        deltaRatio: 0
      });
      this._stop = false;
    }
    get tick() {
      return this._tick.asObservable();
    }
    nextTick(timestamp) {
      this.lastTimestamp = this.lastTimestamp || this.timestamp;
      this.deltaTime = Utils.preciseNow() - this.timestamp;
      this.timestamp = timestamp;
      this._tick.next({
        timestamp: this.timestamp,
        deltaTime: this.deltaTime,
        frame: this.frame,
        deltaRatio: ~~this.deltaTime / ~~Utils.fps2ms(this.fps)
      });
      this.lastTimestamp = this.timestamp;
      this.frame++;
    }
    /**
     * start the schedule
     * @return {Scheduler} returns this scheduler instance
     */
    start(options) {
      if (options.maxFps)
        this.maxFps = options.maxFps;
      if (options.fps)
        this.fps = options.fps;
      if (options.delay)
        this.requestedDelay = options.delay;
      const requestAnimationFrame = (fn) => {
        if (Utils.isBrowser()) {
          window.requestAnimationFrame(fn.bind(this));
        } else {
          setTimeout(() => {
            this.requestedDelay = 0;
            fn(Utils.preciseNow());
          }, Utils.fps2ms(this.fps) + this.requestedDelay);
        }
      };
      if (!this.maxFps) {
        const loop = (timestamp) => {
          requestAnimationFrame(loop);
          this.nextTick(timestamp);
        };
        requestAnimationFrame(loop);
      } else {
        const msInterval = Utils.fps2ms(this.maxFps);
        let now = Utils.preciseNow();
        let then = Utils.preciseNow();
        const loop = (timestamp) => {
          if (this._stop)
            return;
          requestAnimationFrame(loop);
          now = Utils.preciseNow();
          const elapsed = now - then;
          if (elapsed > msInterval) {
            then = now - elapsed % msInterval;
            this.nextTick(timestamp);
          }
        };
        requestAnimationFrame(loop);
      }
      return this;
    }
    stop() {
      this._stop = true;
      this._tick.complete();
    }
  }
  function log(message) {
    return new Error(`[RPGJS] - ${message}`);
  }
  function warning(...message) {
    console.warn("[RPGJS Warning]", ...message);
  }
  const Logger = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    log,
    warning
  }, Symbol.toStringTag, { value: "Module" }));
  function RpgModule(options) {
    return (target) => {
      if (options.hooks) {
        target.hooks = options.hooks;
      }
      for (let key in options) {
        target.prototype[key] = options[key];
      }
    };
  }
  async function loadModules(modules, obj, middleware) {
    const {
      side,
      relations
    } = obj;
    let playerProps = {};
    let hooks = {};
    const getModuleClass = (module2) => {
      if (!module2)
        return null;
      let plug = [];
      if (!isArray$2(module2)) {
        plug = [module2];
      } else {
        plug = module2;
      }
      const [moduleClassSides, options] = plug;
      const moduleClass = moduleClassSides[side];
      if (!moduleClass)
        return null;
      return {
        moduleClass,
        options
      };
    };
    for (let module2 of modules) {
      const moduleObject = getModuleClass(module2);
      if (!moduleObject)
        continue;
      const {
        moduleClass
      } = moduleObject;
      if (moduleClass.hooks) {
        for (let key in moduleClass.hooks) {
          if (!hooks[key])
            hooks[key] = [];
          hooks[key] = [...hooks[key], ...moduleClass.hooks[key]];
        }
      }
    }
    for (let module2 of modules) {
      const moduleObject = getModuleClass(module2);
      if (!moduleObject)
        continue;
      const {
        moduleClass,
        options
      } = moduleObject;
      let mod;
      if (options && side == "client" && options[
        "server"
        /* Server */
      ]) {
        warning(`Data that may be sensitive (normally visible only on the server side) are made optional and visible on the client side.
Instead, import the configuration with the server! flag into an import. Example: 

import config from 'server!./config

'`, options[
          "server"
          /* Server */
        ]);
      }
      if (options && !isClass(moduleClass) && isFunction$2(moduleClass)) {
        mod = new (moduleClass(options[side]))();
      } else if (isClass(moduleClass)) {
        mod = new moduleClass();
      } else {
        mod = moduleClass;
      }
      if (middleware) {
        mod = middleware(mod);
        if (isPromise$1(mod)) {
          mod = await mod;
        }
      }
      const {
        imports,
        maps,
        spritesheets,
        sounds,
        gui,
        scenes,
        engine,
        database,
        worldMaps,
        scalability,
        events
      } = mod;
      if (imports) {
        await loadModules(imports, obj);
      }
      if (maps) {
        RpgPlugin.on(HookServer.AddMap, () => maps);
      }
      if (events) {
        RpgPlugin.on(HookServer.AddEvent, () => events);
      }
      if (worldMaps) {
        RpgPlugin.on(HookServer.AddWorldMaps, () => worldMaps);
      }
      if (database) {
        RpgPlugin.on(HookServer.AddDatabase, () => database);
      }
      if (spritesheets) {
        RpgPlugin.on(HookClient.AddSpriteSheet, () => spritesheets);
      }
      if (sounds) {
        RpgPlugin.on(HookClient.AddSound, () => sounds);
      }
      if (gui) {
        RpgPlugin.on(HookClient.AddGui, () => gui);
      }
      const player = side == "server" ? mod.player : mod.sprite;
      const loadRelations = (hook, relationName) => {
        if (!hook)
          return;
        for (let method2 in relations[relationName]) {
          const hookName = relations[relationName][method2];
          if (hook[method2])
            RpgPlugin.on(hookName, hook[method2]);
        }
        if (hooks[relationName]) {
          for (let methodName of hooks[relationName]) {
            const hookName = side + "." + relationName + "." + methodName;
            RpgPlugin.customHooks[hookName] = true;
            if (hook[methodName])
              RpgPlugin.on(hookName, hook[methodName]);
          }
        }
      };
      loadRelations(player, "player");
      if (player && player.props) {
        playerProps = Object.assign(playerProps, player.props);
      }
      loadRelations(engine, "engine");
      if (scalability)
        loadRelations(scalability._hooks, "scalability");
      if (scenes)
        loadRelations(scenes.map, "sceneMap");
    }
    return {
      playerProps
    };
  }
  function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
  }
  function quickselectStep(arr, k, left, right, compare) {
    while (right > left) {
      if (right - left > 600) {
        var n = right - left + 1;
        var m = k - left + 1;
        var z = Math.log(n);
        var s = 0.5 * Math.exp(2 * z / 3);
        var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
        var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
        var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
        quickselectStep(arr, k, newLeft, newRight, compare);
      }
      var t = arr[k];
      var i = left;
      var j = right;
      swap(arr, left, k);
      if (compare(arr[right], t) > 0)
        swap(arr, left, right);
      while (i < j) {
        swap(arr, i, j);
        i++;
        j--;
        while (compare(arr[i], t) < 0)
          i++;
        while (compare(arr[j], t) > 0)
          j--;
      }
      if (compare(arr[left], t) === 0)
        swap(arr, left, j);
      else {
        j++;
        swap(arr, j, right);
      }
      if (j <= k)
        left = j + 1;
      if (k <= j)
        right = j - 1;
    }
  }
  function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
  function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  class RBush {
    constructor(maxEntries = 9) {
      this._maxEntries = Math.max(4, maxEntries);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
      this.clear();
    }
    all() {
      return this._all(this.data, []);
    }
    search(bbox) {
      let node = this.data;
      const result = [];
      if (!intersects(bbox, node))
        return result;
      const toBBox = this.toBBox;
      const nodesToSearch = [];
      while (node) {
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          const childBBox = node.leaf ? toBBox(child) : child;
          if (intersects(bbox, childBBox)) {
            if (node.leaf)
              result.push(child);
            else if (contains(bbox, childBBox))
              this._all(child, result);
            else
              nodesToSearch.push(child);
          }
        }
        node = nodesToSearch.pop();
      }
      return result;
    }
    collides(bbox) {
      let node = this.data;
      if (!intersects(bbox, node))
        return false;
      const nodesToSearch = [];
      while (node) {
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          const childBBox = node.leaf ? this.toBBox(child) : child;
          if (intersects(bbox, childBBox)) {
            if (node.leaf || contains(bbox, childBBox))
              return true;
            nodesToSearch.push(child);
          }
        }
        node = nodesToSearch.pop();
      }
      return false;
    }
    load(data) {
      if (!(data && data.length))
        return this;
      if (data.length < this._minEntries) {
        for (let i = 0; i < data.length; i++) {
          this.insert(data[i]);
        }
        return this;
      }
      let node = this._build(data.slice(), 0, data.length - 1, 0);
      if (!this.data.children.length) {
        this.data = node;
      } else if (this.data.height === node.height) {
        this._splitRoot(this.data, node);
      } else {
        if (this.data.height < node.height) {
          const tmpNode = this.data;
          this.data = node;
          node = tmpNode;
        }
        this._insert(node, this.data.height - node.height - 1, true);
      }
      return this;
    }
    insert(item) {
      if (item)
        this._insert(item, this.data.height - 1);
      return this;
    }
    clear() {
      this.data = createNode([]);
      return this;
    }
    remove(item, equalsFn) {
      if (!item)
        return this;
      let node = this.data;
      const bbox = this.toBBox(item);
      const path = [];
      const indexes = [];
      let i, parent, goingUp;
      while (node || path.length) {
        if (!node) {
          node = path.pop();
          parent = path[path.length - 1];
          i = indexes.pop();
          goingUp = true;
        }
        if (node.leaf) {
          const index = findItem(item, node.children, equalsFn);
          if (index !== -1) {
            node.children.splice(index, 1);
            path.push(node);
            this._condense(path);
            return this;
          }
        }
        if (!goingUp && !node.leaf && contains(node, bbox)) {
          path.push(node);
          indexes.push(i);
          i = 0;
          parent = node;
          node = node.children[0];
        } else if (parent) {
          i++;
          node = parent.children[i];
          goingUp = false;
        } else
          node = null;
      }
      return this;
    }
    toBBox(item) {
      return item;
    }
    compareMinX(a, b) {
      return a.minX - b.minX;
    }
    compareMinY(a, b) {
      return a.minY - b.minY;
    }
    toJSON() {
      return this.data;
    }
    fromJSON(data) {
      this.data = data;
      return this;
    }
    _all(node, result) {
      const nodesToSearch = [];
      while (node) {
        if (node.leaf)
          result.push(...node.children);
        else
          nodesToSearch.push(...node.children);
        node = nodesToSearch.pop();
      }
      return result;
    }
    _build(items, left, right, height) {
      const N = right - left + 1;
      let M = this._maxEntries;
      let node;
      if (N <= M) {
        node = createNode(items.slice(left, right + 1));
        calcBBox(node, this.toBBox);
        return node;
      }
      if (!height) {
        height = Math.ceil(Math.log(N) / Math.log(M));
        M = Math.ceil(N / Math.pow(M, height - 1));
      }
      node = createNode([]);
      node.leaf = false;
      node.height = height;
      const N2 = Math.ceil(N / M);
      const N1 = N2 * Math.ceil(Math.sqrt(M));
      multiSelect(items, left, right, N1, this.compareMinX);
      for (let i = left; i <= right; i += N1) {
        const right2 = Math.min(i + N1 - 1, right);
        multiSelect(items, i, right2, N2, this.compareMinY);
        for (let j = i; j <= right2; j += N2) {
          const right3 = Math.min(j + N2 - 1, right2);
          node.children.push(this._build(items, j, right3, height - 1));
        }
      }
      calcBBox(node, this.toBBox);
      return node;
    }
    _chooseSubtree(bbox, node, level, path) {
      while (true) {
        path.push(node);
        if (node.leaf || path.length - 1 === level)
          break;
        let minArea = Infinity;
        let minEnlargement = Infinity;
        let targetNode;
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          const area = bboxArea(child);
          const enlargement = enlargedArea(bbox, child) - area;
          if (enlargement < minEnlargement) {
            minEnlargement = enlargement;
            minArea = area < minArea ? area : minArea;
            targetNode = child;
          } else if (enlargement === minEnlargement) {
            if (area < minArea) {
              minArea = area;
              targetNode = child;
            }
          }
        }
        node = targetNode || node.children[0];
      }
      return node;
    }
    _insert(item, level, isNode) {
      const bbox = isNode ? item : this.toBBox(item);
      const insertPath = [];
      const node = this._chooseSubtree(bbox, this.data, level, insertPath);
      node.children.push(item);
      extend(node, bbox);
      while (level >= 0) {
        if (insertPath[level].children.length > this._maxEntries) {
          this._split(insertPath, level);
          level--;
        } else
          break;
      }
      this._adjustParentBBoxes(bbox, insertPath, level);
    }
    // split overflowed node into two
    _split(insertPath, level) {
      const node = insertPath[level];
      const M = node.children.length;
      const m = this._minEntries;
      this._chooseSplitAxis(node, m, M);
      const splitIndex = this._chooseSplitIndex(node, m, M);
      const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
      newNode.height = node.height;
      newNode.leaf = node.leaf;
      calcBBox(node, this.toBBox);
      calcBBox(newNode, this.toBBox);
      if (level)
        insertPath[level - 1].children.push(newNode);
      else
        this._splitRoot(node, newNode);
    }
    _splitRoot(node, newNode) {
      this.data = createNode([node, newNode]);
      this.data.height = node.height + 1;
      this.data.leaf = false;
      calcBBox(this.data, this.toBBox);
    }
    _chooseSplitIndex(node, m, M) {
      let index;
      let minOverlap = Infinity;
      let minArea = Infinity;
      for (let i = m; i <= M - m; i++) {
        const bbox1 = distBBox(node, 0, i, this.toBBox);
        const bbox2 = distBBox(node, i, M, this.toBBox);
        const overlap = intersectionArea(bbox1, bbox2);
        const area = bboxArea(bbox1) + bboxArea(bbox2);
        if (overlap < minOverlap) {
          minOverlap = overlap;
          index = i;
          minArea = area < minArea ? area : minArea;
        } else if (overlap === minOverlap) {
          if (area < minArea) {
            minArea = area;
            index = i;
          }
        }
      }
      return index || M - m;
    }
    // sorts node children by the best axis for split
    _chooseSplitAxis(node, m, M) {
      const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
      const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
      const xMargin = this._allDistMargin(node, m, M, compareMinX);
      const yMargin = this._allDistMargin(node, m, M, compareMinY);
      if (xMargin < yMargin)
        node.children.sort(compareMinX);
    }
    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin(node, m, M, compare) {
      node.children.sort(compare);
      const toBBox = this.toBBox;
      const leftBBox = distBBox(node, 0, m, toBBox);
      const rightBBox = distBBox(node, M - m, M, toBBox);
      let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
      for (let i = m; i < M - m; i++) {
        const child = node.children[i];
        extend(leftBBox, node.leaf ? toBBox(child) : child);
        margin += bboxMargin(leftBBox);
      }
      for (let i = M - m - 1; i >= m; i--) {
        const child = node.children[i];
        extend(rightBBox, node.leaf ? toBBox(child) : child);
        margin += bboxMargin(rightBBox);
      }
      return margin;
    }
    _adjustParentBBoxes(bbox, path, level) {
      for (let i = level; i >= 0; i--) {
        extend(path[i], bbox);
      }
    }
    _condense(path) {
      for (let i = path.length - 1, siblings; i >= 0; i--) {
        if (path[i].children.length === 0) {
          if (i > 0) {
            siblings = path[i - 1].children;
            siblings.splice(siblings.indexOf(path[i]), 1);
          } else
            this.clear();
        } else
          calcBBox(path[i], this.toBBox);
      }
    }
  }
  function findItem(item, items, equalsFn) {
    if (!equalsFn)
      return items.indexOf(item);
    for (let i = 0; i < items.length; i++) {
      if (equalsFn(item, items[i]))
        return i;
    }
    return -1;
  }
  function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
  }
  function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode)
      destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;
    for (let i = k; i < p; i++) {
      const child = node.children[i];
      extend(destNode, node.leaf ? toBBox(child) : child);
    }
    return destNode;
  }
  function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
  }
  function compareNodeMinX(a, b) {
    return a.minX - b.minX;
  }
  function compareNodeMinY(a, b) {
    return a.minY - b.minY;
  }
  function bboxArea(a) {
    return (a.maxX - a.minX) * (a.maxY - a.minY);
  }
  function bboxMargin(a) {
    return a.maxX - a.minX + (a.maxY - a.minY);
  }
  function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
  }
  function intersectionArea(a, b) {
    const minX = Math.max(a.minX, b.minX);
    const minY = Math.max(a.minY, b.minY);
    const maxX = Math.min(a.maxX, b.maxX);
    const maxY = Math.min(a.maxY, b.maxY);
    return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
  }
  function contains(a, b) {
    return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
  }
  function intersects(a, b) {
    return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
  }
  function createNode(children) {
    return {
      children,
      height: 1,
      leaf: true,
      minX: Infinity,
      minY: Infinity,
      maxX: -Infinity,
      maxY: -Infinity
    };
  }
  function multiSelect(arr, left, right, n, compare) {
    const stack = [left, right];
    while (stack.length) {
      right = stack.pop();
      left = stack.pop();
      if (right - left <= n)
        continue;
      const mid = left + Math.ceil((right - left) / n / 2) * n;
      quickselect(arr, mid, left, right, compare);
      stack.push(left, mid, mid, right);
    }
  }
  class RpgCommonWorldMaps {
    constructor(id) {
      this.id = id;
      this.mapsTree = new RBush(500);
      this.maps = /* @__PURE__ */ new Map();
    }
    /**
     * Adding information from the map to the world
     *
     * > Maximum maps in world: 500
     * 
     * @title Add Map in world
     * @method world.addMap(wordMapInfo,map)
     * @param {object} wordMapInfo 
     * Object file:
     * ```ts
     * {
     *  fileName: string;
        height: number;
        width: number;
        x: number;
        y: number;
     * }
        ```
        `fileName` represents a file to the JSON file (TMX transformed) or directly the Tiled Map Editor object
     * 
     * @param {class of RpgMap} map 
     * @since 3.0.0-beta.8
     * @memberof RpgWorldMaps
     */
    addMap(wordMapInfo, map2) {
      const {
        x,
        y,
        height,
        width
      } = wordMapInfo;
      map2.prototype.worldMapParent = this;
      this.maps.set(map2.id, wordMapInfo);
      this.mapsTree.insert({
        minX: x,
        minY: y,
        maxX: x + width,
        maxY: y + height,
        map: map2
      });
    }
    updateMap(mapId, wordMapInfo) {
      const map2 = this.maps.get(mapId);
      if (map2) {
        const item = this.mapsTree.all().find((item2) => item2.map.id == mapId);
        if (!item)
          return false;
        this.maps.set(mapId, wordMapInfo);
        item.map.prototype.worldMapParent = this;
        item.minX = wordMapInfo.x;
        item.minY = wordMapInfo.y;
        item.maxX = wordMapInfo.x + wordMapInfo.width;
        item.maxY = wordMapInfo.y + wordMapInfo.height;
        return true;
      }
      return false;
    }
    /**
     * Remove map of the world
     * @title Remove map of the world
     * @method world.removeMap(mapId)
     * @param {string} mapId 
     * @returns {boolean}
     * @since 3.0.0-beta.8
     * @memberof RpgWorldMaps
     */
    removeMap(mapId) {
      const map2 = this.maps.get(mapId);
      if (map2) {
        const item = this.mapsTree.all().find((item2) => item2.map.id == mapId);
        if (!item)
          return false;
        this.maps.delete(mapId);
        item.map.prototype.worldMapParent = void 0;
        this.mapsTree.remove(item);
        return true;
      }
      return false;
    }
    removeAllMaps() {
      this.maps.forEach((map2, id) => {
        this.removeMap(id);
      });
    }
    /**
     * Retrieve information from the world
     * 
     * @title Retrieve information from the world
     * @method world.getMapInfo(id)
     * @param {string} id map id
     * @return {RpgTiledWorldMap | undefined}
     * {
     *  id?: string
     *  properties?: object
     *  fileName: string;
        height: number;
        width: number;
        x: number;
        y: number;
     * }
     * @since 3.0.0-beta.8
     * @memberof RpgWorldMaps
     */
    getMapInfo(id) {
      return this.maps.get(id);
    }
    /**
     * Retrieves neighboring maps according to positions or direction
     * 
     * @title Retrieves neighboring maps
     * @method world.getAdjacentMaps(map,search)
     * @param {RpgMap} map The source map. We want to find the neighboring maps of the source map
     * @param { PositionBox | Direction | { x: number, y: number } } search Research method
     *  * PositionBox. An object of the following form:
     *  `{ minX: number, minY: number, maxX: number, maxY: number }`
     *  * Direction. Collect all the maps in the given direction (e.g. the maps at the top)
     *  * Point: { x: number, y: number }
     * @return { {class of RpgMap}[] }
     * @since 3.0.0-beta.8
     * @example
     * ```ts
     * world.getAdjacentMaps(mymap, Direction.Up) // returns [class of RpgMap]
     * ```
     * @memberof RpgWorldMaps
     */
    getAdjacentMaps(map2, search) {
      let position = {};
      const point = search;
      if (typeof search == "number") {
        const padding = 1;
        switch (search) {
          case exports2.Direction.Up:
            position = {
              minX: map2.worldX + padding,
              maxX: map2.worldX + map2.widthPx - padding,
              minY: map2.worldY - padding - 1,
              maxY: map2.worldY - padding
            };
            break;
          case exports2.Direction.Right:
            position = {
              minX: map2.worldX + map2.widthPx + padding,
              maxX: map2.worldX + map2.widthPx + padding + 1,
              minY: map2.worldY + padding,
              maxY: map2.worldY + map2.heightPx - padding
            };
            break;
          case exports2.Direction.Down:
            position = {
              minX: map2.worldX + padding,
              maxX: map2.worldX + map2.widthPx - padding,
              minY: map2.worldY + map2.heightPx + padding,
              maxY: map2.worldY + map2.heightPx + padding + 1
            };
            break;
          case exports2.Direction.Left:
            position = {
              minX: map2.worldX - padding,
              maxX: map2.worldX - padding - 1,
              minY: map2.worldY + padding,
              maxY: map2.worldY + map2.heightPx - padding
            };
            break;
        }
      } else if (point.x) {
        position = {
          minX: point.x,
          maxX: point.x,
          minY: point.y,
          maxY: point.y
        };
      } else {
        position = search;
      }
      const result = this.mapsTree.search(position);
      return result.map((ret) => ret.map);
    }
  }
  function hexToRGB(hex) {
    let r = parseInt(hex.substring(0, 2), 16);
    let g = parseInt(hex.substring(2, 4), 16);
    let b = parseInt(hex.substring(4, 6), 16);
    return [r, g, b];
  }
  function RGBToHex(rgb) {
    let r = rgb[0].toString(16).padStart(2, "0");
    let g = rgb[1].toString(16).padStart(2, "0");
    let b = rgb[2].toString(16).padStart(2, "0");
    return r + g + b;
  }
  function transitionColor(startColor, endColor, steps) {
    let startRGB = hexToRGB(startColor.replace("#", ""));
    let endRGB = hexToRGB(endColor.replace("#", ""));
    let deltaRGB = [(endRGB[0] - startRGB[0]) / steps, (endRGB[1] - startRGB[1]) / steps, (endRGB[2] - startRGB[2]) / steps];
    let colors = [];
    for (let i = 0; i < steps; i++) {
      let color = [startRGB[0] + deltaRGB[0] * i, startRGB[1] + deltaRGB[1] * i, startRGB[2] + deltaRGB[2] * i];
      colors.push(RGBToHex(color));
    }
    colors.push(endColor.replace("#", ""));
    return colors;
  }
  const DefaultInput = {
    [exports2.Control.Up]: {
      repeat: true,
      bind: exports2.Input.Up
    },
    [exports2.Control.Down]: {
      repeat: true,
      bind: exports2.Input.Down
    },
    [exports2.Control.Right]: {
      repeat: true,
      bind: exports2.Input.Right
    },
    [exports2.Control.Left]: {
      repeat: true,
      bind: exports2.Input.Left
    },
    [exports2.Control.Action]: {
      bind: [exports2.Input.Space, exports2.Input.Enter]
    },
    [exports2.Control.Back]: {
      bind: exports2.Input.Escape
    }
  };
  class InjectContext {
    constructor() {
      this.instances = /* @__PURE__ */ new Map();
    }
    inject(constructor, args = []) {
      const serviceName = constructor.name;
      if (!this.instances.has(serviceName)) {
        const instance = new constructor(this, ...args);
        if (instance["initialize"]) {
          instance["initialize"](...args);
        }
        this.instances.set(serviceName, instance);
      }
      return this.instances.get(serviceName);
    }
  }
  exports2.AbstractObject = AbstractObject;
  exports2.DefaultInput = DefaultInput;
  exports2.EventEmitter = EventEmitter;
  exports2.GameSide = GameSide;
  exports2.Hit = Hit;
  exports2.HookClient = HookClient;
  exports2.HookServer = HookServer;
  exports2.InjectContext = InjectContext;
  exports2.LiteralDirection = LiteralDirection;
  exports2.Logger = Logger;
  exports2.MockIo = io;
  exports2.PrebuiltGui = PrebuiltGui;
  exports2.RpgCommonEvent = RpgCommonEvent;
  exports2.RpgCommonGame = RpgCommonGame;
  exports2.RpgCommonMap = RpgCommonMap;
  exports2.RpgCommonPlayer = RpgCommonPlayer;
  exports2.RpgCommonWorldMaps = RpgCommonWorldMaps;
  exports2.RpgModule = RpgModule;
  exports2.RpgPlugin = RpgPlugin;
  exports2.RpgShape = RpgShape;
  exports2.Scheduler = Scheduler;
  exports2.ShapePositioning = ShapePositioning;
  exports2.TransportIo = io;
  exports2.Utils = Utils$1;
  exports2.Vector2d = Vector2d;
  exports2.VirtualGrid = VirtualGrid;
  exports2.loadModules = loadModules;
  exports2.transitionColor = transitionColor;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
});
