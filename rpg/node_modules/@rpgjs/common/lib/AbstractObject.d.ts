import { RpgShape } from './Shape';
import SAT from 'sat';
import { TileInfo } from './Map';
import { RpgCommonGame } from './Game';
import { Vector2d } from './Vector2d';
import { Box } from './VirtualGrid';
import { Behavior, ClientMode, Direction, MoveTo, Position, PositionXY, Tick } from '@rpgjs/types';
import { Observable, Subject } from 'rxjs';
type CollisionOptions = {
    collision?: (event: AbstractObject) => void;
    near?: (event: AbstractObject) => void;
    allSearch?: boolean;
};
export declare class AbstractObject {
    gameEngine: RpgCommonGame;
    playerId: string;
    map: string;
    height: number;
    width: number;
    speed: number;
    direction: number;
    moving: boolean;
    checkCollision: boolean;
    clientModeMove: ClientMode;
    behavior: Behavior;
    hitbox: SAT.Box;
    inShapes: {
        [shapeId: string]: RpgShape;
    };
    disableVirtualGrid: boolean;
    private shapes;
    private _position;
    private _hitboxPos;
    private collisionWith;
    private _collisionWithTiles;
    private _collisionWithShapes;
    private destroyMove$;
    _destroy$: Subject<void>;
    static get ACTIONS(): {
        IDLE: number;
        RUN: number;
        ACTION: number;
    };
    constructor(gameEngine: RpgCommonGame, playerId: string);
    get id(): string;
    set id(str: string);
    updateInVirtualGrid(): void;
    get canMove(): boolean;
    set canMove(val: boolean);
    /**
     * Get/Set position x, y and z of player
     *
     * z is the depth layer. By default, its value is 0. Collisions and overlays will be performed with other objects on the same z-position.
     *
     * @title Get/Set position
     * @prop { { x: number, y: number, z: number } } position
     * @memberof Player
     */
    set position(val: Position | Vector2d);
    get position(): Vector2d;
    get worldPositionX(): number;
    get worldPositionY(): number;
    set posX(val: any);
    set posY(val: any);
    set posZ(val: any);
    /**
    *
    * Recovers all the colliding shapes of the current player
    *
    * @title Get Collision of shapes
    * @since 3.2.0
    * @readonly
    * @prop { RpgShape[] } shapes
    * @memberof Player
    * @memberof RpgSpriteLogic
    */
    get shapesCollision(): RpgShape[];
    /**
    *
    * Recovers all the colliding tiles of the current player
    *
    * @title Get Collision of tiles
    * @since 3.0.0-beta.4
    * @readonly
    * @prop { TileInfo[] } tiles
    * @memberof Player
    * @memberof RpgSpriteLogic
    */
    get tilesCollision(): TileInfo[];
    /**
     *
     * Recovers all other players and events colliding with the current player's hitbox
     *
     * @title Get Collision of other players/events
     * @since 3.0.0-beta.4
     * @readonly
     * @prop { (RpgPlayer | RpgEvent)[] } otherPlayersCollision
     * @memberof Player
     * @memberof RpgSpriteLogic
     */
    get otherPlayersCollision(): AbstractObject[];
    /**
     * Define the size of the player. You can set the hitbox for collisions
     *
     * ```ts
     * player.setSizes({
     *      width: 32,
     *      height: 32
     * })
     * ```
     *
     * and with hitbox:
     *
     *  ```ts
     * player.setSizes({
     *      width: 32,
     *      height: 32,
     *      hitbox: {
     *          width: 20,
     *          height: 20
     *      }
     * })
     * ```
     *
     * @title Set Sizes
     * @method player.setSizes(key,value)
     * @param { { width: number, height: number, hitbox?: { width: number, height: number } } } obj
     * @deprecated
     * @returns {void}
     * @memberof Player
     */
    setSizes(obj: {
        width: number;
        height: number;
        hitbox?: {
            width: number;
            height: number;
        };
    }): void;
    /**
     * Define the hitbox of the player.
     *
     * ```ts
     * player.setHitbox(20, 20)
     * ```
     *
     * @title Set Hitbox
     * @method player.setHitbox(width,height)
     * @param {number} width
     * @param {number} height
     * @returns {void}
     * @memberof Player
     */
    setHitbox(width: number, height: number): void;
    set wHitbox(val: any);
    set hHitbox(val: any);
    get wHitbox(): any;
    get hHitbox(): any;
    private directionToAngle;
    /**
     * Retrieves a tile and checks if the player has a collision
     *
     * ```ts
     * const tileInfo = player.getTile(20, 30)
     * console.log(tileInfo)
     * ```
     *
     * Example of returns:
     *
     * ```ts
     *   {
     *       tiles: [
     *           {
     *               id: 0,
     *               terrain: [],
     *               probability: null,
     *               properties: [Object],
     *               animations: [],
     *               objectGroups: [],
     *               image: null,
     *               gid: 1
     *           }
     *       ],
     *       hasCollision: false,
     *       isOverlay: undefined,
     *       objectGroups: [],
     *       isClimbable: undefined,
     *       tileIndex: 93
     *   }
     * ```
     *
     * @title Get Tile
     * @since 3.0.0-beta.4
     * @method player.getTile(x,y,z?)
     * @param {number} x
     * @param {number} y
     * @param {number} [z]
     * @returns {object}
     * @memberof Player
     * @memberof RpgSpriteLogic
     */
    getTile(x: number, y: number, z?: number, hitbox?: SAT.Box): TileInfo;
    private collisionObjects;
    private collisionShapes;
    computeNextPositionByTarget(nextPosition: Vector2d, target: Vector2d): Promise<Vector2d>;
    isCollided(nextPosition: Vector2d, options?: CollisionOptions): Promise<boolean>;
    /**
     * Attach a shape to the player (and allow interaction with it)
     *
     * ```ts
     * import { ShapePositioning } from '@rpgjs/server'
     *
     * player.attachShape({
     *      width: 100,
     *      height: 100,
     *      positioning: ShapePositioning.Center
     * })
     * ```
     *
     * @title Attach Shape
     * @method player.attachShape(parameters)
     * @param { { width: number, height: number, positioning?, name?, properties?: object } } obj
     * - positioning: Indicate where the shape is placed.
     * - properties: An object in order to retrieve information when interacting with the shape
     * - name: The name of the shape
     * @since 3.0.0-beta.3
     * @returns {RpgShape}
     * @memberof Player
     */
    attachShape(obj: {
        width: number;
        height: number;
        positioning?: string;
        name?: string;
        properties?: object;
    }): RpgShape;
    /**
     * Returns all shapes assigned to this player
     *
     * @title Get Shapes
     * @method player.getShapes()
     * @returns {RpgShape[]}
     * @since 3.0.0-beta.3
     * @memberof Player
     * @memberof RpgSpriteLogic
     */
    getShapes(): RpgShape[];
    private autoChangeDirection;
    /**
    * Stops the movement of the player who moves towards his target
    *
    * @title Stop Move To
    * @method player.stopMoveTo()
    * @returns {void}
    * @since 3.2.0
    * @memberof MoveManager
    */
    stopMoveTo(): void;
    private _lookToward;
    _moveTo(tick$: Observable<Tick>, positionTarget: AbstractObject | RpgShape | PositionXY, options?: MoveTo): Observable<Vector2d>;
    /**
     * Retrieves all shapes where the player is located
     *
     * @title Get In-Shapes
     * @method player.getInShapes()
     * @returns {RpgShape[]}
     * @since 3.0.0-beta.3
     * @memberof Player
     */
    getInShapes(): RpgShape[];
    /**
    * Get the current direction.
    *
    * ```ts
    * player.getDirection()
    * ```
    *
    * @title Get Direction
    * @method player.getDirection()
    * @returns {Direction | number} direction
    * @memberof Player
    */
    getDirection(direction?: Direction | number): string | number;
    /**
    * Changes the player's direction
    *
    * ```ts
    * import { Direction } from '@rpgjs/server'
    *
    * player.changeDirection(Direction.Left)
    * ```
    *
    * @title Change direction
    * @method player.changeDirection(direction)
    * @param {Direction} direction
    * @enum {string}
    *
    * Direction.Left | left
    * Direction.Right | right
    * Direction.Up | up
    * Direction.Down | down
    * @returns {boolean} the direction has changed
    * @memberof Player
    */
    changeDirection(direction: Direction): boolean;
    /**
     * Gets the necessary number of pixels to allow the player to cross a tile.
     * This is the ratio between the height or width of the tile and the speed of the player.
     */
    get nbPixelInTile(): any;
    getSizeMaxShape(x?: number, y?: number): Box;
}
export interface AbstractObject {
    readonly type: string;
    through: boolean;
    throughOtherPlayer: boolean;
    autoChangeMap?(nextPosition: Position): Promise<boolean>;
    execMethod(methodName: string, methodData?: any, instance?: any): any;
    changeMap(mapName: string): any;
    syncChanges(): any;
}
export {};
