import { intersection, generateUID, toRadians, isInstanceOf, round } from './Utils.js';
import { Hit, HitType } from './Hit.js';
import { RpgShape } from './Shape.js';
import SAT from 'sat';
import { RpgCommonMap } from './Map.js';
import { RpgPlugin, HookServer } from './Plugin.js';
import { GameSide } from './Game.js';
import { Vector2d, Vector2dZero } from './Vector2d.js';
import { Behavior, Direction, MoveClientMode, PlayerType } from '@rpgjs/types';
import { from, map, mergeMap, Subject, tap, takeUntil, filter } from 'rxjs';
const ACTIONS = { IDLE: 0, RUN: 1, ACTION: 2 };
export class AbstractObject {
    static get ACTIONS() {
        return ACTIONS;
    }
    constructor(gameEngine, playerId) {
        this.gameEngine = gameEngine;
        this.playerId = playerId;
        this.map = '';
        this.height = 0;
        this.width = 0;
        this.direction = 3;
        this.moving = false;
        /*
            Properties for move mode
        */
        this.checkCollision = true;
        this.clientModeMove = MoveClientMode.ByDirection;
        this.behavior = Behavior.Direction;
        this.inShapes = {};
        this.disableVirtualGrid = false;
        this.shapes = [];
        this.collisionWith = [];
        this._collisionWithTiles = [];
        this._collisionWithShapes = [];
        this.destroyMove$ = new Subject();
        // notifier for destroy
        this._destroy$ = new Subject();
        this._hitboxPos = new SAT.Vector(0, 0);
        this.setHitbox(this.width, this.height);
        this.position = { x: 0, y: 0, z: 0 };
    }
    get id() {
        return this.playerId;
    }
    set id(str) {
        this.playerId = str;
    }
    updateInVirtualGrid() {
        const map = this.mapInstance;
        if (map && !this.disableVirtualGrid /*&& this.gameEngine.isWorker TODO */) {
            map.grid.insertInCells(this.id, this.getSizeMaxShape());
        }
    }
    get canMove() {
        return this.clientModeMove == MoveClientMode.ByDirection;
    }
    set canMove(val) {
        this.clientModeMove = val ? MoveClientMode.ByDirection : MoveClientMode.Disabled;
    }
    /**
     * Get/Set position x, y and z of player
     *
     * z is the depth layer. By default, its value is 0. Collisions and overlays will be performed with other objects on the same z-position.
     *
     * @title Get/Set position
     * @prop { { x: number, y: number, z: number } } position
     * @memberof Player
     */
    set position(val) {
        if (this.isDestroyed)
            return;
        const { x, y, z } = val;
        if (!isInstanceOf(val, Vector2d)) {
            val = new Vector2d(x, y, z);
        }
        this._hitboxPos.x = x;
        this._hitboxPos.y = y;
        this._hitboxPos.z = z;
        this.updateInVirtualGrid();
        this._position = new Proxy(val, {
            get: (target, prop) => target[prop],
            set: (target, prop, value) => {
                this._hitboxPos[prop] = value;
                target[prop] = value;
                this.updateInVirtualGrid();
                return true;
            }
        });
    }
    get position() {
        return this._position;
    }
    get worldPositionX() {
        let x = this.position.x;
        if (this.mapInstance) {
            x += this.mapInstance.worldX;
        }
        return x;
    }
    get worldPositionY() {
        let y = this.position.y;
        if (this.mapInstance) {
            y += this.mapInstance.worldY;
        }
        return y;
    }
    set posX(val) {
        this.position.x = val;
    }
    set posY(val) {
        this.position.y = val;
    }
    set posZ(val) {
        this.position.z = val;
    }
    /** @internal */
    get mapInstance() {
        if (this.gameEngine.side == GameSide.Client) {
            return RpgCommonMap.bufferClient.get(this.map);
        }
        return RpgCommonMap.buffer.get(this.map);
    }
    /**
    *
    * Recovers all the colliding shapes of the current player
    *
    * @title Get Collision of shapes
    * @since 3.2.0
    * @readonly
    * @prop { RpgShape[] } shapes
    * @memberof Player
    * @memberof RpgSpriteLogic
    */
    get shapesCollision() {
        return this._collisionWithShapes;
    }
    /**
    *
    * Recovers all the colliding tiles of the current player
    *
    * @title Get Collision of tiles
    * @since 3.0.0-beta.4
    * @readonly
    * @prop { TileInfo[] } tiles
    * @memberof Player
    * @memberof RpgSpriteLogic
    */
    get tilesCollision() {
        return this._collisionWithTiles;
    }
    /**
     *
     * Recovers all other players and events colliding with the current player's hitbox
     *
     * @title Get Collision of other players/events
     * @since 3.0.0-beta.4
     * @readonly
     * @prop { (RpgPlayer | RpgEvent)[] } otherPlayersCollision
     * @memberof Player
     * @memberof RpgSpriteLogic
     */
    get otherPlayersCollision() {
        return this.collisionWith;
    }
    /**
     * Define the size of the player. You can set the hitbox for collisions
     *
     * ```ts
     * player.setSizes({
     *      width: 32,
     *      height: 32
     * })
     * ```
     *
     * and with hitbox:
     *
     *  ```ts
     * player.setSizes({
     *      width: 32,
     *      height: 32,
     *      hitbox: {
     *          width: 20,
     *          height: 20
     *      }
     * })
     * ```
     *
     * @title Set Sizes
     * @method player.setSizes(key,value)
     * @param { { width: number, height: number, hitbox?: { width: number, height: number } } } obj
     * @deprecated
     * @returns {void}
     * @memberof Player
     */
    setSizes(obj) {
        this.width = obj.width;
        this.height = obj.height;
        if (obj.hitbox) {
            this.hitbox = new SAT.Box(this._hitboxPos, obj.hitbox.width, obj.hitbox.height);
        }
    }
    /**
     * Define the hitbox of the player.
     *
     * ```ts
     * player.setHitbox(20, 20)
     * ```
     *
     * @title Set Hitbox
     * @method player.setHitbox(width,height)
     * @param {number} width
     * @param {number} height
     * @returns {void}
     * @memberof Player
     */
    setHitbox(width, height) {
        const map = this.mapInstance;
        if (map) {
            this.width = map.tileWidth;
            this.height = map.tileHeight;
        }
        this.hitbox = new SAT.Box(this._hitboxPos, width, height);
        this.wHitbox = width;
        this.hHitbox = height;
        this.updateInVirtualGrid();
    }
    set wHitbox(val) {
        this.hitbox.w = val;
    }
    set hHitbox(val) {
        this.hitbox.h = val;
    }
    get wHitbox() {
        return this.hitbox.w;
    }
    get hHitbox() {
        return this.hitbox.h;
    }
    directionToAngle(direction) {
        const angle = (direction < 2 ? +direction + 2 : direction - 2) * 90;
        return toRadians(angle);
    }
    /** @internal */
    defineNextPosition(direction, deltaTimeInt) {
        const angle = this.directionToAngle(direction);
        const computePosition = (prop) => {
            return this.position[prop] + this.speed * deltaTimeInt
                * (Math.round(Math[prop == 'x' ? 'cos' : 'sin'](angle) * 100) / 100);
        };
        // If it's greater than 1, round value to reduces bandwidth
        const x = this.speed < 1 ? computePosition('x') : round(computePosition('x'));
        const y = this.speed < 1 ? computePosition('y') : round(computePosition('y'));
        return new Vector2d(x, y, ~~this.position.z);
    }
    /** @internal */
    setPosition({ x, y, tileX, tileY }, move = true) {
        const { tileWidth, tileHeight } = this.mapInstance;
        if (x !== undefined)
            this.posX = x;
        if (y !== undefined)
            this.posY = y;
        if (tileX !== undefined)
            this.posX = tileX * tileWidth;
        if (tileY !== undefined)
            this.posY = tileY * tileHeight;
    }
    /** @internal */
    async triggerCollisionWith(type) {
        let doChanges = false;
        for (let collisionWith of this.collisionWith) {
            if (collisionWith.isDestroyed)
                continue;
            if (collisionWith instanceof RpgShape) {
                const goMap = collisionWith.getProperty('go-map');
                if (goMap && 'changeMap' in this)
                    await this.changeMap(goMap);
            }
            else {
                if (type == AbstractObject.ACTIONS.ACTION) {
                    if ('onAction' in collisionWith) {
                        await collisionWith.execMethod('onAction', [this]);
                        doChanges = true;
                    }
                }
                else if ('onPlayerTouch' in collisionWith) {
                    await collisionWith.execMethod('onPlayerTouch', [this]);
                    doChanges = true;
                }
            }
        }
        if (this.syncChanges && doChanges)
            this.syncChanges();
    }
    /** @internal */
    zCollision(other) {
        const z = this.position.z;
        const otherZ = other.position.z;
        return intersection([z, z + this.height], [otherZ, otherZ + other.height]);
    }
    /** @internal */
    moveByDirection(direction, deltaTimeInt) {
        const nextPosition = this.defineNextPosition(direction, deltaTimeInt);
        return this.move(nextPosition);
    }
    /**
     * Retrieves a tile and checks if the player has a collision
     *
     * ```ts
     * const tileInfo = player.getTile(20, 30)
     * console.log(tileInfo)
     * ```
     *
     * Example of returns:
     *
     * ```ts
     *   {
     *       tiles: [
     *           {
     *               id: 0,
     *               terrain: [],
     *               probability: null,
     *               properties: [Object],
     *               animations: [],
     *               objectGroups: [],
     *               image: null,
     *               gid: 1
     *           }
     *       ],
     *       hasCollision: false,
     *       isOverlay: undefined,
     *       objectGroups: [],
     *       isClimbable: undefined,
     *       tileIndex: 93
     *   }
     * ```
     *
     * @title Get Tile
     * @since 3.0.0-beta.4
     * @method player.getTile(x,y,z?)
     * @param {number} x
     * @param {number} y
     * @param {number} [z]
     * @returns {object}
     * @memberof Player
     * @memberof RpgSpriteLogic
     */
    getTile(x, y, z = 0, hitbox) {
        const map = this.mapInstance;
        return map.getTile(hitbox || this.hitbox, x, y, [z, this.height]);
    }
    async collisionObjects(playerSizeBox, hitbox, triggers) {
        const map = this.mapInstance;
        if (!map)
            return true;
        const events = this.gameEngine.world.getObjectsOfGroup(this.map, this);
        const objects = map.grid.getObjectsByBox(playerSizeBox);
        let boolFound = false;
        for (let objectId of objects) {
            // client side: read "object" property
            if (!events[objectId])
                continue;
            const event = events[objectId]['object'] || events[objectId];
            if (event.id == this.id)
                continue;
            if (!this.zCollision(event))
                continue;
            const collided = Hit.testPolyCollision(HitType.Box, hitbox, event.hitbox);
            for (let shape of this.shapes) {
                await this.collisionWithShape(shape, event);
            }
            for (let shape of event.shapes) {
                await event.collisionWithShape(shape, this);
            }
            if (triggers?.near)
                triggers.near(event);
            if (collided) {
                this.collisionWith.push(event);
                this.triggerCollisionWith();
                let throughOtherPlayer = false;
                if (event.type == PlayerType.Player && this.type == PlayerType.Player) {
                    if (!(event.throughOtherPlayer || this.throughOtherPlayer)) {
                        boolFound = true;
                        if (!triggers?.allSearch)
                            return true;
                    }
                    else {
                        throughOtherPlayer = true;
                    }
                }
                if (!throughOtherPlayer && (!(event.through || this.through))) {
                    boolFound = true;
                    if (!triggers?.allSearch)
                        return true;
                }
            }
            if (boolFound) {
                if (triggers?.collision)
                    triggers.collision(event);
            }
        }
        return boolFound;
    }
    /** @internal */
    async collisionWithShape(shape, player, nextPosition) {
        const collision = shape.hasCollision;
        const z = shape.z;
        if (shape.isShapePosition())
            return false;
        if (z !== undefined && !this.zCollision({
            position: { z },
            height: this.mapInstance.zTileHeight
        })) {
            return false;
        }
        let position;
        let { hitbox } = player;
        if (nextPosition) {
            position = nextPosition.copy();
        }
        else {
            position = player.position.copy();
        }
        const hitboxObj = Hit.createObjectHitbox(position.x, position.y, position.z, hitbox.w, hitbox.h);
        let collided = Hit.testPolyCollision(shape.type, hitboxObj, shape.hitbox);
        const playerPositionSaved = player.position.copy();
        // Position can changed after enter or exit shape. So, we need to verify if position changed and update if z is changed
        // If X or Y changed, we need to return true, it means that stop the current movement, and apply the new position
        const verifyIfPositionChanged = () => {
            if (this.position.z != playerPositionSaved.z && nextPosition) {
                nextPosition.z = this.position.z;
            }
            if (this.position.x != playerPositionSaved.x || this.position.y != playerPositionSaved.y) {
                return true;
            }
        };
        if (collided) {
            this._collisionWithShapes.push(shape);
            // TODO: in shape after map load
            if (!collision)
                await shape.in(player);
            if (verifyIfPositionChanged() === true)
                return true;
            this.triggerCollisionWith();
            if (collision)
                return true;
        }
        else {
            await shape.out(player);
            if (verifyIfPositionChanged() === true)
                return true;
        }
        return false;
    }
    async collisionShapes(playerSizeBox, nextPosition, triggers) {
        const map = this.mapInstance;
        if (!map)
            return false;
        const shapes = this.gameEngine.world.getShapesOfGroup(this.map);
        const shapesInGrid = this.gameEngine.side == GameSide.Client
            ? new Set(Object.keys(shapes))
            : map.gridShapes.getObjectsByBox(playerSizeBox);
        let boolFound = false;
        for (let shapeId of shapesInGrid) {
            const shape = shapes[shapeId]['object'] || shapes[shapeId];
            if (triggers?.near)
                triggers.near(shape);
            const bool = await this.collisionWithShape(shape, this, nextPosition);
            if (bool) {
                if (triggers?.collision)
                    triggers.collision(shape);
                boolFound = true;
                if (!triggers?.allSearch)
                    return true;
            }
        }
        return boolFound;
    }
    async computeNextPositionByTarget(nextPosition, target) {
        const pullDistance = target.distanceWith(nextPosition);
        if (pullDistance <= this.speed) {
            return nextPosition.set(target);
        }
        const pull = (target.copy().subtract(nextPosition)).multiply((1 / pullDistance));
        const totalPush = new Vector2dZero();
        let contenders = 0;
        const hitbox = Hit.createObjectHitbox(nextPosition.x, nextPosition.y, nextPosition.z, this.hitbox.w, this.hitbox.h);
        const createObstacle = function (x, y, radius) {
            const obstacle = new Vector2d(x, y);
            let push = nextPosition.copy().subtract(obstacle);
            let distance = (nextPosition.distanceWith(obstacle) - radius) - radius;
            if (distance < radius * 2 * 10) {
                ++contenders;
                if (distance < 0.0001)
                    distance = 0.0001; // avoid div by 0
                let weight = 1 / distance;
                totalPush.add(push.multiply(weight));
            }
            return obstacle;
        };
        const area = this.mapInstance.tileheight * 2;
        this.mapInstance.gridTiles.getCells({
            minX: nextPosition.x - area,
            maxX: nextPosition.x + area,
            minY: nextPosition.y - area,
            maxY: nextPosition.y + area
        }, (index) => {
            if (index < 0)
                return;
            const pos = this.mapInstance.getTilePosition(index);
            const hitbox = Hit.createObjectHitbox(pos.x, pos.y, nextPosition.z, this.hitbox.w, this.hitbox.h);
            const radius = this.mapInstance.tilewidth / 2;
            const tile = this.getTile(pos.x, pos.y, nextPosition.z, hitbox);
            if (tile.hasCollision) {
                createObstacle(pos.x, pos.y, radius);
            }
        });
        const playerSizeBox = this.getSizeMaxShape(nextPosition.x, nextPosition.y);
        await this.collisionObjects(playerSizeBox, hitbox, {
            collision: (event) => {
                const { x, y } = event.position;
                createObstacle(x, y, event.hitbox.w);
            },
            allSearch: true
        });
        await this.collisionShapes(playerSizeBox, nextPosition, {
            collision: (shape) => {
                const { x, y } = shape.position;
                createObstacle(x, y, shape.hitbox.w);
            },
            allSearch: true
        });
        pull
            .multiply(Math.max(1, 4 * contenders))
            .add(totalPush)
            .normalize();
        return nextPosition.add(pull.multiply(this.speed));
    }
    async isCollided(nextPosition, options = {}) {
        this.collisionWith = [];
        this._collisionWithTiles = [];
        const prevMapId = this.map;
        const hitbox = Hit.createObjectHitbox(nextPosition.x, nextPosition.y, 0, this.hitbox.w, this.hitbox.h);
        const boundingMap = this.mapInstance?.boundingMap(nextPosition, this.hitbox);
        let collided = false;
        if (boundingMap?.bounding) {
            this.position.set(nextPosition);
            if (!options.allSearch)
                return true;
            else
                collided = true;
        }
        const tileCollision = (x, y) => {
            const tile = this.getTile(x, y, nextPosition.z, hitbox);
            if (tile.hasCollision) {
                this._collisionWithTiles.push(tile);
                return true;
            }
            return false;
        };
        if (tileCollision(nextPosition.x, nextPosition.y) ||
            tileCollision(nextPosition.x + this.hitbox.w, nextPosition.y) ||
            tileCollision(nextPosition.x, nextPosition.y + this.hitbox.h) ||
            tileCollision(nextPosition.x + this.hitbox.w, nextPosition.y + this.hitbox.h)) {
            if (!options.allSearch)
                return true;
            else
                collided = true;
        }
        if (this.autoChangeMap && this.type == PlayerType.Player) {
            const changeMap = await this.autoChangeMap(nextPosition);
            if (changeMap) {
                return true;
            }
        }
        const playerSizeBox = this.getSizeMaxShape(nextPosition.x, nextPosition.y);
        if (await this.collisionObjects(playerSizeBox, hitbox, options)) {
            if (!options.allSearch)
                return true;
            else
                collided = true;
        }
        if (await this.collisionShapes(playerSizeBox, nextPosition, options)) {
            if (!options.allSearch)
                return true;
            else
                collided = true;
        }
        // if there is a change of map after a move, the moves are not changed
        if (prevMapId != this.map) {
            return true;
        }
        return collided;
    }
    /**
     * Attach a shape to the player (and allow interaction with it)
     *
     * ```ts
     * import { ShapePositioning } from '@rpgjs/server'
     *
     * player.attachShape({
     *      width: 100,
     *      height: 100,
     *      positioning: ShapePositioning.Center
     * })
     * ```
     *
     * @title Attach Shape
     * @method player.attachShape(parameters)
     * @param { { width: number, height: number, positioning?, name?, properties?: object } } obj
     * - positioning: Indicate where the shape is placed.
     * - properties: An object in order to retrieve information when interacting with the shape
     * - name: The name of the shape
     * @since 3.0.0-beta.3
     * @returns {RpgShape}
     * @memberof Player
     */
    attachShape(obj) {
        obj.name = (obj.name || generateUID());
        const shape = new RpgShape({
            ...obj,
            fixEvent: this
        });
        this.shapes.push(shape);
        return shape;
    }
    /**
     * Returns all shapes assigned to this player
     *
     * @title Get Shapes
     * @method player.getShapes()
     * @returns {RpgShape[]}
     * @since 3.0.0-beta.3
     * @memberof Player
     * @memberof RpgSpriteLogic
     */
    getShapes() {
        return this.shapes;
    }
    autoChangeDirection(nextPosition) {
        const { x, y } = this.position;
        const { x: nx, y: ny } = nextPosition;
        const diff = Math.abs(x - nx) > Math.abs(y - ny);
        if (diff) {
            if (nx > x) {
                this.changeDirection(Direction.Right);
            }
            else {
                this.changeDirection(Direction.Left);
            }
        }
        else {
            if (ny > y) {
                this.changeDirection(Direction.Down);
            }
            else {
                this.changeDirection(Direction.Up);
            }
        }
    }
    // @internal
    /**
     * We need to know if the event is deleted. Because when the event is deleted, you don't update the positions and you don't send the positions back to the client.
     */
    get isDestroyed() {
        return !!this._destroy$['_closed'];
    }
    /**
    * Stops the movement of the player who moves towards his target
    *
    * @title Stop Move To
    * @method player.stopMoveTo()
    * @returns {void}
    * @since 3.2.0
    * @memberof MoveManager
    */
    stopMoveTo() {
        if (this.destroyMove$.closed)
            return;
        this.moving = false;
        this.destroyMove$.next(true);
        this.destroyMove$.unsubscribe();
    }
    _lookToward(player, otherPlayer) {
        const { x, y } = player;
        const { x: ox, y: oy } = otherPlayer;
        // Calculate the differences between the x and y coordinates.
        const dx = ox - x;
        const dy = oy - y;
        // Determine the primary direction based on the relative magnitude
        // of the x and y differences.
        if (Math.abs(dx) > Math.abs(dy)) {
            if (dx > 0) {
                return Direction.Right;
            }
            else {
                return Direction.Left;
            }
        }
        else {
            if (dy > 0) {
                return Direction.Down;
            }
            else {
                return Direction.Up;
            }
        }
    }
    _moveTo(tick$, positionTarget, options = {}) {
        let i = 0;
        let count = 0;
        const lastPositions = [];
        this.stopMoveTo();
        this.moving = true;
        this.destroyMove$ = new Subject();
        const { infinite, onStuck, onComplete } = options;
        const getPosition = () => {
            let pos;
            if ('x' in positionTarget) {
                pos = new Vector2d(positionTarget.x, positionTarget.y);
            }
            else {
                pos = positionTarget.position;
            }
            return pos;
        };
        return tick$
            .pipe(takeUntil(this.destroyMove$), takeUntil(this._destroy$), mergeMap(() => from(this.computeNextPositionByTarget(this.position.copy(), getPosition()))), filter(() => {
            return this.isDestroyed === false;
        }), map((position) => {
            this.autoChangeDirection(position);
            return this.position.set(position);
        }), tap((position) => {
            lastPositions[i] = position.copy();
            i++;
            count++;
            if (i >= 3) {
                i = 0;
            }
            if (lastPositions[2] &&
                (lastPositions[0].isEqual(lastPositions[2]) ||
                    lastPositions[1].isEqual(lastPositions[2]) ||
                    lastPositions[0].isEqual(lastPositions[1]))) {
                this.direction = this._lookToward(this.position, getPosition());
                onStuck?.(count);
                this.moving = false;
            }
            else if (this.position.isEqual(getPosition())) {
                onComplete?.();
                if (!infinite) {
                    this.stopMoveTo();
                }
            }
            else {
                count = 0;
                this.moving = true;
            }
        }));
    }
    /** @internal */
    async move(nextPosition) {
        this.autoChangeDirection(nextPosition);
        const notCollided = !(await this.isCollided(nextPosition));
        if ((notCollided || !this.checkCollision) && !this.isDestroyed) {
            this.position = nextPosition.copy();
            await RpgPlugin.emit(HookServer.PlayerMove, this);
        }
        return true;
    }
    /**
     * Retrieves all shapes where the player is located
     *
     * @title Get In-Shapes
     * @method player.getInShapes()
     * @returns {RpgShape[]}
     * @since 3.0.0-beta.3
     * @memberof Player
     */
    getInShapes() {
        return Object.values(this.inShapes);
    }
    /**
    * Get the current direction.
    *
    * ```ts
    * player.getDirection()
    * ```
    *
    * @title Get Direction
    * @method player.getDirection()
    * @returns {Direction | number} direction
    * @memberof Player
    */
    getDirection(direction) {
        return direction || this.direction;
    }
    /**
    * Changes the player's direction
    *
    * ```ts
    * import { Direction } from '@rpgjs/server'
    *
    * player.changeDirection(Direction.Left)
    * ```
    *
    * @title Change direction
    * @method player.changeDirection(direction)
    * @param {Direction} direction
    * @enum {string}
    *
    * Direction.Left | left
    * Direction.Right | right
    * Direction.Up | up
    * Direction.Down | down
    * @returns {boolean} the direction has changed
    * @memberof Player
    */
    changeDirection(direction) {
        const dir = +this.getDirection(direction);
        if (dir === undefined)
            return false;
        this.direction = dir;
        return true;
    }
    /**
     * Gets the necessary number of pixels to allow the player to cross a tile.
     * This is the ratio between the height or width of the tile and the speed of the player.
     */
    get nbPixelInTile() {
        const direction = this.getDirection();
        switch (direction) {
            case Direction.Down:
            case Direction.Up:
                return Math.floor(this.mapInstance.tileHeight / this.speed);
            case Direction.Left:
            case Direction.Right:
                return Math.floor(this.mapInstance.tileWidth / this.speed);
            default:
                return NaN;
        }
    }
    getSizeMaxShape(x, y) {
        const _x = x || this.position.x;
        const _y = y || this.position.y;
        let minX = _x;
        let minY = _y;
        let maxX = _x + this.wHitbox;
        let maxY = _y + this.hHitbox;
        const shapes = this.getShapes();
        for (let shape of shapes) {
            if (shape.x < minX)
                minX = shape.x;
            if (shape.y < minY)
                minY = shape.y;
            const shapeMaxX = shape.x + shape.width;
            const shapeMaxY = shape.y + shape.height;
            if (shapeMaxX > maxX)
                maxX = shapeMaxX;
            if (shapeMaxY > maxY)
                maxY = shapeMaxY;
        }
        return {
            minX,
            minY,
            maxX,
            maxY
        };
    }
    /** @internal */
    async execMethod(methodName, methodData, instance) { }
}
//# sourceMappingURL=AbstractObject.js.map