import { generateUID, isClass } from './Utils.js';
import { EventEmitter } from './EventEmitter.js';
import { RpgCommonPlayer } from './Player.js';
import { Control, Direction } from '@rpgjs/types';
import { RpgPlugin } from './Plugin.js';
import { GameWorker } from './Worker.js';
import { RpgShape } from './Shape.js';
export var GameSide;
(function (GameSide) {
    GameSide["Server"] = "server";
    GameSide["Client"] = "client";
    GameSide["Worker"] = "worker";
})(GameSide || (GameSide = {}));
export class RpgCommonGame extends EventEmitter {
    initialize(side) {
        this.side = side;
        this.events = {}; // events for all player in map
    }
    get isWorker() {
        return this.side == 'worker';
    }
    start(world) {
        this.world = world;
    }
    createWorkers(options) {
        return new GameWorker(options);
    }
    addObject(_class, playerId) {
        let event;
        if (!playerId)
            playerId = generateUID();
        if (isClass(_class)) {
            if (this.side == GameSide.Client) {
                event = new _class(this, playerId);
            }
            else {
                event = new _class(playerId);
            }
        }
        else {
            event = _class;
        }
        return event;
    }
    addPlayer(playerClass, playerId) {
        const player = this.addObject(playerClass, playerId);
        return player;
    }
    addEvent(eventClass, eventId) {
        const event = this.addObject(eventClass, eventId);
        return event;
    }
    addShape(obj) {
        const id = obj.name = (obj.name || generateUID());
        const shape = new RpgShape(obj);
        shape.name = id;
        return shape;
    }
    async processInput(playerId, controls) {
        const player = this.world.getObject(playerId);
        const inputs = [];
        if (!player)
            return {
                player,
                inputs
            };
        const routesMove = [];
        while (player.pendingMove.length > 0) {
            const inputData = player.pendingMove.shift();
            let { input, deltaTimeInt } = inputData;
            let moving = false;
            if (controls && controls[input]) {
                const control = controls[input];
                const now = Date.now();
                const inputTime = player.inputsTimestamp[input] || 0;
                if (inputTime >= now) {
                    continue;
                }
                if (control.delay) {
                    let duration;
                    let otherControls = [];
                    if (typeof control.delay == 'number') {
                        duration = control.delay;
                    }
                    else {
                        duration = control.delay.duration;
                        if (control.delay.otherControls) {
                            otherControls = control.delay.otherControls;
                        }
                    }
                    player.inputsTimestamp[input] = now + duration;
                    for (let control of otherControls) {
                        player.inputsTimestamp[control] = now + duration;
                    }
                }
            }
            if (input == Control.Action) {
                await player.triggerCollisionWith(RpgCommonPlayer.ACTIONS.ACTION);
            }
            else if (input == Direction.Left ||
                input == Direction.Right ||
                input == Direction.Up ||
                input == Direction.Down) {
                player.moving = true;
                moving = true;
                const isMove = await player.moveByDirection(+input, deltaTimeInt || 1);
                if (isMove) {
                    routesMove.push(inputData);
                }
            }
            // TODO, is Worker
            // verify if is server because, rpg mode causes a bug (see #184)
            if (this.side == GameSide.Server) {
                await RpgPlugin.emit('Server.onInput', [player, {
                        ...inputData,
                        moving
                    }], true);
            }
            inputs.push(input);
        }
        return {
            player,
            inputs
        };
    }
}
//# sourceMappingURL=Game.js.map