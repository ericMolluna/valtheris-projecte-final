import { HitObject } from './Hit';
import SAT from 'sat';
import { RpgShape } from './Shape';
import { VirtualGrid } from './VirtualGrid';
import { RpgCommonWorldMaps } from './WorldMaps';
import { TiledMap, Tile, TiledObjectClass, MapClass } from '@rpgjs/tiled';
import { Vector2d } from './Vector2d';
import { AbstractObject } from './AbstractObject';
import { RpgCommonGame } from './Game';
import { Observable } from 'rxjs';
import { HitBox, MovingHitbox, Tick } from '@rpgjs/types';
export interface TileInfo {
    tiles: Tile[];
    hasCollision: boolean | undefined;
    isClimbable?: boolean | undefined;
    isOverlay: boolean | undefined;
    objectGroups: TiledObjectClass[];
    tileIndex: number;
}
export interface LayerInfo {
    type: string;
    name: string;
    opacity: number;
    visible: boolean;
    properties: any;
    objects: HitObject[];
    tiles: Tile[];
}
export declare class RpgCommonMap extends MapClass {
    /**
     * @title map id
     * @readonly
     * @prop {string} [id]
     * @memberof Map
     * */
    readonly id: string;
    grid: VirtualGrid;
    gridShapes: VirtualGrid;
    gridTiles: VirtualGrid;
    get tileWidth(): number;
    get tileHeight(): number;
    private worldMapParent;
    /**
     * Retrieves the X position of the map in the world (0 if no world assigned)
     *
     * @title World X Position
     * @prop {number} [worldX]
     * @readonly
     * @since 3.0.0-beta.8
     * @memberof Map
     * */
    get worldX(): number;
    /**
     * Retrieves the Y position of the map in the world (0 if no world assigned)
     *
     * @title World Y Position
     * @prop {number} [worldY]
     * @readonly
     * @since 3.0.0-beta.8
     * @memberof Map
     * */
    get worldY(): number;
    /**
     * Memorize the maps so you don't have to make a new request or open a file each time you load a map
     */
    static get buffer(): Map<any, any>;
    /**
     * In RPG mode, to avoid confusion with buffer, we have a new variable to memorize the maps
     */
    static get bufferClient(): Map<any, any>;
    load(data: TiledMap): void;
    /**
     * Create a shape dynamically on the map
     *
     * Object:
     *  - (number) x: Position X
     *  - (number) y: Position Y
     *  - (number) width: Width
     *  - (number) height: Height
     *  - (object) properties (optionnal):
     *      - (number) z: Position Z
     *      - (hexadecimal) color: Color (shared with client)
     *      - (boolean) collision
     *      - You can your own properties
     *
     * @title Create Shape
     * @since 3.0.0-beta.3
     * @method map.createShape(obj)
     * @param {object} obj
     * @returns {RpgShape}
     * @memberof Map
     */
    createShape(obj: HitObject): RpgShape;
    /**
     * Delete a shape
     *
     * @title Delete Shape
     * @method map.removeShape(name)
     * @param {string} name Name of shape
     * @returns {void}
     * @memberof Map
     */
    removeShape(name: string): void;
    clearShapes(): void;
    /**
     * Return all shapes on the map
     *
     * @title Get Shapes
     * @method map.getShapes()
     * @returns {RpgShape[]}
     * @memberof Map
     * @memberof RpgSceneMap
     */
    getShapes(): RpgShape[];
    /**
     * Returns a shape by its name. Returns undefined is nothing is found
     *
     * @title Get Shape by name
     * @method map.getShape(name)
     * @param {string} name Name of shape
     * @returns {RpgShape[] | undefined}
     * @memberof Map
     * @memberof RpgSceneMap
     */
    getShape(name: string): RpgShape | undefined;
    getPositionByShape(filter: (shape: RpgShape) => {}): {
        x: number;
        y: number;
        z: number;
    } | null;
    /**
     * Get tile and verify collision with hitbox
     * @param hitbox
     * @param x
     * @param y
     * @param z
     * @returns TileInfo
     */
    getTile(hitbox: any, x: number, y: number, z?: [number, number]): TileInfo;
    /**
     * Assign the map to a world

     * @title Assign the map to a world
     * @method map.setInWorldMaps(name)
     * @param {RpgWorldMaps} worldMap world maps
     * @since 3.0.0-beta.8
     * @memberof Map
     */
    setInWorldMaps(worldMap: RpgCommonWorldMaps): void;
    /**
     * Remove this map from the world
     * @title Remove this map from the world
     * @method map.removeFromWorldMaps()
     * @returns {boolean | undefined}
     * @since 3.0.0-beta.8
     * @memberof Map
     */
    removeFromWorldMaps(): boolean | undefined;
    /**
    * Recover the world attached to this map (`undefined` if no world attached)

    * @title Get attached World
    * @method map.getInWorldMaps()
    * @return {RpgCommonWorldMaps | undefined}
    * @since 3.0.0-beta.8
    * @memberof Map
    */
    getInWorldMaps(): RpgCommonWorldMaps | undefined;
    boundingMap(nextPosition: Vector2d, hitbox: SAT): {
        bounding: boolean;
        nextPosition: Vector2d;
    } | null;
    _createMovingHitbox<T extends RpgCommonGame>(gameEngine: T, tick$: Observable<Tick>, mapId: string, hitboxes: Pick<HitBox, 'width' | 'height' | 'x' | 'y'>[], options?: MovingHitbox): Observable<AbstractObject>;
}
