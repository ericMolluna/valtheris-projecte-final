class MockIo {
    constructor() {
        this.events = new Map();
    }
    on(name, value) {
        this.events.set(name, value);
    }
    off(name) {
        this.events.delete(name);
    }
    once(name, value) {
        this.on(name, value);
    }
    _trigger(name, data, client) {
        const fn = this.events.get(name);
        if (fn)
            fn(data, client);
    }
}
class MockSocket {
    constructor(io, handshake) {
        this.io = io;
        this.handshake = handshake;
        this.id = '' + Math.random();
    }
    on(name, value) {
        this.io.on(name, value, this.id);
        return this;
    }
    once(name, value) {
        this.io.once(name, value, this.id);
        return this;
    }
    emit(name, data) {
        this.io.emit(name, data, this.id);
    }
    removeAllListeners(name) {
        return this.off(name);
    }
    off(name) {
        this.io.off(name, this.id);
    }
}
class MockClientIo extends MockIo {
    constructor() {
        super(...arguments);
        this.id = '';
    }
    connection(handshake) {
        serverIo.connection(this, handshake);
        this._trigger('connect', undefined);
        return this;
    }
    emit(name, data) {
        serverIo._trigger(name, data, this);
        return this;
    }
    disconnect() {
        this.emit('disconnect', undefined);
    }
}
class MockServerIo extends MockIo {
    constructor() {
        super(...arguments);
        this.clients = new Map();
    }
    connection(client, handshake) {
        const socket = new MockSocket(this, handshake);
        this.clients.set(socket.id, client);
        client.id = socket.id;
        this._trigger('connection', socket);
    }
    emit(name, data, id) {
        this.clients.get(id)?._trigger(name, data);
    }
    clear() {
        this.clients.clear();
    }
}
export const serverIo = new MockServerIo();
export const ClientIo = MockClientIo;
//# sourceMappingURL=io.js.map