(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("@rpgjs/common"), require("@rpgjs/database")) : typeof define === "function" && define.amd ? define(["exports", "@rpgjs/common", "@rpgjs/database"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.RpgServer = {}, global2.common, global2.database));
})(this, function(exports2, common, database) {
  "use strict";
  const GENERIC_KEY_SCHEMA = "@";
  class Utils {
    static isObject(val) {
      return typeof val === "object" && !Array.isArray(val) && val != null;
    }
    static propertiesToArray(obj) {
      const addDelimiter = (a, b) => a ? `${a}.${b}` : b;
      const paths = (obj2 = {}, head = "") => {
        return Object.entries(obj2).reduce((product, array2) => {
          const [key] = array2;
          const value = array2[1];
          const extraProp = Room.hasExtraProp(value);
          let fullPath = addDelimiter(head, key == "0" ? GENERIC_KEY_SCHEMA : key);
          if (extraProp) {
            if (value.$syncWithClient === false) {
              return product;
            }
          }
          if (key[0] != "_" && !extraProp && (Utils.isObject(value) || Array.isArray(value))) {
            if (Object.keys(value).length == 0) {
              return product.concat(fullPath);
            }
            return product.concat(paths(value, fullPath));
          } else {
            return product.concat(fullPath);
          }
        }, []);
      };
      return paths(obj);
    }
    static generateId(n = 5) {
      return Math.random().toString(36).substring(n);
    }
    static async resolveValue(value) {
      if (value instanceof Promise) {
        return await value;
      }
      return value;
    }
    static set(obj, path2, value, onlyPlainObject = false) {
      if (Object(obj) !== obj)
        return obj;
      if (typeof path2 === "string") {
        path2 = path2.split(".");
      }
      let len = path2.length;
      if (!len)
        return obj;
      let current = obj;
      for (let i2 = 0; i2 < len - 1; i2++) {
        let segment = path2[i2];
        let nextSegment = path2[i2 + 1];
        let isNextNumeric = !isNaN(nextSegment) && isFinite(nextSegment);
        if (!current[segment] || typeof current[segment] !== "object") {
          current[segment] = isNextNumeric && !onlyPlainObject ? [] : {};
        }
        current = current[segment];
      }
      current[path2[len - 1]] = value;
      return obj;
    }
    static get(obj, path2) {
      const keys2 = path2.split(".");
      let current = obj;
      for (let key of keys2) {
        if (current[key] === void 0) {
          return void 0;
        }
        current = current[key];
      }
      return current;
    }
    static bufferFrom(input) {
      if (typeof input === "string") {
        let encoder2 = new TextEncoder();
        return encoder2.encode(input);
      } else if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
        return new Uint8Array(input);
      } else {
        throw new Error("Input type not supported");
      }
    }
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getAugmentedNamespace(n) {
    if (n.__esModule)
      return n;
    var f = n.default;
    if (typeof f == "function") {
      var a = function a2() {
        if (this instanceof a2) {
          var args = [null];
          args.push.apply(args, arguments);
          var Ctor = Function.bind.apply(f, args);
          return new Ctor();
        }
        return f.apply(this, arguments);
      };
      a.prototype = f.prototype;
    } else
      a = {};
    Object.defineProperty(a, "__esModule", {
      value: true
    });
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  }
  var browser$2 = {};
  var encode$4 = {};
  var encodeBuffer = {};
  var writeCore = {};
  var extBuffer = {};
  var bufferish = {};
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var inited = false;
  function init() {
    inited = true;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup[i2] = code[i2];
      revLookup[code.charCodeAt(i2)] = i2;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
  }
  function toByteArray(b64) {
    if (!inited) {
      init();
    }
    var i2, j, l, tmp, placeHolders, arr;
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
    arr = new Arr(len * 3 / 4 - placeHolders);
    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;
    for (i2 = 0, j = 0; i2 < l; i2 += 4, j += 3) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[L++] = tmp >> 16 & 255;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[L++] = tmp & 255;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint82, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint82[i2] << 16) + (uint82[i2 + 1] << 8) + uint82[i2 + 2];
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint82) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint82.length;
    var extraBytes = len % 3;
    var output = "";
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint82, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint82[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[tmp << 4 & 63];
      output += "==";
    } else if (extraBytes === 2) {
      tmp = (uint82[len - 2] << 8) + uint82[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[tmp >> 4 & 63];
      output += lookup[tmp << 2 & 63];
      output += "=";
    }
    parts.push(output);
    return parts.join("");
  }
  function read$2(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i2];
    i2 += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  }
  function write$2(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c2 = Math.pow(2, -e)) < 1) {
        e--;
        c2 *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c2;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c2 >= 2) {
        e++;
        c2 /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c2 - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
    }
    buffer[offset + i2 - d] |= s * 128;
  }
  var toString$4 = {}.toString;
  var isArray$7 = Array.isArray || function(arr) {
    return toString$4.call(arr) == "[object Array]";
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  var INSPECT_MAX_BYTES = 50;
  Buffer$2.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== void 0 ? global.TYPED_ARRAY_SUPPORT : true;
  kMaxLength();
  function kMaxLength() {
    return Buffer$2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function createBuffer(that, length) {
    if (kMaxLength() < length) {
      throw new RangeError("Invalid typed array length");
    }
    if (Buffer$2.TYPED_ARRAY_SUPPORT) {
      that = new Uint8Array(length);
      that.__proto__ = Buffer$2.prototype;
    } else {
      if (that === null) {
        that = new Buffer$2(length);
      }
      that.length = length;
    }
    return that;
  }
  function Buffer$2(arg, encodingOrOffset, length) {
    if (!Buffer$2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$2)) {
      return new Buffer$2(arg, encodingOrOffset, length);
    }
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new Error(
          "If encoding is specified then the first argument must be a string"
        );
      }
      return allocUnsafe(this, arg);
    }
    return from$1(this, arg, encodingOrOffset, length);
  }
  Buffer$2.poolSize = 8192;
  Buffer$2._augment = function(arr) {
    arr.__proto__ = Buffer$2.prototype;
    return arr;
  };
  function from$1(that, value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length);
    }
    if (typeof value === "string") {
      return fromString(that, value, encodingOrOffset);
    }
    return fromObject(that, value);
  }
  Buffer$2.from = function(value, encodingOrOffset, length) {
    return from$1(null, value, encodingOrOffset, length);
  };
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    Buffer$2.prototype.__proto__ = Uint8Array.prototype;
    Buffer$2.__proto__ = Uint8Array;
  }
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }
  function alloc(that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
    }
    return createBuffer(that, size);
  }
  Buffer$2.alloc = function(size, fill, encoding) {
    return alloc(null, size, fill, encoding);
  };
  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer$2.TYPED_ARRAY_SUPPORT) {
      for (var i2 = 0; i2 < size; ++i2) {
        that[i2] = 0;
      }
    }
    return that;
  }
  Buffer$2.allocUnsafe = function(size) {
    return allocUnsafe(null, size);
  };
  Buffer$2.allocUnsafeSlow = function(size) {
    return allocUnsafe(null, size);
  };
  function fromString(that, string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer$2.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }
    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);
    var actual = that.write(string, encoding);
    if (actual !== length) {
      that = that.slice(0, actual);
    }
    return that;
  }
  function fromArrayLike$1(that, array2) {
    var length = array2.length < 0 ? 0 : checked(array2.length) | 0;
    that = createBuffer(that, length);
    for (var i2 = 0; i2 < length; i2 += 1) {
      that[i2] = array2[i2] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array2, byteOffset, length) {
    array2.byteLength;
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError("'offset' is out of bounds");
    }
    if (array2.byteLength < byteOffset + (length || 0)) {
      throw new RangeError("'length' is out of bounds");
    }
    if (byteOffset === void 0 && length === void 0) {
      array2 = new Uint8Array(array2);
    } else if (length === void 0) {
      array2 = new Uint8Array(array2, byteOffset);
    } else {
      array2 = new Uint8Array(array2, byteOffset, length);
    }
    if (Buffer$2.TYPED_ARRAY_SUPPORT) {
      that = array2;
      that.__proto__ = Buffer$2.prototype;
    } else {
      that = fromArrayLike$1(that, array2);
    }
    return that;
  }
  function fromObject(that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);
      if (that.length === 0) {
        return that;
      }
      obj.copy(that, 0, 0, len);
      return that;
    }
    if (obj) {
      if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
        if (typeof obj.length !== "number" || isnan(obj.length)) {
          return createBuffer(that, 0);
        }
        return fromArrayLike$1(that, obj);
      }
      if (obj.type === "Buffer" && isArray$7(obj.data)) {
        return fromArrayLike$1(that, obj.data);
      }
    }
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
    }
    return length | 0;
  }
  Buffer$2.isBuffer = isBuffer$2;
  function internalIsBuffer(b) {
    return !!(b != null && b._isBuffer);
  }
  Buffer$2.compare = function compare(a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError("Arguments must be Buffers");
    }
    if (a === b)
      return 0;
    var x = a.length;
    var y = b.length;
    for (var i2 = 0, len = Math.min(x, y); i2 < len; ++i2) {
      if (a[i2] !== b[i2]) {
        x = a[i2];
        y = b[i2];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer$2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer$2.concat = function concat(list, length) {
    if (!isArray$7(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer$2.alloc(0);
    }
    var i2;
    if (length === void 0) {
      length = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length += list[i2].length;
      }
    }
    var buffer = Buffer$2.allocUnsafe(length);
    var pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      var buf = list[i2];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer;
  };
  function byteLength(string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length;
    }
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      string = "" + string;
    }
    var len = string.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
        case void 0:
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string).length;
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer$2.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer$2.prototype._isBuffer = true;
  function swap(b, n, m) {
    var i2 = b[n];
    b[n] = b[m];
    b[m] = i2;
  }
  Buffer$2.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i2 = 0; i2 < len; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer$2.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i2 = 0; i2 < len; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer$2.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i2 = 0; i2 < len; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer$2.prototype.toString = function toString2() {
    var length = this.length | 0;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer$2.prototype.equals = function equals(b) {
    if (!internalIsBuffer(b))
      throw new TypeError("Argument must be a Buffer");
    if (this === b)
      return true;
    return Buffer$2.compare(this, b) === 0;
  };
  Buffer$2.prototype.inspect = function inspect2() {
    var str2 = "";
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str2 = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
      if (this.length > max)
        str2 += " ... ";
    }
    return "<Buffer " + str2 + ">";
  };
  Buffer$2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError("Argument must be a Buffer");
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i2 = 0; i2 < len; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x = thisCopy[i2];
        y = targetCopy[i2];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    if (buffer.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (isNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer$2.from(val, encoding);
    }
    if (internalIsBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (Buffer$2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    var i2;
    if (dir) {
      var foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read2(arr, i2 + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer$2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer$2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer$2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new TypeError("Invalid hex string");
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i2 = 0; i2 < length; ++i2) {
      var parsed = parseInt(string.substr(i2 * 2, 2), 16);
      if (isNaN(parsed))
        return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer$2.prototype.write = function write3(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    var remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
          return asciiWrite(this, string, offset, length);
        case "latin1":
        case "binary":
          return latin1Write(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer$2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf);
    } else {
      return fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i2 = start;
    while (i2 < end) {
      var firstByte = buf[i2];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i2 = 0;
    while (i2 < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = "";
    for (var i2 = start; i2 < end; ++i2) {
      out += toHex(buf[i2]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for (var i2 = 0; i2 < bytes.length; i2 += 2) {
      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    }
    return res;
  }
  Buffer$2.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf;
    if (Buffer$2.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer$2.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer$2(sliceLen, void 0);
      for (var i2 = 0; i2 < sliceLen; ++i2) {
        newBuf[i2] = this[i2 + start];
      }
    }
    return newBuf;
  };
  function checkOffset(offset, ext2, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext2 > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer$2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength2 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    return val;
  };
  Buffer$2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    var val = this[offset + --byteLength2];
    var mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer$2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer$2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer$2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer$2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer$2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer$2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength2 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer$2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    var i2 = byteLength2;
    var mul = 1;
    var val = this[offset + --i2];
    while (i2 > 0 && (mul *= 256)) {
      val += this[offset + --i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer$2.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer$2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer$2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer$2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer$2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer$2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return read$2(this, offset, true, 23, 4);
  };
  Buffer$2.prototype.readFloatBE = function readFloatBE2(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return read$2(this, offset, false, 23, 4);
  };
  Buffer$2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return read$2(this, offset, true, 52, 8);
  };
  Buffer$2.prototype.readDoubleBE = function readDoubleBE2(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return read$2(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext2, max, min) {
    if (!internalIsBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext2 > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer$2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    var mul = 1;
    var i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength2 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer$2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    var i2 = byteLength2 - 1;
    var mul = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer$2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    if (!Buffer$2.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    this[offset] = value & 255;
    return offset + 1;
  };
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 65535 + value + 1;
    for (var i2 = 0, j = Math.min(buf.length - offset, 2); i2 < j; ++i2) {
      buf[offset + i2] = (value & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
    }
  }
  Buffer$2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    if (Buffer$2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer$2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    if (Buffer$2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 4294967295 + value + 1;
    for (var i2 = 0, j = Math.min(buf.length - offset, 4); i2 < j; ++i2) {
      buf[offset + i2] = value >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
    }
  }
  Buffer$2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    if (Buffer$2.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer$2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    if (Buffer$2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  Buffer$2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    var i2 = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer$2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    var i2 = byteLength2 - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer$2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (!Buffer$2.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer$2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    if (Buffer$2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer$2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    if (Buffer$2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  Buffer$2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (Buffer$2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer$2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    if (Buffer$2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext2, max, min) {
    if (offset + ext2 > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    write$2(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer$2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer$2.prototype.writeFloatBE = function writeFloatBE2(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    write$2(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer$2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer$2.prototype.writeDoubleBE = function writeDoubleBE2(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer$2.prototype.copy = function copy2(target, targetStart, start, end) {
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("sourceStart out of bounds");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    var i2;
    if (this === target && start < targetStart && targetStart < end) {
      for (i2 = len - 1; i2 >= 0; --i2) {
        target[i2 + targetStart] = this[i2 + start];
      }
    } else if (len < 1e3 || !Buffer$2.TYPED_ARRAY_SUPPORT) {
      for (i2 = 0; i2 < len; ++i2) {
        target[i2 + targetStart] = this[i2 + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }
    return len;
  };
  Buffer$2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer$2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
    } else if (typeof val === "number") {
      val = val & 255;
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    var i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end; ++i2) {
        this[i2] = val;
      }
    } else {
      var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer$2(val, encoding).toString());
      var len = bytes.length;
      for (i2 = 0; i2 < end - start; ++i2) {
        this[i2 + start] = bytes[i2 % len];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  function base64clean(str2) {
    str2 = stringtrim(str2).replace(INVALID_BASE64_RE, "");
    if (str2.length < 2)
      return "";
    while (str2.length % 4 !== 0) {
      str2 = str2 + "=";
    }
    return str2;
  }
  function stringtrim(str2) {
    if (str2.trim)
      return str2.trim();
    return str2.replace(/^\s+|\s+$/g, "");
  }
  function toHex(n) {
    if (n < 16)
      return "0" + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i2 = 0; i2 < length; ++i2) {
      codePoint = string.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str2) {
    var byteArray = [];
    for (var i2 = 0; i2 < str2.length; ++i2) {
      byteArray.push(str2.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str2, units) {
    var c2, hi, lo;
    var byteArray = [];
    for (var i2 = 0; i2 < str2.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c2 = str2.charCodeAt(i2);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str2) {
    return toByteArray(base64clean(str2));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i2 = 0; i2 < length; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src.length)
        break;
      dst[i2 + offset] = src[i2];
    }
    return i2;
  }
  function isnan(val) {
    return val !== val;
  }
  function isBuffer$2(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
  }
  function isFastBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  }
  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
  }
  var bufferGlobal = c("undefined" !== typeof Buffer$2 && Buffer$2) || c(commonjsGlobal.Buffer) || c("undefined" !== typeof window && window.Buffer) || commonjsGlobal.Buffer;
  function c(B) {
    return B && B.isBuffer && B;
  }
  var toString$3 = {}.toString;
  var isarray = Array.isArray || function(arr) {
    return toString$3.call(arr) == "[object Array]";
  };
  var bufferishArrayExports = {};
  var bufferishArray = {
    get exports() {
      return bufferishArrayExports;
    },
    set exports(v2) {
      bufferishArrayExports = v2;
    }
  };
  var hasRequiredBufferishArray;
  function requireBufferishArray() {
    if (hasRequiredBufferishArray)
      return bufferishArrayExports;
    hasRequiredBufferishArray = 1;
    var Bufferish2 = requireBufferish();
    var exports3 = bufferishArray.exports = alloc2(0);
    exports3.alloc = alloc2;
    exports3.concat = Bufferish2.concat;
    exports3.from = from2;
    function alloc2(size) {
      return new Array(size);
    }
    function from2(value) {
      if (!Bufferish2.isBuffer(value) && Bufferish2.isView(value)) {
        value = Bufferish2.Uint8Array.from(value);
      } else if (Bufferish2.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish2.from.call(exports3, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return Array.prototype.slice.call(value);
    }
    return bufferishArrayExports;
  }
  var bufferishBufferExports = {};
  var bufferishBuffer = {
    get exports() {
      return bufferishBufferExports;
    },
    set exports(v2) {
      bufferishBufferExports = v2;
    }
  };
  var hasRequiredBufferishBuffer;
  function requireBufferishBuffer() {
    if (hasRequiredBufferishBuffer)
      return bufferishBufferExports;
    hasRequiredBufferishBuffer = 1;
    var Bufferish2 = requireBufferish();
    var Buffer2 = Bufferish2.global;
    var exports3 = bufferishBuffer.exports = Bufferish2.hasBuffer ? alloc2(0) : [];
    exports3.alloc = Bufferish2.hasBuffer && Buffer2.alloc || alloc2;
    exports3.concat = Bufferish2.concat;
    exports3.from = from2;
    function alloc2(size) {
      return new Buffer2(size);
    }
    function from2(value) {
      if (!Bufferish2.isBuffer(value) && Bufferish2.isView(value)) {
        value = Bufferish2.Uint8Array.from(value);
      } else if (Bufferish2.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish2.from.call(exports3, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (Buffer2.from && Buffer2.from.length !== 1) {
        return Buffer2.from(value);
      } else {
        return new Buffer2(value);
      }
    }
    return bufferishBufferExports;
  }
  var bufferishUint8arrayExports = {};
  var bufferishUint8array = {
    get exports() {
      return bufferishUint8arrayExports;
    },
    set exports(v2) {
      bufferishUint8arrayExports = v2;
    }
  };
  var hasRequiredBufferishUint8array;
  function requireBufferishUint8array() {
    if (hasRequiredBufferishUint8array)
      return bufferishUint8arrayExports;
    hasRequiredBufferishUint8array = 1;
    var Bufferish2 = requireBufferish();
    var exports3 = bufferishUint8array.exports = Bufferish2.hasArrayBuffer ? alloc2(0) : [];
    exports3.alloc = alloc2;
    exports3.concat = Bufferish2.concat;
    exports3.from = from2;
    function alloc2(size) {
      return new Uint8Array(size);
    }
    function from2(value) {
      if (Bufferish2.isView(value)) {
        var byteOffset = value.byteOffset;
        var byteLength2 = value.byteLength;
        value = value.buffer;
        if (value.byteLength !== byteLength2) {
          if (value.slice) {
            value = value.slice(byteOffset, byteOffset + byteLength2);
          } else {
            value = new Uint8Array(value);
            if (value.byteLength !== byteLength2) {
              value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength2);
            }
          }
        }
      } else if (typeof value === "string") {
        return Bufferish2.from.call(exports3, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return new Uint8Array(value);
    }
    return bufferishUint8arrayExports;
  }
  var bufferishProto = {};
  var bufferLite = {};
  bufferLite.copy = copy;
  bufferLite.toString = toString$2;
  bufferLite.write = write$1;
  function write$1(string, offset) {
    var buffer = this;
    var index2 = offset || (offset |= 0);
    var length = string.length;
    var chr = 0;
    var i2 = 0;
    while (i2 < length) {
      chr = string.charCodeAt(i2++);
      if (chr < 128) {
        buffer[index2++] = chr;
      } else if (chr < 2048) {
        buffer[index2++] = 192 | chr >>> 6;
        buffer[index2++] = 128 | chr & 63;
      } else if (chr < 55296 || chr > 57343) {
        buffer[index2++] = 224 | chr >>> 12;
        buffer[index2++] = 128 | chr >>> 6 & 63;
        buffer[index2++] = 128 | chr & 63;
      } else {
        chr = (chr - 55296 << 10 | string.charCodeAt(i2++) - 56320) + 65536;
        buffer[index2++] = 240 | chr >>> 18;
        buffer[index2++] = 128 | chr >>> 12 & 63;
        buffer[index2++] = 128 | chr >>> 6 & 63;
        buffer[index2++] = 128 | chr & 63;
      }
    }
    return index2 - offset;
  }
  function toString$2(encoding, start, end) {
    var buffer = this;
    var index2 = start | 0;
    if (!end)
      end = buffer.length;
    var string = "";
    var chr = 0;
    while (index2 < end) {
      chr = buffer[index2++];
      if (chr < 128) {
        string += String.fromCharCode(chr);
        continue;
      }
      if ((chr & 224) === 192) {
        chr = (chr & 31) << 6 | buffer[index2++] & 63;
      } else if ((chr & 240) === 224) {
        chr = (chr & 15) << 12 | (buffer[index2++] & 63) << 6 | buffer[index2++] & 63;
      } else if ((chr & 248) === 240) {
        chr = (chr & 7) << 18 | (buffer[index2++] & 63) << 12 | (buffer[index2++] & 63) << 6 | buffer[index2++] & 63;
      }
      if (chr >= 65536) {
        chr -= 65536;
        string += String.fromCharCode((chr >>> 10) + 55296, (chr & 1023) + 56320);
      } else {
        string += String.fromCharCode(chr);
      }
    }
    return string;
  }
  function copy(target, targetStart, start, end) {
    var i2;
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (!targetStart)
      targetStart = 0;
    var len = end - start;
    if (target === this && start < targetStart && targetStart < end) {
      for (i2 = len - 1; i2 >= 0; i2--) {
        target[i2 + targetStart] = this[i2 + start];
      }
    } else {
      for (i2 = 0; i2 < len; i2++) {
        target[i2 + targetStart] = this[i2 + start];
      }
    }
    return len;
  }
  var hasRequiredBufferishProto;
  function requireBufferishProto() {
    if (hasRequiredBufferishProto)
      return bufferishProto;
    hasRequiredBufferishProto = 1;
    var BufferLite = bufferLite;
    bufferishProto.copy = copy2;
    bufferishProto.slice = slice;
    bufferishProto.toString = toString2;
    bufferishProto.write = gen("write");
    var Bufferish2 = requireBufferish();
    var Buffer2 = Bufferish2.global;
    var isBufferShim = Bufferish2.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer2;
    var brokenTypedArray = isBufferShim && !Buffer2.TYPED_ARRAY_SUPPORT;
    function copy2(target, targetStart, start, end) {
      var thisIsBuffer = Bufferish2.isBuffer(this);
      var targetIsBuffer = Bufferish2.isBuffer(target);
      if (thisIsBuffer && targetIsBuffer) {
        return this.copy(target, targetStart, start, end);
      } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer && Bufferish2.isView(this) && Bufferish2.isView(target)) {
        var buffer = start || end != null ? slice.call(this, start, end) : this;
        target.set(buffer, targetStart);
        return buffer.length;
      } else {
        return BufferLite.copy.call(this, target, targetStart, start, end);
      }
    }
    function slice(start, end) {
      var f = this.slice || !brokenTypedArray && this.subarray;
      if (f)
        return f.call(this, start, end);
      var target = Bufferish2.alloc.call(this, end - start);
      copy2.call(this, target, 0, start, end);
      return target;
    }
    function toString2(encoding, start, end) {
      var f = !isBufferShim && Bufferish2.isBuffer(this) ? this.toString : BufferLite.toString;
      return f.apply(this, arguments);
    }
    function gen(method2) {
      return wrap;
      function wrap() {
        var f = this[method2] || BufferLite[method2];
        return f.apply(this, arguments);
      }
    }
    return bufferishProto;
  }
  var hasRequiredBufferish;
  function requireBufferish() {
    if (hasRequiredBufferish)
      return bufferish;
    hasRequiredBufferish = 1;
    (function(exports3) {
      var Buffer2 = exports3.global = bufferGlobal;
      var hasBuffer = exports3.hasBuffer = Buffer2 && !!Buffer2.isBuffer;
      var hasArrayBuffer = exports3.hasArrayBuffer = "undefined" !== typeof ArrayBuffer;
      var isArray2 = exports3.isArray = isarray;
      exports3.isArrayBuffer = hasArrayBuffer ? isArrayBuffer2 : _false;
      var isBuffer2 = exports3.isBuffer = hasBuffer ? Buffer2.isBuffer : _false;
      var isView = exports3.isView = hasArrayBuffer ? ArrayBuffer.isView || _is("ArrayBuffer", "buffer") : _false;
      exports3.alloc = alloc2;
      exports3.concat = concat;
      exports3.from = from2;
      var BufferArray = exports3.Array = requireBufferishArray();
      var BufferBuffer = exports3.Buffer = requireBufferishBuffer();
      var BufferUint8Array = exports3.Uint8Array = requireBufferishUint8array();
      var BufferProto2 = exports3.prototype = requireBufferishProto();
      function from2(value) {
        if (typeof value === "string") {
          return fromString2.call(this, value);
        } else {
          return auto(this).from(value);
        }
      }
      function alloc2(size) {
        return auto(this).alloc(size);
      }
      function concat(list, length) {
        if (!length) {
          length = 0;
          Array.prototype.forEach.call(list, dryrun);
        }
        var ref = this !== exports3 && this || list[0];
        var result = alloc2.call(ref, length);
        var offset = 0;
        Array.prototype.forEach.call(list, append);
        return result;
        function dryrun(buffer) {
          length += buffer.length;
        }
        function append(buffer) {
          offset += BufferProto2.copy.call(buffer, result, offset);
        }
      }
      var _isArrayBuffer = _is("ArrayBuffer");
      function isArrayBuffer2(value) {
        return value instanceof ArrayBuffer || _isArrayBuffer(value);
      }
      function fromString2(value) {
        var expected = value.length * 3;
        var that = alloc2.call(this, expected);
        var actual = BufferProto2.write.call(that, value);
        if (expected !== actual) {
          that = BufferProto2.slice.call(that, 0, actual);
        }
        return that;
      }
      function auto(that) {
        return isBuffer2(that) ? BufferBuffer : isView(that) ? BufferUint8Array : isArray2(that) ? BufferArray : hasBuffer ? BufferBuffer : hasArrayBuffer ? BufferUint8Array : BufferArray;
      }
      function _false() {
        return false;
      }
      function _is(name, key) {
        name = "[object " + name + "]";
        return function(value) {
          return value != null && {}.toString.call(key ? value[key] : value) === name;
        };
      }
    })(bufferish);
    return bufferish;
  }
  extBuffer.ExtBuffer = ExtBuffer$1;
  var Bufferish$5 = requireBufferish();
  function ExtBuffer$1(buffer, type) {
    if (!(this instanceof ExtBuffer$1))
      return new ExtBuffer$1(buffer, type);
    this.buffer = Bufferish$5.from(buffer);
    this.type = type;
  }
  var extPacker = {};
  var hasRequiredExtPacker;
  function requireExtPacker() {
    if (hasRequiredExtPacker)
      return extPacker;
    hasRequiredExtPacker = 1;
    extPacker.setExtPackers = setExtPackers;
    var Bufferish2 = requireBufferish();
    var Buffer2 = Bufferish2.global;
    var packTypedArray = Bufferish2.Uint8Array.from;
    var _encode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtPackers(codec2) {
      codec2.addExtPacker(14, Error, [packError, encode2]);
      codec2.addExtPacker(1, EvalError, [packError, encode2]);
      codec2.addExtPacker(2, RangeError, [packError, encode2]);
      codec2.addExtPacker(3, ReferenceError, [packError, encode2]);
      codec2.addExtPacker(4, SyntaxError, [packError, encode2]);
      codec2.addExtPacker(5, TypeError, [packError, encode2]);
      codec2.addExtPacker(6, URIError, [packError, encode2]);
      codec2.addExtPacker(10, RegExp, [packRegExp, encode2]);
      codec2.addExtPacker(11, Boolean, [packValueOf, encode2]);
      codec2.addExtPacker(12, String, [packValueOf, encode2]);
      codec2.addExtPacker(13, Date, [Number, encode2]);
      codec2.addExtPacker(15, Number, [packValueOf, encode2]);
      if ("undefined" !== typeof Uint8Array) {
        codec2.addExtPacker(17, Int8Array, packTypedArray);
        codec2.addExtPacker(18, Uint8Array, packTypedArray);
        codec2.addExtPacker(19, Int16Array, packTypedArray);
        codec2.addExtPacker(20, Uint16Array, packTypedArray);
        codec2.addExtPacker(21, Int32Array, packTypedArray);
        codec2.addExtPacker(22, Uint32Array, packTypedArray);
        codec2.addExtPacker(23, Float32Array, packTypedArray);
        if ("undefined" !== typeof Float64Array) {
          codec2.addExtPacker(24, Float64Array, packTypedArray);
        }
        if ("undefined" !== typeof Uint8ClampedArray) {
          codec2.addExtPacker(25, Uint8ClampedArray, packTypedArray);
        }
        codec2.addExtPacker(26, ArrayBuffer, packTypedArray);
        codec2.addExtPacker(29, DataView, packTypedArray);
      }
      if (Bufferish2.hasBuffer) {
        codec2.addExtPacker(27, Buffer2, Bufferish2.from);
      }
    }
    function encode2(input) {
      if (!_encode)
        _encode = requireEncode().encode;
      return _encode(input);
    }
    function packValueOf(value) {
      return value.valueOf();
    }
    function packRegExp(value) {
      value = RegExp.prototype.toString.call(value).split("/");
      value.shift();
      var out = [value.pop()];
      out.unshift(value.join("/"));
      return out;
    }
    function packError(value) {
      var out = {};
      for (var key in ERROR_COLUMNS) {
        out[key] = value[key];
      }
      return out;
    }
    return extPacker;
  }
  var writeType = {};
  var int64Buffer = {};
  (function(exports3) {
    !function(exports4) {
      var UNDEFINED = "undefined";
      var BUFFER = UNDEFINED !== typeof Buffer$2 && Buffer$2;
      var UINT8ARRAY = UNDEFINED !== typeof Uint8Array && Uint8Array;
      var ARRAYBUFFER = UNDEFINED !== typeof ArrayBuffer && ArrayBuffer;
      var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
      var isArray2 = Array.isArray || _isArray;
      var BIT32 = 4294967296;
      var BIT24 = 16777216;
      var storage;
      factory("Uint64BE", true, true);
      factory("Int64BE", true, false);
      factory("Uint64LE", false, true);
      factory("Int64LE", false, false);
      function factory(name, bigendian, unsigned) {
        var posH = bigendian ? 0 : 4;
        var posL = bigendian ? 4 : 0;
        var pos0 = bigendian ? 0 : 3;
        var pos1 = bigendian ? 1 : 2;
        var pos2 = bigendian ? 2 : 1;
        var pos3 = bigendian ? 3 : 0;
        var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
        var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
        var proto = Int64.prototype;
        var isName = "is" + name;
        var _isInt64 = "_" + isName;
        proto.buffer = void 0;
        proto.offset = 0;
        proto[_isInt64] = true;
        proto.toNumber = toNumber;
        proto.toString = toString2;
        proto.toJSON = toNumber;
        proto.toArray = toArray2;
        if (BUFFER)
          proto.toBuffer = toBuffer;
        if (UINT8ARRAY)
          proto.toArrayBuffer = toArrayBuffer;
        Int64[isName] = isInt64;
        exports4[name] = Int64;
        return Int64;
        function Int64(buffer, offset, value, raddix) {
          if (!(this instanceof Int64))
            return new Int64(buffer, offset, value, raddix);
          return init2(this, buffer, offset, value, raddix);
        }
        function isInt64(b) {
          return !!(b && b[_isInt64]);
        }
        function init2(that, buffer, offset, value, raddix) {
          if (UINT8ARRAY && ARRAYBUFFER) {
            if (buffer instanceof ARRAYBUFFER)
              buffer = new UINT8ARRAY(buffer);
            if (value instanceof ARRAYBUFFER)
              value = new UINT8ARRAY(value);
          }
          if (!buffer && !offset && !value && !storage) {
            that.buffer = newArray(ZERO, 0);
            return;
          }
          if (!isValidBuffer(buffer, offset)) {
            var _storage = storage || Array;
            raddix = offset;
            value = buffer;
            offset = 0;
            buffer = new _storage(8);
          }
          that.buffer = buffer;
          that.offset = offset |= 0;
          if (UNDEFINED === typeof value)
            return;
          if ("string" === typeof value) {
            fromString2(buffer, offset, value, raddix || 10);
          } else if (isValidBuffer(value, raddix)) {
            fromArray(buffer, offset, value, raddix);
          } else if ("number" === typeof raddix) {
            writeInt32(buffer, offset + posH, value);
            writeInt32(buffer, offset + posL, raddix);
          } else if (value > 0) {
            fromPositive(buffer, offset, value);
          } else if (value < 0) {
            fromNegative(buffer, offset, value);
          } else {
            fromArray(buffer, offset, ZERO, 0);
          }
        }
        function fromString2(buffer, offset, str2, raddix) {
          var pos = 0;
          var len = str2.length;
          var high = 0;
          var low = 0;
          if (str2[0] === "-")
            pos++;
          var sign = pos;
          while (pos < len) {
            var chr = parseInt(str2[pos++], raddix);
            if (!(chr >= 0))
              break;
            low = low * raddix + chr;
            high = high * raddix + Math.floor(low / BIT32);
            low %= BIT32;
          }
          if (sign) {
            high = ~high;
            if (low) {
              low = BIT32 - low;
            } else {
              high++;
            }
          }
          writeInt32(buffer, offset + posH, high);
          writeInt32(buffer, offset + posL, low);
        }
        function toNumber() {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          if (!unsigned)
            high |= 0;
          return high ? high * BIT32 + low : low;
        }
        function toString2(radix) {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          var str2 = "";
          var sign = !unsigned && high & 2147483648;
          if (sign) {
            high = ~high;
            low = BIT32 - low;
          }
          radix = radix || 10;
          while (1) {
            var mod = high % radix * BIT32 + low;
            high = Math.floor(high / radix);
            low = Math.floor(mod / radix);
            str2 = (mod % radix).toString(radix) + str2;
            if (!high && !low)
              break;
          }
          if (sign) {
            str2 = "-" + str2;
          }
          return str2;
        }
        function writeInt32(buffer, offset, value) {
          buffer[offset + pos3] = value & 255;
          value = value >> 8;
          buffer[offset + pos2] = value & 255;
          value = value >> 8;
          buffer[offset + pos1] = value & 255;
          value = value >> 8;
          buffer[offset + pos0] = value & 255;
        }
        function readInt32(buffer, offset) {
          return buffer[offset + pos0] * BIT24 + (buffer[offset + pos1] << 16) + (buffer[offset + pos2] << 8) + buffer[offset + pos3];
        }
      }
      function toArray2(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = null;
        if (raw !== false && offset === 0 && buffer.length === 8 && isArray2(buffer))
          return buffer;
        return newArray(buffer, offset);
      }
      function toBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = BUFFER;
        if (raw !== false && offset === 0 && buffer.length === 8 && Buffer$2.isBuffer(buffer))
          return buffer;
        var dest = new BUFFER(8);
        fromArray(dest, 0, buffer, offset);
        return dest;
      }
      function toArrayBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        var arrbuf = buffer.buffer;
        storage = UINT8ARRAY;
        if (raw !== false && offset === 0 && arrbuf instanceof ARRAYBUFFER && arrbuf.byteLength === 8)
          return arrbuf;
        var dest = new UINT8ARRAY(8);
        fromArray(dest, 0, buffer, offset);
        return dest.buffer;
      }
      function isValidBuffer(buffer, offset) {
        var len = buffer && buffer.length;
        offset |= 0;
        return len && offset + 8 <= len && "string" !== typeof buffer[offset];
      }
      function fromArray(destbuf, destoff, srcbuf, srcoff) {
        destoff |= 0;
        srcoff |= 0;
        for (var i2 = 0; i2 < 8; i2++) {
          destbuf[destoff++] = srcbuf[srcoff++] & 255;
        }
      }
      function newArray(buffer, offset) {
        return Array.prototype.slice.call(buffer, offset, offset + 8);
      }
      function fromPositiveBE(buffer, offset, value) {
        var pos = offset + 8;
        while (pos > offset) {
          buffer[--pos] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeBE(buffer, offset, value) {
        var pos = offset + 8;
        value++;
        while (pos > offset) {
          buffer[--pos] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function fromPositiveLE(buffer, offset, value) {
        var end = offset + 8;
        while (offset < end) {
          buffer[offset++] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeLE(buffer, offset, value) {
        var end = offset + 8;
        value++;
        while (offset < end) {
          buffer[offset++] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function _isArray(val) {
        return !!val && "[object Array]" == Object.prototype.toString.call(val);
      }
    }(typeof exports3.nodeName !== "string" ? exports3 : commonjsGlobal || {});
  })(int64Buffer);
  var writeToken = {};
  var ieee754$2 = {};
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  ieee754$2.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i2];
    i2 += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  ieee754$2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c2 = Math.pow(2, -e)) < 1) {
        e--;
        c2 *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c2;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c2 >= 2) {
        e++;
        c2 /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c2 - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
    }
    buffer[offset + i2 - d] |= s * 128;
  };
  var writeUint8 = {};
  var constant$1 = writeUint8.uint8 = new Array(256);
  for (var i = 0; i <= 255; i++) {
    constant$1[i] = write0(i);
  }
  function write0(type) {
    return function(encoder2) {
      var offset = encoder2.reserve(1);
      encoder2.buffer[offset] = type;
    };
  }
  var ieee754$1 = ieee754$2;
  var Int64Buffer$2 = int64Buffer;
  var Uint64BE$2 = Int64Buffer$2.Uint64BE;
  var Int64BE$2 = Int64Buffer$2.Int64BE;
  var uint8$2 = writeUint8.uint8;
  var Bufferish$4 = requireBufferish();
  var Buffer$1 = Bufferish$4.global;
  var IS_BUFFER_SHIM = Bufferish$4.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer$1;
  var NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer$1.TYPED_ARRAY_SUPPORT;
  var Buffer_prototype = Bufferish$4.hasBuffer && Buffer$1.prototype || {};
  writeToken.getWriteToken = getWriteToken;
  function getWriteToken(options2) {
    if (options2 && options2.uint8array) {
      return init_uint8array();
    } else if (NO_TYPED_ARRAY || Bufferish$4.hasBuffer && options2 && options2.safe) {
      return init_safe();
    } else {
      return init_token$1();
    }
  }
  function init_uint8array() {
    var token = init_token$1();
    token[202] = writeN(202, 4, writeFloatBE);
    token[203] = writeN(203, 8, writeDoubleBE);
    return token;
  }
  function init_token$1() {
    var token = uint8$2.slice();
    token[196] = write1(196);
    token[197] = write2(197);
    token[198] = write4(198);
    token[199] = write1(199);
    token[200] = write2(200);
    token[201] = write4(201);
    token[202] = writeN(202, 4, Buffer_prototype.writeFloatBE || writeFloatBE, true);
    token[203] = writeN(203, 8, Buffer_prototype.writeDoubleBE || writeDoubleBE, true);
    token[204] = write1(204);
    token[205] = write2(205);
    token[206] = write4(206);
    token[207] = writeN(207, 8, writeUInt64BE);
    token[208] = write1(208);
    token[209] = write2(209);
    token[210] = write4(210);
    token[211] = writeN(211, 8, writeInt64BE);
    token[217] = write1(217);
    token[218] = write2(218);
    token[219] = write4(219);
    token[220] = write2(220);
    token[221] = write4(221);
    token[222] = write2(222);
    token[223] = write4(223);
    return token;
  }
  function init_safe() {
    var token = uint8$2.slice();
    token[196] = writeN(196, 1, Buffer$1.prototype.writeUInt8);
    token[197] = writeN(197, 2, Buffer$1.prototype.writeUInt16BE);
    token[198] = writeN(198, 4, Buffer$1.prototype.writeUInt32BE);
    token[199] = writeN(199, 1, Buffer$1.prototype.writeUInt8);
    token[200] = writeN(200, 2, Buffer$1.prototype.writeUInt16BE);
    token[201] = writeN(201, 4, Buffer$1.prototype.writeUInt32BE);
    token[202] = writeN(202, 4, Buffer$1.prototype.writeFloatBE);
    token[203] = writeN(203, 8, Buffer$1.prototype.writeDoubleBE);
    token[204] = writeN(204, 1, Buffer$1.prototype.writeUInt8);
    token[205] = writeN(205, 2, Buffer$1.prototype.writeUInt16BE);
    token[206] = writeN(206, 4, Buffer$1.prototype.writeUInt32BE);
    token[207] = writeN(207, 8, writeUInt64BE);
    token[208] = writeN(208, 1, Buffer$1.prototype.writeInt8);
    token[209] = writeN(209, 2, Buffer$1.prototype.writeInt16BE);
    token[210] = writeN(210, 4, Buffer$1.prototype.writeInt32BE);
    token[211] = writeN(211, 8, writeInt64BE);
    token[217] = writeN(217, 1, Buffer$1.prototype.writeUInt8);
    token[218] = writeN(218, 2, Buffer$1.prototype.writeUInt16BE);
    token[219] = writeN(219, 4, Buffer$1.prototype.writeUInt32BE);
    token[220] = writeN(220, 2, Buffer$1.prototype.writeUInt16BE);
    token[221] = writeN(221, 4, Buffer$1.prototype.writeUInt32BE);
    token[222] = writeN(222, 2, Buffer$1.prototype.writeUInt16BE);
    token[223] = writeN(223, 4, Buffer$1.prototype.writeUInt32BE);
    return token;
  }
  function write1(type) {
    return function(encoder2, value) {
      var offset = encoder2.reserve(2);
      var buffer = encoder2.buffer;
      buffer[offset++] = type;
      buffer[offset] = value;
    };
  }
  function write2(type) {
    return function(encoder2, value) {
      var offset = encoder2.reserve(3);
      var buffer = encoder2.buffer;
      buffer[offset++] = type;
      buffer[offset++] = value >>> 8;
      buffer[offset] = value;
    };
  }
  function write4(type) {
    return function(encoder2, value) {
      var offset = encoder2.reserve(5);
      var buffer = encoder2.buffer;
      buffer[offset++] = type;
      buffer[offset++] = value >>> 24;
      buffer[offset++] = value >>> 16;
      buffer[offset++] = value >>> 8;
      buffer[offset] = value;
    };
  }
  function writeN(type, len, method2, noAssert) {
    return function(encoder2, value) {
      var offset = encoder2.reserve(len + 1);
      encoder2.buffer[offset++] = type;
      method2.call(encoder2.buffer, value, offset, noAssert);
    };
  }
  function writeUInt64BE(value, offset) {
    new Uint64BE$2(this, offset, value);
  }
  function writeInt64BE(value, offset) {
    new Int64BE$2(this, offset, value);
  }
  function writeFloatBE(value, offset) {
    ieee754$1.write(this, value, offset, false, 23, 4);
  }
  function writeDoubleBE(value, offset) {
    ieee754$1.write(this, value, offset, false, 52, 8);
  }
  var IS_ARRAY$1 = isarray;
  var Int64Buffer$1 = int64Buffer;
  var Uint64BE$1 = Int64Buffer$1.Uint64BE;
  var Int64BE$1 = Int64Buffer$1.Int64BE;
  var Bufferish$3 = requireBufferish();
  var BufferProto$1 = requireBufferishProto();
  var WriteToken = writeToken;
  var uint8$1 = writeUint8.uint8;
  var ExtBuffer = extBuffer.ExtBuffer;
  var HAS_UINT8ARRAY = "undefined" !== typeof Uint8Array;
  var HAS_MAP$1 = "undefined" !== typeof Map;
  var extmap = [];
  extmap[1] = 212;
  extmap[2] = 213;
  extmap[4] = 214;
  extmap[8] = 215;
  extmap[16] = 216;
  writeType.getWriteType = getWriteType;
  function getWriteType(options2) {
    var token = WriteToken.getWriteToken(options2);
    var useraw = options2 && options2.useraw;
    var binarraybuffer = HAS_UINT8ARRAY && options2 && options2.binarraybuffer;
    var isBuffer2 = binarraybuffer ? Bufferish$3.isArrayBuffer : Bufferish$3.isBuffer;
    var bin = binarraybuffer ? bin_arraybuffer2 : bin_buffer2;
    var usemap = HAS_MAP$1 && options2 && options2.usemap;
    var map = usemap ? map_to_map2 : obj_to_map;
    var writeType2 = {
      "boolean": bool,
      "function": nil,
      "number": number,
      "object": useraw ? object_raw : object,
      "string": _string(useraw ? raw_head_size : str_head_size),
      "symbol": nil,
      "undefined": nil
    };
    return writeType2;
    function bool(encoder2, value) {
      var type = value ? 195 : 194;
      token[type](encoder2, value);
    }
    function number(encoder2, value) {
      var ivalue = value | 0;
      var type;
      if (value !== ivalue) {
        type = 203;
        token[type](encoder2, value);
        return;
      } else if (-32 <= ivalue && ivalue <= 127) {
        type = ivalue & 255;
      } else if (0 <= ivalue) {
        type = ivalue <= 255 ? 204 : ivalue <= 65535 ? 205 : 206;
      } else {
        type = -128 <= ivalue ? 208 : -32768 <= ivalue ? 209 : 210;
      }
      token[type](encoder2, ivalue);
    }
    function uint64(encoder2, value) {
      var type = 207;
      token[type](encoder2, value.toArray());
    }
    function int64(encoder2, value) {
      var type = 211;
      token[type](encoder2, value.toArray());
    }
    function str_head_size(length) {
      return length < 32 ? 1 : length <= 255 ? 2 : length <= 65535 ? 3 : 5;
    }
    function raw_head_size(length) {
      return length < 32 ? 1 : length <= 65535 ? 3 : 5;
    }
    function _string(head_size) {
      return string;
      function string(encoder2, value) {
        var length = value.length;
        var maxsize = 5 + length * 3;
        encoder2.offset = encoder2.reserve(maxsize);
        var buffer = encoder2.buffer;
        var expected = head_size(length);
        var start = encoder2.offset + expected;
        length = BufferProto$1.write.call(buffer, value, start);
        var actual = head_size(length);
        if (expected !== actual) {
          var targetStart = start + actual - expected;
          var end = start + length;
          BufferProto$1.copy.call(buffer, buffer, targetStart, start, end);
        }
        var type = actual === 1 ? 160 + length : actual <= 3 ? 215 + actual : 219;
        token[type](encoder2, length);
        encoder2.offset += length;
      }
    }
    function object(encoder2, value) {
      if (value === null)
        return nil(encoder2, value);
      if (isBuffer2(value))
        return bin(encoder2, value);
      if (IS_ARRAY$1(value))
        return array2(encoder2, value);
      if (Uint64BE$1.isUint64BE(value))
        return uint64(encoder2, value);
      if (Int64BE$1.isInt64BE(value))
        return int64(encoder2, value);
      var packer = encoder2.codec.getExtPacker(value);
      if (packer)
        value = packer(value);
      if (value instanceof ExtBuffer)
        return ext2(encoder2, value);
      map(encoder2, value);
    }
    function object_raw(encoder2, value) {
      if (isBuffer2(value))
        return raw(encoder2, value);
      object(encoder2, value);
    }
    function nil(encoder2, value) {
      var type = 192;
      token[type](encoder2, value);
    }
    function array2(encoder2, value) {
      var length = value.length;
      var type = length < 16 ? 144 + length : length <= 65535 ? 220 : 221;
      token[type](encoder2, length);
      var encode2 = encoder2.codec.encode;
      for (var i2 = 0; i2 < length; i2++) {
        encode2(encoder2, value[i2]);
      }
    }
    function bin_buffer2(encoder2, value) {
      var length = value.length;
      var type = length < 255 ? 196 : length <= 65535 ? 197 : 198;
      token[type](encoder2, length);
      encoder2.send(value);
    }
    function bin_arraybuffer2(encoder2, value) {
      bin_buffer2(encoder2, new Uint8Array(value));
    }
    function ext2(encoder2, value) {
      var buffer = value.buffer;
      var length = buffer.length;
      var type = extmap[length] || (length < 255 ? 199 : length <= 65535 ? 200 : 201);
      token[type](encoder2, length);
      uint8$1[value.type](encoder2);
      encoder2.send(buffer);
    }
    function obj_to_map(encoder2, value) {
      var keys2 = Object.keys(value);
      var length = keys2.length;
      var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
      token[type](encoder2, length);
      var encode2 = encoder2.codec.encode;
      keys2.forEach(function(key) {
        encode2(encoder2, key);
        encode2(encoder2, value[key]);
      });
    }
    function map_to_map2(encoder2, value) {
      if (!(value instanceof Map))
        return obj_to_map(encoder2, value);
      var length = value.size;
      var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
      token[type](encoder2, length);
      var encode2 = encoder2.codec.encode;
      value.forEach(function(val, key, m) {
        encode2(encoder2, key);
        encode2(encoder2, val);
      });
    }
    function raw(encoder2, value) {
      var length = value.length;
      var type = length < 32 ? 160 + length : length <= 65535 ? 218 : 219;
      token[type](encoder2, length);
      encoder2.send(value);
    }
  }
  var codecBase = {};
  var IS_ARRAY = isarray;
  codecBase.createCodec = createCodec;
  codecBase.install = install;
  codecBase.filter = filter$1;
  var Bufferish$2 = requireBufferish();
  function Codec(options2) {
    if (!(this instanceof Codec))
      return new Codec(options2);
    this.options = options2;
    this.init();
  }
  Codec.prototype.init = function() {
    var options2 = this.options;
    if (options2 && options2.uint8array) {
      this.bufferish = Bufferish$2.Uint8Array;
    }
    return this;
  };
  function install(props) {
    for (var key in props) {
      Codec.prototype[key] = add(Codec.prototype[key], props[key]);
    }
  }
  function add(a, b) {
    return a && b ? ab : a || b;
    function ab() {
      a.apply(this, arguments);
      return b.apply(this, arguments);
    }
  }
  function join$1(filters) {
    filters = filters.slice();
    return function(value) {
      return filters.reduce(iterator2, value);
    };
    function iterator2(value, filter2) {
      return filter2(value);
    }
  }
  function filter$1(filter2) {
    return IS_ARRAY(filter2) ? join$1(filter2) : filter2;
  }
  function createCodec(options2) {
    return new Codec(options2);
  }
  codecBase.preset = createCodec({ preset: true });
  var hasRequiredWriteCore;
  function requireWriteCore() {
    if (hasRequiredWriteCore)
      return writeCore;
    hasRequiredWriteCore = 1;
    var ExtBuffer2 = extBuffer.ExtBuffer;
    var ExtPacker = requireExtPacker();
    var WriteType = writeType;
    var CodecBase = codecBase;
    CodecBase.install({
      addExtPacker,
      getExtPacker,
      init: init2
    });
    writeCore.preset = init2.call(CodecBase.preset);
    function getEncoder(options2) {
      var writeType2 = WriteType.getWriteType(options2);
      return encode2;
      function encode2(encoder2, value) {
        var func = writeType2[typeof value];
        if (!func)
          throw new Error('Unsupported type "' + typeof value + '": ' + value);
        func(encoder2, value);
      }
    }
    function init2() {
      var options2 = this.options;
      this.encode = getEncoder(options2);
      if (options2 && options2.preset) {
        ExtPacker.setExtPackers(this);
      }
      return this;
    }
    function addExtPacker(etype, Class, packer) {
      packer = CodecBase.filter(packer);
      var name = Class.name;
      if (name && name !== "Object") {
        var packers = this.extPackers || (this.extPackers = {});
        packers[name] = extPacker2;
      } else {
        var list = this.extEncoderList || (this.extEncoderList = []);
        list.unshift([Class, extPacker2]);
      }
      function extPacker2(value) {
        if (packer)
          value = packer(value);
        return new ExtBuffer2(value, etype);
      }
    }
    function getExtPacker(value) {
      var packers = this.extPackers || (this.extPackers = {});
      var c2 = value.constructor;
      var e = c2 && c2.name && packers[c2.name];
      if (e)
        return e;
      var list = this.extEncoderList || (this.extEncoderList = []);
      var len = list.length;
      for (var i2 = 0; i2 < len; i2++) {
        var pair = list[i2];
        if (c2 === pair[0])
          return pair[1];
      }
    }
    return writeCore;
  }
  var flexBuffer = {};
  flexBuffer.FlexDecoder = FlexDecoder;
  flexBuffer.FlexEncoder = FlexEncoder;
  var Bufferish$1 = requireBufferish();
  var MIN_BUFFER_SIZE = 2048;
  var MAX_BUFFER_SIZE = 65536;
  var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";
  function FlexDecoder() {
    if (!(this instanceof FlexDecoder))
      return new FlexDecoder();
  }
  function FlexEncoder() {
    if (!(this instanceof FlexEncoder))
      return new FlexEncoder();
  }
  FlexDecoder.mixin = mixinFactory(getDecoderMethods());
  FlexDecoder.mixin(FlexDecoder.prototype);
  FlexEncoder.mixin = mixinFactory(getEncoderMethods());
  FlexEncoder.mixin(FlexEncoder.prototype);
  function getDecoderMethods() {
    return {
      bufferish: Bufferish$1,
      write: write3,
      fetch,
      flush,
      push,
      pull,
      read: read$1,
      reserve,
      offset: 0
    };
    function write3(chunk) {
      var prev = this.offset ? Bufferish$1.prototype.slice.call(this.buffer, this.offset) : this.buffer;
      this.buffer = prev ? chunk ? this.bufferish.concat([prev, chunk]) : prev : chunk;
      this.offset = 0;
    }
    function flush() {
      while (this.offset < this.buffer.length) {
        var start = this.offset;
        var value;
        try {
          value = this.fetch();
        } catch (e) {
          if (e && e.message != BUFFER_SHORTAGE)
            throw e;
          this.offset = start;
          break;
        }
        this.push(value);
      }
    }
    function reserve(length) {
      var start = this.offset;
      var end = start + length;
      if (end > this.buffer.length)
        throw new Error(BUFFER_SHORTAGE);
      this.offset = end;
      return start;
    }
  }
  function getEncoderMethods() {
    return {
      bufferish: Bufferish$1,
      write,
      fetch: fetch2,
      flush,
      push,
      pull: pull2,
      read: read$1,
      reserve,
      send,
      maxBufferSize: MAX_BUFFER_SIZE,
      minBufferSize: MIN_BUFFER_SIZE,
      offset: 0,
      start: 0
    };
    function fetch2() {
      var start = this.start;
      if (start < this.offset) {
        var end = this.start = this.offset;
        return Bufferish$1.prototype.slice.call(this.buffer, start, end);
      }
    }
    function flush() {
      while (this.start < this.offset) {
        var value = this.fetch();
        if (value)
          this.push(value);
      }
    }
    function pull2() {
      var buffers = this.buffers || (this.buffers = []);
      var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];
      buffers.length = 0;
      return chunk;
    }
    function reserve(length) {
      var req = length | 0;
      if (this.buffer) {
        var size = this.buffer.length;
        var start = this.offset | 0;
        var end = start + req;
        if (end < size) {
          this.offset = end;
          return start;
        }
        this.flush();
        length = Math.max(length, Math.min(size * 2, this.maxBufferSize));
      }
      length = Math.max(length, this.minBufferSize);
      this.buffer = this.bufferish.alloc(length);
      this.start = 0;
      this.offset = req;
      return 0;
    }
    function send(buffer) {
      var length = buffer.length;
      if (length > this.minBufferSize) {
        this.flush();
        this.push(buffer);
      } else {
        var offset = this.reserve(length);
        Bufferish$1.prototype.copy.call(buffer, this.buffer, offset);
      }
    }
  }
  function write() {
    throw new Error("method not implemented: write()");
  }
  function fetch() {
    throw new Error("method not implemented: fetch()");
  }
  function read$1() {
    var length = this.buffers && this.buffers.length;
    if (!length)
      return this.fetch();
    this.flush();
    return this.pull();
  }
  function push(chunk) {
    var buffers = this.buffers || (this.buffers = []);
    buffers.push(chunk);
  }
  function pull() {
    var buffers = this.buffers || (this.buffers = []);
    return buffers.shift();
  }
  function mixinFactory(source) {
    return mixin;
    function mixin(target) {
      for (var key in source) {
        target[key] = source[key];
      }
      return target;
    }
  }
  var hasRequiredEncodeBuffer;
  function requireEncodeBuffer() {
    if (hasRequiredEncodeBuffer)
      return encodeBuffer;
    hasRequiredEncodeBuffer = 1;
    encodeBuffer.EncodeBuffer = EncodeBuffer2;
    var preset = requireWriteCore().preset;
    var FlexEncoder2 = flexBuffer.FlexEncoder;
    FlexEncoder2.mixin(EncodeBuffer2.prototype);
    function EncodeBuffer2(options2) {
      if (!(this instanceof EncodeBuffer2))
        return new EncodeBuffer2(options2);
      if (options2) {
        this.options = options2;
        if (options2.codec) {
          var codec2 = this.codec = options2.codec;
          if (codec2.bufferish)
            this.bufferish = codec2.bufferish;
        }
      }
    }
    EncodeBuffer2.prototype.codec = preset;
    EncodeBuffer2.prototype.write = function(input) {
      this.codec.encode(this, input);
    };
    return encodeBuffer;
  }
  var hasRequiredEncode;
  function requireEncode() {
    if (hasRequiredEncode)
      return encode$4;
    hasRequiredEncode = 1;
    encode$4.encode = encode2;
    var EncodeBuffer2 = requireEncodeBuffer().EncodeBuffer;
    function encode2(input, options2) {
      var encoder2 = new EncodeBuffer2(options2);
      encoder2.write(input);
      return encoder2.read();
    }
    return encode$4;
  }
  var decode = {};
  var decodeBuffer = {};
  var readCore = {};
  var extUnpacker = {};
  var hasRequiredExtUnpacker;
  function requireExtUnpacker() {
    if (hasRequiredExtUnpacker)
      return extUnpacker;
    hasRequiredExtUnpacker = 1;
    extUnpacker.setExtUnpackers = setExtUnpackers;
    var Bufferish2 = requireBufferish();
    var Buffer2 = Bufferish2.global;
    var _decode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtUnpackers(codec2) {
      codec2.addExtUnpacker(14, [decode2, unpackError(Error)]);
      codec2.addExtUnpacker(1, [decode2, unpackError(EvalError)]);
      codec2.addExtUnpacker(2, [decode2, unpackError(RangeError)]);
      codec2.addExtUnpacker(3, [decode2, unpackError(ReferenceError)]);
      codec2.addExtUnpacker(4, [decode2, unpackError(SyntaxError)]);
      codec2.addExtUnpacker(5, [decode2, unpackError(TypeError)]);
      codec2.addExtUnpacker(6, [decode2, unpackError(URIError)]);
      codec2.addExtUnpacker(10, [decode2, unpackRegExp]);
      codec2.addExtUnpacker(11, [decode2, unpackClass(Boolean)]);
      codec2.addExtUnpacker(12, [decode2, unpackClass(String)]);
      codec2.addExtUnpacker(13, [decode2, unpackClass(Date)]);
      codec2.addExtUnpacker(15, [decode2, unpackClass(Number)]);
      if ("undefined" !== typeof Uint8Array) {
        codec2.addExtUnpacker(17, unpackClass(Int8Array));
        codec2.addExtUnpacker(18, unpackClass(Uint8Array));
        codec2.addExtUnpacker(19, [unpackArrayBuffer, unpackClass(Int16Array)]);
        codec2.addExtUnpacker(20, [unpackArrayBuffer, unpackClass(Uint16Array)]);
        codec2.addExtUnpacker(21, [unpackArrayBuffer, unpackClass(Int32Array)]);
        codec2.addExtUnpacker(22, [unpackArrayBuffer, unpackClass(Uint32Array)]);
        codec2.addExtUnpacker(23, [unpackArrayBuffer, unpackClass(Float32Array)]);
        if ("undefined" !== typeof Float64Array) {
          codec2.addExtUnpacker(24, [unpackArrayBuffer, unpackClass(Float64Array)]);
        }
        if ("undefined" !== typeof Uint8ClampedArray) {
          codec2.addExtUnpacker(25, unpackClass(Uint8ClampedArray));
        }
        codec2.addExtUnpacker(26, unpackArrayBuffer);
        codec2.addExtUnpacker(29, [unpackArrayBuffer, unpackClass(DataView)]);
      }
      if (Bufferish2.hasBuffer) {
        codec2.addExtUnpacker(27, unpackClass(Buffer2));
      }
    }
    function decode2(input) {
      if (!_decode)
        _decode = requireDecode().decode;
      return _decode(input);
    }
    function unpackRegExp(value) {
      return RegExp.apply(null, value);
    }
    function unpackError(Class) {
      return function(value) {
        var out = new Class();
        for (var key in ERROR_COLUMNS) {
          out[key] = value[key];
        }
        return out;
      };
    }
    function unpackClass(Class) {
      return function(value) {
        return new Class(value);
      };
    }
    function unpackArrayBuffer(value) {
      return new Uint8Array(value).buffer;
    }
    return extUnpacker;
  }
  var readFormat = {};
  var ieee754 = ieee754$2;
  var Int64Buffer = int64Buffer;
  var Uint64BE = Int64Buffer.Uint64BE;
  var Int64BE = Int64Buffer.Int64BE;
  readFormat.getReadFormat = getReadFormat;
  readFormat.readUint8 = uint8;
  var Bufferish = requireBufferish();
  var BufferProto = requireBufferishProto();
  var HAS_MAP = "undefined" !== typeof Map;
  var NO_ASSERT = true;
  function getReadFormat(options2) {
    var binarraybuffer = Bufferish.hasArrayBuffer && options2 && options2.binarraybuffer;
    var int64 = options2 && options2.int64;
    var usemap = HAS_MAP && options2 && options2.usemap;
    var readFormat2 = {
      map: usemap ? map_to_map : map_to_obj,
      array,
      str,
      bin: binarraybuffer ? bin_arraybuffer : bin_buffer,
      ext: ext$1,
      uint8,
      uint16,
      uint32,
      uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),
      int8,
      int16,
      int32,
      int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),
      float32: read(4, readFloatBE),
      float64: read(8, readDoubleBE)
    };
    return readFormat2;
  }
  function map_to_obj(decoder2, len) {
    var value = {};
    var i2;
    var k = new Array(len);
    var v2 = new Array(len);
    var decode2 = decoder2.codec.decode;
    for (i2 = 0; i2 < len; i2++) {
      k[i2] = decode2(decoder2);
      v2[i2] = decode2(decoder2);
    }
    for (i2 = 0; i2 < len; i2++) {
      value[k[i2]] = v2[i2];
    }
    return value;
  }
  function map_to_map(decoder2, len) {
    var value = /* @__PURE__ */ new Map();
    var i2;
    var k = new Array(len);
    var v2 = new Array(len);
    var decode2 = decoder2.codec.decode;
    for (i2 = 0; i2 < len; i2++) {
      k[i2] = decode2(decoder2);
      v2[i2] = decode2(decoder2);
    }
    for (i2 = 0; i2 < len; i2++) {
      value.set(k[i2], v2[i2]);
    }
    return value;
  }
  function array(decoder2, len) {
    var value = new Array(len);
    var decode2 = decoder2.codec.decode;
    for (var i2 = 0; i2 < len; i2++) {
      value[i2] = decode2(decoder2);
    }
    return value;
  }
  function str(decoder2, len) {
    var start = decoder2.reserve(len);
    var end = start + len;
    return BufferProto.toString.call(decoder2.buffer, "utf-8", start, end);
  }
  function bin_buffer(decoder2, len) {
    var start = decoder2.reserve(len);
    var end = start + len;
    var buf = BufferProto.slice.call(decoder2.buffer, start, end);
    return Bufferish.from(buf);
  }
  function bin_arraybuffer(decoder2, len) {
    var start = decoder2.reserve(len);
    var end = start + len;
    var buf = BufferProto.slice.call(decoder2.buffer, start, end);
    return Bufferish.Uint8Array.from(buf).buffer;
  }
  function ext$1(decoder2, len) {
    var start = decoder2.reserve(len + 1);
    var type = decoder2.buffer[start++];
    var end = start + len;
    var unpack = decoder2.codec.getExtUnpacker(type);
    if (!unpack)
      throw new Error("Invalid ext type: " + (type ? "0x" + type.toString(16) : type));
    var buf = BufferProto.slice.call(decoder2.buffer, start, end);
    return unpack(buf);
  }
  function uint8(decoder2) {
    var start = decoder2.reserve(1);
    return decoder2.buffer[start];
  }
  function int8(decoder2) {
    var start = decoder2.reserve(1);
    var value = decoder2.buffer[start];
    return value & 128 ? value - 256 : value;
  }
  function uint16(decoder2) {
    var start = decoder2.reserve(2);
    var buffer = decoder2.buffer;
    return buffer[start++] << 8 | buffer[start];
  }
  function int16(decoder2) {
    var start = decoder2.reserve(2);
    var buffer = decoder2.buffer;
    var value = buffer[start++] << 8 | buffer[start];
    return value & 32768 ? value - 65536 : value;
  }
  function uint32(decoder2) {
    var start = decoder2.reserve(4);
    var buffer = decoder2.buffer;
    return buffer[start++] * 16777216 + (buffer[start++] << 16) + (buffer[start++] << 8) + buffer[start];
  }
  function int32(decoder2) {
    var start = decoder2.reserve(4);
    var buffer = decoder2.buffer;
    return buffer[start++] << 24 | buffer[start++] << 16 | buffer[start++] << 8 | buffer[start];
  }
  function read(len, method2) {
    return function(decoder2) {
      var start = decoder2.reserve(len);
      return method2.call(decoder2.buffer, start, NO_ASSERT);
    };
  }
  function readUInt64BE(start) {
    return new Uint64BE(this, start).toNumber();
  }
  function readInt64BE(start) {
    return new Int64BE(this, start).toNumber();
  }
  function readUInt64BE_int64(start) {
    return new Uint64BE(this, start);
  }
  function readInt64BE_int64(start) {
    return new Int64BE(this, start);
  }
  function readFloatBE(start) {
    return ieee754.read(this, start, false, 23, 4);
  }
  function readDoubleBE(start) {
    return ieee754.read(this, start, false, 52, 8);
  }
  var readToken = {};
  var ReadFormat = readFormat;
  readToken.getReadToken = getReadToken;
  function getReadToken(options2) {
    var format2 = ReadFormat.getReadFormat(options2);
    if (options2 && options2.useraw) {
      return init_useraw(format2);
    } else {
      return init_token(format2);
    }
  }
  function init_token(format2) {
    var i2;
    var token = new Array(256);
    for (i2 = 0; i2 <= 127; i2++) {
      token[i2] = constant(i2);
    }
    for (i2 = 128; i2 <= 143; i2++) {
      token[i2] = fix(i2 - 128, format2.map);
    }
    for (i2 = 144; i2 <= 159; i2++) {
      token[i2] = fix(i2 - 144, format2.array);
    }
    for (i2 = 160; i2 <= 191; i2++) {
      token[i2] = fix(i2 - 160, format2.str);
    }
    token[192] = constant(null);
    token[193] = null;
    token[194] = constant(false);
    token[195] = constant(true);
    token[196] = flex(format2.uint8, format2.bin);
    token[197] = flex(format2.uint16, format2.bin);
    token[198] = flex(format2.uint32, format2.bin);
    token[199] = flex(format2.uint8, format2.ext);
    token[200] = flex(format2.uint16, format2.ext);
    token[201] = flex(format2.uint32, format2.ext);
    token[202] = format2.float32;
    token[203] = format2.float64;
    token[204] = format2.uint8;
    token[205] = format2.uint16;
    token[206] = format2.uint32;
    token[207] = format2.uint64;
    token[208] = format2.int8;
    token[209] = format2.int16;
    token[210] = format2.int32;
    token[211] = format2.int64;
    token[212] = fix(1, format2.ext);
    token[213] = fix(2, format2.ext);
    token[214] = fix(4, format2.ext);
    token[215] = fix(8, format2.ext);
    token[216] = fix(16, format2.ext);
    token[217] = flex(format2.uint8, format2.str);
    token[218] = flex(format2.uint16, format2.str);
    token[219] = flex(format2.uint32, format2.str);
    token[220] = flex(format2.uint16, format2.array);
    token[221] = flex(format2.uint32, format2.array);
    token[222] = flex(format2.uint16, format2.map);
    token[223] = flex(format2.uint32, format2.map);
    for (i2 = 224; i2 <= 255; i2++) {
      token[i2] = constant(i2 - 256);
    }
    return token;
  }
  function init_useraw(format2) {
    var i2;
    var token = init_token(format2).slice();
    token[217] = token[196];
    token[218] = token[197];
    token[219] = token[198];
    for (i2 = 160; i2 <= 191; i2++) {
      token[i2] = fix(i2 - 160, format2.bin);
    }
    return token;
  }
  function constant(value) {
    return function() {
      return value;
    };
  }
  function flex(lenFunc, decodeFunc) {
    return function(decoder2) {
      var len = lenFunc(decoder2);
      return decodeFunc(decoder2, len);
    };
  }
  function fix(len, method2) {
    return function(decoder2) {
      return method2(decoder2, len);
    };
  }
  var hasRequiredReadCore;
  function requireReadCore() {
    if (hasRequiredReadCore)
      return readCore;
    hasRequiredReadCore = 1;
    var ExtBuffer2 = extBuffer.ExtBuffer;
    var ExtUnpacker = requireExtUnpacker();
    var readUint8 = readFormat.readUint8;
    var ReadToken = readToken;
    var CodecBase = codecBase;
    CodecBase.install({
      addExtUnpacker,
      getExtUnpacker,
      init: init2
    });
    readCore.preset = init2.call(CodecBase.preset);
    function getDecoder(options2) {
      var readToken2 = ReadToken.getReadToken(options2);
      return decode2;
      function decode2(decoder2) {
        var type = readUint8(decoder2);
        var func = readToken2[type];
        if (!func)
          throw new Error("Invalid type: " + (type ? "0x" + type.toString(16) : type));
        return func(decoder2);
      }
    }
    function init2() {
      var options2 = this.options;
      this.decode = getDecoder(options2);
      if (options2 && options2.preset) {
        ExtUnpacker.setExtUnpackers(this);
      }
      return this;
    }
    function addExtUnpacker(etype, unpacker) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      unpackers[etype] = CodecBase.filter(unpacker);
    }
    function getExtUnpacker(type) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      return unpackers[type] || extUnpacker2;
      function extUnpacker2(buffer) {
        return new ExtBuffer2(buffer, type);
      }
    }
    return readCore;
  }
  var hasRequiredDecodeBuffer;
  function requireDecodeBuffer() {
    if (hasRequiredDecodeBuffer)
      return decodeBuffer;
    hasRequiredDecodeBuffer = 1;
    decodeBuffer.DecodeBuffer = DecodeBuffer2;
    var preset = requireReadCore().preset;
    var FlexDecoder2 = flexBuffer.FlexDecoder;
    FlexDecoder2.mixin(DecodeBuffer2.prototype);
    function DecodeBuffer2(options2) {
      if (!(this instanceof DecodeBuffer2))
        return new DecodeBuffer2(options2);
      if (options2) {
        this.options = options2;
        if (options2.codec) {
          var codec2 = this.codec = options2.codec;
          if (codec2.bufferish)
            this.bufferish = codec2.bufferish;
        }
      }
    }
    DecodeBuffer2.prototype.codec = preset;
    DecodeBuffer2.prototype.fetch = function() {
      return this.codec.decode(this);
    };
    return decodeBuffer;
  }
  var hasRequiredDecode;
  function requireDecode() {
    if (hasRequiredDecode)
      return decode;
    hasRequiredDecode = 1;
    decode.decode = decode$1;
    var DecodeBuffer2 = requireDecodeBuffer().DecodeBuffer;
    function decode$1(input, options2) {
      var decoder2 = new DecodeBuffer2(options2);
      decoder2.write(input);
      return decoder2.read();
    }
    return decode;
  }
  var encoder = {};
  var eventLiteExports = {};
  var eventLite = {
    get exports() {
      return eventLiteExports;
    },
    set exports(v2) {
      eventLiteExports = v2;
    }
  };
  /**
   * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
   *
   * @copyright Yusuke Kawasaki
   * @license MIT
   * @constructor
   * @see https://github.com/kawanet/event-lite
   * @see http://kawanet.github.io/event-lite/EventLite.html
   * @example
   * var EventLite = require("event-lite");
   *
   * function MyClass() {...}             // your class
   *
   * EventLite.mixin(MyClass.prototype);  // import event methods
   *
   * var obj = new MyClass();
   * obj.on("foo", function() {...});     // add event listener
   * obj.once("bar", function() {...});   // add one-time event listener
   * obj.emit("foo");                     // dispatch event
   * obj.emit("bar");                     // dispatch another event
   * obj.off("foo");                      // remove event listener
   */
  (function(module2) {
    function EventLite2() {
      if (!(this instanceof EventLite2))
        return new EventLite2();
    }
    (function(EventLite3) {
      module2.exports = EventLite3;
      var LISTENERS = "listeners";
      var methods = {
        on: on2,
        once: once2,
        off: off2,
        emit: emit2
      };
      mixin(EventLite3.prototype);
      EventLite3.mixin = mixin;
      function mixin(target) {
        for (var key in methods) {
          target[key] = methods[key];
        }
        return target;
      }
      function on2(type, func) {
        getListeners(this, type).push(func);
        return this;
      }
      function once2(type, func) {
        var that = this;
        wrap.originalListener = func;
        getListeners(that, type).push(wrap);
        return that;
        function wrap() {
          off2.call(that, type, wrap);
          func.apply(this, arguments);
        }
      }
      function off2(type, func) {
        var that = this;
        var listners;
        if (!arguments.length) {
          delete that[LISTENERS];
        } else if (!func) {
          listners = that[LISTENERS];
          if (listners) {
            delete listners[type];
            if (!Object.keys(listners).length)
              return off2.call(that);
          }
        } else {
          listners = getListeners(that, type, true);
          if (listners) {
            listners = listners.filter(ne);
            if (!listners.length)
              return off2.call(that, type);
            that[LISTENERS][type] = listners;
          }
        }
        return that;
        function ne(test) {
          return test !== func && test.originalListener !== func;
        }
      }
      function emit2(type, value) {
        var that = this;
        var listeners = getListeners(that, type, true);
        if (!listeners)
          return false;
        var arglen = arguments.length;
        if (arglen === 1) {
          listeners.forEach(zeroarg);
        } else if (arglen === 2) {
          listeners.forEach(onearg);
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          listeners.forEach(moreargs);
        }
        return !!listeners.length;
        function zeroarg(func) {
          func.call(that);
        }
        function onearg(func) {
          func.call(that, value);
        }
        function moreargs(func) {
          func.apply(that, args);
        }
      }
      function getListeners(that, type, readonly) {
        if (readonly && !that[LISTENERS])
          return;
        var listeners = that[LISTENERS] || (that[LISTENERS] = {});
        return listeners[type] || (listeners[type] = []);
      }
    })(EventLite2);
  })(eventLite);
  encoder.Encoder = Encoder;
  var EventLite$1 = eventLiteExports;
  var EncodeBuffer = requireEncodeBuffer().EncodeBuffer;
  function Encoder(options2) {
    if (!(this instanceof Encoder))
      return new Encoder(options2);
    EncodeBuffer.call(this, options2);
  }
  Encoder.prototype = new EncodeBuffer();
  EventLite$1.mixin(Encoder.prototype);
  Encoder.prototype.encode = function(chunk) {
    this.write(chunk);
    this.emit("data", this.read());
  };
  Encoder.prototype.end = function(chunk) {
    if (arguments.length)
      this.encode(chunk);
    this.flush();
    this.emit("end");
  };
  var decoder = {};
  decoder.Decoder = Decoder;
  var EventLite = eventLiteExports;
  var DecodeBuffer = requireDecodeBuffer().DecodeBuffer;
  function Decoder(options2) {
    if (!(this instanceof Decoder))
      return new Decoder(options2);
    DecodeBuffer.call(this, options2);
  }
  Decoder.prototype = new DecodeBuffer();
  EventLite.mixin(Decoder.prototype);
  Decoder.prototype.decode = function(chunk) {
    if (arguments.length)
      this.write(chunk);
    this.flush();
  };
  Decoder.prototype.push = function(chunk) {
    this.emit("data", chunk);
  };
  Decoder.prototype.end = function(chunk) {
    this.decode(chunk);
    this.emit("end");
  };
  var ext = {};
  requireReadCore();
  requireWriteCore();
  ext.createCodec = codecBase.createCodec;
  var codec = {};
  requireReadCore();
  requireWriteCore();
  codec.codec = {
    preset: codecBase.preset
  };
  browser$2.encode = requireEncode().encode;
  browser$2.decode = requireDecode().decode;
  browser$2.Encoder = encoder.Encoder;
  browser$2.Decoder = decoder.Decoder;
  browser$2.createCodec = ext.createCodec;
  browser$2.codec = codec.codec;
  class Packet {
    constructor(data, roomId) {
      this.data = data;
      this.roomId = roomId;
    }
    get body() {
      return this.data;
    }
    message(otherData) {
      return [this.roomId, Date.now(), otherData ?? this.data];
    }
    clone(data) {
      return new Packet(data, this.roomId);
    }
    encode(otherData) {
      return browser$2.encode(this.message(otherData));
    }
  }
  const { get: get$1, set: set$1 } = Utils;
  class TransmitterClass {
    constructor() {
      this.encode = true;
      this.packets = {};
    }
    addPacket(room, obj) {
      const { id } = room;
      if (!id)
        return;
      if (!this.packets[id])
        this.packets[id] = [];
      this.packets[id].push(new Packet(obj, id));
    }
    forEach(cb) {
      for (let roomId in this.packets) {
        cb(this.packets[roomId], roomId);
      }
    }
    getPackets(room) {
      if (!room.id)
        return;
      return this.packets[room.id];
    }
    clear(room) {
      if (room && room.id) {
        this.packets[room.id] = [];
      } else {
        this.packets = {};
      }
    }
    error(user, error) {
      const err = error instanceof Error ? error.toObject ? error.toObject() : error.message : error;
      user._socket.emit("error", err);
    }
    async emit(user, packet, room) {
      let data = packet.body;
      if (room.$additionalEmitProperties) {
        let additionalData = await Utils.resolveValue(room.$additionalEmitProperties(user, packet.body));
        if (additionalData !== void 0) {
          if (typeof additionalData === "string") {
            additionalData = [additionalData];
          }
          if (Array.isArray(additionalData)) {
            const newData = structuredClone(data);
            for (let path2 of additionalData) {
              set$1(newData, path2, get$1(room, path2));
            }
            data = newData;
          } else {
            data = { ...data, ...additionalData };
          }
        }
      }
      user._socket.emit("w", this.encode ? packet.encode(data) : packet.message(data));
    }
  }
  const Transmitter = new TransmitterClass();
  var UserState;
  (function(UserState2) {
    UserState2["Connected"] = "C";
    UserState2["Disconnected"] = "D";
  })(UserState || (UserState = {}));
  class User {
    constructor() {
      this.$state = UserState.Connected;
      this._secretSessionId = "";
      this._rooms = [];
    }
  }
  User.schema = {
    $state: String
  };
  class CustomError extends Error {
    constructor(customMessage) {
      super(customMessage);
      this.customMessage = customMessage;
      this.status = 500;
      this.code = "INTERNAL_SERVER_ERROR";
      this.message = "Internal Server error";
    }
    toObject() {
      return {
        message: this.customMessage || this.message,
        status: this.status,
        code: this.code
      };
    }
  }
  class NotAuthorized extends CustomError {
    constructor(customMessage) {
      super(customMessage);
      this.status = 401;
      this.code = "NOT_AUTHORIZED";
      this.message = "Not authorized";
    }
  }
  const { set, get } = Utils;
  class Room {
    static hasExtraProp(obj) {
      return obj.$default !== void 0 || obj.$syncWithClient !== void 0 || obj.$permanent !== void 0 || obj.$validate !== void 0 || obj.$effects !== void 0 || obj.$type !== void 0;
    }
    static compileSchema(schema, room) {
      const dict = {};
      const masks = {};
      const permanentObject = [];
      function specialObject(val, p) {
        if (Room.hasExtraProp(val)) {
          if (val.$permanent ?? true)
            permanentObject.push(p);
          if (room && val.$default !== void 0)
            ;
          if (val.$syncWithClient === false) {
            return;
          }
          dict[p] = {
            ...val
          };
        } else {
          dict[p] = val;
          masks[p] = Utils.propertiesToArray(val);
          compile(val, p);
        }
      }
      function compile(schema2, path2 = "") {
        for (let prop in schema2) {
          const val = schema2[prop];
          let p = (path2 ? path2 + "." : "") + prop;
          if (Array.isArray(val)) {
            dict[p] = GENERIC_KEY_SCHEMA;
            p += "." + GENERIC_KEY_SCHEMA;
            if (val[0] === void 0)
              val[0] = {};
            if (Utils.isObject(val[0])) {
              specialObject(val[0], p);
            } else {
              dict[p] = val[0];
              compile(val[0], p);
            }
          } else if (Utils.isObject(val)) {
            specialObject(val, p);
          } else {
            permanentObject.push(p);
            dict[p] = val;
          }
        }
      }
      compile(schema);
      return {
        masks,
        dict,
        permanentObject
      };
    }
    constructor(options2) {
      this.options = options2;
      this.memoryTotalObject = {};
      this.memoryObject = {};
      this.permanentObject = [];
      this.propagateOldRoom = true;
      if (options2.propagateOldRoom) {
        this.propagateOldRoom = options2.propagateOldRoom;
      }
    }
    async join(user, room) {
      if (room["canJoin"]) {
        const authBool = await Utils.resolveValue(room["canJoin"](user, user._socket));
        if (authBool === false || typeof authBool == "string") {
          Transmitter.error(user, new NotAuthorized(authBool));
          return false;
        }
      }
      if (World.agonesSDK) {
        await World.agonesSDK.allocate();
      }
      let firstJoin = !room.users[user.id];
      room.users[user.id] = user;
      const userProxy = World.users[user.id]["proxy"];
      userProxy.$state = UserState.Connected;
      if (firstJoin) {
        if (room["onJoin"])
          await Utils.resolveValue(room["onJoin"](userProxy));
      }
      if (this.getUsersLength(room) == 1) {
        this.memoryTotalObject = Room.extractObjectOfRoom(room, room.$schema);
      }
      const packet = new Packet({
        ...this.memoryTotalObject,
        join: firstJoin
      }, room.id);
      await Transmitter.emit(userProxy, packet, room);
      return true;
    }
    async leave(user, room) {
      if (room["onLeave"])
        room["onLeave"](user);
      const index2 = user._rooms.findIndex((id) => room.id == id);
      user._rooms.splice(index2, 1);
      delete room.users[user.id];
      delete World.users[user.id]["proxy"];
      if (World.nbUsers == 0 && World.agonesSDK) {
        const { onBeforeShutdown, shutdownIfNotPlayers } = World.agonesOptions;
        if (shutdownIfNotPlayers) {
          if (onBeforeShutdown)
            await onBeforeShutdown();
          await World.agonesSDK.shutdown();
        }
      }
    }
    getUsersLength(room) {
      return Object.keys(room.users).length;
    }
    addInputs(room, obj) {
      room.$schema = {
        ...obj,
        ...room.$schema
      };
    }
    snapshotUser(room, userId) {
      const userSchema = this.permanentObject.filter((path2) => path2.startsWith("users.@")).map((path2) => path2.replace("users.@.", ""));
      const userObject = room.users[userId];
      if (!userObject)
        return null;
      return Room.extractObjectOfRoom(userObject, userSchema);
    }
    snapshot(room) {
      return Room.extractObjectOfRoom(room, this.permanentObject);
    }
    setProxy(room) {
      const self2 = this;
      const { dict, permanentObject, masks } = Room.compileSchema(room.$schema, room);
      const proxifiedObjects = /* @__PURE__ */ new WeakSet();
      this.permanentObject = permanentObject;
      room.$dict = dict;
      const getInfoDict = (path2, key, dictPath) => {
        const basePath = dict[dictPath];
        const p = (path2 ? path2 + "." : "") + key;
        const genericPath = (dictPath ? dictPath + "." : "") + (basePath == GENERIC_KEY_SCHEMA ? GENERIC_KEY_SCHEMA : key);
        return {
          fullPath: p,
          genericPath,
          infoDict: dict[genericPath],
          mask: masks[genericPath]
        };
      };
      function deepProxy(object, path2 = "", dictPath = "") {
        if (proxifiedObjects.has(object)) {
          return object;
        }
        return new Proxy(object, {
          set(target, key, val, receiver) {
            const { fullPath: p, infoDict, genericPath, mask } = getInfoDict(path2, key, dictPath);
            if (typeof val == "object" && infoDict && val != null) {
              const valProxy = deepProxy(val, p, genericPath);
              proxifiedObjects.add(valProxy);
              if (path2 == "users") {
                if (!room.users[key]) {
                  if (!valProxy._rooms)
                    valProxy._rooms = [];
                  valProxy._rooms.push(room.id);
                  if (!valProxy.id)
                    valProxy.id = Utils.generateId();
                }
                World.users[key]["proxy"] = valProxy;
              }
              Reflect.set(target, key, val, receiver);
              val = target[key];
            } else {
              if (infoDict == null ? void 0 : infoDict.$validate) {
                const { error } = infoDict.$validate.validate(val);
                if (error)
                  return true;
              }
              Reflect.set(target, key, val, receiver);
              val = target[key];
            }
            if (key == "length" && dict[dictPath] == GENERIC_KEY_SCHEMA) {
              return true;
            }
            if (infoDict) {
              if (infoDict.$effects) {
                for (let propEffect of infoDict.$effects) {
                  let pathEffect = "";
                  if (propEffect.startsWith("$this")) {
                    if (p) {
                      const pSplit = p.split(".");
                      pSplit[pSplit.length - 1] = propEffect.replace("$this.", "");
                      pathEffect = pSplit.join(".");
                    } else {
                      pathEffect = propEffect.replace("$this.", "");
                    }
                  } else {
                    pathEffect = propEffect;
                  }
                  self2.editMemoryObject(pathEffect, room);
                }
              }
              let newObj;
              if (Utils.isObject(infoDict) && val != null && !Room.hasExtraProp(infoDict)) {
                newObj = Room.extractObjectOfRoom(val, mask);
              } else if (infoDict == GENERIC_KEY_SCHEMA) {
                newObj = {};
                if (Object.keys(val).length == 0) {
                  newObj["$reset"] = true;
                }
                for (let key2 in val) {
                  const item = val[key2];
                  if (typeof item == "string" || typeof item == "number" || typeof item == "boolean") {
                    newObj[key2] = item;
                    continue;
                  }
                  newObj[key2] = Room.extractObjectOfRoom(item, dict[genericPath + "." + GENERIC_KEY_SCHEMA]);
                }
              } else {
                newObj = val;
              }
              self2.detectChanges(room, newObj, p);
            }
            return true;
          },
          get(target, key, receiver) {
            const toProxy = (val2, path3) => {
              if (typeof key != "string") {
                return val2;
              }
              if (key[0] == "_" || val2 == null) {
                return val2;
              }
              const { fullPath: p, infoDict, genericPath } = getInfoDict(path3, key, dictPath);
              if (typeof val2 == "object" && infoDict) {
                val2 = deepProxy(val2, p, genericPath);
                proxifiedObjects.add(val2);
              }
              return val2;
            };
            let val = Reflect.get(target, key, receiver);
            val = toProxy(val, path2);
            return val;
          },
          deleteProperty(target, key) {
            const { fullPath: p, infoDict } = getInfoDict(path2, key, dictPath);
            Reflect.deleteProperty(target, key);
            if (infoDict)
              self2.detectChanges(room, null, p);
            return true;
          }
        });
      }
      return deepProxy(room);
    }
    add(id, room) {
      room.id = id;
      room.$dict = {};
      if (!room.$schema)
        room.$schema = {};
      if (!room.$schema.users)
        room.$schema.users = [User.schema];
      if (!room.$inputs)
        room.$inputs = {};
      if (!room.users)
        room.users = {};
      if (room.$inputs)
        this.addInputs(room, room.$inputs);
      room.$detectChanges = () => {
      };
      room.$setSchema = (schema) => {
        room.$schema = schema;
        return this.setProxy(room);
      };
      room.$patchSchema = (schema) => {
        room.$schema = {
          ...room.$schema,
          ...schema
        };
        return this.setProxy(room);
      };
      room.$snapshot = () => {
        return this.snapshot(room);
      };
      room.$snapshotUser = (userId) => {
        return this.snapshotUser(room, userId);
      };
      room.$join = async (user) => {
        if (typeof user == "string") {
          user = World.users[user];
        }
        if (user) {
          return this.join(user, room);
        }
        return false;
      };
      room.$leave = async (user) => {
        if (typeof user == "string") {
          user = World.users[user]["proxy"];
        }
        await this.leave(user, room);
      };
      room.$currentState = () => this.memoryObject;
      room.$setCurrentState = (path2, value) => {
        this.editMemoryObject(path2, value === void 0 ? room : value);
      };
      room.$clearCurrentState = () => {
        this.memoryObject = {};
      };
      room.$parent = this;
      this.proxyRoom = room = this.setProxy(room);
      if (this.proxyRoom["onInit"])
        this.proxyRoom["onInit"]();
      return this.proxyRoom;
    }
    static extractObjectOfRoom(room, schema) {
      const newObj = {};
      const _schema = Array.isArray(schema) ? schema : Utils.propertiesToArray(schema);
      const regex = new RegExp("^(.*?)\\.\\" + GENERIC_KEY_SCHEMA);
      function extractAndSet(obj, path2) {
        if (path2.endsWith("@")) {
          return;
        }
        const match = regex.exec(path2);
        if (match) {
          const generic = get(room, match[1]);
          if (generic && typeof generic === "object") {
            for (let key in generic) {
              if (generic.hasOwnProperty(key)) {
                extractAndSet(obj, path2.replace(GENERIC_KEY_SCHEMA, key));
              }
            }
          }
        } else {
          set(obj, path2, get(room, path2));
        }
      }
      for (let path2 of _schema) {
        extractAndSet(newObj, path2);
      }
      return newObj;
    }
    detectChanges(room, obj, path2) {
      const change = (room2) => {
        const roomInstance = room2.$parent;
        roomInstance.editMemoryObject(path2, obj);
        set(roomInstance.memoryTotalObject, path2, obj);
        if (roomInstance.proxyRoom["onChanges"])
          roomInstance.proxyRoom["onChanges"](roomInstance.memoryObject);
        const id = room2.id;
        World.changes.next({
          ...World.changes.value,
          [id]: room2
        });
      };
      if (obj != null) {
        const [prop, userId] = path2.split(".");
        if (prop == "users") {
          if (!this.propagateOldRoom && !room.users[userId]) {
            return;
          }
          World.forEachUserRooms(userId, change);
          return;
        }
      }
      change(room);
    }
    editMemoryObject(path2, roomOrValue) {
      if (roomOrValue && typeof roomOrValue == "object" && "$currentState" in roomOrValue) {
        set(this.memoryObject, path2, get(roomOrValue, path2), true);
      } else {
        set(this.memoryObject, path2, roomOrValue, true);
      }
    }
  }
  Room.propNameUsers = "users";
  class TransportCommon {
    onConnected(cb) {
      this.onConnectedCb = cb;
    }
    onJoin(cb) {
      this.onJoinCb = cb;
    }
    onInput(cb) {
      this.onInputCb = cb;
    }
    onAction(cb) {
      this.onActionCb = cb;
    }
    onDisconnected(cb) {
      this.onDisconnectedCb = cb;
    }
  }
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v2) {
        return step([n, v2]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = void 0;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from2, pack) {
    if (pack || arguments.length === 2)
      for (var i2 = 0, l = from2.length, ar; i2 < l; i2++) {
        if (ar || !(i2 in from2)) {
          if (!ar)
            ar = Array.prototype.slice.call(from2, 0, i2);
          ar[i2] = from2[i2];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from2));
  }
  function __await(v2) {
    return this instanceof __await ? (this.v = v2, this) : new __await(v2);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i2, q = [];
    return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function verb(n) {
      if (g[n])
        i2[n] = function(v2) {
          return new Promise(function(a, b) {
            q.push([n, v2, a, b]) > 1 || resume2(n, v2);
          });
        };
    }
    function resume2(n, v2) {
      try {
        step(g[n](v2));
      } catch (e) {
        settle2(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle2(q[0][2], r);
    }
    function fulfill(value) {
      resume2("next", value);
    }
    function reject(value) {
      resume2("throw", value);
    }
    function settle2(f, v2) {
      if (f(v2), q.shift(), q.length)
        resume2(q[0][0], q[0][1]);
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i2;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n) {
      i2[n] = o[n] && function(v2) {
        return new Promise(function(resolve2, reject) {
          v2 = o[n](v2), settle2(resolve2, reject, v2.done, v2.value);
        });
      };
    }
    function settle2(resolve2, reject, d, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve2({ value: v3, done: d });
      }, reject);
    }
  }
  function isFunction$5(value) {
    return typeof value === "function";
  }
  function createErrorClass$1(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }
  var UnsubscriptionError$1 = createErrorClass$1(function(_super) {
    return function UnsubscriptionErrorImpl(errors) {
      _super(this);
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
        return i2 + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
    };
  });
  function arrRemove$1(arr, item) {
    if (arr) {
      var index2 = arr.indexOf(item);
      0 <= index2 && arr.splice(index2, 1);
    }
  }
  var Subscription$1 = function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a, e_2, _b;
      var errors;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                  _a.call(_parentage_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction$5(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors = e instanceof UnsubscriptionError$1 ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer$1(finalizer);
              } catch (err) {
                errors = errors !== null && errors !== void 0 ? errors : [];
                if (err instanceof UnsubscriptionError$1) {
                  errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                _b.call(_finalizers_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError$1(errors);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer$1(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove$1(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove$1(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function() {
      var empty = new Subscription2();
      empty.closed = true;
      return empty;
    }();
    return Subscription2;
  }();
  var EMPTY_SUBSCRIPTION = Subscription$1.EMPTY;
  function isSubscription$1(value) {
    return value instanceof Subscription$1 || value && "closed" in value && isFunction$5(value.remove) && isFunction$5(value.add) && isFunction$5(value.unsubscribe);
  }
  function execFinalizer$1(finalizer) {
    if (isFunction$5(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }
  var config$2 = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };
  var timeoutProvider$1 = {
    setTimeout: function(handler, timeout) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = timeoutProvider$1.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
    },
    clearTimeout: function(handle) {
      var delegate = timeoutProvider$1.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: void 0
  };
  function reportUnhandledError$1(err) {
    timeoutProvider$1.setTimeout(function() {
      {
        throw err;
      }
    });
  }
  function noop$4() {
  }
  function errorContext$1(cb) {
    {
      cb();
    }
  }
  var Subscriber$1 = function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (isSubscription$1(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = EMPTY_OBSERVER$1;
      }
      return _this;
    }
    Subscriber2.create = function(next, error, complete) {
      return new SafeSubscriber$1(next, error, complete);
    };
    Subscriber2.prototype.next = function(value) {
      if (this.isStopped)
        ;
      else {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (this.isStopped)
        ;
      else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped)
        ;
      else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  }(Subscription$1);
  var _bind$1 = Function.prototype.bind;
  function bind$3(fn, thisArg) {
    return _bind$1.call(fn, thisArg);
  }
  var ConsumerObserver$1 = function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError$1(error);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError$1(error);
        }
      } else {
        handleUnhandledError$1(err);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError$1(error);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber$1 = function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction$5(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
          error: error !== null && error !== void 0 ? error : void 0,
          complete: complete !== null && complete !== void 0 ? complete : void 0
        };
      } else {
        var context_1;
        if (_this && config$2.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind$3(observerOrNext.next, context_1),
            error: observerOrNext.error && bind$3(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind$3(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver$1(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber$1);
  function handleUnhandledError$1(error) {
    {
      reportUnhandledError$1(error);
    }
  }
  function defaultErrorHandler$1(err) {
    throw err;
  }
  var EMPTY_OBSERVER$1 = {
    closed: true,
    next: noop$4,
    error: defaultErrorHandler$1,
    complete: noop$4
  };
  var observable$1 = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
  function identity$1(x) {
    return x;
  }
  function pipeFromArray$1(fns) {
    if (fns.length === 0) {
      return identity$1;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }
  var Observable$1 = function() {
    function Observable2(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable2 = new Observable2();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
      var _this = this;
      var subscriber = isSubscriber$1(observerOrNext) ? observerOrNext : new SafeSubscriber$1(observerOrNext, error, complete);
      errorContext$1(function() {
        var _a = _this, operator = _a.operator, source = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor$1(promiseCtor);
      return new promiseCtor(function(resolve2, reject) {
        var subscriber = new SafeSubscriber$1({
          next: function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve2
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var _a;
      return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable2.prototype[observable$1] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipeFromArray$1(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor$1(promiseCtor);
      return new promiseCtor(function(resolve2, reject) {
        var value;
        _this.subscribe(function(x) {
          return value = x;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve2(value);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  function getPromiseCtor$1(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config$2.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver$1(value) {
    return value && isFunction$5(value.next) && isFunction$5(value.error) && isFunction$5(value.complete);
  }
  function isSubscriber$1(value) {
    return value && value instanceof Subscriber$1 || isObserver$1(value) && isSubscription$1(value);
  }
  var ObjectUnsubscribedError = createErrorClass$1(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });
  var Subject = function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
    };
    Subject2.prototype.next = function(value) {
      var _this = this;
      errorContext$1(function() {
        var e_1, _a;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
              var observer = _c.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err) {
      var _this = this;
      errorContext$1(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext$1(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function() {
        var _a;
        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
      if (hasError || isStopped) {
        return EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription$1(function() {
        _this.currentObservers = null;
        arrRemove$1(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable2 = new Observable$1();
      observable2.source = this;
      return observable2;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable$1);
  var AnonymousSubject = function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject2.prototype.error = function(err) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a, _b;
      return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject);
  var BehaviorSubject = function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  }(Subject);
  class Transport extends TransportCommon {
    constructor(io, options2 = {}) {
      super();
      this.io = io;
      this.options = options2;
      this.bandwidthData = {};
      this.WINDOW_SECONDS = 10;
      io.on("connection", (socket) => {
        const id = socket.playerId;
        this.bandwidthData[id] = new BehaviorSubject({
          incoming: [],
          outgoing: []
        });
        this.handleConnection(socket, id);
        socket.on(":input", ({ prop, value }) => this.onInputCb(id, prop, value));
        socket.on(":action", ({ name, value }) => this.onActionCb(id, name, value));
        if (options2.clientCanJoinRoom)
          socket.on(":join", (roomId) => this.onJoinCb(roomId, id));
        socket.on("disconnect", () => {
          var _a;
          (_a = this.bandwidthData[id]) == null ? void 0 : _a.unsubscribe();
          delete this.bandwidthData[id];
          this.onDisconnectedCb(id);
        });
      });
      this.use();
    }
    handleConnection(socket, id) {
      this.onConnectedCb(socket, id);
    }
    use() {
      var _a, _b;
      const { maxKbpsIncoming, maxKbpsOutgoing, auth } = this.options;
      (_b = (_a = this.io).use) == null ? void 0 : _b.call(_a, async (socket, next) => {
        let playerId;
        if (auth) {
          try {
            playerId = await Utils.resolveValue(auth(socket));
          } catch (err) {
            socket.disconnect();
            next(new NotAuthorized(err).toObject());
            return;
          }
        }
        if (!playerId)
          playerId = Utils.generateId(5);
        socket.playerId = playerId;
        socket.use((packet, nextMiddleware) => {
          var _a2, _b2;
          if (packet && packet[1]) {
            const packetSize = Utils.bufferFrom(JSON.stringify(packet)).length - 2;
            const data = { size: packetSize, timestamp: Date.now() };
            this.updateBandwidthData(playerId, { incoming: data });
            const kbps = this.calculateKbps(((_a2 = this.bandwidthData[playerId]) == null ? void 0 : _a2.value.incoming) || []);
            if (maxKbpsIncoming && kbps > maxKbpsIncoming) {
              socket.disconnect();
              return;
            }
            this.cleanOldData(((_b2 = this.bandwidthData[playerId]) == null ? void 0 : _b2.value.incoming) || []);
          }
          nextMiddleware();
        });
        const originalEmit = socket.emit;
        socket.emit = (...args) => {
          var _a2, _b2;
          const packetSize = Utils.bufferFrom(JSON.stringify(args)).length - 2;
          const data = { size: packetSize, timestamp: Date.now() };
          this.updateBandwidthData(playerId, { outgoing: data });
          const kbps = this.calculateKbps(((_a2 = this.bandwidthData[playerId]) == null ? void 0 : _a2.value.outgoing) || []);
          if (maxKbpsOutgoing && kbps > maxKbpsOutgoing) {
            socket.disconnect();
            return;
          }
          this.cleanOldData(((_b2 = this.bandwidthData[playerId]) == null ? void 0 : _b2.value.outgoing) || []);
          originalEmit.apply(socket, args);
        };
        next();
      });
    }
    updateBandwidthData(socketId, data) {
      var _a, _b;
      const currentData = ((_a = this.bandwidthData[socketId]) == null ? void 0 : _a.value) || { incoming: [], outgoing: [] };
      if (data.incoming) {
        currentData.incoming.push(data.incoming);
      }
      if (data.outgoing) {
        currentData.outgoing.push(data.outgoing);
      }
      (_b = this.bandwidthData[socketId]) == null ? void 0 : _b.next(currentData);
    }
    cleanOldData(dataArray) {
      const cutOff = Date.now() - this.WINDOW_SECONDS * 1e3;
      while (dataArray.length > 0 && dataArray[0].timestamp < cutOff) {
        dataArray.shift();
      }
    }
    calculateKbps(dataArray) {
      const totalBytes = dataArray.reduce((acc, entry) => acc + entry.size, 0);
      return totalBytes * 8 / (this.WINDOW_SECONDS * 1e3);
    }
    getTelemetry() {
      const socketsData = {};
      let totalKbps = 0;
      for (const [socketId, bandwidth] of Object.entries(this.bandwidthData)) {
        const socketData = bandwidth.value;
        const incomingKbps = this.calculateKbps(socketData.incoming);
        const outgoingKbps = this.calculateKbps(socketData.outgoing);
        socketsData[socketId] = { incomingKbps, outgoingKbps };
        totalKbps += incomingKbps + outgoingKbps;
      }
      return {
        sockets: socketsData,
        totalKbps
      };
    }
  }
  class WorldClass {
    constructor() {
      this.rooms = /* @__PURE__ */ new Map();
      this.users = {};
      this.userClass = User;
      this.timeoutDisconnect = 0;
      this.changes = new BehaviorSubject({});
      this._transport = null;
      this.agonesSDK = null;
      this.agonesOptions = {};
    }
    /**
     * Define user class
     *
     * @method setUserClass()
     * @returns {void}
     */
    setUserClass(userClass) {
      this.userClass = userClass;
    }
    setAgones(agones, options2 = {}) {
      this.agonesSDK = agones;
      this.agonesOptions = options2;
    }
    /**
     * Define transportation. You can set socket.io as default
     *
     * @method transport()
     * @param {object} io
     * @returns {Transport}
     */
    transport(io, options2 = {}) {
      if (options2.timeoutDisconnect) {
        this.timeoutDisconnect = options2.timeoutDisconnect;
      }
      const transport = new Transport(io, options2);
      transport.onConnected(this.connectUser.bind(this));
      transport.onDisconnected(this.disconnectUser.bind(this));
      transport.onJoin(this.joinRoom.bind(this));
      transport.onInput((id, prop, value) => {
        this.forEachUserRooms(id, (room, user) => {
          try {
            if (room.$inputs && room.$inputs[prop]) {
              room[prop] = value;
            }
          } catch (err) {
            Transmitter.error(user, err);
          }
        });
      });
      transport.onAction((id, name, value) => {
        this.forEachUserRooms(id, async (room, user) => {
          if (room.$actions && room.$actions[name]) {
            try {
              room[name](user, value);
            } catch (err) {
              Transmitter.error(user, err);
            }
          }
        });
      });
      return this._transport = transport;
    }
    /**
     * Loop over all rooms of a user
     *
     * Example
     *
     * ```js
     * World.forEachUserRooms('userid', (room, user) => {
     *      console.log(room.id)
     * })
     * ```
     *
     * @method forEachUserRooms()
     * @param {string} userId
     * @param {(room: RoomClass, user: User)} cb
     * @returns {void}
     */
    forEachUserRooms(userId, cb) {
      const user = this.getUser(userId, true);
      if (!user)
        return;
      for (let roomId of user._rooms) {
        const room = this.getRoom(roomId);
        cb(room, user);
      }
    }
    /**
    * Retrieves all users in the world
    *
    * @method getUsers()
    * @returns { {[id: string]: User} }
    */
    getUsers() {
      return this.users;
    }
    /**
     * Get a user in the world
     *
     * @param {string} id User Id
     * @param {boolean} [getProxy] Retrieves the proxied user. (true by default)
     * @returns {User | null}
     */
    getUser(id, getProxy = true) {
      if (!this.users[id])
        return null;
      if (getProxy && this.users[id]["proxy"]) {
        return this.users[id]["proxy"];
      }
      return this.users[id];
    }
    setUser(user, socket) {
      if (socket)
        user._socket = socket;
      user._rooms = [];
      this.users[user.id] = user;
      return this.users[user.id];
    }
    get nbUsers() {
      return Object.keys(this.users).length;
    }
    /**
     * Send the packages to the rooms.
     *
     * @method send()
     */
    async send() {
      for (let [_, room] of this.rooms) {
        const obj = room.$currentState();
        if (Object.keys(obj).length == 0) {
          continue;
        }
        Transmitter.addPacket(room, obj);
        for (let id in room.users) {
          const user = room.users[id];
          const packets = Transmitter.getPackets(room);
          if (packets) {
            for (let packet of packets) {
              await Transmitter.emit(user, packet, room);
            }
          }
        }
        room.$clearCurrentState();
      }
      Transmitter.clear();
    }
    /**
     * Connect a user
     *
     * @method connectUser()
     * @param {object} socket
     * @param {id} userId
     * @param {object} options
     *  - getUserInstance: function that returns a new instance of the user
     * @returns {User}
     */
    connectUser(socket, id, options2 = {}) {
      var _a;
      const existingUser = this.getUser(id, false);
      if (existingUser) {
        if (existingUser._timeoutDisconnect) {
          clearTimeout(existingUser._timeoutDisconnect);
          delete existingUser._timeoutDisconnect;
        }
        existingUser._socket = socket;
        existingUser.$state = UserState.Connected;
        return existingUser;
      }
      const user = ((_a = options2.getUserInstance) == null ? void 0 : _a.call(options2, socket)) ?? new this.userClass();
      user.id = id;
      socket.emit("uid", id);
      this.setUser(user, socket);
      return user;
    }
    /**
     * Removes the user from all rooms and removes him from the world
     *
     * @method disconnectUser()
     * @param {string} userId
     * @returns {void}
     */
    disconnectUser(userId) {
      return new Promise((resolve2, reject) => {
        const user = this.getUser(userId);
        if (!user)
          return resolve2();
        user.$state = UserState.Disconnected;
        const leave = () => {
          const leaveAllPromises = [];
          this.forEachUserRooms(userId, async (room, user2) => {
            if (room.$leave)
              leaveAllPromises.push(room.$leave(user2));
          });
          delete this.users[userId];
          Promise.all(leaveAllPromises).then(resolve2).catch((err) => {
            Transmitter.error(user, err);
            reject(err);
          });
        };
        if (!this.timeoutDisconnect) {
          leave();
          return;
        }
        user._timeoutDisconnect = setTimeout(leave, this.timeoutDisconnect);
      });
    }
    httpUpgrade(httpServer, io) {
      httpServer.removeAllListeners("upgrade");
      httpServer.on("upgrade", (req, socket, head) => {
        if (req.url.startsWith("/socket.io/")) {
          io.engine.handleUpgrade(req, socket, head);
        } else {
          socket.destroy();
        }
      });
    }
    async joinOrLeaveRoom(type, roomId, userId) {
      const room = this.getRoom(roomId);
      if (!room)
        return;
      if (room[type]) {
        try {
          await room[type](this.getUser(userId, false));
        } catch (err) {
          Transmitter.error(this.getUser(userId, false), err);
          throw err;
        }
      }
      return room;
    }
    /**
     * Leave an existing room
     *
     * @param {string} roomId
     * @param {string} userId
     * @returns {RoomClass | undefined}
     */
    async leaveRoom(roomId, userId) {
      return this.joinOrLeaveRoom("$leave", roomId, userId);
    }
    /**
     * Join an existing room
     *
     * @param {string} roomId
     * @param {string} userId
     * @returns {RoomClass | undefined}
     */
    async joinRoom(roomId, userId) {
      return this.joinOrLeaveRoom("$join", roomId, userId);
    }
    /**
     * Add Room
     *
     * Example 1:
     *
     * ```js
     * class ChessRoom {
     *
     * }
     *
     * World.addRoom('myroom', ChessRoom)
     * ```
     *
     * Example 2:
     *
     * ```js
     * class ChessRoom {
     *  constructor(name) { }
     * }
     *
     * World.addRoom('myroom', new ChessRoom('test'))
     * ```
     *
     * @param {string} id room id
     * @param {Class or instance of Class} roomClass
     * @returns instance of Class
     */
    addRoom(id, roomClass, options2 = {}) {
      if (roomClass.constructor.name == "Function") {
        roomClass = new roomClass();
      }
      const room = new Room(options2).add(id, roomClass);
      this.rooms.set(id, room);
      if (this.agonesSDK) {
        this.agonesSDK.setLabel("room.id", id);
      }
      return room;
    }
    /**
     * Get an existing room
     *
     * @param {string} roomId
     * @returns {RoomClass}
     */
    getRoom(id) {
      return this.rooms.get(id);
    }
    /**
     * Recover the rooms of the world
     *
     * @param {string} roomId
     * @returns {Map<string, RoomClass>}
     */
    getRooms() {
      return this.rooms;
    }
    /**
     * Delete the room
     *
     * @param {string} roomId
     * @returns {void}
     */
    removeRoom(id) {
      this.rooms.delete(id);
    }
    /**
     * Remove all rooms and users
     */
    clear() {
      var _a, _b;
      this.rooms.clear();
      this.changes.next({});
      this.users = {};
      if (this._transport) {
        (_b = (_a = this._transport.io) == null ? void 0 : _a.clear) == null ? void 0 : _b.call(_a);
      }
    }
  }
  const World = new WorldClass();
  class MiddlewareHandler {
    constructor() {
      this.middlewares = [];
    }
    use(middleware) {
      this.middlewares.push(middleware);
    }
    run(socket, finalCallback = (err) => {
    }) {
      let index2 = 0;
      const next = (err) => {
        if (err) {
          finalCallback(err);
          return;
        }
        if (index2 >= this.middlewares.length) {
          finalCallback();
          return;
        }
        const middleware = this.middlewares[index2];
        index2 += 1;
        middleware(socket, next);
      };
      next();
    }
    clear() {
      this.middlewares = [];
    }
  }
  class MockIo {
    constructor() {
      this.events = /* @__PURE__ */ new Map();
      this.eventsOnce = /* @__PURE__ */ new Map();
    }
    on(name, value) {
      this.events.set(name, [...this.events.get(name) || [], value]);
    }
    off(name) {
      if (this.eventsOnce.has(name)) {
        this.eventsOnce.delete(name);
        return;
      }
      this.events.delete(name);
    }
    once(name, value) {
      this.eventsOnce.set(name, value);
    }
    _trigger(name, data, client) {
      const events = this.events.get(name) || [];
      for (const event of events) {
        event(data, client);
      }
      const eventOnce = this.eventsOnce.get(name);
      if (eventOnce) {
        eventOnce(data, client);
        this.eventsOnce.delete(name);
      }
    }
  }
  class MockSocket extends MockIo {
    constructor(handshake, client) {
      super();
      this.handshake = handshake;
      this.client = client;
      this.middlewares = new MiddlewareHandler();
      this.id = client.fakeId ?? "" + Math.random();
      this.client.id = this.id;
    }
    emit(name, data) {
      this.client._trigger(name, data);
    }
    removeAllListeners(name) {
      return this.off(name);
    }
    use(cb) {
      this.middlewares.use(cb);
    }
    disconnect() {
    }
  }
  class MockServerIo extends MockIo {
    constructor() {
      super(...arguments);
      this.clients = /* @__PURE__ */ new Map();
      this.middlewares = new MiddlewareHandler();
    }
    connection(client, handshake) {
      return new Promise((resolve2, reject) => {
        const socket = new MockSocket(handshake, client);
        this.clients.set(socket.id, socket);
        client.id = socket.id;
        this.middlewares.run(socket, (err) => {
          if (err) {
            client._trigger("error", err);
            return;
          }
          this._trigger("connection", socket);
          resolve2(socket);
        });
      });
    }
    emit(name, data, id) {
      var _a;
      (_a = this.clients.get(id)) == null ? void 0 : _a._trigger(name, data);
    }
    use(cb) {
      this.middlewares.use(cb);
    }
    clear() {
      this.events.clear();
      this.eventsOnce.clear();
      this.clients.clear();
      this.middlewares.clear();
    }
  }
  new MockServerIo();
  var TiledLayerType;
  (function(TiledLayerType2) {
    TiledLayerType2["Tile"] = "tilelayer";
    TiledLayerType2["ObjectGroup"] = "objectgroup";
    TiledLayerType2["Image"] = "imagelayer";
    TiledLayerType2["Group"] = "group";
  })(TiledLayerType || (TiledLayerType = {}));
  function isTiledFormat(val) {
    return typeof val == "object" && val.version && val.orientation;
  }
  var sax$1 = {};
  var domain;
  function EventHandlers() {
  }
  EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.usingDomains = false;
  EventEmitter.prototype.domain = void 0;
  EventEmitter.prototype._events = void 0;
  EventEmitter.prototype._maxListeners = void 0;
  EventEmitter.defaultMaxListeners = 10;
  EventEmitter.init = function() {
    this.domain = null;
    if (EventEmitter.usingDomains) {
      if (domain.active)
        ;
    }
    if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || isNaN(n))
      throw new TypeError('"n" argument must be a positive number');
    this._maxListeners = n;
    return this;
  };
  function $getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }
  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return $getMaxListeners(this);
  };
  function emitNone(handler, isFn, self2) {
    if (isFn)
      handler.call(self2);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2)
        listeners[i2].call(self2);
    }
  }
  function emitOne(handler, isFn, self2, arg1) {
    if (isFn)
      handler.call(self2, arg1);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2)
        listeners[i2].call(self2, arg1);
    }
  }
  function emitTwo(handler, isFn, self2, arg1, arg2) {
    if (isFn)
      handler.call(self2, arg1, arg2);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2)
        listeners[i2].call(self2, arg1, arg2);
    }
  }
  function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
    if (isFn)
      handler.call(self2, arg1, arg2, arg3);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2)
        listeners[i2].call(self2, arg1, arg2, arg3);
    }
  }
  function emitMany(handler, isFn, self2, args) {
    if (isFn)
      handler.apply(self2, args);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2)
        listeners[i2].apply(self2, args);
    }
  }
  EventEmitter.prototype.emit = function emit2(type) {
    var er, handler, len, args, i2, events, domain2;
    var doError = type === "error";
    events = this._events;
    if (events)
      doError = doError && events.error == null;
    else if (!doError)
      return false;
    domain2 = this.domain;
    if (doError) {
      er = arguments[1];
      if (domain2) {
        if (!er)
          er = new Error('Uncaught, unspecified "error" event');
        er.domainEmitter = this;
        er.domain = domain2;
        er.domainThrown = false;
        domain2.emit("error", er);
      } else if (er instanceof Error) {
        throw er;
      } else {
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
        err.context = er;
        throw err;
      }
      return false;
    }
    handler = events[type];
    if (!handler)
      return false;
    var isFn = typeof handler === "function";
    len = arguments.length;
    switch (len) {
      case 1:
        emitNone(handler, isFn, this);
        break;
      case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;
      case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;
      case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
      default:
        args = new Array(len - 1);
        for (i2 = 1; i2 < len; i2++)
          args[i2 - 1] = arguments[i2];
        emitMany(handler, isFn, this, args);
    }
    return true;
  };
  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    if (typeof listener !== "function")
      throw new TypeError('"listener" argument must be a function');
    events = target._events;
    if (!events) {
      events = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      if (events.newListener) {
        target.emit(
          "newListener",
          type,
          listener.listener ? listener.listener : listener
        );
        events = target._events;
      }
      existing = events[type];
    }
    if (!existing) {
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      } else {
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      }
      if (!existing.warned) {
        m = $getMaxListeners(target);
        if (m && m > 0 && existing.length > m) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          emitWarning(w);
        }
      }
    }
    return target;
  }
  function emitWarning(e) {
    typeof console.warn === "function" ? console.warn(e) : console.log(e);
  }
  EventEmitter.prototype.addListener = function addListener2(type, listener) {
    return _addListener(this, type, listener, false);
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.prependListener = function prependListener2(type, listener) {
    return _addListener(this, type, listener, true);
  };
  function _onceWrap(target, type, listener) {
    var fired = false;
    function g() {
      target.removeListener(type, g);
      if (!fired) {
        fired = true;
        listener.apply(target, arguments);
      }
    }
    g.listener = listener;
    return g;
  }
  EventEmitter.prototype.once = function once2(type, listener) {
    if (typeof listener !== "function")
      throw new TypeError('"listener" argument must be a function');
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };
  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    if (typeof listener !== "function")
      throw new TypeError('"listener" argument must be a function');
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  };
  EventEmitter.prototype.removeListener = function removeListener2(type, listener) {
    var list, events, position, i2, originalListener;
    if (typeof listener !== "function")
      throw new TypeError('"listener" argument must be a function');
    events = this._events;
    if (!events)
      return this;
    list = events[type];
    if (!list)
      return this;
    if (list === listener || list.listener && list.listener === listener) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else {
        delete events[type];
        if (events.removeListener)
          this.emit("removeListener", type, list.listener || listener);
      }
    } else if (typeof list !== "function") {
      position = -1;
      for (i2 = list.length; i2-- > 0; ) {
        if (list[i2] === listener || list[i2].listener && list[i2].listener === listener) {
          originalListener = list[i2].listener;
          position = i2;
          break;
        }
      }
      if (position < 0)
        return this;
      if (list.length === 1) {
        list[0] = void 0;
        if (--this._eventsCount === 0) {
          this._events = new EventHandlers();
          return this;
        } else {
          delete events[type];
        }
      } else {
        spliceOne(list, position);
      }
      if (events.removeListener)
        this.emit("removeListener", type, originalListener || listener);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners2(type) {
    var listeners, events;
    events = this._events;
    if (!events)
      return this;
    if (!events.removeListener) {
      if (arguments.length === 0) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      } else if (events[type]) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else
          delete events[type];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys2 = Object.keys(events);
      for (var i2 = 0, key; i2 < keys2.length; ++i2) {
        key = keys2[i2];
        if (key === "removeListener")
          continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners("removeListener");
      this._events = new EventHandlers();
      this._eventsCount = 0;
      return this;
    }
    listeners = events[type];
    if (typeof listeners === "function") {
      this.removeListener(type, listeners);
    } else if (listeners) {
      do {
        this.removeListener(type, listeners[listeners.length - 1]);
      } while (listeners[0]);
    }
    return this;
  };
  EventEmitter.prototype.listeners = function listeners(type) {
    var evlistener;
    var ret;
    var events = this._events;
    if (!events)
      ret = [];
    else {
      evlistener = events[type];
      if (!evlistener)
        ret = [];
      else if (typeof evlistener === "function")
        ret = [evlistener.listener || evlistener];
      else
        ret = unwrapListeners(evlistener);
    }
    return ret;
  };
  EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") {
      return emitter.listenerCount(type);
    } else {
      return listenerCount$1.call(emitter, type);
    }
  };
  EventEmitter.prototype.listenerCount = listenerCount$1;
  function listenerCount$1(type) {
    var events = this._events;
    if (events) {
      var evlistener = events[type];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }
    return 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };
  function spliceOne(list, index2) {
    for (var i2 = index2, k = i2 + 1, n = list.length; k < n; i2 += 1, k += 1)
      list[i2] = list[k];
    list.pop();
  }
  function arrayClone(arr, i2) {
    var copy2 = new Array(i2);
    while (i2--)
      copy2[i2] = arr[i2];
    return copy2;
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i2 = 0; i2 < ret.length; ++i2) {
      ret[i2] = arr[i2].listener || arr[i2];
    }
    return ret;
  }
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;
  if (typeof global.setTimeout === "function") {
    cachedSetTimeout = setTimeout;
  }
  if (typeof global.clearTimeout === "function") {
    cachedClearTimeout = clearTimeout;
  }
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e2) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e2) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        args[i2 - 1] = arguments[i2];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  }
  function Item(fun, array2) {
    this.fun = fun;
    this.array = array2;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  var title = "browser";
  var platform$2 = "browser";
  var browser = true;
  var env = {};
  var argv = [];
  var version = "";
  var versions = {};
  var release = {};
  var config$1 = {};
  function noop$3() {
  }
  var on = noop$3;
  var addListener = noop$3;
  var once = noop$3;
  var off = noop$3;
  var removeListener = noop$3;
  var removeAllListeners = noop$3;
  var emit = noop$3;
  function binding(name) {
    throw new Error("process.binding is not supported");
  }
  function cwd() {
    return "/";
  }
  function chdir(dir) {
    throw new Error("process.chdir is not supported");
  }
  function umask() {
    return 0;
  }
  var performance = global.performance || {};
  var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
    return (/* @__PURE__ */ new Date()).getTime();
  };
  function hrtime(previousTimestamp) {
    var clocktime = performanceNow.call(performance) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds, nanoseconds];
  }
  var startTime = /* @__PURE__ */ new Date();
  function uptime() {
    var currentTime = /* @__PURE__ */ new Date();
    var dif = currentTime - startTime;
    return dif / 1e3;
  }
  var browser$1 = {
    nextTick,
    title,
    browser,
    env,
    argv,
    version,
    versions,
    on,
    addListener,
    once,
    off,
    removeListener,
    removeAllListeners,
    emit,
    binding,
    cwd,
    chdir,
    umask,
    hrtime,
    platform: platform$2,
    release,
    config: config$1,
    uptime
  };
  var inherits$2;
  if (typeof Object.create === "function") {
    inherits$2 = function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    inherits$2 = function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  const inherits$3 = inherits$2;
  var formatRegExp = /%[sdj%]/g;
  function format(f) {
    if (!isString$9(f)) {
      var objects = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        objects.push(inspect(arguments[i2]));
      }
      return objects.join(" ");
    }
    var i2 = 1;
    var args = arguments;
    var len = args.length;
    var str2 = String(f).replace(formatRegExp, function(x2) {
      if (x2 === "%%")
        return "%";
      if (i2 >= len)
        return x2;
      switch (x2) {
        case "%s":
          return String(args[i2++]);
        case "%d":
          return Number(args[i2++]);
        case "%j":
          try {
            return JSON.stringify(args[i2++]);
          } catch (_) {
            return "[Circular]";
          }
        default:
          return x2;
      }
    });
    for (var x = args[i2]; i2 < len; x = args[++i2]) {
      if (isNull(x) || !isObject$2(x)) {
        str2 += " " + x;
      } else {
        str2 += " " + inspect(x);
      }
    }
    return str2;
  }
  function deprecate(fn, msg) {
    if (isUndefined$2(global.process)) {
      return function() {
        return deprecate(fn, msg).apply(this, arguments);
      };
    }
    if (browser$1.noDeprecation === true) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (browser$1.throwDeprecation) {
          throw new Error(msg);
        } else if (browser$1.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  }
  var debugs = {};
  var debugEnviron;
  function debuglog(set2) {
    if (isUndefined$2(debugEnviron))
      debugEnviron = {}.NODE_DEBUG || "";
    set2 = set2.toUpperCase();
    if (!debugs[set2]) {
      if (new RegExp("\\b" + set2 + "\\b", "i").test(debugEnviron)) {
        var pid = 0;
        debugs[set2] = function() {
          var msg = format.apply(null, arguments);
          console.error("%s %d: %s", set2, pid, msg);
        };
      } else {
        debugs[set2] = function() {
        };
      }
    }
    return debugs[set2];
  }
  function inspect(obj, opts) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3)
      ctx.depth = arguments[2];
    if (arguments.length >= 4)
      ctx.colors = arguments[3];
    if (isBoolean$2(opts)) {
      ctx.showHidden = opts;
    } else if (opts) {
      _extend(ctx, opts);
    }
    if (isUndefined$2(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined$2(ctx.depth))
      ctx.depth = 2;
    if (isUndefined$2(ctx.colors))
      ctx.colors = false;
    if (isUndefined$2(ctx.customInspect))
      ctx.customInspect = true;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  inspect.colors = {
    "bold": [1, 22],
    "italic": [3, 23],
    "underline": [4, 24],
    "inverse": [7, 27],
    "white": [37, 39],
    "grey": [90, 39],
    "black": [30, 39],
    "blue": [34, 39],
    "cyan": [36, 39],
    "green": [32, 39],
    "magenta": [35, 39],
    "red": [31, 39],
    "yellow": [33, 39]
  };
  inspect.styles = {
    "special": "cyan",
    "number": "yellow",
    "boolean": "yellow",
    "undefined": "grey",
    "null": "bold",
    "string": "green",
    "date": "magenta",
    // "name": intentionally not styling
    "regexp": "red"
  };
  function stylizeWithColor(str2, styleType) {
    var style = inspect.styles[styleType];
    if (style) {
      return "\x1B[" + inspect.colors[style][0] + "m" + str2 + "\x1B[" + inspect.colors[style][1] + "m";
    } else {
      return str2;
    }
  }
  function stylizeNoColor(str2, styleType) {
    return str2;
  }
  function arrayToHash(array2) {
    var hash = {};
    array2.forEach(function(val, idx) {
      hash[val] = true;
    });
    return hash;
  }
  function formatValue(ctx, value, recurseTimes) {
    if (ctx.customInspect && value && isFunction$4(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString$9(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }
    var keys2 = Object.keys(value);
    var visibleKeys = arrayToHash(keys2);
    if (ctx.showHidden) {
      keys2 = Object.getOwnPropertyNames(value);
    }
    if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
      return formatError(value);
    }
    if (keys2.length === 0) {
      if (isFunction$4(value)) {
        var name = value.name ? ": " + value.name : "";
        return ctx.stylize("[Function" + name + "]", "special");
      }
      if (isRegExp$2(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      }
      if (isDate$2(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), "date");
      }
      if (isError(value)) {
        return formatError(value);
      }
    }
    var base = "", array2 = false, braces = ["{", "}"];
    if (isArray$6(value)) {
      array2 = true;
      braces = ["[", "]"];
    }
    if (isFunction$4(value)) {
      var n = value.name ? ": " + value.name : "";
      base = " [Function" + n + "]";
    }
    if (isRegExp$2(value)) {
      base = " " + RegExp.prototype.toString.call(value);
    }
    if (isDate$2(value)) {
      base = " " + Date.prototype.toUTCString.call(value);
    }
    if (isError(value)) {
      base = " " + formatError(value);
    }
    if (keys2.length === 0 && (!array2 || value.length == 0)) {
      return braces[0] + base + braces[1];
    }
    if (recurseTimes < 0) {
      if (isRegExp$2(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      } else {
        return ctx.stylize("[Object]", "special");
      }
    }
    ctx.seen.push(value);
    var output;
    if (array2) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
    } else {
      output = keys2.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array2);
      });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }
  function formatPrimitive(ctx, value) {
    if (isUndefined$2(value))
      return ctx.stylize("undefined", "undefined");
    if (isString$9(value)) {
      var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber$2(value))
      return ctx.stylize("" + value, "number");
    if (isBoolean$2(value))
      return ctx.stylize("" + value, "boolean");
    if (isNull(value))
      return ctx.stylize("null", "null");
  }
  function formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
  }
  function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
    var output = [];
    for (var i2 = 0, l = value.length; i2 < l; ++i2) {
      if (hasOwnProperty$2(value, String(i2))) {
        output.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          String(i2),
          true
        ));
      } else {
        output.push("");
      }
    }
    keys2.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          key,
          true
        ));
      }
    });
    return output;
  }
  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array2) {
    var name, str2, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str2 = ctx.stylize("[Getter/Setter]", "special");
      } else {
        str2 = ctx.stylize("[Getter]", "special");
      }
    } else {
      if (desc.set) {
        str2 = ctx.stylize("[Setter]", "special");
      }
    }
    if (!hasOwnProperty$2(visibleKeys, key)) {
      name = "[" + key + "]";
    }
    if (!str2) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str2 = formatValue(ctx, desc.value, null);
        } else {
          str2 = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str2.indexOf("\n") > -1) {
          if (array2) {
            str2 = str2.split("\n").map(function(line) {
              return "  " + line;
            }).join("\n").substr(2);
          } else {
            str2 = "\n" + str2.split("\n").map(function(line) {
              return "   " + line;
            }).join("\n");
          }
        }
      } else {
        str2 = ctx.stylize("[Circular]", "special");
      }
    }
    if (isUndefined$2(name)) {
      if (array2 && key.match(/^\d+$/)) {
        return str2;
      }
      name = JSON.stringify("" + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, "name");
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, "string");
      }
    }
    return name + ": " + str2;
  }
  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function(prev, cur) {
      if (cur.indexOf("\n") >= 0)
        ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length > 60) {
      return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    }
    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
  }
  function isArray$6(ar) {
    return Array.isArray(ar);
  }
  function isBoolean$2(arg) {
    return typeof arg === "boolean";
  }
  function isNull(arg) {
    return arg === null;
  }
  function isNumber$2(arg) {
    return typeof arg === "number";
  }
  function isString$9(arg) {
    return typeof arg === "string";
  }
  function isUndefined$2(arg) {
    return arg === void 0;
  }
  function isRegExp$2(re) {
    return isObject$2(re) && objectToString(re) === "[object RegExp]";
  }
  function isObject$2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  function isDate$2(d) {
    return isObject$2(d) && objectToString(d) === "[object Date]";
  }
  function isError(e) {
    return isObject$2(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
  }
  function isFunction$4(arg) {
    return typeof arg === "function";
  }
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  function _extend(origin, add2) {
    if (!add2 || !isObject$2(add2))
      return origin;
    var keys2 = Object.keys(add2);
    var i2 = keys2.length;
    while (i2--) {
      origin[keys2[i2]] = add2[keys2[i2]];
    }
    return origin;
  }
  function hasOwnProperty$2(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  function BufferList() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  BufferList.prototype.push = function(v2) {
    var entry = { data: v2, next: null };
    if (this.length > 0)
      this.tail.next = entry;
    else
      this.head = entry;
    this.tail = entry;
    ++this.length;
  };
  BufferList.prototype.unshift = function(v2) {
    var entry = { data: v2, next: this.head };
    if (this.length === 0)
      this.tail = entry;
    this.head = entry;
    ++this.length;
  };
  BufferList.prototype.shift = function() {
    if (this.length === 0)
      return;
    var ret = this.head.data;
    if (this.length === 1)
      this.head = this.tail = null;
    else
      this.head = this.head.next;
    --this.length;
    return ret;
  };
  BufferList.prototype.clear = function() {
    this.head = this.tail = null;
    this.length = 0;
  };
  BufferList.prototype.join = function(s) {
    if (this.length === 0)
      return "";
    var p = this.head;
    var ret = "" + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }
    return ret;
  };
  BufferList.prototype.concat = function(n) {
    if (this.length === 0)
      return Buffer$2.alloc(0);
    if (this.length === 1)
      return this.head.data;
    var ret = Buffer$2.allocUnsafe(n >>> 0);
    var p = this.head;
    var i2 = 0;
    while (p) {
      p.data.copy(ret, i2);
      i2 += p.data.length;
      p = p.next;
    }
    return ret;
  };
  var isBufferEncoding = Buffer$2.isEncoding || function(encoding) {
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function assertEncoding(encoding) {
    if (encoding && !isBufferEncoding(encoding)) {
      throw new Error("Unknown encoding: " + encoding);
    }
  }
  function StringDecoder(encoding) {
    this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
    assertEncoding(encoding);
    switch (this.encoding) {
      case "utf8":
        this.surrogateSize = 3;
        break;
      case "ucs2":
      case "utf16le":
        this.surrogateSize = 2;
        this.detectIncompleteChar = utf16DetectIncompleteChar;
        break;
      case "base64":
        this.surrogateSize = 3;
        this.detectIncompleteChar = base64DetectIncompleteChar;
        break;
      default:
        this.write = passThroughWrite;
        return;
    }
    this.charBuffer = new Buffer$2(6);
    this.charReceived = 0;
    this.charLength = 0;
  }
  StringDecoder.prototype.write = function(buffer) {
    var charStr = "";
    while (this.charLength) {
      var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
      buffer.copy(this.charBuffer, this.charReceived, 0, available);
      this.charReceived += available;
      if (this.charReceived < this.charLength) {
        return "";
      }
      buffer = buffer.slice(available, buffer.length);
      charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
      var charCode = charStr.charCodeAt(charStr.length - 1);
      if (charCode >= 55296 && charCode <= 56319) {
        this.charLength += this.surrogateSize;
        charStr = "";
        continue;
      }
      this.charReceived = this.charLength = 0;
      if (buffer.length === 0) {
        return charStr;
      }
      break;
    }
    this.detectIncompleteChar(buffer);
    var end = buffer.length;
    if (this.charLength) {
      buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
      end -= this.charReceived;
    }
    charStr += buffer.toString(this.encoding, 0, end);
    var end = charStr.length - 1;
    var charCode = charStr.charCodeAt(end);
    if (charCode >= 55296 && charCode <= 56319) {
      var size = this.surrogateSize;
      this.charLength += size;
      this.charReceived += size;
      this.charBuffer.copy(this.charBuffer, size, 0, size);
      buffer.copy(this.charBuffer, 0, 0, size);
      return charStr.substring(0, end);
    }
    return charStr;
  };
  StringDecoder.prototype.detectIncompleteChar = function(buffer) {
    var i2 = buffer.length >= 3 ? 3 : buffer.length;
    for (; i2 > 0; i2--) {
      var c2 = buffer[buffer.length - i2];
      if (i2 == 1 && c2 >> 5 == 6) {
        this.charLength = 2;
        break;
      }
      if (i2 <= 2 && c2 >> 4 == 14) {
        this.charLength = 3;
        break;
      }
      if (i2 <= 3 && c2 >> 3 == 30) {
        this.charLength = 4;
        break;
      }
    }
    this.charReceived = i2;
  };
  StringDecoder.prototype.end = function(buffer) {
    var res = "";
    if (buffer && buffer.length)
      res = this.write(buffer);
    if (this.charReceived) {
      var cr = this.charReceived;
      var buf = this.charBuffer;
      var enc = this.encoding;
      res += buf.slice(0, cr).toString(enc);
    }
    return res;
  };
  function passThroughWrite(buffer) {
    return buffer.toString(this.encoding);
  }
  function utf16DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 2;
    this.charLength = this.charReceived ? 2 : 0;
  }
  function base64DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 3;
    this.charLength = this.charReceived ? 3 : 0;
  }
  const stringDecoder = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    StringDecoder
  }, Symbol.toStringTag, { value: "Module" }));
  Readable.ReadableState = ReadableState;
  var debug = debuglog("stream");
  inherits$3(Readable, EventEmitter);
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") {
      return emitter.prependListener(event, fn);
    } else {
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
  }
  function listenerCount(emitter, type) {
    return emitter.listeners(type).length;
  }
  function ReadableState(options2, stream2) {
    options2 = options2 || {};
    this.objectMode = !!options2.objectMode;
    if (stream2 instanceof Duplex)
      this.objectMode = this.objectMode || !!options2.readableObjectMode;
    var hwm = options2.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
    this.highWaterMark = ~~this.highWaterMark;
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.defaultEncoding = options2.defaultEncoding || "utf8";
    this.ranOut = false;
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options2.encoding) {
      this.decoder = new StringDecoder(options2.encoding);
      this.encoding = options2.encoding;
    }
  }
  function Readable(options2) {
    if (!(this instanceof Readable))
      return new Readable(options2);
    this._readableState = new ReadableState(options2, this);
    this.readable = true;
    if (options2 && typeof options2.read === "function")
      this._read = options2.read;
    EventEmitter.call(this);
  }
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    if (!state.objectMode && typeof chunk === "string") {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = "";
      }
    }
    return readableAddChunk(this, state, chunk, encoding, false);
  };
  Readable.prototype.unshift = function(chunk) {
    var state = this._readableState;
    return readableAddChunk(this, state, chunk, "", true);
  };
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  function readableAddChunk(stream2, state, chunk, encoding, addToFront) {
    var er = chunkInvalid(state, chunk);
    if (er) {
      stream2.emit("error", er);
    } else if (chunk === null) {
      state.reading = false;
      onEofChunk(stream2, state);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (state.ended && !addToFront) {
        var e = new Error("stream.push() after EOF");
        stream2.emit("error", e);
      } else if (state.endEmitted && addToFront) {
        var _e = new Error("stream.unshift() after end event");
        stream2.emit("error", _e);
      } else {
        var skipAdd;
        if (state.decoder && !addToFront && !encoding) {
          chunk = state.decoder.write(chunk);
          skipAdd = !state.objectMode && chunk.length === 0;
        }
        if (!addToFront)
          state.reading = false;
        if (!skipAdd) {
          if (state.flowing && state.length === 0 && !state.sync) {
            stream2.emit("data", chunk);
            stream2.read(0);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
            if (state.needReadable)
              emitReadable(stream2);
          }
        }
        maybeReadMore(stream2, state);
      }
    } else if (!addToFront) {
      state.reading = false;
    }
    return needMoreData(state);
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable.prototype.setEncoding = function(enc) {
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function chunkInvalid(state, chunk) {
    var er = null;
    if (!Buffer.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function onEofChunk(stream2, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream2);
  }
  function emitReadable(stream2) {
    var state = stream2._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        nextTick(emitReadable_, stream2);
      else
        emitReadable_(stream2);
    }
  }
  function emitReadable_(stream2) {
    debug("emit readable");
    stream2.emit("readable");
    flow(stream2);
  }
  function maybeReadMore(stream2, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      nextTick(maybeReadMore_, stream2, state);
    }
  }
  function maybeReadMore_(stream2, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug("maybeReadMore read 0");
      stream2.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = !pipeOpts || pipeOpts.end !== false;
    var endFn = doEnd ? onend2 : cleanup;
    if (state.endEmitted)
      nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable) {
      debug("onunpipe");
      if (readable === src) {
        cleanup();
      }
    }
    function onend2() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend2);
      src.removeListener("end", cleanup);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (listenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && src.listeners("data").length) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var _i = 0; _i < len; _i++) {
        dests[_i].emit("unpipe", this);
      }
      return this;
    }
    var i2 = indexOf(state.pipes, dest);
    if (i2 === -1)
      return this;
    state.pipes.splice(i2, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = EventEmitter.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream2, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      nextTick(resume_, stream2, state);
    }
  }
  function resume_(stream2, state) {
    if (!state.reading) {
      debug("resume read 0");
      stream2.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream2.emit("resume");
    flow(stream2);
    if (state.flowing && !state.reading)
      stream2.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream2) {
    var state = stream2._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream2.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream2) {
    var state = this._readableState;
    var paused = false;
    var self2 = this;
    stream2.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          self2.push(chunk);
      }
      self2.push(null);
    });
    stream2.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = self2.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i2 in stream2) {
      if (this[i2] === void 0 && typeof stream2[i2] === "function") {
        this[i2] = function(method2) {
          return function() {
            return stream2[method2].apply(stream2, arguments);
          };
        }(i2);
      }
    }
    var events = ["error", "close", "destroy", "pause", "resume"];
    forEach$2(events, function(ev) {
      stream2.on(ev, self2.emit.bind(self2, ev));
    });
    self2._read = function(n) {
      debug("wrapped _read", n);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return self2;
  };
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c2 = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str2 = p.data;
      var nb = n > str2.length ? str2.length : n;
      if (nb === str2.length)
        ret += str2;
      else
        ret += str2.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str2.length) {
          ++c2;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str2.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer.allocUnsafe(n);
    var p = list.head;
    var c2 = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c2;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  function endReadable(stream2) {
    var state = stream2._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      nextTick(endReadableNT, state, stream2);
    }
  }
  function endReadableNT(state, stream2) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
    }
  }
  function forEach$2(xs, f) {
    for (var i2 = 0, l = xs.length; i2 < l; i2++) {
      f(xs[i2], i2);
    }
  }
  function indexOf(xs, x) {
    for (var i2 = 0, l = xs.length; i2 < l; i2++) {
      if (xs[i2] === x)
        return i2;
    }
    return -1;
  }
  Writable.WritableState = WritableState;
  inherits$3(Writable, EventEmitter);
  function nop() {
  }
  function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
  }
  function WritableState(options2, stream2) {
    Object.defineProperty(this, "buffer", {
      get: deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
    });
    options2 = options2 || {};
    this.objectMode = !!options2.objectMode;
    if (stream2 instanceof Duplex)
      this.objectMode = this.objectMode || !!options2.writableObjectMode;
    var hwm = options2.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
    this.highWaterMark = ~~this.highWaterMark;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    var noDecode = options2.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options2.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function writableStateGetBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  function Writable(options2) {
    if (!(this instanceof Writable) && !(this instanceof Duplex))
      return new Writable(options2);
    this._writableState = new WritableState(options2, this);
    this.writable = true;
    if (options2) {
      if (typeof options2.write === "function")
        this._write = options2.write;
      if (typeof options2.writev === "function")
        this._writev = options2.writev;
    }
    EventEmitter.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream2, cb) {
    var er = new Error("write after end");
    stream2.emit("error", er);
    nextTick(cb, er);
  }
  function validChunk(stream2, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (!Buffer$2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream2.emit("error", er);
      nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (Buffer$2.isBuffer(chunk))
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer$2.from(chunk, encoding);
    }
    return chunk;
  }
  function writeOrBuffer(stream2, state, chunk, encoding, cb) {
    chunk = decodeChunk(state, chunk, encoding);
    if (Buffer$2.isBuffer(chunk))
      encoding = "buffer";
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last2 = state.lastBufferedRequest;
      state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
      if (last2) {
        last2.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream2._writev(chunk, state.onwrite);
    else
      stream2._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream2, state, sync, er, cb) {
    --state.pendingcb;
    if (sync)
      nextTick(cb, er);
    else
      cb(er);
    stream2._writableState.errorEmitted = true;
    stream2.emit("error", er);
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state = stream2._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream2, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream2, state);
      }
      if (sync) {
        nextTick(afterWrite, stream2, state, finished, cb);
      } else {
        afterWrite(stream2, state, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream2, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream2, state);
  }
  function onwriteDrain(stream2, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      while (entry) {
        buffer[count] = entry;
        entry = entry.next;
        count += 1;
      }
      doWrite(stream2, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream2, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequestCount = 0;
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending && !state.finished)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function prefinish(stream2, state) {
    if (!state.prefinished) {
      state.prefinished = true;
      stream2.emit("prefinish");
    }
  }
  function finishMaybe(stream2, state) {
    var need = needFinish(state);
    if (need) {
      if (state.pendingcb === 0) {
        prefinish(stream2, state);
        state.finished = true;
        stream2.emit("finish");
      } else {
        prefinish(stream2, state);
      }
    }
    return need;
  }
  function endWritable(stream2, state, cb) {
    state.ending = true;
    finishMaybe(stream2, state);
    if (cb) {
      if (state.finished)
        nextTick(cb);
      else
        stream2.once("finish", cb);
    }
    state.ended = true;
    stream2.writable = false;
  }
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function(err) {
      var entry = _this.entry;
      _this.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = _this;
      } else {
        state.corkedRequestsFree = _this;
      }
    };
  }
  inherits$3(Duplex, Readable);
  var keys = Object.keys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method])
      Duplex.prototype[method] = Writable.prototype[method];
  }
  function Duplex(options2) {
    if (!(this instanceof Duplex))
      return new Duplex(options2);
    Readable.call(this, options2);
    Writable.call(this, options2);
    if (options2 && options2.readable === false)
      this.readable = false;
    if (options2 && options2.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options2 && options2.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  inherits$3(Transform, Duplex);
  function TransformState(stream2) {
    this.afterTransform = function(er, data) {
      return afterTransform(stream2, er, data);
    };
    this.needTransform = false;
    this.transforming = false;
    this.writecb = null;
    this.writechunk = null;
    this.writeencoding = null;
  }
  function afterTransform(stream2, er, data) {
    var ts = stream2._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb)
      return stream2.emit("error", new Error("no writecb in Transform class"));
    ts.writechunk = null;
    ts.writecb = null;
    if (data !== null && data !== void 0)
      stream2.push(data);
    cb(er);
    var rs = stream2._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      stream2._read(rs.highWaterMark);
    }
  }
  function Transform(options2) {
    if (!(this instanceof Transform))
      return new Transform(options2);
    Duplex.call(this, options2);
    this._transformState = new TransformState(this);
    var stream2 = this;
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options2) {
      if (typeof options2.transform === "function")
        this._transform = options2.transform;
      if (typeof options2.flush === "function")
        this._flush = options2.flush;
    }
    this.once("prefinish", function() {
      if (typeof this._flush === "function")
        this._flush(function(er) {
          done(stream2, er);
        });
      else
        done(stream2);
    });
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("Not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  function done(stream2, er) {
    if (er)
      return stream2.emit("error", er);
    var ws = stream2._writableState;
    var ts = stream2._transformState;
    if (ws.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (ts.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream2.push(null);
  }
  inherits$3(PassThrough, Transform);
  function PassThrough(options2) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options2);
    Transform.call(this, options2);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  inherits$3(Stream, EventEmitter);
  Stream.Readable = Readable;
  Stream.Writable = Writable;
  Stream.Duplex = Duplex;
  Stream.Transform = Transform;
  Stream.PassThrough = PassThrough;
  Stream.Stream = Stream;
  function Stream() {
    EventEmitter.call(this);
  }
  Stream.prototype.pipe = function(dest, options2) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options2 || options2.end !== false)) {
      source.on("end", onend2);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend2() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      if (typeof dest.destroy === "function")
        dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EventEmitter.listenerCount(this, "error") === 0) {
        throw er;
      }
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend2);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  const stream = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Duplex,
    PassThrough,
    Readable,
    Stream,
    Transform,
    Writable,
    default: Stream
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(stream);
  const require$$1 = /* @__PURE__ */ getAugmentedNamespace(stringDecoder);
  (function(exports3) {
    (function(sax2) {
      sax2.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax2.SAXParser = SAXParser;
      sax2.SAXStream = SAXStream;
      sax2.createStream = createStream;
      sax2.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax2.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit2(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i2 in o)
            if (o.hasOwnProperty(i2))
              a.push(i2);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i2 = 0, l = buffers.length; i2 < l; i2++) {
          var len = parser[buffers[i2]].length;
          if (len > maxAllowed) {
            switch (buffers[i2]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i2]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax2.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i2 = 0, l = buffers.length; i2 < l; i2++) {
          parser[buffers[i2]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write: write3,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream2;
      try {
        Stream2 = require$$0.Stream;
      } catch (ex) {
        Stream2 = function() {
        };
      }
      var streamWraps = sax2.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream2.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream2.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require$$1.StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream2.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c2) {
        return c2 === " " || c2 === "\n" || c2 === "\r" || c2 === "	";
      }
      function isQuote(c2) {
        return c2 === '"' || c2 === "'";
      }
      function isAttribEnd(c2) {
        return c2 === ">" || isWhitespace(c2);
      }
      function isMatch(regex, c2) {
        return regex.test(c2);
      }
      function notMatch(regex, c2) {
        return !isMatch(regex, c2);
      }
      var S = 0;
      sax2.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax2.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax2.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax2.ENTITIES).forEach(function(key) {
        var e = sax2.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax2.ENTITIES[key] = s2;
      });
      for (var s in sax2.STATE) {
        sax2.STATE[sax2.STATE[s]] = s;
      }
      S = sax2.STATE;
      function emit2(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode)
          closeText(parser);
        emit2(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
          emit2(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim)
          text = text.trim();
        if (opt.normalize)
          text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit2(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit2(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict)
          parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i2 = name.indexOf(":");
        var qualName = i2 < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i2 = 0, l = parser.attribList.length; i2 < l; i2++) {
            var nv = parser.attribList[i2];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i2 in tag.ns) {
            x[i2] = tag.ns[i2];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0)
          parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c2) {
        if (c2 === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c2)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c2;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i2) {
        var result = "";
        if (i2 < chunk.length) {
          result = chunk.charAt(i2);
        }
        return result;
      }
      function write3(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i2 = 0;
        var c2 = "";
        while (true) {
          c2 = charAt(chunk, i2++);
          parser.c = c2;
          if (!c2) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c2 === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c2 === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c2);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c2);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i2 - 1;
                while (c2 && c2 !== "<" && c2 !== "&") {
                  c2 = charAt(chunk, i2++);
                  if (c2 && parser.trackPosition) {
                    parser.position++;
                    if (c2 === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i2 - 1);
              }
              if (c2 === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c2) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c2 === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c2;
                }
              }
              continue;
            case S.SCRIPT:
              if (c2 === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c2;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c2 === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c2;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c2 === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c2))
                ;
              else if (isMatch(nameStart, c2)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c2;
              } else if (c2 === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c2 === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c2 = new Array(pad).join(" ") + c2;
                }
                parser.textNode += "<" + c2;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c2).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c2 === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c2).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c2 === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c2)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c2;
              } else {
                parser.sgmlDecl += c2;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c2 === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c2;
              continue;
            case S.DOCTYPE:
              if (c2 === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c2;
                if (c2 === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c2)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c2;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c2;
              if (c2 === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c2;
              if (c2 === "]") {
                parser.state = S.DOCTYPE;
              } else if (isQuote(c2)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c2;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c2;
              if (c2 === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c2 === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c2;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c2 === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c2;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c2 !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c2;
                parser.state = S.COMMENT;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c2 === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c2;
              }
              continue;
            case S.CDATA_ENDING:
              if (c2 === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c2;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c2 === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c2 === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c2;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c2 === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c2)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c2;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c2)) {
                continue;
              } else if (c2 === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c2;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c2 === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c2;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c2)) {
                parser.tagName += c2;
              } else {
                newTag(parser);
                if (c2 === ">") {
                  openTag(parser);
                } else if (c2 === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c2)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c2 === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c2)) {
                continue;
              } else if (c2 === ">") {
                openTag(parser);
              } else if (c2 === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c2)) {
                parser.attribName = c2;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c2 === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c2 === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c2)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c2)) {
                parser.attribName += c2;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c2 === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c2)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c2 === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c2)) {
                  parser.attribName = c2;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c2)) {
                continue;
              } else if (isQuote(c2)) {
                parser.q = c2;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c2;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c2 !== parser.q) {
                if (c2 === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c2;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c2)) {
                parser.state = S.ATTRIB;
              } else if (c2 === ">") {
                openTag(parser);
              } else if (c2 === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c2)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c2;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c2)) {
                if (c2 === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c2;
                }
                continue;
              }
              attrib(parser);
              if (c2 === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c2)) {
                  continue;
                } else if (notMatch(nameStart, c2)) {
                  if (parser.script) {
                    parser.script += "</" + c2;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c2;
                }
              } else if (c2 === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c2)) {
                parser.tagName += c2;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c2)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c2)) {
                continue;
              }
              if (c2 === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c2 === ";") {
                parser[buffer] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c2)) {
                parser.entity += c2;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c2;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index2 = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index2 < length) {
              var codePoint = Number(arguments[index2]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index2 + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(exports3);
  })(sax$1);
  var arrayHelper = {
    isArray: function(value) {
      if (Array.isArray) {
        return Array.isArray(value);
      }
      return Object.prototype.toString.call(value) === "[object Array]";
    }
  };
  var isArray$5 = arrayHelper.isArray;
  var optionsHelper = {
    copyOptions: function(options2) {
      var key, copy2 = {};
      for (key in options2) {
        if (options2.hasOwnProperty(key)) {
          copy2[key] = options2[key];
        }
      }
      return copy2;
    },
    ensureFlagExists: function(item, options2) {
      if (!(item in options2) || typeof options2[item] !== "boolean") {
        options2[item] = false;
      }
    },
    ensureSpacesExists: function(options2) {
      if (!("spaces" in options2) || typeof options2.spaces !== "number" && typeof options2.spaces !== "string") {
        options2.spaces = 0;
      }
    },
    ensureAlwaysArrayExists: function(options2) {
      if (!("alwaysArray" in options2) || typeof options2.alwaysArray !== "boolean" && !isArray$5(options2.alwaysArray)) {
        options2.alwaysArray = false;
      }
    },
    ensureKeyExists: function(key, options2) {
      if (!(key + "Key" in options2) || typeof options2[key + "Key"] !== "string") {
        options2[key + "Key"] = options2.compact ? "_" + key : key;
      }
    },
    checkFnExists: function(key, options2) {
      return key + "Fn" in options2;
    }
  };
  var sax = sax$1;
  var helper$2 = optionsHelper;
  var isArray$4 = arrayHelper.isArray;
  var options;
  var currentElement$1;
  function validateOptions$2(userOptions) {
    options = helper$2.copyOptions(userOptions);
    helper$2.ensureFlagExists("ignoreDeclaration", options);
    helper$2.ensureFlagExists("ignoreInstruction", options);
    helper$2.ensureFlagExists("ignoreAttributes", options);
    helper$2.ensureFlagExists("ignoreText", options);
    helper$2.ensureFlagExists("ignoreComment", options);
    helper$2.ensureFlagExists("ignoreCdata", options);
    helper$2.ensureFlagExists("ignoreDoctype", options);
    helper$2.ensureFlagExists("compact", options);
    helper$2.ensureFlagExists("alwaysChildren", options);
    helper$2.ensureFlagExists("addParent", options);
    helper$2.ensureFlagExists("trim", options);
    helper$2.ensureFlagExists("nativeType", options);
    helper$2.ensureFlagExists("nativeTypeAttributes", options);
    helper$2.ensureFlagExists("sanitize", options);
    helper$2.ensureFlagExists("instructionHasAttributes", options);
    helper$2.ensureFlagExists("captureSpacesBetweenElements", options);
    helper$2.ensureAlwaysArrayExists(options);
    helper$2.ensureKeyExists("declaration", options);
    helper$2.ensureKeyExists("instruction", options);
    helper$2.ensureKeyExists("attributes", options);
    helper$2.ensureKeyExists("text", options);
    helper$2.ensureKeyExists("comment", options);
    helper$2.ensureKeyExists("cdata", options);
    helper$2.ensureKeyExists("doctype", options);
    helper$2.ensureKeyExists("type", options);
    helper$2.ensureKeyExists("name", options);
    helper$2.ensureKeyExists("elements", options);
    helper$2.ensureKeyExists("parent", options);
    return options;
  }
  function nativeType(value) {
    var nValue = Number(value);
    if (!isNaN(nValue)) {
      return nValue;
    }
    var bValue = value.toLowerCase();
    if (bValue === "true") {
      return true;
    } else if (bValue === "false") {
      return false;
    }
    return value;
  }
  function addField(type, value) {
    var key;
    if (options.compact) {
      if (!currentElement$1[options[type + "Key"]] && (isArray$4(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + "Key"]) !== -1 : options.alwaysArray)) {
        currentElement$1[options[type + "Key"]] = [];
      }
      if (currentElement$1[options[type + "Key"]] && !isArray$4(currentElement$1[options[type + "Key"]])) {
        currentElement$1[options[type + "Key"]] = [currentElement$1[options[type + "Key"]]];
      }
      if (type + "Fn" in options && typeof value === "string") {
        value = options[type + "Fn"](value, currentElement$1);
      }
      if (type === "instruction" && ("instructionFn" in options || "instructionNameFn" in options)) {
        for (key in value) {
          if (value.hasOwnProperty(key)) {
            if ("instructionFn" in options) {
              value[key] = options.instructionFn(value[key], key, currentElement$1);
            } else {
              var temp = value[key];
              delete value[key];
              value[options.instructionNameFn(key, temp, currentElement$1)] = temp;
            }
          }
        }
      }
      if (isArray$4(currentElement$1[options[type + "Key"]])) {
        currentElement$1[options[type + "Key"]].push(value);
      } else {
        currentElement$1[options[type + "Key"]] = value;
      }
    } else {
      if (!currentElement$1[options.elementsKey]) {
        currentElement$1[options.elementsKey] = [];
      }
      var element = {};
      element[options.typeKey] = type;
      if (type === "instruction") {
        for (key in value) {
          if (value.hasOwnProperty(key)) {
            break;
          }
        }
        element[options.nameKey] = "instructionNameFn" in options ? options.instructionNameFn(key, value, currentElement$1) : key;
        if (options.instructionHasAttributes) {
          element[options.attributesKey] = value[key][options.attributesKey];
          if ("instructionFn" in options) {
            element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement$1);
          }
        } else {
          if ("instructionFn" in options) {
            value[key] = options.instructionFn(value[key], key, currentElement$1);
          }
          element[options.instructionKey] = value[key];
        }
      } else {
        if (type + "Fn" in options) {
          value = options[type + "Fn"](value, currentElement$1);
        }
        element[options[type + "Key"]] = value;
      }
      if (options.addParent) {
        element[options.parentKey] = currentElement$1;
      }
      currentElement$1[options.elementsKey].push(element);
    }
  }
  function manipulateAttributes(attributes) {
    if ("attributesFn" in options && attributes) {
      attributes = options.attributesFn(attributes, currentElement$1);
    }
    if ((options.trim || "attributeValueFn" in options || "attributeNameFn" in options || options.nativeTypeAttributes) && attributes) {
      var key;
      for (key in attributes) {
        if (attributes.hasOwnProperty(key)) {
          if (options.trim)
            attributes[key] = attributes[key].trim();
          if (options.nativeTypeAttributes) {
            attributes[key] = nativeType(attributes[key]);
          }
          if ("attributeValueFn" in options)
            attributes[key] = options.attributeValueFn(attributes[key], key, currentElement$1);
          if ("attributeNameFn" in options) {
            var temp = attributes[key];
            delete attributes[key];
            attributes[options.attributeNameFn(key, attributes[key], currentElement$1)] = temp;
          }
        }
      }
    }
    return attributes;
  }
  function onInstruction(instruction) {
    var attributes = {};
    if (instruction.body && (instruction.name.toLowerCase() === "xml" || options.instructionHasAttributes)) {
      var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
      var match;
      while ((match = attrsRegExp.exec(instruction.body)) !== null) {
        attributes[match[1]] = match[2] || match[3] || match[4];
      }
      attributes = manipulateAttributes(attributes);
    }
    if (instruction.name.toLowerCase() === "xml") {
      if (options.ignoreDeclaration) {
        return;
      }
      currentElement$1[options.declarationKey] = {};
      if (Object.keys(attributes).length) {
        currentElement$1[options.declarationKey][options.attributesKey] = attributes;
      }
      if (options.addParent) {
        currentElement$1[options.declarationKey][options.parentKey] = currentElement$1;
      }
    } else {
      if (options.ignoreInstruction) {
        return;
      }
      if (options.trim) {
        instruction.body = instruction.body.trim();
      }
      var value = {};
      if (options.instructionHasAttributes && Object.keys(attributes).length) {
        value[instruction.name] = {};
        value[instruction.name][options.attributesKey] = attributes;
      } else {
        value[instruction.name] = instruction.body;
      }
      addField("instruction", value);
    }
  }
  function onStartElement(name, attributes) {
    var element;
    if (typeof name === "object") {
      attributes = name.attributes;
      name = name.name;
    }
    attributes = manipulateAttributes(attributes);
    if ("elementNameFn" in options) {
      name = options.elementNameFn(name, currentElement$1);
    }
    if (options.compact) {
      element = {};
      if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
        element[options.attributesKey] = {};
        var key;
        for (key in attributes) {
          if (attributes.hasOwnProperty(key)) {
            element[options.attributesKey][key] = attributes[key];
          }
        }
      }
      if (!(name in currentElement$1) && (isArray$4(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) {
        currentElement$1[name] = [];
      }
      if (currentElement$1[name] && !isArray$4(currentElement$1[name])) {
        currentElement$1[name] = [currentElement$1[name]];
      }
      if (isArray$4(currentElement$1[name])) {
        currentElement$1[name].push(element);
      } else {
        currentElement$1[name] = element;
      }
    } else {
      if (!currentElement$1[options.elementsKey]) {
        currentElement$1[options.elementsKey] = [];
      }
      element = {};
      element[options.typeKey] = "element";
      element[options.nameKey] = name;
      if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
        element[options.attributesKey] = attributes;
      }
      if (options.alwaysChildren) {
        element[options.elementsKey] = [];
      }
      currentElement$1[options.elementsKey].push(element);
    }
    element[options.parentKey] = currentElement$1;
    currentElement$1 = element;
  }
  function onText(text) {
    if (options.ignoreText) {
      return;
    }
    if (!text.trim() && !options.captureSpacesBetweenElements) {
      return;
    }
    if (options.trim) {
      text = text.trim();
    }
    if (options.nativeType) {
      text = nativeType(text);
    }
    if (options.sanitize) {
      text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    addField("text", text);
  }
  function onComment(comment) {
    if (options.ignoreComment) {
      return;
    }
    if (options.trim) {
      comment = comment.trim();
    }
    addField("comment", comment);
  }
  function onEndElement(name) {
    var parentElement = currentElement$1[options.parentKey];
    if (!options.addParent) {
      delete currentElement$1[options.parentKey];
    }
    currentElement$1 = parentElement;
  }
  function onCdata(cdata) {
    if (options.ignoreCdata) {
      return;
    }
    if (options.trim) {
      cdata = cdata.trim();
    }
    addField("cdata", cdata);
  }
  function onDoctype(doctype) {
    if (options.ignoreDoctype) {
      return;
    }
    doctype = doctype.replace(/^ /, "");
    if (options.trim) {
      doctype = doctype.trim();
    }
    addField("doctype", doctype);
  }
  function onError(error) {
    error.note = error;
  }
  var xml2js$2 = function(xml, userOptions) {
    var parser = sax.parser(true, {});
    var result = {};
    currentElement$1 = result;
    options = validateOptions$2(userOptions);
    {
      parser.opt = { strictEntities: true };
      parser.onopentag = onStartElement;
      parser.ontext = onText;
      parser.oncomment = onComment;
      parser.onclosetag = onEndElement;
      parser.onerror = onError;
      parser.oncdata = onCdata;
      parser.ondoctype = onDoctype;
      parser.onprocessinginstruction = onInstruction;
    }
    {
      parser.write(xml).close();
    }
    if (result[options.elementsKey]) {
      var temp = result[options.elementsKey];
      delete result[options.elementsKey];
      result[options.elementsKey] = temp;
      delete result.text;
    }
    return result;
  };
  var helper$1 = optionsHelper;
  var xml2js$1 = xml2js$2;
  function validateOptions$1(userOptions) {
    var options2 = helper$1.copyOptions(userOptions);
    helper$1.ensureSpacesExists(options2);
    return options2;
  }
  var xml2json$1 = function(xml, userOptions) {
    var options2, js, json, parentKey;
    options2 = validateOptions$1(userOptions);
    js = xml2js$1(xml, options2);
    parentKey = "compact" in options2 && options2.compact ? "_parent" : "parent";
    if ("addParent" in options2 && options2.addParent) {
      json = JSON.stringify(js, function(k, v2) {
        return k === parentKey ? "_" : v2;
      }, options2.spaces);
    } else {
      json = JSON.stringify(js, null, options2.spaces);
    }
    return json.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  };
  var helper = optionsHelper;
  var isArray$3 = arrayHelper.isArray;
  var currentElement, currentElementName;
  function validateOptions(userOptions) {
    var options2 = helper.copyOptions(userOptions);
    helper.ensureFlagExists("ignoreDeclaration", options2);
    helper.ensureFlagExists("ignoreInstruction", options2);
    helper.ensureFlagExists("ignoreAttributes", options2);
    helper.ensureFlagExists("ignoreText", options2);
    helper.ensureFlagExists("ignoreComment", options2);
    helper.ensureFlagExists("ignoreCdata", options2);
    helper.ensureFlagExists("ignoreDoctype", options2);
    helper.ensureFlagExists("compact", options2);
    helper.ensureFlagExists("indentText", options2);
    helper.ensureFlagExists("indentCdata", options2);
    helper.ensureFlagExists("indentAttributes", options2);
    helper.ensureFlagExists("indentInstruction", options2);
    helper.ensureFlagExists("fullTagEmptyElement", options2);
    helper.ensureFlagExists("noQuotesForNativeAttributes", options2);
    helper.ensureSpacesExists(options2);
    if (typeof options2.spaces === "number") {
      options2.spaces = Array(options2.spaces + 1).join(" ");
    }
    helper.ensureKeyExists("declaration", options2);
    helper.ensureKeyExists("instruction", options2);
    helper.ensureKeyExists("attributes", options2);
    helper.ensureKeyExists("text", options2);
    helper.ensureKeyExists("comment", options2);
    helper.ensureKeyExists("cdata", options2);
    helper.ensureKeyExists("doctype", options2);
    helper.ensureKeyExists("type", options2);
    helper.ensureKeyExists("name", options2);
    helper.ensureKeyExists("elements", options2);
    return options2;
  }
  function writeIndentation(options2, depth, firstLine) {
    return (!firstLine && options2.spaces ? "\n" : "") + Array(depth + 1).join(options2.spaces);
  }
  function writeAttributes(attributes, options2, depth) {
    if (options2.ignoreAttributes) {
      return "";
    }
    if ("attributesFn" in options2) {
      attributes = options2.attributesFn(attributes, currentElementName, currentElement);
    }
    var key, attr, attrName, quote, result = [];
    for (key in attributes) {
      if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== void 0) {
        quote = options2.noQuotesForNativeAttributes && typeof attributes[key] !== "string" ? "" : '"';
        attr = "" + attributes[key];
        attr = attr.replace(/"/g, "&quot;");
        attrName = "attributeNameFn" in options2 ? options2.attributeNameFn(key, attr, currentElementName, currentElement) : key;
        result.push(options2.spaces && options2.indentAttributes ? writeIndentation(options2, depth + 1, false) : " ");
        result.push(attrName + "=" + quote + ("attributeValueFn" in options2 ? options2.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
      }
    }
    if (attributes && Object.keys(attributes).length && options2.spaces && options2.indentAttributes) {
      result.push(writeIndentation(options2, depth, false));
    }
    return result.join("");
  }
  function writeDeclaration(declaration, options2, depth) {
    currentElement = declaration;
    currentElementName = "xml";
    return options2.ignoreDeclaration ? "" : "<?xml" + writeAttributes(declaration[options2.attributesKey], options2, depth) + "?>";
  }
  function writeInstruction(instruction, options2, depth) {
    if (options2.ignoreInstruction) {
      return "";
    }
    var key;
    for (key in instruction) {
      if (instruction.hasOwnProperty(key)) {
        break;
      }
    }
    var instructionName = "instructionNameFn" in options2 ? options2.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
    if (typeof instruction[key] === "object") {
      currentElement = instruction;
      currentElementName = instructionName;
      return "<?" + instructionName + writeAttributes(instruction[key][options2.attributesKey], options2, depth) + "?>";
    } else {
      var instructionValue = instruction[key] ? instruction[key] : "";
      if ("instructionFn" in options2)
        instructionValue = options2.instructionFn(instructionValue, key, currentElementName, currentElement);
      return "<?" + instructionName + (instructionValue ? " " + instructionValue : "") + "?>";
    }
  }
  function writeComment(comment, options2) {
    return options2.ignoreComment ? "" : "<!--" + ("commentFn" in options2 ? options2.commentFn(comment, currentElementName, currentElement) : comment) + "-->";
  }
  function writeCdata(cdata, options2) {
    return options2.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in options2 ? options2.cdataFn(cdata, currentElementName, currentElement) : cdata.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
  }
  function writeDoctype(doctype, options2) {
    return options2.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in options2 ? options2.doctypeFn(doctype, currentElementName, currentElement) : doctype) + ">";
  }
  function writeText(text, options2) {
    if (options2.ignoreText)
      return "";
    text = "" + text;
    text = text.replace(/&amp;/g, "&");
    text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return "textFn" in options2 ? options2.textFn(text, currentElementName, currentElement) : text;
  }
  function hasContent(element, options2) {
    var i2;
    if (element.elements && element.elements.length) {
      for (i2 = 0; i2 < element.elements.length; ++i2) {
        switch (element.elements[i2][options2.typeKey]) {
          case "text":
            if (options2.indentText) {
              return true;
            }
            break;
          case "cdata":
            if (options2.indentCdata) {
              return true;
            }
            break;
          case "instruction":
            if (options2.indentInstruction) {
              return true;
            }
            break;
          case "doctype":
          case "comment":
          case "element":
            return true;
          default:
            return true;
        }
      }
    }
    return false;
  }
  function writeElement(element, options2, depth) {
    currentElement = element;
    currentElementName = element.name;
    var xml = [], elementName = "elementNameFn" in options2 ? options2.elementNameFn(element.name, element) : element.name;
    xml.push("<" + elementName);
    if (element[options2.attributesKey]) {
      xml.push(writeAttributes(element[options2.attributesKey], options2, depth));
    }
    var withClosingTag = element[options2.elementsKey] && element[options2.elementsKey].length || element[options2.attributesKey] && element[options2.attributesKey]["xml:space"] === "preserve";
    if (!withClosingTag) {
      if ("fullTagEmptyElementFn" in options2) {
        withClosingTag = options2.fullTagEmptyElementFn(element.name, element);
      } else {
        withClosingTag = options2.fullTagEmptyElement;
      }
    }
    if (withClosingTag) {
      xml.push(">");
      if (element[options2.elementsKey] && element[options2.elementsKey].length) {
        xml.push(writeElements(element[options2.elementsKey], options2, depth + 1));
        currentElement = element;
        currentElementName = element.name;
      }
      xml.push(options2.spaces && hasContent(element, options2) ? "\n" + Array(depth + 1).join(options2.spaces) : "");
      xml.push("</" + elementName + ">");
    } else {
      xml.push("/>");
    }
    return xml.join("");
  }
  function writeElements(elements, options2, depth, firstLine) {
    return elements.reduce(function(xml, element) {
      var indent = writeIndentation(options2, depth, firstLine && !xml);
      switch (element.type) {
        case "element":
          return xml + indent + writeElement(element, options2, depth);
        case "comment":
          return xml + indent + writeComment(element[options2.commentKey], options2);
        case "doctype":
          return xml + indent + writeDoctype(element[options2.doctypeKey], options2);
        case "cdata":
          return xml + (options2.indentCdata ? indent : "") + writeCdata(element[options2.cdataKey], options2);
        case "text":
          return xml + (options2.indentText ? indent : "") + writeText(element[options2.textKey], options2);
        case "instruction":
          var instruction = {};
          instruction[element[options2.nameKey]] = element[options2.attributesKey] ? element : element[options2.instructionKey];
          return xml + (options2.indentInstruction ? indent : "") + writeInstruction(instruction, options2, depth);
      }
    }, "");
  }
  function hasContentCompact(element, options2, anyContent) {
    var key;
    for (key in element) {
      if (element.hasOwnProperty(key)) {
        switch (key) {
          case options2.parentKey:
          case options2.attributesKey:
            break;
          case options2.textKey:
            if (options2.indentText || anyContent) {
              return true;
            }
            break;
          case options2.cdataKey:
            if (options2.indentCdata || anyContent) {
              return true;
            }
            break;
          case options2.instructionKey:
            if (options2.indentInstruction || anyContent) {
              return true;
            }
            break;
          case options2.doctypeKey:
          case options2.commentKey:
            return true;
          default:
            return true;
        }
      }
    }
    return false;
  }
  function writeElementCompact(element, name, options2, depth, indent) {
    currentElement = element;
    currentElementName = name;
    var elementName = "elementNameFn" in options2 ? options2.elementNameFn(name, element) : name;
    if (typeof element === "undefined" || element === null || element === "") {
      return "fullTagEmptyElementFn" in options2 && options2.fullTagEmptyElementFn(name, element) || options2.fullTagEmptyElement ? "<" + elementName + "></" + elementName + ">" : "<" + elementName + "/>";
    }
    var xml = [];
    if (name) {
      xml.push("<" + elementName);
      if (typeof element !== "object") {
        xml.push(">" + writeText(element, options2) + "</" + elementName + ">");
        return xml.join("");
      }
      if (element[options2.attributesKey]) {
        xml.push(writeAttributes(element[options2.attributesKey], options2, depth));
      }
      var withClosingTag = hasContentCompact(element, options2, true) || element[options2.attributesKey] && element[options2.attributesKey]["xml:space"] === "preserve";
      if (!withClosingTag) {
        if ("fullTagEmptyElementFn" in options2) {
          withClosingTag = options2.fullTagEmptyElementFn(name, element);
        } else {
          withClosingTag = options2.fullTagEmptyElement;
        }
      }
      if (withClosingTag) {
        xml.push(">");
      } else {
        xml.push("/>");
        return xml.join("");
      }
    }
    xml.push(writeElementsCompact(element, options2, depth + 1, false));
    currentElement = element;
    currentElementName = name;
    if (name) {
      xml.push((indent ? writeIndentation(options2, depth, false) : "") + "</" + elementName + ">");
    }
    return xml.join("");
  }
  function writeElementsCompact(element, options2, depth, firstLine) {
    var i2, key, nodes, xml = [];
    for (key in element) {
      if (element.hasOwnProperty(key)) {
        nodes = isArray$3(element[key]) ? element[key] : [element[key]];
        for (i2 = 0; i2 < nodes.length; ++i2) {
          switch (key) {
            case options2.declarationKey:
              xml.push(writeDeclaration(nodes[i2], options2, depth));
              break;
            case options2.instructionKey:
              xml.push((options2.indentInstruction ? writeIndentation(options2, depth, firstLine) : "") + writeInstruction(nodes[i2], options2, depth));
              break;
            case options2.attributesKey:
            case options2.parentKey:
              break;
            case options2.textKey:
              xml.push((options2.indentText ? writeIndentation(options2, depth, firstLine) : "") + writeText(nodes[i2], options2));
              break;
            case options2.cdataKey:
              xml.push((options2.indentCdata ? writeIndentation(options2, depth, firstLine) : "") + writeCdata(nodes[i2], options2));
              break;
            case options2.doctypeKey:
              xml.push(writeIndentation(options2, depth, firstLine) + writeDoctype(nodes[i2], options2));
              break;
            case options2.commentKey:
              xml.push(writeIndentation(options2, depth, firstLine) + writeComment(nodes[i2], options2));
              break;
            default:
              xml.push(writeIndentation(options2, depth, firstLine) + writeElementCompact(nodes[i2], key, options2, depth, hasContentCompact(nodes[i2], options2)));
          }
          firstLine = firstLine && !xml.length;
        }
      }
    }
    return xml.join("");
  }
  var js2xml$2 = function(js, options2) {
    options2 = validateOptions(options2);
    var xml = [];
    currentElement = js;
    currentElementName = "_root_";
    if (options2.compact) {
      xml.push(writeElementsCompact(js, options2, 0, true));
    } else {
      if (js[options2.declarationKey]) {
        xml.push(writeDeclaration(js[options2.declarationKey], options2, 0));
      }
      if (js[options2.elementsKey] && js[options2.elementsKey].length) {
        xml.push(writeElements(js[options2.elementsKey], options2, 0, !xml.length));
      }
    }
    return xml.join("");
  };
  var js2xml$1 = js2xml$2;
  var json2xml$1 = function(json, options2) {
    if (json instanceof Buffer) {
      json = json.toString();
    }
    var js = null;
    if (typeof json === "string") {
      try {
        js = JSON.parse(json);
      } catch (e) {
        throw new Error("The JSON structure is invalid");
      }
    } else {
      js = json;
    }
    return js2xml$1(js, options2);
  };
  var xml2js = xml2js$2;
  var xml2json = xml2json$1;
  var js2xml = js2xml$2;
  var json2xml = json2xml$1;
  var lib = {
    xml2js,
    xml2json,
    js2xml,
    json2xml
  };
  function normalizeArray(parts, allowAboveRoot) {
    var up = 0;
    for (var i2 = parts.length - 1; i2 >= 0; i2--) {
      var last2 = parts[i2];
      if (last2 === ".") {
        parts.splice(i2, 1);
      } else if (last2 === "..") {
        parts.splice(i2, 1);
        up++;
      } else if (up) {
        parts.splice(i2, 1);
        up--;
      }
    }
    if (allowAboveRoot) {
      for (; up--; up) {
        parts.unshift("..");
      }
    }
    return parts;
  }
  var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var splitPath = function(filename) {
    return splitPathRe.exec(filename).slice(1);
  };
  function resolve() {
    var resolvedPath = "", resolvedAbsolute = false;
    for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
      var path2 = i2 >= 0 ? arguments[i2] : "/";
      if (typeof path2 !== "string") {
        throw new TypeError("Arguments to path.resolve must be strings");
      } else if (!path2) {
        continue;
      }
      resolvedPath = path2 + "/" + resolvedPath;
      resolvedAbsolute = path2.charAt(0) === "/";
    }
    resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
      return !!p;
    }), !resolvedAbsolute).join("/");
    return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
  }
  function normalize(path2) {
    var isPathAbsolute = isAbsolute(path2), trailingSlash = substr(path2, -1) === "/";
    path2 = normalizeArray(filter(path2.split("/"), function(p) {
      return !!p;
    }), !isPathAbsolute).join("/");
    if (!path2 && !isPathAbsolute) {
      path2 = ".";
    }
    if (path2 && trailingSlash) {
      path2 += "/";
    }
    return (isPathAbsolute ? "/" : "") + path2;
  }
  function isAbsolute(path2) {
    return path2.charAt(0) === "/";
  }
  function join() {
    var paths = Array.prototype.slice.call(arguments, 0);
    return normalize(filter(paths, function(p, index2) {
      if (typeof p !== "string") {
        throw new TypeError("Arguments to path.join must be strings");
      }
      return p;
    }).join("/"));
  }
  function relative(from2, to) {
    from2 = resolve(from2).substr(1);
    to = resolve(to).substr(1);
    function trim2(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== "")
          break;
      }
      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== "")
          break;
      }
      if (start > end)
        return [];
      return arr.slice(start, end - start + 1);
    }
    var fromParts = trim2(from2.split("/"));
    var toParts = trim2(to.split("/"));
    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i2 = 0; i2 < length; i2++) {
      if (fromParts[i2] !== toParts[i2]) {
        samePartsLength = i2;
        break;
      }
    }
    var outputParts = [];
    for (var i2 = samePartsLength; i2 < fromParts.length; i2++) {
      outputParts.push("..");
    }
    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join("/");
  }
  var sep = "/";
  var delimiter = ":";
  function dirname(path2) {
    var result = splitPath(path2), root = result[0], dir = result[1];
    if (!root && !dir) {
      return ".";
    }
    if (dir) {
      dir = dir.substr(0, dir.length - 1);
    }
    return root + dir;
  }
  function basename(path2, ext2) {
    var f = splitPath(path2)[2];
    if (ext2 && f.substr(-1 * ext2.length) === ext2) {
      f = f.substr(0, f.length - ext2.length);
    }
    return f;
  }
  function extname(path2) {
    return splitPath(path2)[3];
  }
  const path = {
    extname,
    basename,
    dirname,
    sep,
    delimiter,
    relative,
    join,
    isAbsolute,
    normalize,
    resolve
  };
  function filter(xs, f) {
    if (xs.filter)
      return xs.filter(f);
    var res = [];
    for (var i2 = 0; i2 < xs.length; i2++) {
      if (f(xs[i2], i2, xs))
        res.push(xs[i2]);
    }
    return res;
  }
  var substr = "ab".substr(-1) === "b" ? function(str2, start, len) {
    return str2.substr(start, len);
  } : function(str2, start, len) {
    if (start < 0)
      start = str2.length + start;
    return str2.substr(start, len);
  };
  class TiledParser {
    constructor(xml, filePath = "") {
      this.xml = xml;
      this.filePath = filePath;
      this.layers = /* @__PURE__ */ new Map();
      this.transform = (obj) => {
        var _a, _b;
        if (!obj)
          return;
        const attr = obj.attributes || obj._attributes;
        if (!attr)
          return obj;
        let newObj = {
          ...obj,
          ...attr,
          ...TiledParser.propToNumber(attr, ["version", "width", "height", "tilewidth", "tileheight", "nextlayerid", "nextobjectid", "hexsidelength", "opacity", "x", "y", "offsetx", "offsety", "startx", "starty", "id", "firstgid", "imageheight", "imagewidth", "margin", "columns", "rows", "tilecount", "rotation", "gid", "tileid", "duration", "parallaxx", "parallaxy", "repeatx", "repeaty", "pixelsize"]),
          ...TiledParser.propToBool(attr, ["visible", "infinite", "locked", "bold", "italic", "kerning", "strikeout", "underline", "wrap"])
        };
        if (newObj.properties) {
          const properties = TiledParser.toArray(newObj.properties.property);
          const propObj = {};
          for (let prop of properties) {
            const attr2 = prop._attributes;
            if (!attr2)
              continue;
            let val;
            switch (attr2.type) {
              case "file":
                val = this.getImagePath(attr2.value);
                break;
              case "object":
              case "float":
              case "int":
                val = +attr2.value;
                break;
              case "bool":
                val = attr2.value == "true" ? true : false;
                break;
              case "class":
                val = {
                  ...((_a = this.transform(prop)) == null ? void 0 : _a.properties) ?? {},
                  _classname: attr2.propertytype
                };
                break;
              default:
                val = attr2.value;
            }
            propObj[attr2.name] = val;
          }
          newObj.properties = propObj;
        }
        if (newObj.polygon) {
          newObj.polygon = this.transform(newObj.polygon);
        }
        if (newObj.polyline) {
          newObj.polyline = this.transform(newObj.polyline);
        }
        if (newObj.points) {
          newObj = newObj.points.split(" ").map((point) => {
            const pos = point.split(",");
            return {
              x: +pos[0],
              y: +pos[1]
            };
          });
        }
        if (newObj.point) {
          newObj.point = true;
        }
        if (newObj.ellipse) {
          newObj.ellipse = true;
        }
        if (newObj.text) {
          newObj.text = {
            text: newObj.text._text,
            ...this.transform(newObj.text)
          };
          delete newObj.text._text;
        }
        if (newObj.image) {
          newObj.image = this.transform(newObj.image);
        }
        if (newObj.source) {
          newObj.source = this.getImagePath(newObj.source);
        }
        const objectgroup = newObj.object || ((_b = newObj.objectgroup) == null ? void 0 : _b.object);
        if (objectgroup) {
          newObj.objects = TiledParser.toArray(objectgroup).map((object) => {
            return this.transform(object);
          });
        }
        delete newObj._attributes;
        delete newObj.attributes;
        delete newObj.object;
        delete newObj.objectgroup;
        return newObj;
      };
    }
    static toArray(prop) {
      if (!prop)
        return [];
      if (!Array.isArray(prop))
        return [prop];
      return prop;
    }
    getImagePath(image) {
      const baseName = path.dirname(this.filePath);
      if (this.filePath.startsWith("http"))
        return new URL(image, this.filePath).href;
      return path.join(baseName, image);
    }
    static unpackTileBytes(buffer, size) {
      const expectedCount = size * 4;
      if (buffer.length !== expectedCount) {
        throw new Error("Expected " + expectedCount + " bytes of tile data; received " + buffer.length);
      }
      let tileIndex = 0;
      const array2 = [];
      for (let i2 = 0; i2 < expectedCount; i2 += 4) {
        array2[tileIndex] = buffer.readUInt32LE(i2);
        tileIndex++;
      }
      return array2;
    }
    static decode(obj, size) {
      const {
        encoding,
        data
      } = obj;
      if (encoding == "base64") {
        return TiledParser.unpackTileBytes(Buffer$2.from(data.trim(), "base64"), size);
      } else if (encoding == "csv") {
        return data.trim().split(",").map((x) => +x);
      }
      return data;
    }
    parseMap() {
      const json = lib.xml2js(this.xml, {
        compact: true
      });
      const jsonNoCompact = lib.xml2js(this.xml);
      const tileset = json.map.tileset;
      json.map.group;
      const recursiveObjectGroup = (obj) => {
        const {
          objectgroup,
          group,
          layer,
          imagelayer
        } = obj;
        const setLayer = (type) => {
          if (!type)
            return;
          TiledParser.toArray(type).forEach((val) => {
            if (this.layers.has(+val._attributes.id)) {
              throw new Error(`Tiled Parser Error: Layer with id ${val._attributes.id} already exists`);
            }
            this.layers.set(+val._attributes.id, val);
          });
        };
        setLayer(objectgroup);
        setLayer(layer);
        setLayer(group);
        setLayer(imagelayer);
        if (group) {
          recursiveObjectGroup(group);
        }
      };
      recursiveObjectGroup(json.map);
      const recursiveLayer = (elements, array2 = []) => {
        var _a;
        if (!elements)
          return array2;
        for (let element of elements) {
          const {
            name
          } = element;
          if (!["layer", "group", "imagelayer", "objectgroup"].includes(name))
            continue;
          const data = (_a = element.elements) == null ? void 0 : _a.find((el) => el.name == "data");
          element.layer = this.layers.get(+element.attributes.id);
          const obj = {
            ...this.transform(data) ?? {},
            ...this.transform(element),
            ...this.transform(element.layer),
            layers: recursiveLayer(element.elements),
            data: data ? data.elements[0].text : void 0,
            type: name == "layer" ? "tilelayer" : name
          };
          delete obj.elements;
          delete obj.layer;
          if (obj.data)
            obj.data = TiledParser.decode(obj, obj.width * obj.height);
          array2.push(obj);
        }
        return array2;
      };
      const layers = recursiveLayer(jsonNoCompact.elements[0].elements);
      const tilesets = TiledParser.toArray(tileset).map((tileset2) => {
        const obj = this.transform(tileset2);
        return obj;
      });
      const ret = {
        ...this.transform(json.map),
        layers,
        tilesets
      };
      delete ret.layer;
      delete ret.tileset;
      delete ret.group;
      delete ret.imagelayer;
      return ret;
    }
    parseTileset() {
      const json = lib.xml2js(this.xml, {
        compact: true
      });
      const {
        tileset
      } = json;
      const ret = {
        ...this.transform(tileset),
        image: this.transform(tileset.image),
        tiles: TiledParser.toArray(tileset.tile).map((tile) => {
          const ret2 = this.transform(tile);
          if (tile.animation) {
            ret2.animations = TiledParser.toArray(tile.animation.frame).map(this.transform);
          }
          delete ret2.animation;
          return ret2;
        })
      };
      delete ret.tile;
      return ret;
    }
  }
  TiledParser.propToNumber = (obj, props) => {
    for (let key of props) {
      if (obj[key] !== void 0) {
        obj[key] = +obj[key];
      }
    }
    return obj;
  };
  TiledParser.propToBool = (obj, props) => {
    for (let key of props) {
      if (obj[key] !== void 0) {
        obj[key] = obj[key] == "true" || obj[key] == "1";
      }
    }
    return obj;
  };
  function bind$2(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }
  const { toString: toString$1 } = Object.prototype;
  const { getPrototypeOf: getPrototypeOf$1 } = Object;
  const kindOf$1 = ((cache) => (thing) => {
    const str2 = toString$1.call(thing);
    return cache[str2] || (cache[str2] = str2.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  const kindOfTest$1 = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf$1(thing) === type;
  };
  const typeOfTest$1 = (type) => (thing) => typeof thing === type;
  const { isArray: isArray$2 } = Array;
  const isUndefined$1 = typeOfTest$1("undefined");
  function isBuffer$1(val) {
    return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && isFunction$3(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  const isArrayBuffer$1 = kindOfTest$1("ArrayBuffer");
  function isArrayBufferView$1(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer$1(val.buffer);
    }
    return result;
  }
  const isString$8 = typeOfTest$1("string");
  const isFunction$3 = typeOfTest$1("function");
  const isNumber$1 = typeOfTest$1("number");
  const isObject$1 = (thing) => thing !== null && typeof thing === "object";
  const isBoolean$1 = (thing) => thing === true || thing === false;
  const isPlainObject$1 = (val) => {
    if (kindOf$1(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf$1(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
  };
  const isDate$1 = kindOfTest$1("Date");
  const isFile$1 = kindOfTest$1("File");
  const isBlob$1 = kindOfTest$1("Blob");
  const isFileList$1 = kindOfTest$1("FileList");
  const isStream$1 = (val) => isObject$1(val) && isFunction$3(val.pipe);
  const isFormData$1 = (thing) => {
    const pattern = "[object FormData]";
    return thing && (typeof FormData === "function" && thing instanceof FormData || toString$1.call(thing) === pattern || isFunction$3(thing.toString) && thing.toString() === pattern);
  };
  const isURLSearchParams$1 = kindOfTest$1("URLSearchParams");
  const trim$1 = (str2) => str2.trim ? str2.trim() : str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach$1(obj, fn, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i2;
    let l;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray$2(obj)) {
      for (i2 = 0, l = obj.length; i2 < l; i2++) {
        fn.call(null, obj[i2], i2, obj);
      }
    } else {
      const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys2.length;
      let key;
      for (i2 = 0; i2 < len; i2++) {
        key = keys2[i2];
        fn.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey$1(obj, key) {
    key = key.toLowerCase();
    const keys2 = Object.keys(obj);
    let i2 = keys2.length;
    let _key;
    while (i2-- > 0) {
      _key = keys2[i2];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  const _global$1 = (() => {
    if (typeof globalThis !== "undefined")
      return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  })();
  const isContextDefined$1 = (context) => !isUndefined$1(context) && context !== _global$1;
  function merge$1() {
    const { caseless } = isContextDefined$1(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey$1(result, key) || key;
      if (isPlainObject$1(result[targetKey]) && isPlainObject$1(val)) {
        result[targetKey] = merge$1(result[targetKey], val);
      } else if (isPlainObject$1(val)) {
        result[targetKey] = merge$1({}, val);
      } else if (isArray$2(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i2 = 0, l = arguments.length; i2 < l; i2++) {
      arguments[i2] && forEach$1(arguments[i2], assignValue);
    }
    return result;
  }
  const extend$1 = (a, b, thisArg, { allOwnKeys } = {}) => {
    forEach$1(b, (val, key) => {
      if (thisArg && isFunction$3(val)) {
        a[key] = bind$2(val, thisArg);
      } else {
        a[key] = val;
      }
    }, { allOwnKeys });
    return a;
  };
  const stripBOM$1 = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  const inherits$1 = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  const toFlatObject$1 = (sourceObj, destObj, filter2, propFilter) => {
    let props;
    let i2;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null)
      return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i2 = props.length;
      while (i2-- > 0) {
        prop = props[i2];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter2 !== false && getPrototypeOf$1(sourceObj);
    } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  const endsWith$1 = (str2, searchString, position) => {
    str2 = String(str2);
    if (position === void 0 || position > str2.length) {
      position = str2.length;
    }
    position -= searchString.length;
    const lastIndex = str2.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
  const toArray$1 = (thing) => {
    if (!thing)
      return null;
    if (isArray$2(thing))
      return thing;
    let i2 = thing.length;
    if (!isNumber$1(i2))
      return null;
    const arr = new Array(i2);
    while (i2-- > 0) {
      arr[i2] = thing[i2];
    }
    return arr;
  };
  const isTypedArray$1 = ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf$1(Uint8Array));
  const forEachEntry$1 = (obj, fn) => {
    const generator = obj && obj[Symbol.iterator];
    const iterator2 = generator.call(obj);
    let result;
    while ((result = iterator2.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };
  const matchAll$1 = (regExp, str2) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str2)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  const isHTMLForm$1 = kindOfTest$1("HTMLFormElement");
  const toCamelCase$1 = (str2) => {
    return str2.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  const hasOwnProperty$1 = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
  const isRegExp$1 = kindOfTest$1("RegExp");
  const reduceDescriptors$1 = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach$1(descriptors2, (descriptor, name) => {
      if (reducer(descriptor, name, obj) !== false) {
        reducedDescriptors[name] = descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  const freezeMethods$1 = (obj) => {
    reduceDescriptors$1(obj, (descriptor, name) => {
      if (isFunction$3(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj[name];
      if (!isFunction$3(value))
        return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  const toObjectSet$1 = (arrayOrString, delimiter2) => {
    const obj = {};
    const define2 = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray$2(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter2));
    return obj;
  };
  const noop$2 = () => {
  };
  const toFiniteNumber$1 = (value, defaultValue) => {
    value = +value;
    return Number.isFinite(value) ? value : defaultValue;
  };
  const ALPHA$1 = "abcdefghijklmnopqrstuvwxyz";
  const DIGIT$1 = "0123456789";
  const ALPHABET$1 = {
    DIGIT: DIGIT$1,
    ALPHA: ALPHA$1,
    ALPHA_DIGIT: ALPHA$1 + ALPHA$1.toUpperCase() + DIGIT$1
  };
  const generateString$1 = (size = 16, alphabet = ALPHABET$1.ALPHA_DIGIT) => {
    let str2 = "";
    const { length } = alphabet;
    while (size--) {
      str2 += alphabet[Math.random() * length | 0];
    }
    return str2;
  };
  function isSpecCompliantForm$1(thing) {
    return !!(thing && isFunction$3(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
  }
  const toJSONObject$1 = (obj) => {
    const stack = new Array(10);
    const visit = (source, i2) => {
      if (isObject$1(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (!("toJSON" in source)) {
          stack[i2] = source;
          const target = isArray$2(source) ? [] : {};
          forEach$1(source, (value, key) => {
            const reducedValue = visit(value, i2 + 1);
            !isUndefined$1(reducedValue) && (target[key] = reducedValue);
          });
          stack[i2] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit(obj, 0);
  };
  const utils$1 = {
    isArray: isArray$2,
    isArrayBuffer: isArrayBuffer$1,
    isBuffer: isBuffer$1,
    isFormData: isFormData$1,
    isArrayBufferView: isArrayBufferView$1,
    isString: isString$8,
    isNumber: isNumber$1,
    isBoolean: isBoolean$1,
    isObject: isObject$1,
    isPlainObject: isPlainObject$1,
    isUndefined: isUndefined$1,
    isDate: isDate$1,
    isFile: isFile$1,
    isBlob: isBlob$1,
    isRegExp: isRegExp$1,
    isFunction: isFunction$3,
    isStream: isStream$1,
    isURLSearchParams: isURLSearchParams$1,
    isTypedArray: isTypedArray$1,
    isFileList: isFileList$1,
    forEach: forEach$1,
    merge: merge$1,
    extend: extend$1,
    trim: trim$1,
    stripBOM: stripBOM$1,
    inherits: inherits$1,
    toFlatObject: toFlatObject$1,
    kindOf: kindOf$1,
    kindOfTest: kindOfTest$1,
    endsWith: endsWith$1,
    toArray: toArray$1,
    forEachEntry: forEachEntry$1,
    matchAll: matchAll$1,
    isHTMLForm: isHTMLForm$1,
    hasOwnProperty: hasOwnProperty$1,
    hasOwnProp: hasOwnProperty$1,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors: reduceDescriptors$1,
    freezeMethods: freezeMethods$1,
    toObjectSet: toObjectSet$1,
    toCamelCase: toCamelCase$1,
    noop: noop$2,
    toFiniteNumber: toFiniteNumber$1,
    findKey: findKey$1,
    global: _global$1,
    isContextDefined: isContextDefined$1,
    ALPHABET: ALPHABET$1,
    generateString: generateString$1,
    isSpecCompliantForm: isSpecCompliantForm$1,
    toJSONObject: toJSONObject$1
  };
  function AxiosError$1(message, code, config2, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config2 && (this.config = config2);
    request && (this.request = request);
    response && (this.response = response);
  }
  utils$1.inherits(AxiosError$1, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$1.toJSONObject(this.config),
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }
  });
  const prototype$3 = AxiosError$1.prototype;
  const descriptors$1 = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code) => {
    descriptors$1[code] = { value: code };
  });
  Object.defineProperties(AxiosError$1, descriptors$1);
  Object.defineProperty(prototype$3, "isAxiosError", { value: true });
  AxiosError$1.from = (error, code, config2, request, response, customProps) => {
    const axiosError = Object.create(prototype$3);
    utils$1.toFlatObject(error, axiosError, function filter2(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError$1.call(axiosError, error.message, code, config2, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  const httpAdapter$1 = null;
  function isVisitable$1(thing) {
    return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
  }
  function removeBrackets$1(key) {
    return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey$1(path2, key, dots) {
    if (!path2)
      return key;
    return path2.concat(key).map(function each(token, i2) {
      token = removeBrackets$1(token);
      return !dots && i2 ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray$1(arr) {
    return utils$1.isArray(arr) && !arr.some(isVisitable$1);
  }
  const predicates$1 = utils$1.toFlatObject(utils$1, {}, null, function filter2(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData$1(obj, formData, options2) {
    if (!utils$1.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new FormData();
    options2 = utils$1.toFlatObject(options2, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils$1.isUndefined(source[option]);
    });
    const metaTokens = options2.metaTokens;
    const visitor = options2.visitor || defaultVisitor;
    const dots = options2.dots;
    const indexes = options2.indexes;
    const _Blob = options2.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
    if (!utils$1.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null)
        return "";
      if (utils$1.isDate(value)) {
        return value.toISOString();
      }
      if (!useBlob && utils$1.isBlob(value)) {
        throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
      }
      if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key, path2) {
      let arr = value;
      if (value && !path2 && typeof value === "object") {
        if (utils$1.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils$1.isArray(value) && isFlatArray$1(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
          key = removeBrackets$1(key);
          arr.forEach(function each(el, index2) {
            !(utils$1.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey$1([key], index2, dots) : indexes === null ? key : key + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable$1(value)) {
        return true;
      }
      formData.append(renderKey$1(path2, key, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates$1, {
      defaultVisitor,
      convertValue,
      isVisitable: isVisitable$1
    });
    function build(value, path2) {
      if (utils$1.isUndefined(value))
        return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path2.join("."));
      }
      stack.push(value);
      utils$1.forEach(value, function each(el, key) {
        const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils$1.isString(key) ? key.trim() : key,
          path2,
          exposedHelpers
        );
        if (result === true) {
          build(el, path2 ? path2.concat(key) : [key]);
        }
      });
      stack.pop();
    }
    if (!utils$1.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  function encode$3(str2) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str2).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams$1(params, options2) {
    this._pairs = [];
    params && toFormData$1(params, this, options2);
  }
  const prototype$2 = AxiosURLSearchParams$1.prototype;
  prototype$2.append = function append(name, value) {
    this._pairs.push([name, value]);
  };
  prototype$2.toString = function toString2(encoder2) {
    const _encode = encoder2 ? function(value) {
      return encoder2.call(this, value, encode$3);
    } : encode$3;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode$2(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL$1(url, params, options2) {
    if (!params) {
      return url;
    }
    const _encode = options2 && options2.encode || encode$2;
    const serializeFn = options2 && options2.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options2);
    } else {
      serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams$1(params, options2).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  }
  let InterceptorManager$2 = class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options2) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options2 ? options2.synchronous : false,
        runWhen: options2 ? options2.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils$1.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    }
  };
  const InterceptorManager$3 = InterceptorManager$2;
  const transitionalDefaults$1 = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  const URLSearchParams$2 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams$1;
  const FormData$2 = typeof FormData !== "undefined" ? FormData : null;
  const Blob$2 = typeof Blob !== "undefined" ? Blob : null;
  const isStandardBrowserEnv$1 = (() => {
    let product;
    if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  })();
  const isStandardBrowserWebWorkerEnv$1 = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  const platform$1 = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$2,
      FormData: FormData$2,
      Blob: Blob$2
    },
    isStandardBrowserEnv: isStandardBrowserEnv$1,
    isStandardBrowserWebWorkerEnv: isStandardBrowserWebWorkerEnv$1,
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };
  function toURLEncodedForm$1(data, options2) {
    return toFormData$1(data, new platform$1.classes.URLSearchParams(), Object.assign({
      visitor: function(value, key, path2, helpers) {
        if (platform$1.isNode && utils$1.isBuffer(value)) {
          this.append(key, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options2));
  }
  function parsePropPath$1(name) {
    return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject$1(arr) {
    const obj = {};
    const keys2 = Object.keys(arr);
    let i2;
    const len = keys2.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys2[i2];
      obj[key] = arr[key];
    }
    return obj;
  }
  function formDataToJSON$1(formData) {
    function buildPath(path2, value, target, index2) {
      let name = path2[index2++];
      const isNumericKey = Number.isFinite(+name);
      const isLast = index2 >= path2.length;
      name = !name && utils$1.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils$1.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils$1.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path2, value, target[name], index2);
      if (result && utils$1.isArray(target[name])) {
        target[name] = arrayToObject$1(target[name]);
      }
      return !isNumericKey;
    }
    if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
      const obj = {};
      utils$1.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath$1(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  const DEFAULT_CONTENT_TYPE$1 = {
    "Content-Type": void 0
  };
  function stringifySafely$1(rawValue, parser, encoder2) {
    if (utils$1.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$1.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder2 || JSON.stringify)(rawValue);
  }
  const defaults$2 = {
    transitional: transitionalDefaults$1,
    adapter: ["xhr", "http"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils$1.isObject(data);
      if (isObjectPayload && utils$1.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils$1.isFormData(data);
      if (isFormData2) {
        if (!hasJSONContentType) {
          return data;
        }
        return hasJSONContentType ? JSON.stringify(formDataToJSON$1(data)) : data;
      }
      if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
        return data;
      }
      if (utils$1.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$1.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm$1(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData$1(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely$1(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults$2.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform$1.classes.FormData,
      Blob: platform$1.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    }
  };
  utils$1.forEach(["delete", "get", "head"], function forEachMethodNoData(method2) {
    defaults$2.headers[method2] = {};
  });
  utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method2) {
    defaults$2.headers[method2] = utils$1.merge(DEFAULT_CONTENT_TYPE$1);
  });
  const defaults$3 = defaults$2;
  const ignoreDuplicateOf$1 = utils$1.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  const parseHeaders$1 = (rawHeaders) => {
    const parsed = {};
    let key;
    let val;
    let i2;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
      i2 = line.indexOf(":");
      key = line.substring(0, i2).trim().toLowerCase();
      val = line.substring(i2 + 1).trim();
      if (!key || parsed[key] && ignoreDuplicateOf$1[key]) {
        return;
      }
      if (key === "set-cookie") {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    });
    return parsed;
  };
  const $internals$1 = Symbol("internals");
  function normalizeHeader$1(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue$1(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils$1.isArray(value) ? value.map(normalizeValue$1) : String(value);
  }
  function parseTokens$1(str2) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str2)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  function isValidHeaderName$1(str2) {
    return /^[-_a-zA-Z]+$/.test(str2.trim());
  }
  function matchHeaderValue$1(context, value, header, filter2, isHeaderNameFilter) {
    if (utils$1.isFunction(filter2)) {
      return filter2.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils$1.isString(value))
      return;
    if (utils$1.isString(filter2)) {
      return value.indexOf(filter2) !== -1;
    }
    if (utils$1.isRegExp(filter2)) {
      return filter2.test(value);
    }
  }
  function formatHeader$1(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str2) => {
      return char.toUpperCase() + str2;
    });
  }
  function buildAccessors$1(obj, header) {
    const accessorName = utils$1.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  let AxiosHeaders$2 = class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader$1(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key = utils$1.findKey(self2, lHeader);
        if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
          self2[key || _header] = normalizeValue$1(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName$1(header)) {
        setHeaders(parseHeaders$1(header), valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser) {
      header = normalizeHeader$1(header);
      if (header) {
        const key = utils$1.findKey(this, header);
        if (key) {
          const value = this[key];
          if (!parser) {
            return value;
          }
          if (parser === true) {
            return parseTokens$1(value);
          }
          if (utils$1.isFunction(parser)) {
            return parser.call(this, value, key);
          }
          if (utils$1.isRegExp(parser)) {
            return parser.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader$1(header);
      if (header) {
        const key = utils$1.findKey(this, header);
        return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue$1(this, this[key], key, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader$1(_header);
        if (_header) {
          const key = utils$1.findKey(self2, _header);
          if (key && (!matcher || matchHeaderValue$1(self2, self2[key], key, matcher))) {
            delete self2[key];
            deleted = true;
          }
        }
      }
      if (utils$1.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys2 = Object.keys(this);
      let i2 = keys2.length;
      let deleted = false;
      while (i2--) {
        const key = keys2[i2];
        if (!matcher || matchHeaderValue$1(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format2) {
      const self2 = this;
      const headers = {};
      utils$1.forEach(this, (value, header) => {
        const key = utils$1.findKey(headers, header);
        if (key) {
          self2[key] = normalizeValue$1(value);
          delete self2[header];
          return;
        }
        const normalized = format2 ? formatHeader$1(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue$1(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils$1.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header) {
      const internals = this[$internals$1] = this[$internals$1] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader$1(_header);
        if (!accessors[lHeader]) {
          buildAccessors$1(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  };
  AxiosHeaders$2.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils$1.freezeMethods(AxiosHeaders$2.prototype);
  utils$1.freezeMethods(AxiosHeaders$2);
  const AxiosHeaders$3 = AxiosHeaders$2;
  function transformData$1(fns, response) {
    const config2 = this || defaults$3;
    const context = response || config2;
    const headers = AxiosHeaders$3.from(context.headers);
    let data = context.data;
    utils$1.forEach(fns, function transform(fn) {
      data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  function isCancel$1(value) {
    return !!(value && value.__CANCEL__);
  }
  function CanceledError$1(message, config2, request) {
    AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config2, request);
    this.name = "CanceledError";
  }
  utils$1.inherits(CanceledError$1, AxiosError$1, {
    __CANCEL__: true
  });
  function settle$1(resolve2, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve2(response);
    } else {
      reject(new AxiosError$1(
        "Request failed with status code " + response.status,
        [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  const cookies$1 = platform$1.isStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    function standardBrowserEnv() {
      return {
        write: function write3(name, value, expires, path2, domain2, secure) {
          const cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils$1.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils$1.isString(path2)) {
            cookie.push("path=" + path2);
          }
          if (utils$1.isString(domain2)) {
            cookie.push("domain=" + domain2);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read2(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return {
        write: function write3() {
        },
        read: function read2() {
          return null;
        },
        remove: function remove() {
        }
      };
    }()
  );
  function isAbsoluteURL$1(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }
  function combineURLs$1(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath$1(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL$1(requestedURL)) {
      return combineURLs$1(baseURL, requestedURL);
    }
    return requestedURL;
  }
  const isURLSameOrigin$1 = platform$1.isStandardBrowserEnv ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv() {
      const msie = /(msie|trident)/i.test(navigator.userAgent);
      const urlParsingNode = document.createElement("a");
      let originURL;
      function resolveURL(url) {
        let href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return function isURLSameOrigin2() {
        return true;
      };
    }()
  );
  function parseProtocol$1(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  }
  function speedometer$1(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== void 0 ? min : 1e3;
    return function push2(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i2 = tail;
      let bytesCount = 0;
      while (i2 !== head) {
        bytesCount += bytes[i2++];
        i2 = i2 % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  function progressEventReducer$1(listener, isDownloadStream) {
    let bytesNotified = 0;
    const _speedometer = speedometer$1(50, 250);
    return (e) => {
      const loaded = e.loaded;
      const total = e.lengthComputable ? e.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e
      };
      data[isDownloadStream ? "download" : "upload"] = true;
      listener(data);
    };
  }
  const isXHRAdapterSupported$1 = typeof XMLHttpRequest !== "undefined";
  const xhrAdapter$1 = isXHRAdapterSupported$1 && function(config2) {
    return new Promise(function dispatchXhrRequest(resolve2, reject) {
      let requestData = config2.data;
      const requestHeaders = AxiosHeaders$3.from(config2.headers).normalize();
      const responseType = config2.responseType;
      let onCanceled;
      function done2() {
        if (config2.cancelToken) {
          config2.cancelToken.unsubscribe(onCanceled);
        }
        if (config2.signal) {
          config2.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils$1.isFormData(requestData) && (platform$1.isStandardBrowserEnv || platform$1.isStandardBrowserWebWorkerEnv)) {
        requestHeaders.setContentType(false);
      }
      let request = new XMLHttpRequest();
      if (config2.auth) {
        const username = config2.auth.username || "";
        const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
        requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
      }
      const fullPath = buildFullPath$1(config2.baseURL, config2.url);
      request.open(config2.method.toUpperCase(), buildURL$1(fullPath, config2.params, config2.paramsSerializer), true);
      request.timeout = config2.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders$3.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config2,
          request
        };
        settle$1(function _resolve(value) {
          resolve2(value);
          done2();
        }, function _reject(err) {
          reject(err);
          done2();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config2, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config2, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = config2.transitional || transitionalDefaults$1;
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        reject(new AxiosError$1(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
          config2,
          request
        ));
        request = null;
      };
      if (platform$1.isStandardBrowserEnv) {
        const xsrfValue = (config2.withCredentials || isURLSameOrigin$1(fullPath)) && config2.xsrfCookieName && cookies$1.read(config2.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config2.xsrfHeaderName, xsrfValue);
        }
      }
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }
      if (!utils$1.isUndefined(config2.withCredentials)) {
        request.withCredentials = !!config2.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = config2.responseType;
      }
      if (typeof config2.onDownloadProgress === "function") {
        request.addEventListener("progress", progressEventReducer$1(config2.onDownloadProgress, true));
      }
      if (typeof config2.onUploadProgress === "function" && request.upload) {
        request.upload.addEventListener("progress", progressEventReducer$1(config2.onUploadProgress));
      }
      if (config2.cancelToken || config2.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError$1(null, config2, request) : cancel);
          request.abort();
          request = null;
        };
        config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
        if (config2.signal) {
          config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol$1(fullPath);
      if (protocol && platform$1.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config2));
        return;
      }
      request.send(requestData || null);
    });
  };
  const knownAdapters$1 = {
    http: httpAdapter$1,
    xhr: xhrAdapter$1
  };
  utils$1.forEach(knownAdapters$1, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e) {
      }
      Object.defineProperty(fn, "adapterName", { value });
    }
  });
  const adapters$1 = {
    getAdapter: (adapters2) => {
      adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
      const { length } = adapters2;
      let nameOrAdapter;
      let adapter;
      for (let i2 = 0; i2 < length; i2++) {
        nameOrAdapter = adapters2[i2];
        if (adapter = utils$1.isString(nameOrAdapter) ? knownAdapters$1[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
          break;
        }
      }
      if (!adapter) {
        if (adapter === false) {
          throw new AxiosError$1(
            `Adapter ${nameOrAdapter} is not supported by the environment`,
            "ERR_NOT_SUPPORT"
          );
        }
        throw new Error(
          utils$1.hasOwnProp(knownAdapters$1, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
        );
      }
      if (!utils$1.isFunction(adapter)) {
        throw new TypeError("adapter is not a function");
      }
      return adapter;
    },
    adapters: knownAdapters$1
  };
  function throwIfCancellationRequested$1(config2) {
    if (config2.cancelToken) {
      config2.cancelToken.throwIfRequested();
    }
    if (config2.signal && config2.signal.aborted) {
      throw new CanceledError$1(null, config2);
    }
  }
  function dispatchRequest$1(config2) {
    throwIfCancellationRequested$1(config2);
    config2.headers = AxiosHeaders$3.from(config2.headers);
    config2.data = transformData$1.call(
      config2,
      config2.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
      config2.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters$1.getAdapter(config2.adapter || defaults$3.adapter);
    return adapter(config2).then(function onAdapterResolution(response) {
      throwIfCancellationRequested$1(config2);
      response.data = transformData$1.call(
        config2,
        config2.transformResponse,
        response
      );
      response.headers = AxiosHeaders$3.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel$1(reason)) {
        throwIfCancellationRequested$1(config2);
        if (reason && reason.response) {
          reason.response.data = transformData$1.call(
            config2,
            config2.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders$3.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  const headersToObject$1 = (thing) => thing instanceof AxiosHeaders$3 ? thing.toJSON() : thing;
  function mergeConfig$1(config1, config2) {
    config2 = config2 || {};
    const config3 = {};
    function getMergedValue(target, source, caseless) {
      if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
        return utils$1.merge.call({ caseless }, target, source);
      } else if (utils$1.isPlainObject(source)) {
        return utils$1.merge({}, source);
      } else if (utils$1.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a, b, caseless) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(a, b, caseless);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(void 0, a, caseless);
      }
    }
    function valueFromConfig2(a, b) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(void 0, b);
      }
    }
    function defaultToConfig2(a, b) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(void 0, b);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(void 0, a);
      }
    }
    function mergeDirectKeys(a, b, prop) {
      if (prop in config2) {
        return getMergedValue(a, b);
      } else if (prop in config1) {
        return getMergedValue(void 0, a);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b) => mergeDeepProperties(headersToObject$1(a), headersToObject$1(b), true)
    };
    utils$1.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
    });
    return config3;
  }
  const VERSION$1 = "1.3.4";
  const validators$3 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
    validators$3[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
    };
  });
  const deprecatedWarnings$1 = {};
  validators$3.transitional = function transitional(validator2, version2, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator2 === false) {
        throw new AxiosError$1(
          formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
          AxiosError$1.ERR_DEPRECATED
        );
      }
      if (version2 && !deprecatedWarnings$1[opt]) {
        deprecatedWarnings$1[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  function assertOptions$1(options2, schema, allowUnknown) {
    if (typeof options2 !== "object") {
      throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
    }
    const keys2 = Object.keys(options2);
    let i2 = keys2.length;
    while (i2-- > 0) {
      const opt = keys2[i2];
      const validator2 = schema[opt];
      if (validator2) {
        const value = options2[opt];
        const result = value === void 0 || validator2(value, opt, options2);
        if (result !== true) {
          throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
      }
    }
  }
  const validator$1 = {
    assertOptions: assertOptions$1,
    validators: validators$3
  };
  const validators$2 = validator$1.validators;
  let Axios$2 = class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager$3(),
        response: new InterceptorManager$3()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    request(configOrUrl, config2) {
      if (typeof configOrUrl === "string") {
        config2 = config2 || {};
        config2.url = configOrUrl;
      } else {
        config2 = configOrUrl || {};
      }
      config2 = mergeConfig$1(this.defaults, config2);
      const { transitional, paramsSerializer, headers } = config2;
      if (transitional !== void 0) {
        validator$1.assertOptions(transitional, {
          silentJSONParsing: validators$2.transitional(validators$2.boolean),
          forcedJSONParsing: validators$2.transitional(validators$2.boolean),
          clarifyTimeoutError: validators$2.transitional(validators$2.boolean)
        }, false);
      }
      if (paramsSerializer !== void 0) {
        validator$1.assertOptions(paramsSerializer, {
          encode: validators$2.function,
          serialize: validators$2.function
        }, true);
      }
      config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders;
      contextHeaders = headers && utils$1.merge(
        headers.common,
        headers[config2.method]
      );
      contextHeaders && utils$1.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method2) => {
          delete headers[method2];
        }
      );
      config2.headers = AxiosHeaders$3.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i2 = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest$1.bind(this), void 0];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config2);
        while (i2 < len) {
          promise = promise.then(chain[i2++], chain[i2++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config2;
      i2 = 0;
      while (i2 < len) {
        const onFulfilled = requestInterceptorChain[i2++];
        const onRejected = requestInterceptorChain[i2++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = dispatchRequest$1.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      i2 = 0;
      len = responseInterceptorChain.length;
      while (i2 < len) {
        promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
      }
      return promise;
    }
    getUri(config2) {
      config2 = mergeConfig$1(this.defaults, config2);
      const fullPath = buildFullPath$1(config2.baseURL, config2.url);
      return buildURL$1(fullPath, config2.params, config2.paramsSerializer);
    }
  };
  utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method2) {
    Axios$2.prototype[method2] = function(url, config2) {
      return this.request(mergeConfig$1(config2 || {}, {
        method: method2,
        url,
        data: (config2 || {}).data
      }));
    };
  });
  utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method2) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data, config2) {
        return this.request(mergeConfig$1(config2 || {}, {
          method: method2,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data
        }));
      };
    }
    Axios$2.prototype[method2] = generateHTTPMethod();
    Axios$2.prototype[method2 + "Form"] = generateHTTPMethod(true);
  });
  const Axios$3 = Axios$2;
  let CancelToken$2 = class CancelToken2 {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve2) {
        resolvePromise = resolve2;
      });
      const token = this;
      this.promise.then((cancel) => {
        if (!token._listeners)
          return;
        let i2 = token._listeners.length;
        while (i2-- > 0) {
          token._listeners[i2](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve2) => {
          token.subscribe(resolve2);
          _resolve = resolve2;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config2, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError$1(message, config2, request);
        resolvePromise(token.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index2 = this._listeners.indexOf(listener);
      if (index2 !== -1) {
        this._listeners.splice(index2, 1);
      }
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken2(function executor(c2) {
        cancel = c2;
      });
      return {
        token,
        cancel
      };
    }
  };
  const CancelToken$3 = CancelToken$2;
  function spread$1(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError$1(payload) {
    return utils$1.isObject(payload) && payload.isAxiosError === true;
  }
  const HttpStatusCode$2 = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode$2).forEach(([key, value]) => {
    HttpStatusCode$2[value] = key;
  });
  const HttpStatusCode$3 = HttpStatusCode$2;
  function createInstance$1(defaultConfig) {
    const context = new Axios$3(defaultConfig);
    const instance = bind$2(Axios$3.prototype.request, context);
    utils$1.extend(instance, Axios$3.prototype, context, { allOwnKeys: true });
    utils$1.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create(instanceConfig) {
      return createInstance$1(mergeConfig$1(defaultConfig, instanceConfig));
    };
    return instance;
  }
  const axios$2 = createInstance$1(defaults$3);
  axios$2.Axios = Axios$3;
  axios$2.CanceledError = CanceledError$1;
  axios$2.CancelToken = CancelToken$3;
  axios$2.isCancel = isCancel$1;
  axios$2.VERSION = VERSION$1;
  axios$2.toFormData = toFormData$1;
  axios$2.AxiosError = AxiosError$1;
  axios$2.Cancel = axios$2.CanceledError;
  axios$2.all = function all(promises) {
    return Promise.all(promises);
  };
  axios$2.spread = spread$1;
  axios$2.isAxiosError = isAxiosError$1;
  axios$2.mergeConfig = mergeConfig$1;
  axios$2.AxiosHeaders = AxiosHeaders$3;
  axios$2.formToJSON = (thing) => formDataToJSON$1(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios$2.HttpStatusCode = HttpStatusCode$3;
  axios$2.default = axios$2;
  const axios$3 = axios$2;
  const fs = {};
  class TiledParserFile {
    constructor(file, {
      basePath = "",
      staticDir = "",
      relativePath = ""
    } = {}) {
      this.file = file;
      this.basePath = basePath;
      this.staticDir = staticDir;
      this.relativePath = relativePath;
    }
    static isBrowser() {
      return typeof window !== "undefined" && !window.useFileSystem;
    }
    static typeOfFile(file) {
      file = file.trim();
      const isString2 = typeof file == "string";
      const info = {
        isXml: isString2 && file.startsWith("<?xml"),
        isObject: !!file["version"],
        isHttp: isString2 && file.startsWith("http")
      };
      return {
        ...info,
        isPath: !info.isXml && !info.isObject && !info.isHttp
      };
    }
    _parseFile(file, type, cb) {
      const isXml = (content) => TiledParserFile.typeOfFile(content).isXml;
      const loadContent = (content) => {
        if (!content) {
          return cb(null);
        }
        if (isXml(content)) {
          const parser = new TiledParser(content, this.staticDir ? "" : isXml(file) ? this.relativePath : file);
          if (type == "map") {
            const json = parser.parseMap();
            return cb(json);
          } else if (type == "tileset") {
            const json = parser.parseTileset();
            return cb(json);
          }
        }
        return cb(JSON.parse(content));
      };
      if (TiledParserFile.typeOfFile(file).isObject) {
        return cb(file);
      }
      const {
        isHttp
      } = TiledParserFile.typeOfFile(file);
      if (isXml(file)) {
        loadContent(file);
      } else if (isHttp || TiledParserFile.isBrowser() && {}.NODE_ENV != "test") {
        let url = isHttp ? file : path.join(this.basePath, this.staticDir, file);
        if (TiledParserFile.isBrowser() && window.urlCache) {
          url = window.urlCache[file];
        }
        axios$3.get(url).then((res) => res.data).then(loadContent);
      } else {
        let filepath = file;
        if (file.startsWith("/")) {
          filepath = path.join(this.basePath ? this.basePath : "", file);
        }
        if (this.staticDir) {
          filepath = path.join(this.staticDir, file);
        }
        fs.readFile(path.normalize(filepath), "utf-8", (err, data) => {
          if (err)
            return cb(null, err);
          loadContent(data);
        });
        return;
      }
    }
    parseFile(cb, options2 = {}) {
      const {
        getOnlyBasename
      } = options2;
      const basename2 = (path2) => path2.substring(path2.lastIndexOf("/") + 1);
      if (getOnlyBasename) {
        if (TiledParserFile.typeOfFile(this.file).isPath) {
          this.file = basename2(this.file);
        }
      }
      this._parseFile(this.file, "map", (map, err) => {
        let hasError = false;
        if (err)
          return cb(null, err);
        if (map.tilesets) {
          const parseTileset = [];
          const finish = () => {
            loadAll++;
            if (loadAll == map.tilesets.length && !hasError) {
              map.tilesets = parseTileset;
              cb(map);
            }
          };
          let loadAll = 0;
          for (let i2 = 0; i2 < map.tilesets.length; i2++) {
            const tileset = map.tilesets[i2];
            if (!tileset.source) {
              parseTileset[i2] = tileset;
              finish();
              continue;
            }
            if (getOnlyBasename) {
              if (TiledParserFile.typeOfFile(tileset.source).isPath) {
                tileset.source = basename2(tileset.source);
              }
            }
            this._parseFile(tileset.source, "tileset", (result, err2) => {
              if (err2) {
                hasError = true;
                return cb(null, err2);
              }
              parseTileset[i2] = {
                ...result,
                firstgid: tileset.firstgid
              };
              finish();
            });
          }
        }
      });
    }
    parseFilePromise(options2 = {}) {
      return new Promise((resolve2, reject) => {
        this.parseFile((ret, err) => {
          if (ret)
            resolve2(ret);
          else
            reject(err);
        }, options2);
      });
    }
  }
  var lodash_mergeExports = {};
  var lodash_merge = {
    get exports() {
      return lodash_mergeExports;
    },
    set exports(v2) {
      lodash_mergeExports = v2;
    }
  };
  (function(module2, exports3) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports3 && !exports3.nodeType && exports3;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, allocUnsafe2 = Buffer2 ? Buffer2.allocUnsafe : void 0, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeMax = Math.max, nativeNow = Date.now;
    var Map2 = getNative(root, "Map"), nativeCreate = getNative(Object, "create");
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject2(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject2(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject2(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray2(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject2(objValue) || isFunction2(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity2), func + "");
    }
    var baseSetToString = !defineProperty ? identity2 : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant2(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array2) {
      var index2 = -1, length = source.length;
      array2 || (array2 = Array(length));
      while (++index2 < length) {
        array2[index2] = source[index2];
      }
      return array2;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index2 = -1, length = props.length;
      while (++index2 < length) {
        var key = props[index2];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index2 < length) {
          var source = sources[index2];
          if (source) {
            assigner(object, source, index2, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index2, object) {
      if (!isObject2(object)) {
        return false;
      }
      var type = typeof index2;
      if (type == "number" ? isArrayLike2(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
        return eq(object[index2], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString2(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array2 = Array(length);
        while (++index2 < length) {
          array2[index2] = args[start + index2];
        }
        index2 = -1;
        var otherArgs = Array(start + 1);
        while (++index2 < start) {
          otherArgs[index2] = args[index2];
        }
        otherArgs[start] = transform(array2);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray2 = Array.isArray;
    function isArrayLike2(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike2(value);
    }
    var isBuffer2 = nativeIsBuffer || stubFalse;
    function isFunction2(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject2(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var merge2 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function constant2(value) {
      return function() {
        return value;
      };
    }
    function identity2(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module2.exports = merge2;
  })(lodash_merge, lodash_mergeExports);
  class Log {
    constructor(id, msg) {
      this.id = id;
      this.msg = msg;
    }
  }
  class ItemLog {
    static notInInventory(itemClass) {
      return new Log("ITEM_NOT_INVENTORY", `The item ${itemClass.name} is not in inventory`);
    }
    static notUseItem(itemClass) {
      return new Log("NOT_USE_ITEM", `The player cannot use the ${itemClass.name} item.`);
    }
    static chanceToUseFailed(itemClass) {
      return new Log("USE_CHANCE_ITEM_FAILED", `Chance to use the ${itemClass.name} item has failed`);
    }
    static invalidToEquiped(itemClass) {
      return new Log("INVALID_ITEM_TO_EQUIP", `The item ${itemClass.name} is not a weapon or armor`);
    }
    static canNotEquip(itemClass) {
      return new Log("CANNOT_EQUIP", `The item ${itemClass.name} cannot be equiped`);
    }
    static isAlreadyEquiped(itemClass) {
      return new Log("ITEM_ALREADY_EQUIPED", `The item ${itemClass.name} is already equiped`);
    }
    static haveNotPrice(itemClass) {
      return new Log("NOT_PRICE", `Define a price > 0 to buy ${itemClass.name}`);
    }
    static notEnoughGold(itemClass, nb) {
      return new Log("NOT_ENOUGH_GOLD", `not enough gold to buy ${nb} ${itemClass.name}`);
    }
    static tooManyToSell(itemClass, nbToSell, nb) {
      return new Log("TOO_MANY_ITEM_TO_SELL", `Too many items to sell: ${nbToSell} ${itemClass.name}, only ${nb} in inventory`);
    }
    static restriction(itemClass) {
      return new Log("RESTRICTION_ITEM", `A state blocks the use of the ${itemClass.name} skill`);
    }
  }
  class SkillLog {
    static notLearned(skillClass) {
      return new Log("SKILL_NOT_LEARNED", `the skill ${skillClass.name} is not learned`);
    }
    static notEnoughSp(skillClass, skillSp, playerSp) {
      return new Log("NOT_ENOUGH_SP", `not enough SP to use ${skillClass.name} skill. ${skillSp} Skill'SP is is greater than ${playerSp} Player'SP`);
    }
    static chanceToUseFailed(skillClass) {
      return new Log("USE_CHANCE_SKILL_FAILED", `Chance to use the ${skillClass.name} skill has failed`);
    }
    static restriction(skillClass) {
      return new Log("RESTRICTION_SKILL", `A state blocks the use of the ${skillClass.name} skill`);
    }
    static alreadyLearned(skillClass) {
      return new Log("SKILL_ALREADY_LEARNED", `The ${skillClass.name} skill is already learned`);
    }
  }
  class StateLog {
    static addFailed(stateClass) {
      return new Log("ADD_STATE_FAILED", `Adding the ${stateClass.name} state has failed`);
    }
    static removeFailed(stateClass) {
      return new Log("REMOVE_STATE_FAILED", `Removing the ${stateClass.name} state has failed`);
    }
    static notApplied(stateClass) {
      return new Log("STATE_NOT_APPLIED", `State ${stateClass.name} does not exist`);
    }
  }
  const {
    random: random$1
  } = common.Utils;
  const MAXHP = "maxHp";
  const MAXSP = "maxSp";
  const ATK = "atk";
  const PDEF = "pdef";
  const SDEF = "sdef";
  const STR = "str";
  const AGI = "agi";
  const INT = "int";
  const DEX = "dex";
  const MAXHP_CURVE = {
    start: 741,
    end: 7467
  };
  const MAXSP_CURVE = {
    start: 534,
    end: 5500
  };
  const STR_CURVE = {
    start: 67,
    end: 635
  };
  const AGI_CURVE = {
    start: 58,
    end: 582
  };
  const INT_CURVE = {
    start: 36,
    end: 7318
  };
  const DEX_CURVE = {
    start: 54,
    end: 564
  };
  const DAMAGE_CRITICAL = function(damage, a, b) {
    if (random$1(0, 100) < 4 * a[DEX] / b[AGI]) {
      damage *= 2;
    }
    return damage;
  };
  const DAMAGE_PHYSIC = function(a, b) {
    let damage = Math.round((a[ATK] - b[PDEF] / 2) * ((20 + a[STR]) / 20));
    if (damage < 0)
      damage = 0;
    return damage;
  };
  const DAMAGE_GUARD = function(damage) {
    return damage / 2;
  };
  const COEFFICIENT_ELEMENTS = function(a, b, bDef) {
    return (a.rate + 1) * (b.rate + 1) / (bDef.rate == 0 ? bDef.rate * 4 : 1);
  };
  const DAMAGE_SKILL = function(a, b, skill) {
    let power = skill.power + a[ATK] * (skill.coefficient[ATK] || 0);
    if (power > 0) {
      power -= b[PDEF] * (skill.coefficient[PDEF] || 0) / 2;
      power -= b[SDEF] * (skill.coefficient[SDEF] || 0) / 2;
      power = Math.max(power, 0);
    }
    let rate = 20;
    [STR, DEX, AGI, INT].forEach((val) => rate += a[val] * (skill.coefficient[val] || 0));
    return Math.round(power * rate / 20);
  };
  const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    AGI,
    AGI_CURVE,
    ATK,
    COEFFICIENT_ELEMENTS,
    DAMAGE_CRITICAL,
    DAMAGE_GUARD,
    DAMAGE_PHYSIC,
    DAMAGE_SKILL,
    DEX,
    DEX_CURVE,
    INT,
    INT_CURVE,
    MAXHP,
    MAXHP_CURVE,
    MAXSP,
    MAXSP_CURVE,
    PDEF,
    SDEF,
    STR,
    STR_CURVE
  }, Symbol.toStringTag, { value: "Module" }));
  const {
    isString: isString$7
  } = common.Utils;
  class ParameterManager {
    constructor() {
      this._paramsModifier = {};
      this._hp = 0;
      this._sp = 0;
      this._exp = 0;
      this._level = 0;
      this.initialLevel = 1;
      this.finalLevel = 99;
    }
    /** 
     * Changes the health points
     * - Cannot exceed the MaxHP parameter
     * - Cannot have a negative value
     * - If the value is 0, a hook named `onDead()` is called in the RpgPlayer class.
     * 
     * ```ts
     * player.hp = 100
     * ``` 
     * @title Change HP
     * @prop {number} player.hp
     * @default MaxHPValue
     * @memberof ParameterManager
     * */
    set hp(val) {
      if (val > this.param[MAXHP]) {
        val = this.param[MAXHP];
      } else if (val <= 0) {
        this["execMethod"]("onDead");
        val = 0;
      }
      this._hp = val;
    }
    get hp() {
      return this._hp;
    }
    /** 
     * Changes the skill points
     * - Cannot exceed the MaxSP parameter
     * - Cannot have a negative value
     * 
     * ```ts
     * player.sp = 200
     * ``` 
     * @title Change SP
     * @prop {number} player.sp
     * @default MaxSPValue
     * @memberof ParameterManager
     * */
    set sp(val) {
      if (val > this.param[MAXSP]) {
        val = this.param[MAXSP];
      }
      this._sp = val;
    }
    get sp() {
      return this._sp;
    }
    /** 
     * Changing the player's experience. 
     * ```ts
     * player.exp += 100
     * ```
     * 
     * Levels are based on the experience curve.
     * 
     * ```ts
     * console.log(player.level) // 1
     * console.log(player.expForNextlevel) // 150
     * player.exp += 160
     * console.log(player.level) // 2
     * ```
     * 
     * @title Change Experience
     * @prop {number} player.exp
     * @default 0
     * @memberof ParameterManager
     * */
    set exp(val) {
      this._exp = val;
      this.level;
      while (this.expForNextlevel < this._exp) {
        this.level += 1;
      }
    }
    get exp() {
      return this._exp;
    }
    /** 
     * Changing the player's level. 
     * 
     * ```ts
     * player.level += 1
     * ``` 
     * 
     * The level will be between the initial level given by the `initialLevel` and final level given by `finalLevel`
     * 
     * ```ts
     * player.finalLevel = 50
     * player.level = 60 
     * console.log(player.level) // 50
     * ```
     * 
     * @title Change Level
     * @prop {number} player.level
     * @default 1
     * @memberof ParameterManager
     * */
    set level(val) {
      const lastLevel = this._level;
      if (this.finalLevel && val > this.finalLevel) {
        val = this.finalLevel;
      }
      if (this._class) {
        for (let i2 = this._level; i2 <= val; i2++) {
          for (let skill of this._class.skillsToLearn) {
            if (skill.level == i2) {
              this["learnSkill"](skill.skill);
            }
          }
        }
      }
      const hasNewLevel = val - lastLevel;
      if (hasNewLevel > 0) {
        this["execMethod"]("onLevelUp", [hasNewLevel]);
      }
      this._level = val;
    }
    get level() {
      return this._level;
    }
    /** 
    * ```ts
    * console.log(player.expForNextlevel) // 150
    * ```
    * @title Experience for next level ?
    * @prop {number} player.expForNextlevel
    * @readonly
    * @memberof ParameterManager
    * */
    get expForNextlevel() {
      return this._expForLevel(this.level + 1);
    }
    /** 
     * Read the value of a parameter. Put the name of the parameter.
     * 
     * ```ts
     * import { Presets } from '@rpgjs/server'
     * 
     * const { MAXHP } = Presets 
     * 
     * console.log(player.param[MAXHP])
     * ```
     * 
     * > Possible to use the `player.getParamValue(name)` method instead
     * @title Get Param Value
     * @prop {object} player.param
     * @readonly
     * @memberof ParameterManager
     * */
    get param() {
      const obj = {};
      this._parameters.forEach((val, name) => {
        obj[name] = this.getParamValue(name);
      });
      return obj;
    }
    get paramsModifier() {
      const params = {};
      const paramsAvg = {};
      const changeParam = (paramsModifier) => {
        for (let key in paramsModifier) {
          const {
            rate,
            value
          } = paramsModifier[key];
          if (!params[key])
            params[key] = {
              rate: 0,
              value: 0
            };
          if (!paramsAvg[key])
            paramsAvg[key] = 0;
          if (value)
            params[key].value += value;
          if (rate !== void 0)
            params[key].rate += rate;
          paramsAvg[key]++;
        }
      };
      const getModifier = (prop) => {
        if (!isString$7(prop)) {
          changeParam(prop);
          return;
        }
        for (let el of this[prop]) {
          if (!el.paramsModifier)
            continue;
          changeParam(el.paramsModifier);
        }
      };
      getModifier(this._paramsModifier);
      getModifier("states");
      getModifier("equipments");
      for (let key in params) {
        params[key].rate /= paramsAvg[key];
      }
      return params;
    }
    /** 
     * Changes the values of some parameters
     * 
     * > It is important that these parameters have been created beforehand with the `addParameter()` method.
     * > By default, the following settings have been created: 
     * - maxhp
     * - maxsp
     * - str
     * - int
     * - dex
     * - agi
     * 
     * **Object Key**
     * 
     * The key of the object is the name of the parameter
     * 
     * > The good practice is to retrieve the name coming from a constant
     * 
     * **Object Value**
     * 
     * The value of the key is an object containing: 
     * ``` 
     * {
     *   value: number,
     *   rate: number
     * }
     * ```
     * 
     * - value: Adds a number to the parameter
     * - rate: Adds a rate to the parameter
     * 
     * > Note that you can put both (value and rate)
     * 
     * In the case of a state or the equipment of a weapon or armor, the parameters will be changed but if the state disappears or the armor/weapon is de-equipped, then the parameters will return to the initial state.
     * 
     * @prop {Object} [paramsModifier]
     * @example
     * 
     * ```ts
     * import { Presets } from '@rpgjs/server'
     * 
     * const { MAXHP } = Presets
     * 
     * player.paramsModifier = {
     *      [MAXHP]: {
     *          value: 100
     *      }
     * }
     * ```
     * 
     * 1. Player has 741 MaxHp
     * 2. After changing the parameter, he will have 841 MaxHp
     * 
     * @title Set Parameters Modifier
     * @prop {number} paramsModifier
     * @memberof ParameterManager
     * */
    set paramsModifier(val) {
      this._paramsModifier = val;
      this.changeRoomState("param");
    }
    get parameters() {
      return this._parameters;
    }
    set parameters(val) {
      this._parameters = val;
    }
    _expForLevel(level) {
      const {
        basis,
        extra,
        accelerationA,
        accelerationB
      } = this.expCurve;
      return Math.round(basis * Math.pow(level - 1, 0.9 + accelerationA / 250) * level * (level + 1) / (6 + Math.pow(level, 2) / 50 / accelerationB) + (level - 1) * extra);
    }
    getParam(name) {
      const features = this._parameters.get(name);
      if (!features) {
        throw `Parameter ${name} not exists. Please use addParameter() before`;
      }
      return features;
    }
    getParamValue(name) {
      const features = this.getParam(name);
      let curveVal = Math.floor((features.end - features.start) * ((this.level - 1) / (this.finalLevel - this.initialLevel))) + features.start;
      const modifier = this.paramsModifier[name];
      if (modifier) {
        if (modifier.rate)
          curveVal *= modifier.rate;
        if (modifier.value)
          curveVal += modifier.value;
      }
      return curveVal;
    }
    /** 
     * Give a new parameter. Give a start value and an end value. 
     * The start value will be set to the level set at `player.initialLevel` and the end value will be linked to the level set at `player.finalLevel`.
     * 
     * ```ts
     * const SPEED = 'speed'
     * 
     * player.addParameter(SPEED, {
     *     start: 10,
     *     end: 100
     * })
     * 
     * player.param[SPEED] // 10
     * player.level += 5
     * player.param[SPEED] // 14
     * ```
     * 
     * @title Add custom parameters
     * @method player.addParameter(name,curve)
     * @param {name} name 
     * @param {object} curve Scheme of the object: { start: number, end: number }
     * @returns {void}
     * @memberof ParameterManager
     * */
    addParameter(name, {
      start,
      end
    }) {
      this._parameters.set(name, {
        start,
        end
      });
      const maxHp = this.param[MAXHP];
      const maxSp = this.param[MAXSP];
      if (name == MAXHP && this.hp > maxHp) {
        this.hp = maxHp;
      } else if (name == MAXSP && this.sp > maxSp) {
        this.sp = maxSp;
      }
      this.changeRoomState("param." + name);
    }
    /** 
     * Gives back in percentage of health points to skill points
     * 
     * ```ts
     * import { Presets } from '@rpgjs/server'
     * 
     * const { MAXHP } = Presets 
     * 
     * console.log(player.param[MAXHP]) // 800
     * player.hp = 100
     * player.recovery({ hp: 0.5 }) // = 800 * 0.5
     * console.log(player.hp) // 400
     * ```
     * 
     * @title Recovery HP and/or SP
     * @method player.recovery(params)
     * @param {object} params Scheme of the object: { hp: number, sp: number }. The values of the numbers must be in 0 and 1
     * @returns {void}
     * @memberof ParameterManager
     * */
    recovery({
      hp,
      sp
    }) {
      if (hp)
        this.hp = this.param[MAXHP] * hp;
      if (sp)
        this.sp = this.param[MAXSP] * sp;
    }
    /** 
     * restores all HP and SP
     * 
     * ```ts
     * import { Presets } from '@rpgjs/server'
     * 
     * const { MAXHP, MAXSP } = Presets 
     * 
     * console.log(player.param[MAXHP], player.param[MAXSP]) // 800, 230
     * player.hp = 100
     * player.sp = 0
     * player.allRecovery()
     * console.log(player.hp, player.sp) // 800, 230
     * ```
     * 
     * @title All Recovery
     * @method player.allRecovery()
     * @returns {void}
     * @memberof ParameterManager
     * */
    allRecovery() {
      this.recovery({
        hp: 1,
        sp: 1
      });
    }
  }
  const {
    arrayUniq: arrayUniq$1,
    arrayFlat: arrayFlat$1,
    applyMixins: applyMixins$7
  } = common.Utils;
  class EffectManager {
    // TODO
    applyEffect(item) {
      if (item.hpValue) {
        this.hp += item.hpValue;
      }
      if (item.hpRate) {
        this.hp += this.param[MAXHP] * item.hpRate;
      }
      if (item.spValue) {
        this.sp += item.spValue;
      }
      if (item.spRate) {
        this.sp += this.param[MAXSP] * item.spRate;
      }
    }
    /** 
     * ```ts
     * import { Effect } from '@rpgjs/database'
     * 
     * const bool = player.hasEffect(Effect.CAN_NOT_SKILL)
     * ```
     * 
     * @title Has Effect
     * @method player.hasEffect(effect)
     * @param {Effect} effect
     * @returns {boolean}
     * @memberof EffectManager
     * */
    hasEffect(effect) {
      return this.effects.includes(effect);
    }
    /** 
     * Retrieves a array of effects assigned to the player, state effects and effects of weapons and armors equipped with the player's own weapons.
     * 
     * ```ts
     * console.log(player.effects)
     * ``` 
     * @title Get Effects
     * @prop {Array<Effect>} player.effects
     * @memberof EffectManager
     * */
    get effects() {
      const getEffects = (prop) => {
        return arrayFlat$1(this[prop].map((el) => el.effects || []));
      };
      return arrayUniq$1([...this._effects, ...getEffects("states"), ...getEffects("equipments")]);
    }
    /** 
     * Assigns effects to the player. If you give a array, it does not change the effects of the player's states and armor/weapons equipped.
     * 
     * ```ts
     * import { Effect } from '@rpgjs/database'
     * 
     * player.effects = [Effect.CAN_NOT_SKILL]
     * ``` 
     * @title Set Effects
     * @prop {Array<Effect>} player.effects
     * @memberof EffectManager
     * */
    set effects(val) {
      this._effects = val;
    }
  }
  applyMixins$7(EffectManager, [ParameterManager]);
  class GoldManager {
    constructor() {
      this._gold = 0;
    }
    /** 
    * You can change the game money
    * 
    * ```ts
    * player.gold += 100
    * ```
    * 
    * @title Change Gold
    * @prop {number} player.gold
    * @default 0
    * @memberof GoldManager
    * */
    set gold(val) {
      if (val < 0) {
        val = 0;
      }
      this._gold = val;
    }
    get gold() {
      return this._gold;
    }
  }
  class ItemFixture {
    getFeature(name, prop) {
      const array2 = {};
      for (let item of this.equipments) {
        if (item[name]) {
          for (let feature of item[name]) {
            const {
              rate
            } = feature;
            const instance = feature[prop];
            const cache = array2[instance.id];
            if (cache && cache.rate >= rate)
              continue;
            array2[instance.id] = feature;
          }
        }
      }
      return Object.values(array2);
    }
  }
  const {
    isInstanceOf: isInstanceOf$2,
    applyMixins: applyMixins$6,
    isString: isString$6
  } = common.Utils;
  class StateManager {
    constructor() {
      this.states = [];
    }
    /** 
     * Recovers the player's states defense on inventory.  This list is generated from the `statesDefense` property defined on the weapons or armors equipped.
     * If several items have the same element, only the highest rate will be taken into account.
     * 
     * ```ts
     * import { Armor, State } from '@rpgjs/server'
     * 
     * @State({
     *      name: 'Paralyze'
     * })
     * class Paralyze {}
     * 
     * @Armor({
     *      name: 'Shield',
     *      statesDefense: [{ rate: 1, state: Paralyze }]
     * })
     * class Shield {}
     * 
     * @Armor({
     *      name: 'FireShield',
     *      statesDefense: [{ rate: 0.5, state: Paralyze }]
     * })
     * class FireShield {}
     *
     * player.addItem(Shield)
     * player.addItem(FireShield)
     * player.equip(Shield)
     * player.equip(FireShield)
     * 
     * console.log(player.statesDefense) // [{ rate: 1, state: instance of Paralyze }]
     * ``` 
     * @title Get States Defense
     * @prop {Array<{ rate: number, state: StateClass}>} player.statesDefense
     * @readonly
     * @memberof StateManager
     * */
    get statesDefense() {
      return this.getFeature("statesDefense", "state");
    }
    /** 
     * Set or retrieves all the states where the player is vulnerable or not. 
     * 
     * ```ts
     * import { Class, State } from '@rpgjs/server'
     * 
     * @State({
     *      name: 'Paralyze'
     * })
     * class Paralyze {}
     * 
     * @State({
     *      name: 'Sleep'
     * })
     * class Sleep {}
     * 
     * @Class({
     *      name: 'Fighter',
     *      statesEfficiency: [{ rate: 1, state: Paralyze }]
     * })
     * class Hero {}
     * 
     * player.setClass(Hero)
     * 
     * console.log(player.statesEfficiency) // [{ rate: 1, instance of Paralyze }]
     * 
     * player.statesEfficiency = [{ rate: 2, state: Sleep }]
     * 
     * console.log(player.statesEfficiency) // [{ rate: 1, state: instance of Paralyze }, { rate: 2, state: instance of Sleep }]
     * ``` 
     * @title Set/Get States Efficiency
     * @prop {Array<{ rate: number, state: StateClass}>} player.statesEfficiency
     * @memberof StateManager
     * */
    get statesEfficiency() {
      return this._statesEfficiency;
    }
    set statesEfficiency(val) {
      this._statesEfficiency = val;
    }
    applyStates(player, {
      addStates,
      removeStates
    }) {
      if (addStates) {
        for (let {
          state,
          rate
        } of addStates) {
          player.addState(state, rate);
        }
      }
      if (removeStates) {
        for (let {
          state,
          rate
        } of removeStates) {
          player.removeState(state, rate);
        }
      }
    }
    /**
     * Get a state to the player. Returns `null` if the state is not present on the player
     * ```ts
     * import Paralyze from 'your-database/states/paralyze'
     * 
     * player.getState(Paralyze)
     *  ```
     * 
     * @title Get State
     * @method player.getState(stateClass)
     * @param {StateClass | string} stateClass or state id
     * @returns {instance of StateClass | null}
     * @memberof StateManager
     */
    getState(stateClass) {
      if (isString$6(stateClass))
        stateClass = this.databaseById(stateClass);
      return this.states.find((state) => {
        if (isString$6(stateClass)) {
          return state.id == stateClass;
        }
        return isInstanceOf$2(state, stateClass);
      });
    }
    /**
     * Adds a state to the player. Set the chance between 0 and 1 that the state can apply
     * ```ts
     * import Paralyze from 'your-database/states/paralyze'
     * 
     * try { 
     *      player.addState(Paralyze)
     * }
     * catch (err) {
     *      console.log(err)
     * }
     *  ```
     * 
     * @title Add State
     * @method player.addState(stateClass,chance=1)
     * @param {StateClass | string} stateClass state class or state id
     * @param {number} [chance] 1 by default
     * @throws {StateLog} addFailed 
     * If the chance to add the state has failed (defined with the `chance` param)
     *  ```
     * {
     *      id: ADD_STATE_FAILED,
     *      msg: '...'
     * }
     * ```
     * @returns {instance of StateClass}
     * @memberof StateManager
     * @todo
     */
    addState(stateClass, chance = 1) {
      const state = this.getState(stateClass);
      if (isString$6(stateClass)) {
        stateClass = this.databaseById(stateClass);
      }
      if (!state) {
        if (Math.random() > chance) {
          throw StateLog.addFailed(stateClass);
        }
        const instance = new stateClass();
        this.states.push(instance);
        this.applyStates(this, instance);
        return instance;
      }
      return null;
    }
    /**
     * Remove a state to the player. Set the chance between 0 and 1 that the state can be removed
     * ```ts
     * import Paralyze from 'your-database/states/paralyze'
     * 
     * try { 
     *      player.removeState(Paralyze)
     * }
     * catch (err) {
     *      console.log(err)
     * }
     *  ```
     * 
     * @title Remove State
     * @method player.removeState(stateClass,chance=1)
     * @param {StateClass|string} stateClass class state or state id
     * @param {number} [chance] 1 by default
     * @throws {StateLog} removeFailed 
     * If the chance to remove the state has failed (defined with the `chance` param)
     *  ```
     * {
     *      id: REMOVE_STATE_FAILED,
     *      msg: '...'
     * }
     * ```
     * @throws {StateLog} notApplied 
     * If the status does not exist
     *  ```
     * {
     *      id: STATE_NOT_APPLIED,
     *      msg: '...'
     * }
     * ```
     * @returns {instance of StateClass}
     * @memberof StateManager
     */
    removeState(stateClass, chance = 1) {
      const index2 = this.states.findIndex((state) => {
        if (isString$6(stateClass)) {
          return state.id == stateClass;
        }
        return isInstanceOf$2(state, stateClass);
      });
      if (index2 != -1) {
        if (Math.random() > chance) {
          throw StateLog.removeFailed(stateClass);
        }
        this.states.splice(index2, 1);
      } else {
        throw StateLog.notApplied(stateClass);
      }
    }
    findStateEfficiency(stateClass) {
      return this.statesEfficiency.find((state) => isInstanceOf$2(state.state, stateClass));
    }
  }
  applyMixins$6(StateManager, [ItemFixture]);
  const {
    isString: isString$5,
    isInstanceOf: isInstanceOf$1,
    applyMixins: applyMixins$5
  } = common.Utils;
  class ItemManager {
    constructor() {
      this.equipments = [];
    }
    /**
    * Retrieves the information of an object: the number and the instance 
    * @title Get Item
    * @method player.getItem(itemClass)
    * @param {ItemClass | string} itemClass Identifier of the object if the parameter is a string
    * @returns {{ nb: number, item: instance of ItemClass }}
    * @memberof ItemManager
    * @example
    * 
    * ```ts
    * import Potion from 'your-database/potion'
    * 
    * player.addItem(Potion, 5)
    * const inventory = player.getItem(Potion)
    * console.log(inventory) // { nb: 5, item: <instance of Potion> }
    *  ```
    */
    getItem(itemClass) {
      const index2 = this._getItemIndex(itemClass);
      return this.items[index2];
    }
    /**
     * Check if the player has the item in his inventory.
     * @title Has Item
     * @method player.hasItem(itemClass)
     * @param {ItemClass | string} itemClass Identifier of the object if the parameter is a string
     * @returns {boolean}
     * @memberof ItemManager
     * @example
     * 
     * ```ts
     * import Potion from 'your-database/potion'
     * 
     * player.hasItem(Potion) // false
     *  ```
     */
    hasItem(itemClass) {
      return !!this.getItem(itemClass);
    }
    _getItemIndex(itemClass) {
      return this.items.findIndex((it) => {
        if (isString$5(itemClass)) {
          return it.item.id == itemClass;
        }
        return isInstanceOf$1(it.item, itemClass);
      });
    }
    /**
     * Add an item in the player's inventory. You can give more than one by specifying `nb`
     * 
     * `onAdd()` method is called on the ItemClass
     * 
     * @title Add Item
     * @method player.addItem(item,nb=1)
     * @param {ItemClass} itemClass 
     * @param {number} [nb] Default 1
     * @returns {{ nb: number, item: instance of ItemClass }}
     * @memberof ItemManager
     * @example
     * 
     * ```ts
     * import Potion from 'your-database/potion'
     * player.addItem(Potion, 5)
     *  ```
     */
    addItem(itemClass, nb = 1) {
      if (isString$5(itemClass))
        itemClass = this.databaseById(itemClass);
      let itemIndex = this._getItemIndex(itemClass);
      if (itemIndex != -1) {
        this.items[itemIndex].nb += nb;
      } else {
        const instance = new itemClass();
        this.items.push({
          item: instance,
          nb
        });
        itemIndex = this.items.length - 1;
      }
      const {
        item
      } = this.items[itemIndex];
      this["execMethod"]("onAdd", [this], item);
      return this.items[itemIndex];
    }
    /**
     * Deletes an item. Decreases the value `nb`. If the number falls to 0, then the item is removed from the inventory. The method then returns `undefined`
     * 
     * `onRemove()` method is called on the ItemClass
     * 
     * @title Remove Item
     * @method player.removeItem(item,nb=1)
     * @param {ItemClass | string} itemClass string is item id
     * @param {number} [nb] Default 1
     * @returns {{ nb: number, item: instance of ItemClass } | undefined}
     * @throws {ItemLog} notInInventory 
     * If the object is not in the inventory, an exception is raised
     *  ```
     * {
     *      id: ITEM_NOT_INVENTORY,
     *      msg: '...'
     * }
     * ```
     * @memberof ItemManager
     * @example
     * 
     * ```ts
     * import Potion from 'your-database/potion'
     * 
     * try {
     *    player.removeItem(Potion, 5)
     * }
     * catch (err) {
     *    console.log(err)
     * }
     * ```
     */
    removeItem(itemClass, nb = 1) {
      const itemIndex = this._getItemIndex(itemClass);
      if (itemIndex == -1) {
        throw ItemLog.notInInventory(itemClass);
      }
      const currentNb = this.items[itemIndex].nb;
      const {
        item
      } = this.items[itemIndex];
      if (currentNb - nb <= 0) {
        this.items.splice(itemIndex, 1);
      } else {
        this.items[itemIndex].nb -= nb;
      }
      this["execMethod"]("onRemove", [this], item);
      return this.items[itemIndex];
    }
    /**
     * Purchases an item and reduces the amount of gold
     * 
     * `onAdd()` method is called on the ItemClass
     * 
     * @title Buy Item
     * @method player.buyItem(item,nb=1)
     * @param {ItemClass | string} itemClass string is item id
     * @param {number} [nb] Default 1
     * @returns {{ nb: number, item: instance of ItemClass }}
     * @throws {ItemLog} haveNotPrice 
     * If you have not set a price on the item
     *  ```
     * {
     *      id: NOT_PRICE,
     *      msg: '...'
     * }
     * ```
     * @throws {ItemLog} notEnoughGold 
     * If the player does not have enough money
     *  ```
     * {
     *      id: NOT_ENOUGH_GOLD,
     *      msg: '...'
     * }
     * ```
     * @memberof ItemManager
     * @example
     * 
     * ```ts
     * import Potion from 'your-database/potion'
     * 
     * try {
     *    player.buyItem(Potion)
     * }
     * catch (err) {
     *    console.log(err)
     * }
     * ```
     */
    buyItem(itemClass, nb = 1) {
      if (isString$5(itemClass))
        itemClass = this.databaseById(itemClass);
      const ItemClass2 = itemClass;
      if (!ItemClass2.price) {
        throw ItemLog.haveNotPrice(itemClass);
      }
      const totalPrice = nb * ItemClass2.price;
      if (this.gold < totalPrice) {
        throw ItemLog.notEnoughGold(itemClass, nb);
      }
      this.gold -= totalPrice;
      return this.addItem(ItemClass2, nb);
    }
    /**
     * Sell an item and the player wins the amount of the item divided by 2
     * 
     * `onRemove()` method is called on the ItemClass
     * 
     * @title Sell Item
     * @method player.sellItem(item,nb=1)
     * @param {ItemClass | string} itemClass string is item id
     * @param {number} [nbToSell] Default 1
     * @returns {{ nb: number, item: instance of ItemClass }}
     * @throws {ItemLog} haveNotPrice 
     * If you have not set a price on the item
     *   ```
     * {
     *      id: NOT_PRICE,
     *      msg: '...'
     * }
     * ```
     * @throws {ItemLog} notInInventory 
     * If the object is not in the inventory, an exception is raised
     *  ```
     * {
     *      id: ITEM_NOT_INVENTORY,
     *      msg: '...'
     * }
     * ```
     * @throws {ItemLog} tooManyToSell 
     * If the number of items for sale exceeds the number of actual items in the inventory
     *  ```
     * {
     *      id: TOO_MANY_ITEM_TO_SELL,
     *      msg: '...'
     * }
     * ```
     * @memberof ItemManager
     * @example
     * 
     * ```ts
     * import Potion from 'your-database/potion'
     * 
     * try {
     *     player.addItem(Potion)
     *     player.sellItem(Potion)
     * }
     * catch (err) {
     *    console.log(err)
     * }
     * ```
     */
    sellItem(itemClass, nbToSell = 1) {
      if (isString$5(itemClass))
        itemClass = this.databaseById(itemClass);
      const ItemClass2 = itemClass;
      const inventory = this.getItem(ItemClass2);
      if (!inventory) {
        throw ItemLog.notInInventory(itemClass);
      }
      const {
        item,
        nb
      } = inventory;
      if (nb - nbToSell < 0) {
        throw ItemLog.tooManyToSell(itemClass, nbToSell, nb);
      }
      if (!ItemClass2.price) {
        throw ItemLog.haveNotPrice(itemClass);
      }
      this.gold += ItemClass2.price / 2 * nbToSell;
      this.removeItem(ItemClass2, nbToSell);
      return inventory;
    }
    getParamItem(name) {
      let nb = 0;
      for (let item of this.equipments) {
        nb += item[name] || 0;
      }
      const modifier = this.paramsModifier[name];
      if (modifier) {
        if (modifier.value)
          nb += modifier.value;
        if (modifier.rate)
          nb *= modifier.rate;
      }
      return nb;
    }
    /**
     * recover the attack sum of items equipped on the player.
     * 
     * @title Get the player's attack
     * @prop {number} player.atk
     * @memberof ItemManager
     */
    get atk() {
      return this.getParamItem(ATK);
    }
    /**
    * recover the physic defense sum of items equipped on the player.
    * 
    * @title Get the player's pdef
    * @prop {number} player.pdef
    * @memberof ItemManager
    */
    get pdef() {
      return this.getParamItem(PDEF);
    }
    /**
    * recover the skill defense sum of items equipped on the player.
    * 
    * @title Get the player's sdef
    * @prop {number} player.sdef
    * @memberof ItemManager
    */
    get sdef() {
      return this.getParamItem(SDEF);
    }
    /**
     *  Use an object. Applies effects and states. Removes the object from the inventory then
     * 
     * `onUse()` method is called on the ItemClass (If the use has worked)
     * `onRemove()` method is called on the ItemClass
     * 
     * @title Use an Item
     * @method player.useItem(item,nb=1)
     * @param {ItemClass | string} itemClass string is item id
     * @returns {{ nb: number, item: instance of ItemClass }}
     * @throws {ItemLog} restriction 
     * If the player has the `Effect.CAN_NOT_ITEM` effect
     *   ```
     * {
     *      id: RESTRICTION_ITEM,
     *      msg: '...'
     * }
     * ```
     * @throws {ItemLog} notInInventory 
     * If the object is not in the inventory, an exception is raised
     *  ```
     * {
     *      id: ITEM_NOT_INVENTORY,
     *      msg: '...'
     * }
     * ```
     * @throws {ItemLog} notUseItem 
     * If the `consumable` property is on false
     *  ```
     * {
     *      id: NOT_USE_ITEM,
     *      msg: '...'
     * }
     * ```
     * @throws {ItemLog} chanceToUseFailed 
     * Chance to use the item has failed. Chances of use is defined with `ItemClass.hitRate`
     *  ```
     * {
     *      id: USE_CHANCE_ITEM_FAILED,
     *      msg: '...'
     * }
     * ```
     * > the item is still deleted from the inventory
     * 
     * `onUseFailed()` method is called on the ItemClass
     * 
     * @memberof ItemManager
     * @example
     * 
     * ```ts
     * import Potion from 'your-database/potion'
     * 
     * try {
     *     player.addItem(Potion)
     *     player.useItem(Potion)
     * }
     * catch (err) {
     *    console.log(err)
     * }
     * ```
     */
    useItem(itemClass) {
      const inventory = this.getItem(itemClass);
      if (this.hasEffect(database.Effect.CAN_NOT_ITEM)) {
        throw ItemLog.restriction(itemClass);
      }
      if (!inventory) {
        throw ItemLog.notInInventory(itemClass);
      }
      const {
        item
      } = inventory;
      if (item.consumable === false) {
        throw ItemLog.notUseItem(itemClass);
      }
      const hitRate = item.hitRate ?? 1;
      if (Math.random() > hitRate) {
        this.removeItem(itemClass);
        this["execMethod"]("onUseFailed", [this], item);
        throw ItemLog.chanceToUseFailed(itemClass);
      }
      this.applyEffect(item);
      this.applyStates(this, item);
      this["execMethod"]("onUse", [this], item);
      this.removeItem(itemClass);
      return inventory;
    }
    /**
     * Equips a weapon or armor on a player. Think first to add the item in the inventory with the `addItem()` method before equipping the item.
     * 
     * `onEquip()` method is called on the ItemClass
     * 
     * @title Equip Weapon or Armor
     * @method player.equip(itemClass,equip=true)
     * @param {ItemClass | string} itemClass string is item id
     * @param {number} [equip] Equip the object if true or un-equipped if false
     * @returns {void}
     * @throws {ItemLog} notInInventory 
     * If the item is not in the inventory
     *  ```
        {
            id: ITEM_NOT_INVENTORY,
            msg: '...'
        }
        ```
     * @throws {ItemLog} invalidToEquiped 
        If the item is not by a weapon or armor
        ```
        {
            id: INVALID_ITEM_TO_EQUIP,
            msg: '...'
        }
        ```
    * @throws {ItemLog} isAlreadyEquiped 
        If the item Is already equipped
        ```
        {
            id: ITEM_ALREADY_EQUIPED,
            msg: '...'
        }
        ```
     * @memberof ItemManager
     * @example
     * 
     * ```ts
     * import Sword from 'your-database/sword'
     * 
     * try {
     *      player.addItem(Sword)
     *      player.equip(Sword)
     * }
     * catch (err) {
     *    console.log(err)
     * }
     * ```
     */
    equip(itemClass, equip = true) {
      const inventory = this.getItem(itemClass);
      if (!inventory) {
        throw ItemLog.notInInventory(itemClass);
      }
      if (itemClass._type == "item") {
        throw ItemLog.invalidToEquiped(itemClass);
      }
      if (this._class && this._class[database.ClassHooks.canEquip]) {
        const canEquip = this["execMethodSync"](database.ClassHooks.canEquip, [inventory.item, this], this._class);
        if (!canEquip) {
          throw ItemLog.canNotEquip(itemClass);
        }
      }
      const item = inventory.item;
      if (item.equipped && equip) {
        throw ItemLog.isAlreadyEquiped(itemClass);
      }
      item.equipped = equip;
      if (!equip) {
        const index2 = this.equipments.findIndex((it) => it.id == item.id);
        this.equipments.splice(index2, 1);
      } else {
        this.equipments.push(item);
      }
      this["execMethod"]("onEquip", [this, equip], item);
    }
  }
  applyMixins$5(ItemManager, [GoldManager, StateManager, EffectManager]);
  const {
    isArray: isArray$1,
    isString: isString$4,
    isInstanceOf,
    applyMixins: applyMixins$4
  } = common.Utils;
  class SkillManager {
    _getSkillIndex(skillClass) {
      return this.skills.findIndex((skill) => {
        if (isString$4(skill)) {
          return skill.id == skillClass;
        }
        if (isString$4(skillClass)) {
          return skillClass == (skill.id || skill);
        }
        return isInstanceOf(skill, skillClass);
      });
    }
    /**
     * Retrieves a learned skill. Returns null, if not found
     * ```ts
     * import Fire from 'your-database/skills/fire'
     * 
     * player.getSkill(Fire)
     *  ```
     * 
     * @title Get Skill
     * @method player.getSkill(skillClass)
     * @param {SkillClass | string} skillClass or data id
     * @returns {instance of SkillClass | null}
     * @memberof SkillManager
     */
    getSkill(skillClass) {
      const index2 = this._getSkillIndex(skillClass);
      return this.skills[index2] ?? null;
    }
    /**
     * Learn a skill. Attributes the coefficient 1 to the parameter INT (intelligence) if cd is not present on the class.
     * 
     * `onLearn()` method is called on the SkillClass
     * 
     * ```ts
     * import Fire from 'your-database/skills/fire'
     * 
     * player.learnSkill(Fire)
     *  ```
     * 
     * @title Learn Skill
     * @method player.learnSkill(skillClass)
     * @param {SkillClass | string} skillClass or data id
     * @throws {SkillLog} alreadyLearned
     *  If the player already knows the skill
     *  ```
        {
            id: SKILL_ALREADY_LEARNED,
            msg: '...'
        }
        ```
     * @returns {instance of SkillClass}
     * @memberof SkillManager
     */
    learnSkill(skillClass) {
      if (this.getSkill(skillClass)) {
        throw SkillLog.alreadyLearned(skillClass);
      }
      if (isString$4(skillClass))
        skillClass = this.databaseById(skillClass);
      const instance = new skillClass();
      this.skills.push(instance);
      this["execMethod"]("onLearn", [this], instance);
      return instance;
    }
    /**
     * Forget a skill
     * 
     * `onForget()` method is called on the SkillClass
     * 
     * ```ts
     * import Fire from 'your-database/skills/fire'
     * 
     * try {
     *      player.forgetSkill(Fire) 
     * }
     * catch (err) {
     *      console.log(err)
     * }
     *  ```
     * 
     * @title Forget Skill
     * @method player.learnSkill(skillClass)
     * @param {SkillClass | string} skillClass or data id
     * @throws {SkillLog} notLearned 
     * If trying to forget a skill not learned
     *  ```
     * {
     *      id: SKILL_NOT_LEARNED,
     *      msg: '...'
     * }
     * ```
     * @returns {instance of SkillClass}
     * @memberof SkillManager
     */
    forgetSkill(skillClass) {
      if (isString$4(skillClass))
        skillClass = this.databaseById(skillClass);
      const index2 = this._getSkillIndex(skillClass);
      if (index2 == -1) {
        throw SkillLog.notLearned(skillClass);
      }
      const instance = this.skills[index2];
      this.skills.splice(index2, 1);
      this["execMethod"]("onForget", [this], instance);
      return instance;
    }
    /**
     * Using a skill
     * 
     * `onUse()` method is called on the SkillClass
     * 
     * If other players are indicated then damage will be done to these other players. The method `applyDamage()` will be executed
     * 
     * ```ts
     * import Fire from 'your-database/skills/fire'
     * 
     * try {
     *      player.useSkill(Fire) 
     * }
     * catch (err) {
     *      console.log(err)
     * }
     *  ```
     * 
     * or 
     * 
     * 
     * * ```ts
     * import Fire from 'your-database/skills/fire'
     * 
     * try {
     *      player.useSkill(Fire, otherPlayer) 
     * }
     * catch (err) {
     *      console.log(err)
     * }
     *  ```
     * 
     * @title Use Skill
     * @method player.useSkill(skillClass,otherPlayer)
     * @param {SkillClass | string} skillClass or data id
     * @param {Array<RpgPlayer> | RpgPlayer} [otherPlayer] 
     * @throws {SkillLog} restriction 
     * If the player has the `Effect.CAN_NOT_SKILL` effect 
     *  ```
     * {
     *      id: RESTRICTION_SKILL,
     *      msg: '...'
     * }
     * ```
     * @throws {SkillLog} notLearned 
     * If the player tries to use an unlearned skill
     *  ```
     * {
     *      id: SKILL_NOT_LEARNED,
     *      msg: '...'
     * }
     * ```
     * @throws {SkillLog} notEnoughSp 
     * If the player does not have enough SP to use the skill
     *  ```
     * {
     *      id: NOT_ENOUGH_SP,
     *      msg: '...'
     * }
     * ```
     * @throws {SkillLog} chanceToUseFailed 
     * If the chance to use the skill has failed (defined with the `hitRate` property)
     *  ```
     * {
     *      id: USE_CHANCE_SKILL_FAILED,
     *      msg: '...'
     * }
     * ```
     * 
     * `onUseFailed()` method is called on the SkillClass
     * 
     * @returns {instance of SkillClass}
     * @memberof SkillManager
     * @todo
     */
    useSkill(skillClass, otherPlayer) {
      const skill = this.getSkill(skillClass);
      if (this.hasEffect(database.Effect.CAN_NOT_SKILL)) {
        throw SkillLog.restriction(skillClass);
      }
      if (!skill) {
        throw SkillLog.notLearned(skillClass);
      }
      if (skill.spCost > this.sp) {
        throw SkillLog.notEnoughSp(skillClass, skill.spCost, this.sp);
      }
      this.sp -= skill.spCost / (this.hasEffect(database.Effect.HALF_SP_COST) ? 2 : 1);
      const hitRate = skill.hitRate ?? 1;
      if (Math.random() > hitRate) {
        this["execMethod"]("onUseFailed", [this, otherPlayer], skill);
        throw SkillLog.chanceToUseFailed(skillClass);
      }
      if (otherPlayer) {
        let players = otherPlayer;
        if (!isArray$1(players)) {
          players = [otherPlayer];
        }
        for (let player of players) {
          this.applyStates(player, skill);
          player.applyDamage(this, skill);
        }
      }
      this["execMethod"]("onUse", [this, otherPlayer], skill);
      return skill;
    }
  }
  applyMixins$4(SkillManager, [ParameterManager, StateManager, EffectManager]);
  const {
    applyMixins: applyMixins$3,
    isString: isString$3
  } = common.Utils;
  class ClassManager {
    /** 
     * Assign a class to the player
     * 
     * ```ts
     * import { Fighter } from 'my-database/classes/fighter'
     * 
     * player.setClass(Fighter)
     * ```
     * 
     * @title Set Class
     * @method player.setClass(ClassClass)
     * @param {ClassClass | string} class class or id
     * @returns {instance of ClassClass} 
     * @memberof ClassManager
     * */
    setClass(_class) {
      if (isString$3(_class))
        _class = this.databaseById(_class);
      this._class = new _class();
      this["execMethod"]("onSet", [this], this._class);
      return this._class;
    }
    /** 
     * Allows to give a set of already defined properties to the player (default equipment, or a list of skills to learn according to the level)
     * 
     * ```ts
     * import { Hero } from 'my-database/classes/hero'
     * 
     * player.setActor(Hero)
     * ```
     * 
     * @title Set Actor
     * @method player.setActor(ActorClass)
     * @param {ActorClass | string} actorClass actor class or id
     * @returns {instance of ActorClass} 
     * @memberof ClassManager
     * */
    setActor(actorClass) {
      if (isString$3(actorClass))
        actorClass = this.databaseById(actorClass);
      const actor = new actorClass();
      ["name", "initialLevel", "finalLevel", "expCurve"].forEach((key) => {
        if (actor[key])
          this[key] = actor[key];
      });
      for (let param in actor.parameters) {
        this.addParameter(param, actor.parameters[param]);
      }
      for (let item of actor.startingEquipment) {
        this.addItem(item);
        this.equip(item, true);
      }
      if (actor.class)
        this.setClass(actor.class);
      this["execMethod"]("onSet", [this], actor);
      return actor;
    }
  }
  applyMixins$3(ClassManager, [ParameterManager, ItemManager]);
  const {
    arrayUniq,
    applyMixins: applyMixins$2
  } = common.Utils;
  class ElementManager extends ItemFixture {
    /** 
    * Recovers the player's elements defense on inventory.  This list is generated from the `elementsDefense` property defined on the weapons or armors equipped.
    * If several items have the same element, only the highest rate will be taken into account.
    * 
    * ```ts
    * import { Armor } from '@rpgjs/server'
    * 
    * enum Elements {
    *   Fire = 'fire'
    * }
    * 
    * @Armor({
    *      name: 'Shield',
    *      elementsDefense: [{ rate: 1, element: Elements.Fire }]
    * })
    * class Shield {}
    * 
    * @Armor({
    *      name: 'FireShield',
    *      elementsDefense: [{ rate: 0.5, element: Elements.Fire }]
    * })
    * class FireShield {}
    * 
    * player.addItem(Shield)
    * player.addItem(FireShield)
    * player.equip(Shield)
    * player.equip(FireShield)
    * 
    * console.log(player.elementsDefense) // [{ rate: 1, element: 'fire' }]
    * ``` 
    * @title Get Elements Defense
    * @prop {Array<{ rate: number, element: Element}>} player.elementsDefense
    * @readonly
    * @memberof ElementManager
    * */
    get elementsDefense() {
      return this.getFeature("elementsDefense", "element");
    }
    /** 
    * Set or retrieves all the elements where the player is vulnerable or not. 
    * 
    * ```ts
    * import { Class } from '@rpgjs/server'
    * 
    * enum Elements {
    *   Fire = 'fire',
    *   Ice = 'ice'
    * }
    * 
    * @Class({
    *      name: 'Fighter',
    *      elementsEfficiency: [{ rate: 1, element: Elements.Fire }]
    * })
    * class Hero {}
    * 
    * player.setClass(Hero)
    * 
    * console.log(player.elementsEfficiency) // [{ rate: 1, element: 'fire' }]
    * 
    * player.elementsEfficiency = [{ rate: 2, element: Elements.Ice }]
    * 
    * console.log(player.elementsEfficiency) // [{ rate: 1, element: 'fire' }, { rate: 2, element: 'ice' }]
    * ``` 
    * @title Set/Get Elements Efficiency
    * @prop {Array<{ rate: number, element: Element}>} player.elementsEfficiency
    * @memberof ElementManager
    * */
    get elementsEfficiency() {
      if (this._class) {
        return [...this._elementsEfficiency, ...this._class.elementsEfficiency];
      }
      return this._elementsEfficiency;
    }
    set elementsEfficiency(val) {
      this._elementsEfficiency = val;
    }
    /** 
     * Retrieves a array of elements assigned to the player and the elements of the weapons / armor equipped
     * 
     * ```ts
     * console.log(player.elements)
     * ``` 
     * @title Get Elements
     * @prop {Array<Element>} player.elements
     * @readonly
     * @memberof ElementManager
     * */
    get elements() {
      let elements = [];
      for (let item of this.equipments) {
        if (item.elements) {
          elements = [...elements, ...item.elements];
        }
      }
      return arrayUniq(elements);
    }
    coefficientElements(otherPlayer) {
      const atkPlayerElements = otherPlayer.elements;
      const playerElements = this.elementsEfficiency;
      let coefficient = 1;
      for (let atkElement of atkPlayerElements) {
        const elementPlayer = playerElements.find((el) => el.element == atkElement.element);
        const elementPlayerDef = this.elementsDefense.find((el) => el.element == atkElement.element);
        if (!elementPlayer)
          continue;
        const fn = this.getFormulas("coefficientElements");
        if (!fn) {
          return coefficient;
        }
        coefficient += fn(atkElement, elementPlayer, elementPlayerDef || {
          rate: 0
        });
      }
      return coefficient;
    }
  }
  applyMixins$2(ElementManager, [ItemFixture]);
  class Gui extends common.EventEmitter {
    constructor(id, player) {
      super();
      this.id = id;
      this.player = player;
      this._close = () => {
      };
      this._blockPlayerInput = false;
    }
    open(data, {
      waitingAction = false,
      blockPlayerInput = false
    } = {}) {
      return new Promise((resolve2) => {
        this.player.moving = false;
        this.player.emit("gui.open", {
          guiId: this.id,
          data
        });
        this._blockPlayerInput = blockPlayerInput;
        if (blockPlayerInput) {
          this.player.canMove = false;
        }
        if (!waitingAction) {
          resolve2(null);
        } else {
          this._close = resolve2;
        }
      });
    }
    close(data) {
      this.player.emit("gui.exit", this.id);
      if (this._blockPlayerInput) {
        this.player.canMove = true;
      }
      this._close(data);
    }
  }
  var HitType;
  (function(HitType2) {
    HitType2["Box"] = "box";
    HitType2["Circle"] = "circle";
    HitType2["Polygon"] = "polygon";
  })(HitType || (HitType = {}));
  var MoveClientMode;
  (function(MoveClientMode2) {
    MoveClientMode2[MoveClientMode2["Disabled"] = 0] = "Disabled";
    MoveClientMode2[MoveClientMode2["ByDirection"] = 1] = "ByDirection";
    MoveClientMode2[MoveClientMode2["Drag"] = 2] = "Drag";
  })(MoveClientMode || (MoveClientMode = {}));
  var Behavior;
  (function(Behavior2) {
    Behavior2[Behavior2["Direction"] = 0] = "Direction";
    Behavior2[Behavior2["Target"] = 1] = "Target";
  })(Behavior || (Behavior = {}));
  var Direction;
  (function(Direction2) {
    Direction2[Direction2["Up"] = 1] = "Up";
    Direction2[Direction2["Down"] = 3] = "Down";
    Direction2[Direction2["Left"] = 4] = "Left";
    Direction2[Direction2["Right"] = 2] = "Right";
    Direction2[Direction2["UpRight"] = 1.5] = "UpRight";
    Direction2[Direction2["DownRight"] = 2.5] = "DownRight";
    Direction2[Direction2["DownLeft"] = 3.5] = "DownLeft";
    Direction2[Direction2["UpLeft"] = 2.5] = "UpLeft";
  })(Direction || (Direction = {}));
  var PlayerType;
  (function(PlayerType2) {
    PlayerType2["Player"] = "player";
    PlayerType2["Event"] = "event";
    PlayerType2["Shape"] = "shape";
  })(PlayerType || (PlayerType = {}));
  var SocketMethods;
  (function(SocketMethods2) {
    SocketMethods2["CameraFollow"] = "cameraFollow";
    SocketMethods2["ShowAnimation"] = "showAnimation";
    SocketMethods2["PlaySound"] = "playSound";
    SocketMethods2["ModeMove"] = "modeMove";
  })(SocketMethods || (SocketMethods = {}));
  var SocketEvents;
  (function(SocketEvents2) {
    SocketEvents2["CallMethod"] = "callMethod";
    SocketEvents2["GameReload"] = "gameReload";
    SocketEvents2["ChangeServer"] = "changeServer";
    SocketEvents2["LoadScene"] = "loadScene";
  })(SocketEvents || (SocketEvents = {}));
  var Control;
  (function(Control2) {
    Control2["Action"] = "action";
    Control2["Attack"] = "attack";
    Control2["Defense"] = "defense";
    Control2["Skill"] = "skill";
    Control2["Back"] = "back";
    Control2[Control2["Up"] = 1] = "Up";
    Control2[Control2["Down"] = 3] = "Down";
    Control2[Control2["Right"] = 2] = "Right";
    Control2[Control2["Left"] = 4] = "Left";
  })(Control || (Control = {}));
  var Input;
  (function(Input2) {
    Input2["Break"] = "break";
    Input2["Backspace"] = "backspace";
    Input2["Tab"] = "tab";
    Input2["Clear"] = "clear";
    Input2["Enter"] = "enter";
    Input2["Shift"] = "shift";
    Input2["Ctrl"] = "ctrl";
    Input2["Alt"] = "alt";
    Input2["Pause"] = "pause/break";
    Input2["CapsLock"] = "caps lock";
    Input2["Escape"] = "escape";
    Input2["Conversion"] = "conversion";
    Input2["NonConversion"] = "non-conversion";
    Input2["Space"] = "space";
    Input2["PageUp"] = "page up";
    Input2["PageDown"] = "page down";
    Input2["End"] = "end";
    Input2["Home"] = "home";
    Input2[Input2["Left"] = 4] = "Left";
    Input2[Input2["Up"] = 1] = "Up";
    Input2[Input2["Right"] = 2] = "Right";
    Input2[Input2["Down"] = 3] = "Down";
    Input2["Select"] = "select";
    Input2["Print"] = "print";
    Input2["Execute"] = "execute";
    Input2["PrintScreen"] = "Print Screen";
    Input2["Insert"] = "insert";
    Input2["Delete"] = "delete";
    Input2["Zero"] = "0";
    Input2["One"] = "1";
    Input2["Two"] = "2";
    Input2["Three"] = "3";
    Input2["Four"] = "4";
    Input2["Five"] = "5";
    Input2["Six"] = "6";
    Input2["Seven"] = "7";
    Input2["Height"] = "8";
    Input2["Nine"] = "9";
    Input2["Equal"] = "=";
    Input2["Semicolon"] = "semicolon (firefox), equals";
    Input2["LessThan"] = "<";
    Input2["Equals"] = "equals (firefox)";
    Input2["Beta"] = "ß";
    Input2["At"] = "@";
    Input2["A"] = "a";
    Input2["B"] = "b";
    Input2["C"] = "c";
    Input2["D"] = "d";
    Input2["E"] = "e";
    Input2["F"] = "f";
    Input2["G"] = "g";
    Input2["H"] = "h";
    Input2["I"] = "i";
    Input2["J"] = "j";
    Input2["K"] = "k";
    Input2["L"] = "l";
    Input2["M"] = "m";
    Input2["N"] = "n";
    Input2["O"] = "o";
    Input2["P"] = "p";
    Input2["Q"] = "q";
    Input2["R"] = "r";
    Input2["S"] = "s";
    Input2["T"] = "t";
    Input2["U"] = "u";
    Input2["V"] = "v";
    Input2["W"] = "w";
    Input2["X"] = "x";
    Input2["Y"] = "y";
    Input2["Z"] = "z";
    Input2["SearchKey"] = "Windows Key / Left ⌘ / Chromebook Search key";
    Input2["NumPad0"] = "numpad 0";
    Input2["NumPad1"] = "numpad 1";
    Input2["NumPad2"] = "numpad 2";
    Input2["NumPad3"] = "numpad 3";
    Input2["NumPad4"] = "numpad 4";
    Input2["NumPad5"] = "numpad 5";
    Input2["NumPad6"] = "numpad 6";
    Input2["NumPad7"] = "numpad 7";
    Input2["NumPad8"] = "numpad 8";
    Input2["NumPad9"] = "numpad 9";
    Input2["Multiply"] = "multiply";
    Input2["Add"] = "add";
    Input2["Subtract"] = "subtract";
    Input2["DecimalPoint"] = "decimal point";
    Input2["Divide"] = "divide";
    Input2["F1"] = "f1";
    Input2["F2"] = "f2";
    Input2["F3"] = "f3";
    Input2["F4"] = "f4";
    Input2["F5"] = "f5";
    Input2["F6"] = "f6";
    Input2["F7"] = "f7";
    Input2["F8"] = "f8";
    Input2["F9"] = "f9";
    Input2["F10"] = "f10";
    Input2["F11"] = "f11";
    Input2["F12"] = "f12";
    Input2["F13"] = "f13";
    Input2["F14"] = "f14";
    Input2["F15"] = "f15";
    Input2["F16"] = "f16";
    Input2["F17"] = "f17";
    Input2["F18"] = "f18";
    Input2["F19"] = "f19";
    Input2["F20"] = "f20";
    Input2["F21"] = "f21";
    Input2["F22"] = "f22";
    Input2["F23"] = "f23";
    Input2["F24"] = "f24";
    Input2["NumLock"] = "num lock";
    Input2["ScrollLock"] = "scroll lock";
    Input2["CircumflexAccent"] = "^";
    Input2["ExclamationMark"] = "!";
    Input2["Hash"] = "#";
    Input2["Dollar"] = "$";
    Input2["AccentU"] = "ù";
    Input2["PageBackward"] = "page backward";
    Input2["PageForWard"] = "page forward";
    Input2["Star"] = "*";
    Input2["DecreaseVolume"] = "decrease volume level";
    Input2["IncreaseVolume"] = "increase volume level";
    Input2["Next"] = "next";
    Input2["Previous"] = "previous";
    Input2["Stop"] = "stop";
    Input2["PlayPause"] = "play/pause";
    Input2["Email"] = "e-mail";
    Input2["SemiColon"] = "semi-colon / ñ";
    Input2["EqualSign"] = "equal sign";
    Input2["Comma"] = "comma";
    Input2["Dash"] = "dash";
    Input2["FowardSlach"] = "forward slash / ç";
    Input2["GraveAccent"] = "grave accent / ñ / æ";
    Input2["OpenBracket"] = "open bracket";
    Input2["BackSlach"] = "back slash";
    Input2["CloseBracket"] = "close bracket / å";
    Input2["SingleQuote"] = "single quote / ø";
    Input2["BackQuote"] = "`";
    Input2["Altgr"] = "altgr";
  })(Input || (Input = {}));
  function isFunction$2(value) {
    return typeof value === "function";
  }
  function createErrorClass(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }
  var UnsubscriptionError = createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors) {
      _super(this);
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
        return i2 + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
    };
  });
  function arrRemove(arr, item) {
    if (arr) {
      var index2 = arr.indexOf(item);
      0 <= index2 && arr.splice(index2, 1);
    }
  }
  var Subscription = function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a, e_2, _b;
      var errors;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                  _a.call(_parentage_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction$2(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors = e instanceof UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors = errors !== null && errors !== void 0 ? errors : [];
                if (err instanceof UnsubscriptionError) {
                  errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                _b.call(_finalizers_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError(errors);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function() {
      var empty = new Subscription2();
      empty.closed = true;
      return empty;
    }();
    return Subscription2;
  }();
  Subscription.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction$2(value.remove) && isFunction$2(value.add) && isFunction$2(value.unsubscribe);
  }
  function execFinalizer(finalizer) {
    if (isFunction$2(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }
  var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };
  var timeoutProvider = {
    setTimeout: function(handler, timeout) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = timeoutProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
    },
    clearTimeout: function(handle) {
      var delegate = timeoutProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: void 0
  };
  function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function() {
      {
        throw err;
      }
    });
  }
  function noop$1() {
  }
  function errorContext(cb) {
    {
      cb();
    }
  }
  var Subscriber = function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber2.create = function(next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };
    Subscriber2.prototype.next = function(value) {
      if (this.isStopped)
        ;
      else {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (this.isStopped)
        ;
      else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped)
        ;
      else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  }(Subscription);
  var _bind = Function.prototype.bind;
  function bind$1(fn, thisArg) {
    return _bind.call(fn, thisArg);
  }
  var ConsumerObserver = function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError(error);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber = function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction$2(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
          error: error !== null && error !== void 0 ? error : void 0,
          complete: complete !== null && complete !== void 0 ? complete : void 0
        };
      } else {
        var context_1;
        if (_this && config.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind$1(observerOrNext.next, context_1),
            error: observerOrNext.error && bind$1(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind$1(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber);
  function handleUnhandledError(error) {
    {
      reportUnhandledError(error);
    }
  }
  function defaultErrorHandler(err) {
    throw err;
  }
  var EMPTY_OBSERVER = {
    closed: true,
    next: noop$1,
    error: defaultErrorHandler,
    complete: noop$1
  };
  var observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
  function identity(x) {
    return x;
  }
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }
  var Observable = function() {
    function Observable2(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable2 = new Observable2();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
      errorContext(function() {
        var _a = _this, operator = _a.operator, source = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve2, reject) {
        var subscriber = new SafeSubscriber({
          next: function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve2
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var _a;
      return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable2.prototype[observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve2, reject) {
        var value;
        _this.subscribe(function(x) {
          return value = x;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve2(value);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver(value) {
    return value && isFunction$2(value.next) && isFunction$2(value.error) && isFunction$2(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
  }
  function hasLift(source) {
    return isFunction$2(source === null || source === void 0 ? void 0 : source.lift);
  }
  function operate(init2) {
    return function(source) {
      if (hasLift(source)) {
        return source.lift(function(liftedSource) {
          try {
            return init2(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  function createOperatorSubscriber(destination, onNext, onComplete, onError2, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError2, onFinalize);
  }
  var OperatorSubscriber = function(_super) {
    __extends(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError2, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value) {
        try {
          onNext(value);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError2 ? function(err) {
        try {
          onError2(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber2.prototype.unsubscribe = function() {
      var _a;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
      }
    };
    return OperatorSubscriber2;
  }(Subscriber);
  function isScheduler(value) {
    return value && isFunction$2(value.schedule);
  }
  function last(arr) {
    return arr[arr.length - 1];
  }
  function popScheduler(args) {
    return isScheduler(last(args)) ? args.pop() : void 0;
  }
  var isArrayLike = function(x) {
    return x && typeof x.length === "number" && typeof x !== "function";
  };
  function isPromise$1(value) {
    return isFunction$2(value === null || value === void 0 ? void 0 : value.then);
  }
  function isInteropObservable(input) {
    return isFunction$2(input[observable]);
  }
  function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction$2(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
  }
  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  var iterator = getSymbolIterator();
  function isIterable(input) {
    return isFunction$2(input === null || input === void 0 ? void 0 : input[iterator]);
  }
  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a, value, done2;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            reader = readableStream.getReader();
            _b.label = 1;
          case 1:
            _b.trys.push([1, , 9, 10]);
            _b.label = 2;
          case 2:
            return [4, __await(reader.read())];
          case 3:
            _a = _b.sent(), value = _a.value, done2 = _a.done;
            if (!done2)
              return [3, 5];
            return [4, __await(void 0)];
          case 4:
            return [2, _b.sent()];
          case 5:
            return [4, __await(value)];
          case 6:
            return [4, _b.sent()];
          case 7:
            _b.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }
  function isReadableStreamLike(obj) {
    return isFunction$2(obj === null || obj === void 0 ? void 0 : obj.getReader);
  }
  function innerFrom(input) {
    if (input instanceof Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise$1(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw createInvalidObservableTypeError(input);
  }
  function fromInteropObservable(obj) {
    return new Observable(function(subscriber) {
      var obs = obj[observable]();
      if (isFunction$2(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  function fromArrayLike(array2) {
    return new Observable(function(subscriber) {
      for (var i2 = 0; i2 < array2.length && !subscriber.closed; i2++) {
        subscriber.next(array2[i2]);
      }
      subscriber.complete();
    });
  }
  function fromPromise(promise) {
    return new Observable(function(subscriber) {
      promise.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError);
    });
  }
  function fromIterable(iterable) {
    return new Observable(function(subscriber) {
      var e_1, _a;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
            _a.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  function fromAsyncIterable(asyncIterable) {
    return new Observable(function(subscriber) {
      process$1(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  }
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
  }
  function process$1(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter(this, void 0, void 0, function() {
      var value, e_2_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
              return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
              return [3, 8];
            return [4, _a.call(asyncIterable_1)];
          case 7:
            _b.sent();
            _b.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2)
              throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }
  function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === void 0) {
      delay = 0;
    }
    if (repeat === void 0) {
      repeat = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat) {
        parentSubscription.add(this.schedule(null, delay));
      } else {
        this.unsubscribe();
      }
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
      return scheduleSubscription;
    }
  }
  function observeOn(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return operate(function(source, subscriber) {
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.next(value);
        }, delay);
      }, function() {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay);
      }, function(err) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.error(err);
        }, delay);
      }));
    });
  }
  function subscribeOn(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return operate(function(source, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source.subscribe(subscriber);
      }, delay));
    });
  }
  function scheduleObservable(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }
  function schedulePromise(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }
  function scheduleArray(input, scheduler) {
    return new Observable(function(subscriber) {
      var i2 = 0;
      return scheduler.schedule(function() {
        if (i2 === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i2++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }
  function scheduleIterable(input, scheduler) {
    return new Observable(function(subscriber) {
      var iterator$1;
      executeSchedule(subscriber, scheduler, function() {
        iterator$1 = input[iterator]();
        executeSchedule(subscriber, scheduler, function() {
          var _a;
          var value;
          var done2;
          try {
            _a = iterator$1.next(), value = _a.value, done2 = _a.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done2) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function() {
        return isFunction$2(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return();
      };
    });
  }
  function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable(function(subscriber) {
      executeSchedule(subscriber, scheduler, function() {
        var iterator2 = input[Symbol.asyncIterator]();
        executeSchedule(subscriber, scheduler, function() {
          iterator2.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }
  function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
  }
  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable(input)) {
        return scheduleObservable(input, scheduler);
      }
      if (isArrayLike(input)) {
        return scheduleArray(input, scheduler);
      }
      if (isPromise$1(input)) {
        return schedulePromise(input, scheduler);
      }
      if (isAsyncIterable(input)) {
        return scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable(input)) {
        return scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike(input)) {
        return scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw createInvalidObservableTypeError(input);
  }
  function from(input, scheduler) {
    return scheduler ? scheduled(input, scheduler) : innerFrom(input);
  }
  function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = popScheduler(args);
    return from(args, scheduler);
  }
  function switchMap(project, resultSelector) {
    return operate(function(source, subscriber) {
      var innerSubscriber = null;
      var index2 = 0;
      var isComplete = false;
      var checkComplete = function() {
        return isComplete && !innerSubscriber && subscriber.complete();
      };
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
        var innerIndex = 0;
        var outerIndex = index2++;
        innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
          return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
        }, function() {
          innerSubscriber = null;
          checkComplete();
        }));
      }, function() {
        isComplete = true;
        checkComplete();
      }));
    });
  }
  function takeUntil(notifier) {
    return operate(function(source, subscriber) {
      innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
        return subscriber.complete();
      }, noop$1));
      !subscriber.closed && source.subscribe(subscriber);
    });
  }
  function tap(observerOrNext, error, complete) {
    var tapObserver = isFunction$2(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
    return tapObserver ? operate(function(source, subscriber) {
      var _a;
      (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
      var isUnsub = true;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var _a2;
        (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
        subscriber.next(value);
      }, function() {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        subscriber.complete();
      }, function(err) {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
        subscriber.error(err);
      }, function() {
        var _a2, _b;
        if (isUnsub) {
          (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        }
        (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
      }));
    }) : identity;
  }
  const {
    arrayFlat,
    random,
    isFunction: isFunction$1,
    capitalize
  } = common.Utils;
  function wait(sec) {
    return new Promise((resolve2) => {
      setTimeout(resolve2, sec * 1e3);
    });
  }
  var Frequency = /* @__PURE__ */ ((Frequency2) => {
    Frequency2[Frequency2["Lowest"] = 600] = "Lowest";
    Frequency2[Frequency2["Lower"] = 400] = "Lower";
    Frequency2[Frequency2["Low"] = 200] = "Low";
    Frequency2[Frequency2["High"] = 100] = "High";
    Frequency2[Frequency2["Higher"] = 50] = "Higher";
    Frequency2[Frequency2["Highest"] = 25] = "Highest";
    Frequency2[Frequency2["None"] = 0] = "None";
    return Frequency2;
  })(Frequency || {});
  var Speed = /* @__PURE__ */ ((Speed2) => {
    Speed2[Speed2["Slowest"] = 0.2] = "Slowest";
    Speed2[Speed2["Slower"] = 0.5] = "Slower";
    Speed2[Speed2["Slow"] = 1] = "Slow";
    Speed2[Speed2["Normal"] = 3] = "Normal";
    Speed2[Speed2["Fast"] = 5] = "Fast";
    Speed2[Speed2["Faster"] = 7] = "Faster";
    Speed2[Speed2["Fastest"] = 10] = "Fastest";
    return Speed2;
  })(Speed || {});
  class MoveList {
    repeatMove(direction, repeat) {
      return new Array(repeat).fill(direction);
    }
    repeatTileMove(direction, repeat, propMap) {
      return (player, map) => {
        const repeatTile = Math.floor(map[propMap] / player.speed) * repeat;
        return this[direction](repeatTile);
      };
    }
    right(repeat = 1) {
      return this.repeatMove(common.Direction.Right, repeat);
    }
    left(repeat = 1) {
      return this.repeatMove(common.Direction.Left, repeat);
    }
    up(repeat = 1) {
      return this.repeatMove(common.Direction.Up, repeat);
    }
    down(repeat = 1) {
      return this.repeatMove(common.Direction.Down, repeat);
    }
    wait(sec) {
      return wait(sec);
    }
    random(repeat = 1) {
      return new Array(repeat).fill(null).map(() => [common.Direction.Right, common.Direction.Left, common.Direction.Up, common.Direction.Down][random(0, 3)]);
    }
    tileRight(repeat = 1) {
      return this.repeatTileMove("right", repeat, "tileWidth");
    }
    tileLeft(repeat = 1) {
      return this.repeatTileMove("left", repeat, "tileWidth");
    }
    tileUp(repeat = 1) {
      return this.repeatTileMove("up", repeat, "tileHeight");
    }
    tileDown(repeat = 1) {
      return this.repeatTileMove("down", repeat, "tileHeight");
    }
    tileRandom(repeat = 1) {
      return (player, map) => {
        let directions = [];
        for (let i2 = 0; i2 < repeat; i2++) {
          const randFn = [this.tileRight(), this.tileLeft(), this.tileUp(), this.tileDown()][random(0, 3)];
          directions = [...directions, ...randFn(player, map)];
        }
        return directions;
      };
    }
    _awayFromPlayerDirection(player, otherPlayer) {
      const directionOtherPlayer = otherPlayer.getDirection();
      let newDirection = 0;
      switch (directionOtherPlayer) {
        case common.Direction.Left:
        case common.Direction.Right:
          if (otherPlayer.position.x > player.position.x) {
            newDirection = common.Direction.Left;
          } else {
            newDirection = common.Direction.Right;
          }
          break;
        case common.Direction.Up:
        case common.Direction.Down:
          if (otherPlayer.position.y > player.position.y) {
            newDirection = common.Direction.Up;
          } else {
            newDirection = common.Direction.Down;
          }
          break;
      }
      return newDirection;
    }
    _towardPlayerDirection(player, otherPlayer) {
      const directionOtherPlayer = otherPlayer.getDirection();
      let newDirection = 0;
      switch (directionOtherPlayer) {
        case common.Direction.Left:
        case common.Direction.Right:
          if (otherPlayer.position.x > player.position.x) {
            newDirection = common.Direction.Right;
          } else {
            newDirection = common.Direction.Left;
          }
          break;
        case common.Direction.Up:
        case common.Direction.Down:
          if (otherPlayer.position.y > player.position.y) {
            newDirection = common.Direction.Down;
          } else {
            newDirection = common.Direction.Up;
          }
          break;
      }
      return newDirection;
    }
    _awayFromPlayer({
      isTile,
      typeMov
    }, otherPlayer, repeat = 1) {
      const method2 = (dir) => {
        const direction = common.LiteralDirection[dir];
        return this[isTile ? "tile" + capitalize(direction) : direction](repeat);
      };
      return (player, map) => {
        let newDirection = 0;
        switch (typeMov) {
          case "away":
            newDirection = this._awayFromPlayerDirection(player, otherPlayer);
            break;
          case "toward":
            newDirection = this._towardPlayerDirection(player, otherPlayer);
            break;
        }
        let direction = method2(newDirection);
        if (isFunction$1(direction)) {
          direction = direction(player, map);
        }
        return direction;
      };
    }
    towardPlayer(player, repeat = 1) {
      return this._awayFromPlayer({
        isTile: false,
        typeMov: "toward"
      }, player, repeat);
    }
    tileTowardPlayer(player, repeat = 1) {
      return this._awayFromPlayer({
        isTile: true,
        typeMov: "toward"
      }, player, repeat);
    }
    awayFromPlayer(player, repeat = 1) {
      return this._awayFromPlayer({
        isTile: false,
        typeMov: "away"
      }, player, repeat);
    }
    tileAwayFromPlayer(player, repeat = 1) {
      return this._awayFromPlayer({
        isTile: true,
        typeMov: "away"
      }, player, repeat);
    }
    turnLeft() {
      return "turn-" + common.Direction.Left;
    }
    turnRight() {
      return "turn-" + common.Direction.Right;
    }
    turnUp() {
      return "turn-" + common.Direction.Up;
    }
    turnDown() {
      return "turn-" + common.Direction.Down;
    }
    turnRandom() {
      return [this.turnRight(), this.turnLeft(), this.turnUp(), this.turnDown()][random(0, 3)];
    }
    turnAwayFromPlayer(otherPlayer) {
      return (player) => {
        const direction = this._awayFromPlayerDirection(player, otherPlayer);
        return "turn-" + direction;
      };
    }
    turnTowardPlayer(otherPlayer) {
      return (player) => {
        const direction = this._towardPlayerDirection(player, otherPlayer);
        return "turn-" + direction;
      };
    }
  }
  const Move = new MoveList();
  class MoveManager {
    /**
     * Gives an itinerary. 
     * 
     * You can create your own motion function:
     * 
     * ```ts
     * import { Direction } from '@rpgjs/server'
     * 
     * const customMove = () => {
     *      return [Direction.Left, Direction.Up]
     * }
     * 
     * player.moveRoutes([ customMove() ])
     * ```
     * 
     * Your function can also return a function:
     * 
     *  ```ts
     * import { Direction, RpgPlayer } from '@rpgjs/server'
     * 
     * // This function can be found in another file. By returning a function, you have access to the player who is making a move.
     * const customMove = (otherPlayer: RpgPlayer) => {
     *      return (player: RpgPlayer, map) => {
     *          return otherPlayer.position.x > player.position.x ? Direction.Left : Direction.Right
     *      }
     * }
     * 
     * player.moveRoutes([ customMove(otherPlayer) ])
     * ```
     * 
     * the function contains two parameters:
     * 
     * - `player`: the player concerned by the movement
     * - `map`: The information of the current map
     * 
     * @title Give an itinerary
     * @method player.moveRoutes(routes)
     * @param {Array<Move>} routes
     * @returns {Promise}
     * @memberof MoveManager
     * @example 
     * 
     * ```ts
     * import { Move } from '@rpgjs/server'
     * 
     * await player.moveRoutes([ Move.tileLeft(), Move.tileDown(2) ])
     * // The path is over when the promise is resolved
     * ```
     */
    moveRoutes(routes) {
      let count = 0;
      let frequence = 0;
      this.breakRoutes();
      return new Promise(async (resolve2) => {
        this._finishRoute = resolve2;
        routes = routes.map((route) => {
          if (isFunction$1(route)) {
            const map = this.getCurrentMap();
            if (!map) {
              return void 0;
            }
            return route.apply(route, [this, map]);
          }
          return route;
        });
        routes = arrayFlat(routes);
        const move = () => {
          if (!this) {
            return of(null);
          }
          if (!this.getCurrentMap()) {
            return of(null);
          }
          if (count >= this["nbPixelInTile"]) {
            if (frequence < this.frequency) {
              frequence++;
              return of(null);
            }
          }
          frequence = 0;
          count++;
          const [route] = routes;
          if (route === void 0) {
            this.breakRoutes();
            return of(null);
          }
          let ob$ = new Observable();
          switch (route) {
            case common.Direction.Left:
            case common.Direction.Down:
            case common.Direction.Right:
            case common.Direction.Up:
              ob$ = from(this.moveByDirection(route, 1));
              break;
            case "turn-" + common.Direction.Left:
              ob$ = of(this.changeDirection(common.Direction.Left));
              break;
            case "turn-" + common.Direction.Right:
              ob$ = of(this.changeDirection(common.Direction.Right));
              break;
            case "turn-" + common.Direction.Up:
              ob$ = of(this.changeDirection(common.Direction.Up));
              break;
            case "turn-" + common.Direction.Down:
              ob$ = of(this.changeDirection(common.Direction.Down));
              break;
          }
          return ob$.pipe(tap(() => {
            routes.shift();
          }));
        };
        this.movingSubscription = this.server.tick.pipe(takeUntil(this._destroy$.pipe(tap(() => {
          this.breakRoutes(true);
        }))), switchMap(move)).subscribe();
      });
    }
    /**
     * Giving a path that repeats itself in a loop to a character
     * 
     * You can stop the movement at any time with `breakRoutes()` and replay it with `replayRoutes()`.
     * 
     * @title Infinite Move Routes
     * @method player.infiniteMoveRoute(routes)
     * @param {Array<Move>} routes
     * @returns {void}
     * @memberof MoveManager
     * @example 
     * 
     * ```ts
     * import { Move } from '@rpgjs/server'
     * 
     * player.infiniteMoveRoute([ Move.tileRandom() ])
     * ```
     */
    infiniteMoveRoute(routes) {
      this._infiniteRoutes = routes;
      const move = (isBreaking) => {
        if (isBreaking)
          return;
        this.moveRoutes(routes).then(move);
      };
      move(false);
    }
    /**
     * Works only for infinite movements. You must first use the method `infiniteMoveRoute()`
     * 
     * @title Stop an infinite movement
     * @method player.breakRoutes(force=false)
     * @param {boolean} [force] Forces the stop of the infinite movement
     * @returns {void}
     * @memberof MoveManager
     * @example 
     * 
     * ```ts
     * import { Move } from '@rpgjs/server'
     * 
     * player.infiniteMoveRoute([ Move.tileRandom() ])
     * player.breakRoutes(true)
     * ```
     */
    breakRoutes(force = false) {
      var _a;
      if (this._finishRoute) {
        (_a = this.movingSubscription) == null ? void 0 : _a.unsubscribe();
        this._finishRoute(force);
      }
    }
    /**
     * Works only for infinite movements. You must first use the method `infiniteMoveRoute()`
     * If the road was stopped with `breakRoutes()`, you can restart it with this method
     * 
     * @title Replay an infinite movement
     * @method player.replayRoutes()
     * @returns {void}
     * @memberof MoveManager
     * @example 
     * 
     * ```ts
     * import { Move } from '@rpgjs/server'
     * 
     * player.infiniteMoveRoute([ Move.tileRandom() ])
     * player.breakRoutes(true)
     * player.replayRoutes()
     * ```
     */
    replayRoutes() {
      if (this._infiniteRoutes)
        this.infiniteMoveRoute(this._infiniteRoutes);
    }
    moveTo(position, options2) {
      return this["_moveTo"](this.server.tick, position, options2);
    }
    // TODO
    setMoveMode(mode) {
      if (mode.checkCollision)
        this.checkCollision = mode.checkCollision;
      if (mode.clientMode)
        this.clientModeMove = mode.clientMode;
      if (mode.behavior)
        this.behavior = mode.behavior;
      this.emit(SocketEvents.CallMethod, {
        objectId: this.id,
        name: SocketMethods.ModeMove,
        params: [mode]
      });
    }
  }
  class DialogGui extends Gui {
    constructor(player) {
      super(common.PrebuiltGui.Dialog, player);
    }
    openDialog(message, options2) {
      if (!options2.choices)
        options2.choices = [];
      if (options2.autoClose == void 0)
        options2.autoClose = false;
      if (!options2.position)
        options2.position = "bottom";
      if (options2.fullWidth == void 0)
        options2.fullWidth = true;
      if (options2.typewriterEffect == void 0)
        options2.typewriterEffect = true;
      const event = options2.talkWith;
      let memoryDir;
      if (event) {
        memoryDir = event.direction;
        event.breakRoutes(true);
        event.moveRoutes([Move.turnTowardPlayer(this.player)]);
      }
      const data = {
        autoClose: options2.autoClose,
        position: options2.position,
        fullWidth: options2.fullWidth,
        typewriterEffect: options2.typewriterEffect,
        // remove value property. It is not useful to know this on the client side.
        choices: options2.choices.map((choice) => ({
          text: choice.text
        }))
      };
      return super.open({
        message,
        ...data
      }, {
        waitingAction: true,
        blockPlayerInput: true
      }).then((val) => {
        if (event) {
          event.replayRoutes();
          event.direction = memoryDir;
        }
        return val;
      });
    }
  }
  class MenuGui extends Gui {
    constructor(player) {
      super(common.PrebuiltGui.MainMenu, player);
    }
    open() {
      this.on("useItem", (id) => {
        try {
          this.player.useItem(id);
          this.player.syncChanges();
        } catch (err) {
          this.player.showNotification(err.msg);
        }
      });
      return super.open("", {
        waitingAction: true,
        blockPlayerInput: true
      });
    }
  }
  class ShopGui extends Gui {
    constructor(player) {
      super(common.PrebuiltGui.Shop, player);
    }
    open(items) {
      items = items.map((item) => {
        const it = new item();
        return {
          price: it.price,
          name: it.name,
          description: it.description,
          id: it.id,
          type: item.type
        };
      });
      this.on("buyItem", ({
        id,
        nb
      }) => {
        try {
          this.player.buyItem(id, nb);
        } catch (err) {
          console.log(err);
        }
      });
      this.on("sellItem", ({
        id,
        nb
      }) => {
        try {
          this.player.sellItem(id, nb);
        } catch (err) {
          console.log(err);
        }
      });
      return super.open({
        items
      }, {
        waitingAction: true,
        blockPlayerInput: true
      });
    }
  }
  class NotificationGui extends Gui {
    constructor(player) {
      super(common.PrebuiltGui.Notification, player);
    }
  }
  class GuiManager {
    /**
     * Show a text. This is a graphical interface already built. Opens the GUI named `rpg-dialog`
     * 
     * ```ts
     * player.showText('Hello World')
     * ```
     * 
     * The method returns a promise. It is resolved when the dialog box is closed.
     * 
     * ```ts
     * await player.showText('Hello World')
     * // dialog box is closed, then ...
     * ```
     * 
     * **Option: position**
     * 
     * You can define how the dialog box is displayed:
     * - top
     * - middle
     * - bottom
     * 
     * (bottom by default)
     * 
     * ```ts
     * player.showText('Hello World', {
     *      position: 'top'
     * })
     * ```
     * 
     * **Option: fullWidth**
     * 
     * `boolean` (true by default)
     * 
     * Indicate that the dialog box will take the full width of the screen.
     * 
     * ```ts
     * player.showText('Hello World', {
     *      fullWidth: true
     * })
     * ```
     * 
     * **Option: autoClose**
     * 
     * `boolean` (false by default)
     * 
     * If false, the user will have to press Enter to close the dialog box.
     * 
     *  ```ts
     * player.showText('Hello World', {
     *      autoClose: true
     * })
     * ```
     * 
     * **Option: typewriterEffect**
     * 
     * `boolean` (true by default)
     * 
     * Performs a typewriter effect
     * 
     *  ```ts
     * player.showText('Hello World', {
     *      typewriterEffect: false
     * })
     * ```
     * 
     * **Option: talkWith**
     * 
     * `RpgPlayer` (nothing by default)
     * 
     * If you specify the event or another player, the other player will stop his or her movement and look in the player's direction.
     * 
     *  ```ts
     * // Code in an event
     * player.showText('Hello World', {
     *      talkWith: this
     * })
     * ```
     * 
     * @title Show Text 
     * @method player.showText(text,options)
     * @param {string} text 
     * @param {object} [options] the different options, see usage below
     * @returns {Promise}
     * @memberof GuiManager
     */
    showText(msg, options2 = {}) {
      const gui = new DialogGui(this);
      this._gui[gui.id] = gui;
      return gui.openDialog(msg, options2);
    }
    /**
     * Shows a dialog box with a choice. Opens the GUI named `rpg-dialog`
     * 
     * ```ts
     * const choice = await player.showChoices('What color do you prefer?', [
     *      { text: 'Black', value: 'black' },
     *      { text: 'Rather the blue', value: 'blue' },
     *      { text: 'I don\'t have a preference!', value: 'none' }
     * ])
     * 
     * // If the player selects the first
     * console.log(choice) // { text: 'Black', value: 'black' }
     * ```
     * 
     * @title Show Choices 
     * @method player.showChoices(text,choices)
     * @param {string} text 
     * @param {Array<{ text: string, value: any }>} choices
     * @param {object} [options] Same options as the openDialog method
     * @returns {Promise<Choice | null>}
     * @memberof GuiManager
     */
    showChoices(msg, choices, options2) {
      return this.showText(msg, {
        choices,
        ...options2
      }).then((indexSelected) => {
        if (!choices[indexSelected])
          return null;
        return choices[indexSelected];
      });
    }
    /**
     * Displays a notification . Opens the GUI named `rpg-notification`
     * 
     * @title Displays a notification
     * @method player.showNotification()
     * @param {string} message - The message to display in the notification
     * @param {object} options - An object containing options for the notification
     * @param {number} options.time - The time to display the notification for (in ms). Default: 2000ms
     * @param {string} options.icon - The icon to display in the notification. Put the identifier of the spritesheet (defined on the client side)
     * @param {string} options.sound - The sound to play when the notification is shown. Set the sound ID (defined on the client side)
     * @returns {void}
     * @memberof GuiManager
     */
    showNotification(message, options2 = {}) {
      const gui = new NotificationGui(this);
      this._gui[gui.id] = gui;
      const data = {
        message,
        ...options2
      };
      return gui.open(data);
    }
    /**
     * Calls main menu. Opens the GUI named `rpg-main-menu`
     * 
     * @title Call Main Menu
     * @method player.callMainMenu()
     * @returns {void}
     * @memberof GuiManager
     */
    callMainMenu() {
      const gui = new MenuGui(this);
      this._gui[gui.id] = gui;
      return gui.open();
    }
    /**
     * Calls shop menu. Opens the GUI named `rpg-shop`
     * 
     * @title Call Shop Menu
     * @method player.callShop()
     * @returns {void}
     * @memberof GuiManager
     */
    callShop(items) {
      const gui = new ShopGui(this);
      this._gui[gui.id] = gui;
      return gui.open(items);
    }
    /**
         * Call a custom Gui
    
         * ```ts
         * // Calls a client-side component, created with VueJS, named "inn".
         * const gui = player.gui('inn')
         * 
         *  // You can wait for actions on the menu. It only works if the menu is open.
         * gui.on('accept', () => {
         *      player.allRecovery()
         * })
         * 
         * // The GUI is opened by passing recoverable data on the client side.
         * gui.open({ hello: 'world' })
         * ```
         * 
         * When opening the GUI, one can give options
         * 
         * ```ts
         * await gui.open({ hello: 'world' }, {
         *      waitingAction: true,
         *      blockPlayerInput: true
         * })
         * // After the GUI is closed
         * ```
         * 
         * - `blockPlayerInput`: while the GUI is open, the player can not move on the map
         * - `waitingAction`: We explicitly wait until the GUI is closed for the promise to be resolved.
         * 
         * @title Call custom GUI
         * @method player.gui(guiId)
         * @param {string} guiId
         * @returns {Gui}
         * @memberof GuiManager
         */
    gui(guiId) {
      const gui = new Gui(guiId, this);
      this._gui[guiId] = gui;
      return gui;
    }
    /**
     * Closes the GUI and removes it from memory
     * 
     * @title Close custom GUI
     * @method player.removeGui(guiId,data)
     * @param {string} guiId
     * @param {object} [data] Passing data if you close the GUI 
     * @returns {Gui}
     * @memberof GuiManager
     */
    removeGui(guiId, data) {
      if (this._gui[guiId]) {
        this._gui[guiId].close(data);
        delete this._gui[guiId];
      }
    }
    _attachedGui(players, display) {
      if (!common.Utils.isArray(players)) {
        players = [players];
      }
      this.emit("gui.tooltip", {
        players: players.map((player) => player.id),
        display
      });
    }
    /** 
     * Display the GUI attached to the players
     * 
     * If you don't specify the players as parameters, it will display the GUI of the instance 
     * But you can specify which GUIs to display by specifying the players as the first parameter
     * 
     * @title View to GUI attached
     * @method player.showAttachedGui(players?)
     * @param {RpgPlayer[] | RpgPlayer} [players] The GUIs attached to the players to display
     * @since 3.0.0-beta.5
     * @example
     * ```ts
     * player.showAttachedGui()
     * ```
     * ```ts
     * player.showAttachedGui(aPlayer)
     * ```
     * ```ts
     * player.showAttachedGui([player1, player2])
     * ```
     * @memberof GuiManager
     * */
    showAttachedGui(players) {
      const _players = players || this;
      this._attachedGui(_players, true);
    }
    /** 
     * Hide the GUI attached to the players
     * 
     * @title Hide to GUI attached
     * @method player.hideAttachedGui(players?)
     * @param {RpgPlayer[] | RpgPlayer} [players] The GUIs attached to the players to hide
     * @since 3.0.0-beta.5
     * @example
     * ```ts
     * player.hideAttachedGui()
     * ```
     * ```ts
     * player.hideAttachedGui(aPlayer)
     * ```
     * ```ts
     * player.hideAttachedGui([player1, player2])
     * ```
     * @memberof GuiManager
     * */
    hideAttachedGui(players) {
      const _players = players || this;
      this._attachedGui(_players, false);
    }
  }
  class VariableManager {
    /** 
     * Assign a variable to the player
     * 
     * ```ts
     * player.setVariable('OPEN_CHEST', true)
     * ```
     * 
     * @title Set variable
     * @method player.setVariable(key,val)
     * @param {string} key
     * @param {any} val
     * @returns {void}
     * @memberof VariableManager
     * */
    setVariable(key, val) {
      this.variables.set(key, val);
    }
    /** 
     * Get a variable
     * 
     * ```ts
     * const val = player.getVariable('OPEN_CHEST')
     * ```
     * 
     * @title Get variable
     * @method player.setVariable(key,val)
     * @param {string} key
     * @returns {any} 
     * @memberof VariableManager
     * */
    getVariable(key) {
      return this.variables.get(key);
    }
    /** 
     * Remove a variable
     * 
     * ```ts
     * player.removeVariable('OPEN_CHEST')
     * ```
     * 
     * @title Remove variable
     * @method player.removeVariable(key)
     * @param {string} key
     * @returns {boolean} true if a variable existed and has been removed, or false if the variable does not exist.
     * @memberof VariableManager
     * */
    removeVariable(key) {
      return this.variables.delete(key);
    }
  }
  const {
    applyMixins: applyMixins$1
  } = common.Utils;
  class BattleManager {
    /** 
     * Apply damage. Player will lose HP. the `attackerPlayer` parameter is the other player, the one who attacks.
     * 
     * If you don't set the skill parameter, it will be a physical attack.
     * The attack formula is already defined but you can customize it in the server options
     * 
     * ```ts
     * player.applyDamage(attackerPlayer) // returns { damage: number }
     * ```
     * 
     * @title Apply Damage
     * @method player.applyDamage(attackerPlayer,skill)
     * @param {RpgPlayer} attackerPlayer The attacking player
     * @param {any} [skill]
     * @returns {object} 
     * @memberof BattleManager
     * */
    applyDamage(attackerPlayer, skill) {
      const getParam = (player) => {
        const params = {};
        this.parameters.forEach((val, key) => {
          params[key] = player.param[key];
        });
        return {
          [ATK]: player.atk,
          [PDEF]: player.pdef,
          [SDEF]: player.sdef,
          ...params
        };
      };
      let damage = 0, fn;
      let critical = false;
      let guard = false;
      let superGuard = false;
      let elementVulnerable = false;
      const paramA = getParam(attackerPlayer);
      const paramB = getParam(this);
      if (skill) {
        fn = this.getFormulas("damageSkill");
        if (!fn) {
          throw new Error("Skill Formulas not exists");
        }
        damage = fn(paramA, paramB, skill);
      } else {
        fn = this.getFormulas("damagePhysic");
        if (!fn) {
          throw new Error("Physic Formulas not exists");
        }
        damage = fn(paramA, paramB);
        const coef = this.coefficientElements(attackerPlayer);
        if (coef >= 2) {
          elementVulnerable = true;
        }
        damage *= coef;
        fn = this.getFormulas("damageCritical");
        if (fn) {
          let newDamage = fn(damage, paramA, paramB);
          if (damage != newDamage) {
            critical = true;
          }
          damage = newDamage;
        }
      }
      if (this.hasEffect(database.Effect.GUARD)) {
        fn = this.getFormulas("damageGuard");
        if (fn) {
          let newDamage = fn(damage, paramA, paramB);
          if (damage != newDamage) {
            guard = true;
          }
          damage = newDamage;
        }
      }
      if (this.hasEffect(database.Effect.SUPER_GUARD)) {
        damage /= 4;
        superGuard = true;
      }
      this.hp -= damage;
      return {
        damage,
        critical,
        elementVulnerable,
        guard,
        superGuard
      };
    }
    getFormulas(name) {
      return this.server.damageFormulas[name];
    }
  }
  applyMixins$1(BattleManager, [ParameterManager, ElementManager, EffectManager]);
  const defaultStyle = (style) => ({
    borderColor: "#000000",
    borderWidth: 2,
    bgColor: "#000000",
    borderRadius: 5,
    ...style
  });
  const bar = (current, max, style, text) => {
    return {
      id: "bar",
      value: {
        current,
        max,
        text: text === null ? "" : text || "{$current}/{$max}",
        style
      }
    };
  };
  const Components = {
    /**
     * Displays a bar
     * 
     * Example:
     * 
     * ```ts
     * import { Components } from '@rpgjs/server'
     * Components.bar('hp', 'param.maxHp', {
     *    bgColor: '#ab0606'
     * })
     * ```
     * 
     * For text, you can use the following variables:
     * - {$current} current value
     * - {$max} maximum value
     * - {$percent} percentage
     * 
     * Example:
     * 
     * ```ts
     * import { Components } from '@rpgjs/server'
     * Components.bar('hp', 'param.maxHp', {
     *   bgColor: '#ab0606'
     * }, 'HP: {$current}/{$max}')
     * ```
     * 
     * and you can also use the variables of player:
     * 
     * ```ts
     * import { Components } from '@rpgjs/server'
     * Components.bar('hp', 'param.maxHp', {
     *  bgColor: '#ab0606'
     * }, 'HP: {$current}/{$max} - {name}') // HP: 100/100 - John
     * ```
     * 
     * @title Bar Component
     * @param {string} current Parameter that corresponds to the current value
     * @param {string} max Parameter that corresponds to the maximum value
     * @param {object} [style] style
     * @param {string} [style.bgColor] background color. Hexadecimal format.
     * @param {string} [style.fillColor] fill color. Hexadecimal format.
     * @param {string} [style.borderColor] border color. Hexadecimal format.
     * @param {number} [style.borderWidth] border width
     * @param {number} [style.height] height
     * @param {number} [style.width] width
     * @param {number} [style.borderRadius] border radius
     * @param {number} [style.opacity] opacity
     * @param {string | null} [text] text above bar. if null, no text will be displayed. You can use the variables
     * @returns {BarComponentObject}
     * @memberof Components
     * @since 3.3.0
     */
    bar,
    /**
     * Displays a life bar
     * 
     * @title HP Bar Component
     * @param {object} [style] style. See bar style (Components.bar())
     * @param {string | null} [text] test above bar (Components.bar())
     * @returns {BarComponentObject}
     * @memberof Components
     * @since 3.3.0
     */
    hpBar(style, text) {
      return bar("hp", "param.maxHp", {
        ...defaultStyle({
          fillColor: "#ab0606"
        }),
        ...style || {}
      }, text);
    },
    /**
    * Displays a SP bar
    * 
    * @title SP Bar Component
    * @param {object} [style] style. See bar style (Components.bar())
    * @param {string | null} [text] test above bar (Components.bar())
    * @returns {BarComponentObject}
    * @memberof Components
    * @since 3.3.0
    */
    spBar(style, text) {
      return bar("sp", "param.maxSp", {
        ...defaultStyle({
          fillColor: "#0fa38c"
        }),
        ...style || {}
      }, text);
    },
    /**
    * Put on the text. You can read the content of a variable with {} format (see example below)
    * 
    * Example:
    * 
    * ```ts
    * import { Components } from '@rpgjs/server'
    * Components.text('Hello World')
    * ```
    * 
    * Example with variable:
    * 
    * ```ts
    * import { Components } from '@rpgjs/server'
    * Components.text('{name}')
    * ```
    * 
    * Other example with position:
    * 
    * ```ts
    * import { Components } from '@rpgjs/server'
    * Components.text('X: {position.x} Y: {position.y}')
    * ```
    * 
    * With style:
    * 
    * ```ts
    * import { Components } from '@rpgjs/server'
    * Components.text('Hello World', {
    *      fill: '#ffffff',
    *      fontSize: 20,
    *      fontFamily: 'Arial',
    *      stroke: '#000000',
    *      fontStyle: 'italic',
    *      fontWeight: 'bold'
    * })
    * ```
    * 
    * @title Text Component
    * @param {string} value source
    * @param {object} [style] style
    * @param {string} [style.fill] color. Hexadecimal format.
    * @param {number} [style.fontSize] font size
    * @param {string} [style.fontFamily] font family
    * @param {string} [style.stroke] stroke color. Hexadecimal format.
    * @param {'normal' | 'italic' | 'oblique'} [style.fontStyle] font style
    * @param {'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900'} [style.fontWeight] font weight
    * @param {number} [style.opacity] opacity. Between 0 and 1
    * @param {boolean} [style.wordWrap] word wrap
    * @param {'left' | 'center' | 'right' | 'justify'} [style.align] align
    * @returns {TextComponentObject}
    * @memberof Components
    * @since 3.3.0
    */
    text(value, style) {
      return {
        id: "text",
        value: {
          text: value,
          style: {
            fill: "#ffffff",
            fontSize: 15,
            ...style || {}
          }
        }
      };
    },
    /**
     * Add a shape
     * 
     * Example:
     * 
     * ```ts
     * import { Components } from '@rpgjs/server'
     * Components.shape({
     *      fill: '#ffffff',
     *      type: 'circle',
     *      radius: 10
     * })
     * ```
     * 
     * You can use parameters:
     * 
     * ```ts
     * import { Components } from '@rpgjs/server'
     * Components.shape({
     *      fill: '#ffffff',
     *      type: 'circle',
     *      radius: 'hp'
     * })
     * ```
     * 
     * Here, the radius will be the same as the hp value
     * 
     * @title Shape Component
     * @param {object} value 
     * @param {string} value.fill color. Hexadecimal format.
     * @param {number | string} [value.opacity] opacity. Between 0 and 1
     * @param {string} value.type type of shape. Can be 'circle' or 'rectangle', 'ellipse' or 'polygon', 'line' or 'rounded-rectangle'
     * @param {number | string} [value.radius] if type is circle, radius of the circle
     * @param {number | string} [value.width] if type is rectangle or ellipse, width of the rectangle
     * @param {number | string} [value.height] if type is rectangle or ellipse, height of the rectangle
     * @param {number | string} [value.x1] if type is line, x1 position of the line
     * @param {number | string} [value.y1] if type is line, y1 position of the line
     * @param {number | string} [value.x2] if type is line, x2 position of the line
     * @param {number | string} [value.y2] if type is line, y2 position of the line
     * @param {number[]} [value.points] if type is polygon, points of the polygon
     * @param {object} [value.line] border style
     * @param {string} [value.line.color] border color. Hexadecimal format.
     * @param {number} [value.line.width] border width
     * @param {number} [value.line.alpha] border opacity. Between 0 and 1
     * @returns {ShapeComponentObject}
     * @memberof Components
     * @since 3.3.0
     */
    shape(value) {
      return {
        id: "shape",
        value
      };
    },
    /**
     * Put the link to an image or the identifier of an image (if the spritesheet exists)
     * 
     * Example:
     * 
     * ```ts
     * import { Components } from '@rpgjs/server'
     * Components.image('mygraphic.png')
     * ```
     * 
     * @title Image Component
     * @param {string} value source
     * @returns {ImageComponentObject}
     * @memberof Components
     * @since 3.3.0
     */
    image(value) {
      return {
        id: "image",
        value
      };
    },
    /**
     * Indicates the tile ID
     * 
     * Example:
     * 
     * ```ts
     * import { Components } from '@rpgjs/server'
     * Components.tile(3)
     * ```
     * 
     * @title Tile Component
     * @param {number} value tile ID
     * @returns {TileComponentObject}
     * @memberof Components
     * @since 3.3.0
     */
    tile(value) {
      return {
        id: "tile",
        value
      };
    },
    debug() {
      return {
        id: "debug",
        value: ""
      };
    }
  };
  class ComponentManager {
    /**
     * Give the spritesheet identifier
     * 
     * Since version 3.0.0-rc, you can define several graphic elements. If you put a number, it represents the tile ID in the tileset
     * 
     * Example 1:
     * ```ts
     * player.setGraphic(['body', 'shield'])
     * ```
     * 
     * Example 2:
     * ```ts
     * player.setGraphic(3) // Use tile #3
     * ```
     * 
     * > You must, on the client side, create the spritesheet in question. Guide: [Create Sprite](/guide/create-sprite.html)
     * 
     * @title Set Graphic
     * @method player.setGraphic(graphic)
     * @param {string | number | (string | number)[]} graphic
     * @returns {void}
     * @memberof ComponentManager
     */
    setGraphic(graphic) {
      const components = common.Utils.isArray(graphic) ? graphic : [graphic];
      const col = [...components.map((value) => ({
        id: common.Utils.isString(value) ? "graphic" : "tile",
        value
      }))];
      this.removeComponentById("center", "graphic");
      this.mergeComponent("center", col);
    }
    /**
     * Delete components
     * 
     * @title Remove Components
     * @param {string} position Position of the components. Can be: `top`, `center`, `bottom`, `left`, `right`
     * @memberof ComponentManager
     * @since 3.3.0
     */
    removeComponents(position) {
      this.layout[position].lines = [];
    }
    /**
     * Delete components by id. 
     * 
     * @title Remove Component By Id
     * @param {string} position Position of the components. Can be: `top`, `center`, `bottom`, `left`, `right`
     * @param {string} id Id of the component
     * @since 3.3.0
     */
    removeComponentById(position, id) {
      var _a;
      let lines = ((_a = this.layout[position]) == null ? void 0 : _a.lines) || [];
      lines = lines.map((line) => {
        line.col = line.col.filter((c2) => c2.id !== id);
        return line;
      });
      lines = lines.filter((line) => line.col.length > 0);
      this.layout[position].lines = lines;
    }
    /**
     * Merges components with existing components
     * 
     * For use layout and options, see [setComponentsTop](/api/player.html#setcomponentstop)
     * 
     * @title Merge Components
     * @param {string} position Position of the components. Can be: `top`, `center`, `bottom`, `left`, `right`
     * @param {Object} layout 
     * @param {Object} options 
     * @memberof ComponentManager
     * @since 3.3.0
     */
    mergeComponent(position, layout, options2 = {}) {
      var _a;
      if (!(layout instanceof Array)) {
        layout = [layout];
      }
      this.layout[position] = {
        lines: [...((_a = this.layout[position]) == null ? void 0 : _a.lines) || [], ...layout.map((col) => {
          if (!common.Utils.isArray(col)) {
            col = [col];
          }
          return {
            col
          };
        })],
        ...options2
      };
    }
    setComponents(position, layout, options2 = {}) {
      this.layout[position].lines = [];
      this.mergeComponent(position, layout, options2);
    }
    /**
     * Add components to the center of the graphic.
     * 
     * View [setComponentsTop](/api/player.html#setcomponentstop) for more information
     * 
     * > Be careful, because if you assign, it deletes the graphics and if the lines are superimposed (unlike the other locations)
     * 
     * @title Set Components Center
     * @method player.setComponentsCenter(layout,options)
     * @param {Object} layout 
     * @param {Object} options 
     * @memberof ComponentManager
     * @since 3.3.0
     */
    setComponentsCenter(layout, options2 = {}) {
      this.setComponents("center", layout, options2);
    }
    /**
     * Add components to the top of the graphic. e.g. text, life bar etc. The block will be centred
     * The first array corresponds to the rows, and the nested table to the array in the row
     * 
     * Example:
     * 
     * ```ts
     * import { Components } from '@rpgjs/server'
     * 
     * player.setComponentsTop([
     *      [Components.text('Hello World')],
     *      [Components.hpBar()]
     * ]) // 2 lines with 1 component each
     * ```
     * 
     *  or
     * 
     * ```ts
     * import { Components } from '@rpgjs/server'
     * 
     * player.setComponentsTop([
     *      [Components.text('Hello World'), Components.hpBar()]
     * ]) // 1 line with 2 components
     * ```
     * 
     * You can be faster if you only have lines
     * 
     * ```ts
     * player.setComponentsTop([
     *      Components.text('Hello World'),
     *      Components.hpBar()
     * ]) // 2 lines with 1 component each
     * ```
     * 
     * or one component:
     * 
     * ```ts
     * player.setComponentsTop(Components.text('Hello World')) // 1 line with 1 component
     * ```
     * 
     * You can add options to manage the style
     * 
     * ```ts
     * player.setComponentsTop([
     *      Components.text('Hello World'),
     *      Components.hpBar()
     * ], {
     *      width: 100,
     *      height: 20,
     *      marginTop: 10,
     * })
     * ```
     * 
     * @title Set Components Top
     * @method player.setComponentsTop(layout,options)
     * @param {ComponentObject[][] | ComponentObject[] | ComponentObject} layout Components
     * @param {Object} [options = {}] Options
     * @param {number} [options.width] Width of the block
     * @param {number} [options.height = 20] Height of the block
     * @param {number} [options.marginTop] Margin top
     * @param {number} [options.marginBottom] Margin bottom
     * @param {number} [options.marginLeft] Margin left
     * @param {number} [options.marginRight] Margin right
     * @memberof ComponentManager
     * @since 3.3.0
     */
    setComponentsTop(layout, options2 = {}) {
      this.setComponents("top", layout, options2);
    }
    /**
     * Add components to the bottom of the graphic.
     * 
     * View [setComponentsTop](/api/player.html#setcomponentstop) for more information
     * 
     * @title Set Components Bottom
     * @method player.setComponentsBottom(layout,options)
     * @param {Object} layout 
     * @param {Object} options 
     * @memberof ComponentManager
     * @since 3.3.0
     */
    setComponentsBottom(layout, options2 = {}) {
      this.setComponents("bottom", layout, options2);
    }
    /**
     * Add components to the left of the graphic.
     * 
     * View [setComponentsTop](/api/player.html#setcomponentstop) for more information
     * 
     * @title Set Components Left
     * @method player.setComponentsLeft(layout,options)
     * @param {Object} layout 
     * @param {Object} options 
     * @memberof ComponentManager
     * @since 3.3.0
     */
    setComponentsLeft(layout, options2 = {}) {
      this.setComponents("left", layout, options2);
    }
    /**
     * Add components to the right of the graphic.
     * 
     * View [setComponentsTop](/api/player.html#setcomponentstop) for more information
     * 
     * @title Set Components Right
     * @method player.setComponentsRight(layout,options)
     * @param {Object} layout 
     * @param {Object} options 
     * @memberof ComponentManager
     * @since 3.3.0
     */
    setComponentsRight(layout, options2 = {}) {
      this.setComponents("right", layout, options2);
    }
  }
  var EventMode = /* @__PURE__ */ ((EventMode2) => {
    EventMode2["Shared"] = "shared";
    EventMode2["Scenario"] = "scenario";
    return EventMode2;
  })(EventMode || {});
  class EventManager {
    /**
    * Get Event in current map
    * @title Get Event
    * @since 3.0.0-beta.7
    * @method map.getEvent(eventId)
    * @param {string} eventId Event Id
    * @returns {RpgEvent | undefined}
    * @memberof Map
    */
    getEvent(eventId) {
      return this.events[eventId];
    }
    getEventByName(eventName) {
      const events = Object.keys(this.events);
      const key = events.find((key2) => this.events[key2].name == eventName);
      if (!key)
        return;
      return this.events[key];
    }
    /**
    * Removes an event from the map. Returns false if the event is not found
    * 
    * Deletion of an event forced to be performed at the end of several aynschronous notions
    * 
    * @title Remove Event
    * @since 3.0.0-beta.4
    * @method map.removeEvent(eventId)
    * @param {string} eventId Event Name
    * @returns {boolean}
    * @memberof Map
    */
    removeEvent(eventId) {
      var _a, _b, _c, _d, _e, _f;
      if (!this.events[eventId])
        return false;
      const mode = this.events[eventId].mode;
      let currentState;
      if (mode == "scenario") {
        currentState = ((_d = (_c = (_b = (_a = this.getCurrentMap()) == null ? void 0 : _a.$currentState().users) == null ? void 0 : _b[this.id]) == null ? void 0 : _c.events) == null ? void 0 : _d[eventId]) ?? {};
      } else {
        currentState = ((_e = this.$currentState().events) == null ? void 0 : _e[eventId]) ?? {};
      }
      this.removeObject(this.events[eventId], mode);
      delete this.events[eventId];
      if (mode == "scenario") {
        (_f = this.getCurrentMap()) == null ? void 0 : _f.$setCurrentState(`users.${this.id}.events.${eventId}`, {
          ...currentState,
          deleted: true
        });
      } else {
        this.$setCurrentState(`events.${eventId}`, {
          ...currentState,
          deleted: true
        });
      }
      return true;
    }
    // @internal
    removeObject(object, mode = "shared") {
      const map = this.getCurrentMap();
      if (!map)
        return;
      map.getShapes().forEach((shape) => shape.out(object));
      const events = Object.values(map.game.world.getObjectsOfGroup(map.id, object));
      for (let event of events) {
        object.getShapes().forEach((shape) => shape.out(event));
        event.getShapes().forEach((shape) => shape.out(object));
      }
      object._destroy$.next();
      object._destroy$.complete();
      if (object.type != PlayerType.Player)
        object._destroy$["_closed"] = true;
      map.grid.clearObjectInCells(object.id);
      for (let playerId in map.players) {
        if (object.id == playerId)
          continue;
        const otherPlayer = map.players[playerId];
        if (otherPlayer.followingId == object.id) {
          otherPlayer.cameraFollow(otherPlayer);
        }
      }
      if (map.nbPlayers === 1 && object.type === PlayerType.Player) {
        map.remove(true);
      }
    }
  }
  let instanceContext = null;
  function inject(service, args = []) {
    return instanceContext.inject(service, args);
  }
  function setInject(context) {
    instanceContext = context;
  }
  const {
    isPromise,
    applyMixins,
    isString: isString$2
  } = common.Utils;
  const commonSchemaFeature = {
    name: {
      $permanent: false
    },
    description: {
      $permanent: false
    },
    id: String
  };
  const itemSchemas = {
    price: {
      $permanent: false
    },
    consumable: {
      $permanent: false
    },
    ...commonSchemaFeature
  };
  const componentSchema = {
    id: String,
    value: String
  };
  const layoutSchema = {
    width: Number,
    height: Number,
    marginBottom: Number,
    marginTop: Number,
    marginLeft: Number,
    marginRight: Number,
    lines: [{
      col: [componentSchema]
    }]
  };
  const playerSchemas = {
    position: {
      x: Number,
      y: Number,
      z: Number
    },
    direction: Number,
    teleported: {
      $permanent: false
    },
    deleted: {
      $permanent: false
    },
    moving: {
      $permanent: false
    },
    param: Object,
    hp: Number,
    sp: Number,
    gold: Number,
    level: {
      $effects: ["$this.expForNextlevel", "$this.param"]
    },
    expForNextlevel: {
      $permanent: false
    },
    exp: Number,
    name: String,
    items: [{
      nb: Number,
      item: itemSchemas
    }],
    _class: commonSchemaFeature,
    equipments: [itemSchemas],
    skills: [{
      spCost: {
        $permanent: false
      },
      ...commonSchemaFeature
    }],
    states: [commonSchemaFeature],
    effects: [String],
    layout: {
      top: layoutSchema,
      bottom: layoutSchema,
      left: layoutSchema,
      right: layoutSchema,
      center: layoutSchema
    },
    action: Number,
    map: String,
    speed: Number,
    frequency: Number,
    canMove: Boolean,
    through: Boolean,
    throughOtherPlayer: Boolean,
    width: Number,
    height: Number,
    wHitbox: Number,
    hHitbox: Number,
    // only for server
    _statesEfficiency: [{
      rate: {
        $syncWithClient: false
      },
      state: {
        $syncWithClient: false
      }
    }],
    tmpPositions: {
      $syncWithClient: false
    },
    initialLevel: {
      $syncWithClient: false
    },
    finalLevel: {
      $syncWithClient: false
    }
  };
  const layoutObject = {
    lines: []
  };
  const _RpgPlayer = class extends common.RpgCommonPlayer {
    constructor(playerId) {
      super(inject(common.RpgCommonGame), playerId);
      this.playerId = playerId;
      this.type = "player";
      this.layout = {
        top: layoutObject,
        bottom: layoutObject,
        left: layoutObject,
        right: layoutObject,
        center: layoutObject
      };
      this.events = {};
      this._rooms = [];
      this.session = null;
      this.prevMap = "";
      this.touchSide = false;
      this.tmpPositions = null;
      this.otherPossessedPlayer = null;
      this.followingId = null;
      this._dataLoading = false;
      this.gameEngine = inject(common.RpgCommonGame);
      this.teleported = 0;
      this.deleted = false;
      this.initialize();
    }
    // redefine type (as RpgPlayer)
    get otherPlayersCollision() {
      return super.otherPlayersCollision;
    }
    get world() {
      var _a;
      return (_a = this.server) == null ? void 0 : _a.world;
    }
    /** @internal */
    initialize() {
      this.server = inject(RpgServerEngine);
      this.expCurve = {
        basis: 30,
        extra: 20,
        accelerationA: 30,
        accelerationB: 30
      };
      this.parameters = /* @__PURE__ */ new Map();
      this.variables = /* @__PURE__ */ new Map();
      this.states = [];
      this.equipments = [];
      this._effects = [];
      this.items = [];
      this.skills = [];
      this.gold = 0;
      this.exp = 0;
      this.speed = Speed.Normal;
      this.frequency = Frequency.None;
      this.canMove = true;
      this.through = false;
      this.throughOtherPlayer = true;
      this.initialLevel = 1;
      this.finalLevel = 99;
      this.level = this.initialLevel;
      this._gui = {};
      this._elementsEfficiency = [];
      this._statesEfficiency = [];
      this.moving = false;
      this.addParameter(MAXHP, MAXHP_CURVE);
      this.addParameter(MAXSP, MAXSP_CURVE);
      this.addParameter(STR, STR_CURVE);
      this.addParameter(INT, INT_CURVE);
      this.addParameter(DEX, DEX_CURVE);
      this.addParameter(AGI, AGI_CURVE);
      this.allRecovery();
    }
    _init() {
      this._socket.on("gui.interaction", ({
        guiId,
        name,
        data
      }) => {
        if (this._gui[guiId]) {
          this._gui[guiId].emit(name, data);
          this.syncChanges();
        }
      });
      this._socket.on("gui.exit", ({
        guiId,
        data
      }) => {
        this.removeGui(guiId, data);
      });
    }
    get schema() {
      return {
        ..._RpgPlayer.schemas,
        ...this.server["playerProps"]
      };
    }
    /** 
     * ```ts
     * player.name = 'Link'
     * ``` 
     * @title Read/Give a name
     * @prop {string} player.name
     * @memberof Player
     * */
    get name() {
      return this._name;
    }
    set name(val) {
      this._name = val;
    }
    /**
     * Change your map. Indicate the positions to put the player at a place on the map
     * 
     * > The map must be added to RpgServer beforehand. Guide: [Create Map](/guide/create-map.html)
     * 
     * You don't have to give positions but you can put a starting position in the TMX file. Guide: [Start Position](/guide/player-start.html)
     * 
     * @title Change Map
     * @method player.changeMap(mapId,positions)
     * @param {string} mapId
     * @param { {x: number, y: number, z?: number} | string } [positions]
     * @returns {Promise<RpgMap | null>} null if map not exists
     * @memberof Player
     */
    changeMap(mapId, positions) {
      return this.server.sceneMap.changeMap(mapId, this, positions);
    }
    async autoChangeMap(nextPosition) {
      const map = this.getCurrentMap();
      const worldMaps = map == null ? void 0 : map.getInWorldMaps();
      let ret = false;
      if (worldMaps && map) {
        const direction = this.getDirection();
        const marginLeftRight = map.tileWidth / 2;
        const marginTopDown = map.tileHeight / 2;
        const changeMap = async (adjacent, to) => {
          if (this.touchSide) {
            return false;
          }
          this.touchSide = true;
          const [nextMap] = worldMaps.getAdjacentMaps(map, adjacent);
          if (!nextMap)
            return false;
          const id = nextMap.id;
          const nextMapInfo = worldMaps.getMapInfo(id);
          return !!await this.changeMap(id, to(nextMapInfo));
        };
        if (nextPosition.x < marginLeftRight && direction == common.Direction.Left) {
          ret = await changeMap({
            x: map.worldX - 1,
            y: this.worldPositionY + 1
          }, (nextMapInfo) => ({
            x: nextMapInfo.width - this.wHitbox - marginLeftRight,
            y: map.worldY - nextMapInfo.y + nextPosition.y
          }));
        } else if (nextPosition.x > map.widthPx - this.wHitbox - marginLeftRight && direction == common.Direction.Right) {
          ret = await changeMap({
            x: map.worldX + map.widthPx + 1,
            y: this.worldPositionY + 1
          }, (nextMapInfo) => ({
            x: marginLeftRight,
            y: map.worldY - nextMapInfo.y + nextPosition.y
          }));
        } else if (nextPosition.y < marginTopDown && direction == common.Direction.Up) {
          ret = await changeMap({
            x: this.worldPositionX + 1,
            y: map.worldY - 1
          }, (nextMapInfo) => ({
            x: map.worldX - nextMapInfo.x + nextPosition.x,
            y: nextMapInfo.height - this.hHitbox - marginTopDown
          }));
        } else if (nextPosition.y > map.heightPx - this.hHitbox - marginTopDown && direction == common.Direction.Down) {
          ret = await changeMap({
            x: this.worldPositionX + 1,
            y: map.worldY + map.heightPx + 1
          }, (nextMapInfo) => ({
            x: map.worldX - nextMapInfo.x + nextPosition.x,
            y: marginTopDown
          }));
        } else {
          this.touchSide = false;
        }
      }
      return ret;
    }
    /**
     * Dynamically create an event in Scenario mode on the current map
     * 
     * ```ts
     * @EventData({
     *  name: 'EV-1'
     * })
     * class MyEvent extends RpgEvent {
     *  onAction() {
     *      console.log('ok')
     *  }
     * } 
     *
     * player.createDynamicEvent({
     *      x: 100,
     *      y: 100,
     *      event: MyEvent
     * })
     * ```
     * 
     * You can also put an array of objects to create several events at once
     * 
     * @title Create Dynamic Event
     * @since 3.0.0-beta.4
     * @method player.createDynamicEvent(eventObj | eventObj[])
     * @param { { x: number, y: number, z?: number, event: eventClass } } [eventsList]
     * @returns { { [eventId: string]: RpgEvent } }
     * @memberof Player
     */
    createDynamicEvent(eventsList, forceMode = true) {
      if (!eventsList)
        return {};
      const mapInstance = this.getCurrentMap();
      if (!mapInstance) {
        throw "The player is not assigned to any map";
      }
      if (!common.Utils.isArray(eventsList)) {
        eventsList = [eventsList];
      }
      let eventsListMode = eventsList;
      if (forceMode) {
        eventsListMode = eventsList.map((event) => {
          event.event.mode = EventMode.Scenario;
          return event;
        });
      }
      const events = mapInstance.createEvents(eventsListMode, EventMode.Scenario);
      let ret = {};
      for (let key in events) {
        this.events[key] = events[key];
        this.events[key].playerRelated = this;
        this.events[key].execMethod("onInit", [this]);
        ret = {
          ...ret,
          [key]: this.events[key]
        };
      }
      return ret;
    }
    /**
     * Allows to change the positions of the player on the current map. 
     * You can put the X and Y positions or the name of the created shape on Tiled Map Editor.
     * If you have several shapes with the same name, one position will be chosen randomly.
     * 
     * ```ts
     * player.teleport({ x: 100, y: 500 })
     * ```
     * 
     * or
     * 
     * ```ts
     * player.teleport('my-shape-name')
     * ```
     * 
     * If no parameter: 
     * 
     * ```ts
     * player.teleport() // { x: 0, y: 0, z: 0 }
     * ```
     * 
     * @title Teleport on the map
     * @method player.teleport(positions)
     * @param { {x: number, y: number, z?: number} | string } [positions]
     * @returns {Promise<{ {x: number, y: number, z: number} }>}
     * @memberof Player
     */
    async teleport(positions) {
      var _a;
      if (isString$2(positions))
        positions = (_a = this.getCurrentMap()) == null ? void 0 : _a.getPositionByShape((shape) => shape.name == positions || shape.getType() == positions);
      if (!positions)
        positions = {
          x: 0,
          y: 0,
          z: 0
        };
      if (!positions.z)
        positions.z = 0;
      this.teleported++;
      this.position = positions;
      this._lastFramePositions = void 0;
      await this.isCollided(this.position);
      return positions;
    }
    /**
     * Load the saved data with the method save()
     * If the player was on a map, it repositions the player on the map. 
     * 
     * ```ts
     * const json = player.save()
     * player.load(json)
     * ```
     * 
     * @title Load progress
     * @method player.load(json)
     * @param {string} json The JSON sent by the method save()
     * @returns {Promise<boolean | RpgMap | null>}
     * @memberof Player
     */
    async load(json) {
      this._dataLoading = true;
      if (isString$2(json))
        json = JSON.parse(json);
      const getData = (id) => new (this.databaseById(id))();
      for (let key in json) {
        const val = json[key];
        if (common.Utils.isObject(val) && val.hasOwnProperty("0")) {
          json[key] = Object.values(val);
        }
      }
      const items = {};
      if (json.items) {
        for (let it of json.items) {
          items[it.item.id] = getData(it.item.id);
        }
        json.items = json.items.map((it) => ({
          nb: it.nb,
          item: items[it.item.id]
        }));
        if (Array.isArray(json.equipments)) {
          json.equipments = json.equipments.map((it) => {
            items[it.id].equipped = true;
            return items[it.id];
          });
        }
      }
      if (json.states)
        json.states = json.states.map((state) => getData(state.id));
      if (json.skills)
        json.skills = json.skills.map((skill) => getData(skill.id));
      if (json.variables)
        json.variables = new Map(json.variables);
      lodash_mergeExports(this, json);
      this.position = json.position;
      if (json.map) {
        this.map = "";
        const map = await this.changeMap(json.map, json.tmpPositions || json.position);
        this._dataLoading = false;
        return map;
      }
      this._dataLoading = false;
      return null;
    }
    /**
     * Returns a JSON with all the data to keep in memory. Then use the `load()` method to load the data
     * 
     * You can also use the JSON.stringify 
     * 
     * ```ts
     * const json = player.save() // or JSON.stringify(player)
     * player.load(json)
     * ```
     * 
     * @title Save progress
     * @method player.save()
     * @returns {string}
     * @memberof Player
     */
    save() {
      return JSON.stringify(this);
    }
    // TODO
    toObject() {
      return {
        direction: this.direction,
        id: this.id,
        canMove: this.canMove,
        position: {
          x: this.position.x,
          y: this.position.y,
          z: this.position.z
        },
        hitbox: {
          width: this.wHitbox,
          height: this.hHitbox
        },
        map: this.map,
        pendingMove: this.pendingMove,
        speed: this.speed
      };
    }
    toJSON() {
      const {
        permanentObject
      } = Room.compileSchema(this.schema);
      const snapshot = Room.extractObjectOfRoom(this, permanentObject);
      snapshot.variables = [...this.variables];
      return snapshot;
    }
    /**
         * Run the change detection cycle. Normally, as soon as a hook is called in a class, the cycle is started. But you can start it manually
         * The method calls the `onChanges` method on events and synchronizes all map data with the client.
    
         * @title Run Sync Changes
         * @method player.syncChanges()
         * @returns {void}
         * @memberof Player
         */
    syncChanges() {
      this._eventChanges();
    }
    databaseById(id) {
      const data = this.server.database[id];
      if (!data)
        throw new Error(`The ID=${id} data is not found in the database. Add the data in the property "database" of @RpgServer decorator.`);
      return data;
    }
    /**
     * Retrieves data from the current map
     * 
     * returns null if the player is not assigned to a map
     * 
     * @title Get Current Map
     * @method player.getCurrentMap()
     * @returns {RpgMap | null}
     * @memberof Player
     */
    getCurrentMap() {
      return this._getMap(this.map);
    }
    loadScene(name, data) {
      this.emit(SocketEvents.LoadScene, {
        name,
        data
      });
    }
    emitSceneMap() {
      const mapInstance = this.getCurrentMap();
      if (!mapInstance) {
        throw "[Emit] The player is not assigned to any map";
      }
      let {
        data: serializeMap
      } = Object.assign({}, mapInstance);
      delete serializeMap.shapes;
      delete serializeMap.events;
      delete serializeMap._events;
      for (let layer of serializeMap.layers) {
        delete layer.map;
      }
      this.loadScene("map", {
        id: mapInstance.id,
        sounds: mapInstance.sounds,
        ...serializeMap
      });
    }
    gameReload() {
      this.emit(SocketEvents.GameReload);
    }
    changeServer(url, port) {
      this.emit(SocketEvents.ChangeServer, {
        url,
        port
      });
    }
    _getMap(id) {
      return common.RpgCommonMap.buffer.get(id);
    }
    /**
     * Calls the showAnimation() method on the client side to display an animation on the player
     * You must remember to create the spritesheet beforehand
     * 
     * For this type of spritesheet:
     * 
     * ```ts
     * @Spritesheet({
     *  id: 'fire',
     *  image: require('')
     *  textures: {
     *      default: {
     *          animations: [
     *          
     *          ]
     *      }
     *   }
     * })
     * export class FireAnimation {}
     * ```
     * 
     * Here is the call of the method:
     * 
     * ```ts
     * player.showAnimation('fire', 'default')
     * ```
     * 
     * If you don't want to put an animation on top of the event but replace the event graphic with another one, set true as last parameter.
     * This is useful, if for example, you want to make an animated character (sword stroke when pressing a key)
     * When the animation is finished, the original graphic is displayed again
     * 
     * 
     * ```ts
     * player.showAnimation('sword_stroke', 'default', true)
     * ```
     * 
     * Since version 3.0.0-rc, you can define several graphic elements. This allows you to animate them all at once
     * 
     * ```ts
     * player.showAnimation(['body', 'sword_stroke'], 'default', true)
     * ```
     * 
     * ::: tip
     * For this to work, the animations must have been previously defined in `setGraphic`.
     * :::
     * 
     * @title Show Animation
     * @method player.showAnimation(graphic,animationName,replaceGraphic=false)
     * @param {string | string[]} graphic spritesheet identifier
     * @param {string} animationName Name of the animation in the spritesheet
     * @param {boolean} [replaceGraphic] Replace the event graphic with the animation. After the end of the animation, the original graphic is reapplied
     * @returns {void}
     * @memberof Player
     */
    showAnimation(graphic, animationName, replaceGraphic = false) {
      this.emitToMap("callMethod", {
        name: SocketMethods.ShowAnimation,
        params: [graphic, animationName, replaceGraphic]
      });
    }
    /**
     * TODO:
     * 1. It is necessary, on the client side, to make the character move even if controlled by someone else (problem: same playerId so, one will not move because of the client side prediction. Solution: create a new Id ? like session Id ?
     * 2. You would need several sockets per character. If the character changes map or changes server, all players controlling the character must be able to see it
     * 3. If the player regains control, what happens, do we return to the previous map?
     * 4. If it's an event, you must be able to get the event by id in GameEngine
     */
    takePossessionOf(otherPlayer) {
      this.otherPossessedPlayer = otherPlayer;
      this._socket.emit("playerJoined", {
        playerId: otherPlayer.id,
        session: this.session
      });
      this.cameraFollow(otherPlayer);
    }
    /**
     * Sends the client which event or player the camera should follow. You can set options to perform a motion animation
     * 
     * @title Camera Follow
     * @method player.cameraFollow(otherPlayer,options)
     * @param {RpgPlayer | RpgEvent} otherPlayer
     * @param {options} options
     * @param {object | boolean} [options.smoothMove] - animate. Set a boolean to use default parameters
     * @param {number} [options.smoothMove.time=1000] - time to animate
     * @param {string} [options.smoothMove.ease=linear] - easing to use. Go to https://easings.net to get function name
     * @returns {void}
     * @since 3.1.0
     * @memberof Player
     */
    cameraFollow(otherPlayer, options2 = {}) {
      if (otherPlayer.id == this.id) {
        this.followingId = null;
      } else {
        this.followingId = otherPlayer.id;
      }
      this.emit(SocketEvents.CallMethod, {
        objectId: this.playerId,
        name: SocketMethods.CameraFollow,
        params: [otherPlayer.id, options2]
      });
    }
    /**
     * Emit data to clients with socket
     * 
     * @title Emit to client
     * @method player.emit(key,value)
     * @param {string} key
     * @param {any} value
     * @returns {void}
     * @memberof Player
     */
    emit(key, value) {
      if (this._socket)
        this._socket.emit(key, value);
    }
    /**
     * Listen to the data (socket) sent by the client
     * 
     * @title Listen to data from the client
     * @method player.on(key,cb)
     * @param {string} key
     * @param {function} cb
     * @returns {void}
     * @memberof Player
     */
    on(key, cb) {
      if (this._socket)
        this._socket.on(key, cb);
    }
    /**
     * Adds a one-time listener function for the event named eventName
     * 
     * @title Listen one-time to data from the client
     * @method player.once(key,cb)
     * @since 3.0.0-beta.5
     * @param {string} key
     * @param {function} cb
     * @returns {void}
     * @memberof Player
     */
    once(key, cb) {
      if (this._socket)
        this._socket.once(key, cb);
    }
    /**
     * Removes all listeners of the specified eventName.
     * 
     * @title Removes all listeners of the client
     * @method player.off(key)
     * @since 3.0.0-beta.5
     * @param {string} key
     * @returns {void}
     * @memberof Player
     */
    off(key) {
      if (this._socket)
        this._socket.removeAllListeners(key);
    }
    disconnect() {
      if (this._socket)
        this._socket.disconnect();
    }
    emitToMap(key, value) {
      const map = this.getCurrentMap();
      if (map) {
        map.$setCurrentState(`users.${this.id}.${key}`, value);
      }
    }
    execMethodSync(methodName, methodData = [], target) {
      let ret;
      if (target && target[methodName]) {
        ret = target[methodName](...methodData);
      }
      return ret;
    }
    async execMethod(methodName, methodData = [], target) {
      const ignoreIfDataLoading = ["onLevelUp", "onDead"];
      if (ignoreIfDataLoading.includes(methodName) && this._dataLoading) {
        return;
      }
      let ret;
      if (target && target[methodName]) {
        ret = target[methodName](...methodData);
        if (isPromise(ret))
          await ret;
      } else {
        ret = await common.RpgPlugin.emit(`Server.${methodName}`, [this, ...methodData], true);
      }
      this.syncChanges();
      return ret;
    }
    _triggerHook(name, val) {
      if (this[name])
        this[name](val);
      this.emit("Player." + name, val);
    }
    // @internal
    /**
     * Allows you to manually update a status in the rooms that will then be sent to the customer.
     * @param path 
     * @example
     * ```ts
     * player.changeRoomState('hp')
     * ```
     */
    changeRoomState(path2) {
      var _a;
      (_a = this.world) == null ? void 0 : _a.forEachUserRooms(this.id, (room) => {
        room.$setCurrentState(`users.${this.id}.${path2}`);
      });
    }
    _eventChanges() {
      if (!this._getMap(this.map))
        return;
      const {
        events
      } = this._getMap(this.map);
      const arrayEvents = [...Object.values(this.events), ...Object.values(events)];
      for (let event of arrayEvents) {
        if (event.onChanges)
          event.onChanges(this);
      }
    }
    /**
     * Allows to play a sound, heard only by the player or by the players of the map
     * 
     * Here is a sound, client side:
     * 
     * ```ts
     * import { Sound } from '@rpgjs/client'
     * @Sound({
     *      id: 'town-music',
     *      sound: require('./sound/town.ogg')
     * })
     * export class TownMusic {}
     * ```
     * 
     * Here is the call of the method, server side:
     * 
     * ```ts
     * player.playSound('town-music')
     * ```
     * 
     * If you want everyone to listen to the sound on the map:
     * 
     * ```ts
     * player.playSound('town-music', true)
     * ```
     * 
     * @title Play Sound
     * @method player.playSound(soundId,allMap=false)
     * @param {string} soundId Sound identifier, defined on the client side
     * @param {boolean} [forEveryone=false] Indicate if the sound is heard by the players on the map
     * @since 3.0.0-alpha.9
     * @returns {void}
     * @memberof Player
     */
    playSound(soundId, forEveryone = false) {
      const obj = {
        objectId: this.playerId,
        name: SocketMethods.PlaySound,
        params: [soundId]
      };
      if (!forEveryone) {
        this.emit(SocketEvents.CallMethod, obj);
        return;
      }
      this.emitToMap(SocketEvents.CallMethod, obj);
    }
  };
  let RpgPlayer = _RpgPlayer;
  RpgPlayer.schemas = {
    ...playerSchemas,
    events: [playerSchemas]
  };
  applyMixins(RpgPlayer, [EventManager, ItemManager, GoldManager, StateManager, SkillManager, ParameterManager, EffectManager, ClassManager, ElementManager, GuiManager, VariableManager, MoveManager, BattleManager, ComponentManager]);
  class RpgEvent extends RpgPlayer {
    constructor(playerId) {
      super(playerId);
      this.type = "event";
      this.properties = {};
      this.playerRelated = null;
    }
    async execMethod(methodName, methodData = []) {
      if (!this[methodName]) {
        return;
      }
      const ret = this[methodName](...methodData);
      return ret;
    }
    changeRoomState(path2) {
      const room = this.getCurrentMap();
      if (room) {
        room.$setCurrentState(`events.${this.id}.${path2}`);
      }
    }
    /**
    * Deletes the event from the map (in shared or scenario mode)
    * 
    * @title Remove
    * @since 4.0.0
    * @method event.remove()
    * @returns {boolean} true if the event has been removed. If false, the event is not on the map
    * @memberof RpgEvent
    */
    remove() {
      let bool = false;
      if (this.playerRelated)
        bool = this.playerRelated.removeEvent(this.id);
      const map = this.getCurrentMap();
      if (map) {
        bool = map.removeEvent(this.id);
      }
      return bool;
    }
    emitToMap(key, value) {
      const map = this.getCurrentMap();
      if (map) {
        const eventPath = `events.${this.id}.${key}`;
        if (this.playerRelated) {
          map.$setCurrentState(`users.${this.playerRelated.id}.${eventPath}`, value);
        } else {
          map.$setCurrentState(eventPath, value);
        }
      }
    }
  }
  function MapData(options2) {
    return (target) => {
      target.file = options2.file;
      target.id = options2.id;
      target.type = "map";
      target.prototype.name = options2.name;
      target.prototype.file = options2.file;
      target.prototype.id = options2.id;
      target.prototype.sounds = options2.sounds;
      target.prototype.lowMemory = options2.lowMemory;
      target.prototype.$schema = {};
      if (options2.syncSchema) {
        target.prototype.$schema = options2.syncSchema;
      }
      if (!target.prototype.$schema.shapes) {
        target.prototype.$schema.shapes = [{
          type: String,
          name: String,
          x: Number,
          y: Number,
          width: Number,
          height: Number,
          properties: {
            collision: Boolean
          },
          polygon: [{
            x: Number,
            y: Number
          }],
          rotation: Number,
          components: [componentSchema]
        }];
      }
      if (!target.prototype.$schema.users) {
        target.prototype.$schema.users = [RpgPlayer.schemas];
      }
      if (!target.prototype.$schema.events) {
        target.prototype.$schema.events = [RpgPlayer.schemas];
      }
      target.prototype._events = options2.events;
    };
  }
  function EventData(options2) {
    return (target) => {
      target.mode = options2.mode || EventMode.Shared;
      target.width = options2.width;
      target.height = options2.height;
      target.hitbox = options2.hitbox;
      target._name = options2.name;
      target.prototype._name = options2.name;
      target.prototype.mode = target.mode;
    };
  }
  class AutoEvent extends RpgEvent {
    onInit() {
      const {
        graphic,
        direction,
        speed,
        frequency,
        move
      } = this.properties;
      if (graphic) {
        this.setGraphic(graphic);
      }
      if (direction) {
        this.changeDirection(direction);
      }
      if (speed) {
        this.speed = speed;
      }
      if (frequency) {
        this.frequency = frequency;
      }
      if (move == "random") {
        this.infiniteMoveRoute([Move.tileRandom()]);
      }
    }
    async onAction(player) {
      const {
        text
      } = this.properties;
      if (text) {
        await player.showText(text, {
          talkWith: this
        });
      }
    }
  }
  AutoEvent.hitbox = {};
  class RpgMap extends common.RpgCommonMap {
    constructor(_server) {
      super();
      this._server = _server;
      this.events = {};
    }
    // alias of users property in simple-room package
    /**
     * @title Players list
     * @prop { { [playerId: string]: RpgPlayer } } [players]
     * @readonly
     * @memberof Map
     */
    get players() {
      return this["users"];
    }
    /**
     * @title Number of players
     * @prop {number} [nbPlayers]
     * @readonly
     * @memberof Map
     */
    get nbPlayers() {
      return Object.keys(this.players).length;
    }
    $additionalEmitProperties(player) {
      const lastFramePositions = player["_lastFramePositions"];
      let pos;
      let lastFrame;
      if (lastFramePositions) {
        pos = lastFramePositions.position;
        lastFrame = lastFramePositions.frame;
      }
      const data = {
        frame: lastFrame,
        pos
      };
      return data;
    }
    async load() {
      var _a;
      if (common.RpgCommonMap.buffer.has(this.id)) {
        return;
      }
      const data = await this.parseTmx(this.file);
      super.load(data);
      this.getAllObjects().forEach(this.createShape.bind(this));
      this.loadProperties(data.properties);
      (_a = this._server.workers) == null ? void 0 : _a.call("loadMap", {
        id: this.id,
        data
      });
      common.RpgCommonMap.buffer.set(this.id, this);
      this.loadCommonEvents(this._server.inputOptions.events);
      this.createDynamicEvent(this._events);
      if (this.onLoad)
        this.onLoad();
    }
    /**
     * Update the map with new data. Data can be a string (TMX content) or an object (parsed TMX content)
     * New Map data will be sent to all players on the map
     *
     * @title Update map
     * @method map.update(data)
     * @since 4.0.0
     * @returns {Promise<void>}
     * @param {object | string} data
     * @memberof Map
     */
    async update(data) {
      let objectData;
      if (typeof data == "string") {
        objectData = await this.parseTmx(data, this.file);
      } else {
        objectData = data;
      }
      super.load(objectData);
      common.RpgCommonMap.buffer.set(this.id, this);
      this.clearShapes();
      this.getAllObjects().forEach(this.createShape.bind(this));
      for (let playerId in this.players) {
        const player = this.players[playerId];
        player.emitSceneMap();
      }
    }
    /**
     * Update tileset with new data. Data can be a string (TSX content) or an object (TiledTileset)
     * Cache will be removed for this tileset
     * New tileset data will be sent to all players on the map
     * Warning: tileset is not updated for all maps, only for the current map
     * 
     * @title Update tileset
     * @method map.updateTileset(data)
     * @since 4.0.0
     * @returns {<void>}
     * @param {TiledTileset | string} data
     * @memberof Map
     */
    updateTileset(data) {
      let objectData;
      if (typeof data == "string") {
        const parser = new TiledParser(data, this.file);
        objectData = parser.parseTileset();
      } else {
        objectData = data;
      }
      this.removeCacheTileset(objectData.name);
      this.update({
        ...this.data,
        tilesets: this.data.tilesets.map((tileset) => {
          if (tileset.name == objectData.name) {
            objectData.firstgid = tileset.firstgid;
            return objectData;
          }
          return tileset;
        })
      });
    }
    /**
     * Remove the map from the server. If there are still players on the map, an error will be thrown
     * Not delete the map file, only in memory
     * 
     * @title Remove map
     * @method map.remove()
     * @since 4.0.0
     * @returns {void}
     * @throws {Error} If there are still players on the map
     * @memberof Map
     * */
    remove(ignorePlayers = false) {
      const players = Object.values(this.players);
      if (players.length > 0 && !ignorePlayers) {
        throw new Error(`Cannot remove map ${this.id} because there are still players on it`);
      }
      for (let eventId in this.events) {
        this.removeEvent(eventId);
      }
      common.RpgCommonMap.buffer.delete(this.id);
      World.removeRoom(this.id);
    }
    async parseTmx(file, relativePath = "") {
      const hasAssetsPath = !!this._server.envs.VITE_BUILT;
      const parser = new TiledParserFile(file, {
        basePath: {}.NODE_ENV == "test" ? "." : "",
        staticDir: hasAssetsPath ? path.join(this._server.inputOptions.basePath, this._server.assetsPath) : "",
        relativePath
      });
      const data = await parser.parseFilePromise({
        getOnlyBasename: hasAssetsPath
      });
      return data;
    }
    loadProperties(properties) {
      for (let key in properties) {
        this[key] = properties[key];
      }
    }
    get game() {
      return this._server.gameEngine;
    }
    // Hook: called by simple-room package
    onLeave(player) {
      this.removeObject(player);
    }
    /**
     * Loads common events onto the game map.
     *
     * @private
     * @param {RpgClassEvent<RpgEvent>[]} commonEvents - An array of common events to load.
     * @param {RpgPlayer} [player] - The player instance on which to create the dynamic events. If not provided, the function will use the current instance.
     * @returns {void}
     */
    // @internal
    loadCommonEvents(commonEvents, player) {
      let events = [];
      this.getShapes().forEach((shape) => {
        const findEvent = commonEvents.find((event) => event._name == shape.name);
        if (!findEvent)
          return;
        const {
          x,
          y
        } = shape.hitbox;
        events.push({
          x,
          y,
          event: findEvent
        });
      });
      if (player) {
        player.createDynamicEvent(events, false);
      } else {
        this.createDynamicEvent(events);
      }
    }
    // TODO
    autoLoadEvent() {
      this.getShapes().forEach((shape) => {
        const {
          properties
        } = shape;
        const {
          x,
          y,
          pos,
          w,
          h
        } = shape.hitbox;
        if (shape.isEvent() && !this.events[shape.name]) {
          const mode = properties.mode || EventMode.Shared;
          AutoEvent.prototype["_name"] = shape.name;
          AutoEvent.mode = mode;
          AutoEvent.hitbox = {
            width: 32,
            height: 16
          };
          const event = this.createEvent({
            x,
            y,
            event: AutoEvent
          }, mode, shape);
          if (event)
            this.events[shape.name] = event;
        }
      });
    }
    /**
     * Edit a tile on the map. All players on the map will see the modified tile
     * 
     * 
     * @title Change Tile in map
     * @since 3.0.0-beta.4
     * @method map.setTile(x,y,layer,tileInfo)
     * @param {number} x Position X
     * @param {number} y Position Y
     * @param {string | ((layer: any) => boolean)} layer Name of the layer where you want to put a tile. OYou can also put a function that will act as a filter. The first parameter is the layer and you return a boolean to indicate if you modify the tile of this layer or not
     * @param {object} tileInfo Object with the following properties:
     *  - {number} gid: The tile number in tileset (from 1)
     *  - {object} properties Property of the tile. You own object. To set a collision, set the `collision:true` property
     * @example
     * ```ts
     * map.setTile(15, 18, 'mylayer', { gid: 2 })
     * ```
     * @returns {void}
     * @memberof Map
     */
    setTile(x, y, layerFilter, tileInfo) {
      const tiles = super.setTile(x, y, layerFilter, tileInfo);
      const players = Object.values(this["users"]);
      for (let player of players) {
        player.emit("changeTile", tiles);
      }
      return tiles;
    }
    getEventShape(eventName) {
      return this.getShapes().find((shape) => shape.name == eventName);
    }
    /**
     * Dynamically create an event in Shared mode
     * 
     * ```ts
     * @EventData({
     *  name: 'EV-1'
     * })
     * class MyEvent extends RpgEvent {
     *  onAction() {
     *      console.log('ok')
     *  }
     * } 
     *
     * map.createDynamicEvent({
     *      x: 100,
     *      y: 100,
     *      event: MyEvent
     * })
     * ```
     * 
     * You can also put an array of objects to create several events at once
     * 
     * @title Create Dynamic Event
     * @since 3.0.0-beta.4
     * @method map.createDynamicEvent(eventObj|eventObj[])
     * @param { { x: number, y: number, z?: number, event: eventClass } } eventsList
     * @returns { { [eventId: string]: RpgEvent } }
     * @memberof Map
     */
    createDynamicEvent(eventsList) {
      if (!eventsList)
        return {};
      if (!common.Utils.isArray(eventsList)) {
        eventsList = [eventsList];
      }
      const events = this.createEvents(eventsList, EventMode.Shared);
      let ret = {};
      for (let key in events) {
        this.events[key] = events[key];
        this.events[key].updateInVirtualGrid();
        this.events[key].execMethod("onInit");
        ret = {
          ...ret,
          [key]: this.events[key]
        };
      }
      return ret;
    }
    createEvent(obj, mode, shape) {
      let event, position;
      if (obj.x === void 0) {
        event = obj;
      } else {
        event = obj.event;
        position = {
          x: obj.x,
          y: obj.y,
          z: obj.z ?? 0
        };
      }
      if ("$decorator" in event) {
        const options2 = event.$decorator;
        EventData(options2)(event);
      }
      if (event.mode != mode) {
        return null;
      }
      const ev = this.game.addEvent(event);
      const _shape = shape || this.getEventShape(ev.name);
      ev.map = this.id;
      ev.width = event.width || this.tileWidth;
      ev.height = event.height || this.tileHeight;
      if (_shape && _shape.properties)
        ev.properties = _shape.properties;
      if (event.hitbox)
        ev.setHitbox(event.hitbox.width, event.hitbox.height);
      ev.teleport(position || ev.name);
      return ev;
    }
    createEvents(eventsList, mode) {
      const events = {};
      if (!eventsList)
        return events;
      for (let obj of eventsList) {
        const ev = this.createEvent(obj, mode);
        if (ev) {
          events[ev.id] = ev;
        }
      }
      return events;
    }
    /**
         * Allows to create a temporary hitbox on the map that can have a movement
    For example, you can use it to explode a bomb and find all the affected players, or during a sword strike, you can create a moving hitbox and find the affected players again
         * @title Create a temporary and moving hitbox
         * @since 3.2.0
         * @method map.createMovingHitbox(hitboxes,options)
         * @param {Array<{ width: number, height: number, x: number, y: number }>} hitboxes Create several hitboxes that will give an effect of movement
         * @param {object} [options]
         * @param {speed} [options.speed=1] speed of movement (in frames)
         * @returns {Observable<AbstractObject>} You find the methods of position and movement of an event
         * @memberof Map
         * @example
         * 
         * ```ts
         * // Two hitboxes that will be done very quickly
         * map.createMovingHitbox(
         *   [ 
         *      { x: 0, y: 0, width: 100, height: 100 },
         *      { x: 20, y: 0, width: 100, height: 100 } 
         *   ]
         * ).subscribe({
         *      next(hitbox) {
         *          console.log(hitbox.otherPlayersCollision)
         *      },
         *      complete() {
         *          console.log('finish')
         *      }
         * })
         * ```
         */
    createMovingHitbox(hitboxes, options2 = {}) {
      return this._createMovingHitbox(this.game, this._server.tick, this.id, hitboxes, options2);
    }
    setSync(schema) {
      return this.$setSchema(schema);
    }
    // Reflects itself. Just for compatibility with the EventManager class
    getCurrentMap() {
      return this;
    }
  }
  common.Utils.applyMixins(RpgMap, [EventManager]);
  class RpgWorldMaps extends common.RpgCommonWorldMaps {
    load(world, sceneMap) {
      for (let worldMap of world.maps) {
        const {
          fileName
        } = worldMap;
        let id, map;
        if (worldMap.id) {
          id = worldMap.id;
        } else if (common.Utils.isString(fileName)) {
          id = common.Utils.extractId(fileName);
        }
        const create = () => sceneMap.createDynamicMap({
          id,
          file: world.basePath ? `${world.basePath}/${fileName}` : fileName
        });
        if (!id) {
          map = create();
        } else {
          map = sceneMap.getMapBydId(id) ?? create();
        }
        this.addMap(worldMap, map);
      }
      return this;
    }
  }
  var __defProp$1 = Object.defineProperty;
  var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
  var __decorateClass$1 = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
    for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
      if (decorator = decorators[i2])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp$1(target, key, result);
    return result;
  };
  class SceneMap {
    constructor(sceneMapObject) {
      this.maps = [];
      this.mapsById = {};
      this.worldMaps = /* @__PURE__ */ new Map();
      this.server = inject(RpgServerEngine);
      const {
        maps,
        worldMaps,
        events
      } = sceneMapObject;
      this.maps = maps;
      this.mapsById = {};
      common.RpgCommonMap.buffer.clear();
      if (this.maps) {
        for (let map of this.maps) {
          this.createDynamicMap(map);
        }
      }
      if (worldMaps) {
        for (let worldMap of worldMaps) {
          this.createDynamicWorldMaps(worldMap);
        }
      }
    }
    /**
     * Returns an array of RpgClassMap objects that represent maps with static properties.
     * 
     * @title Get maps
     * @method sceneMap.getMaps()
     * @returns {RpgClassMap<RpgMap>[]} Array of RpgClassMap objects.
     * @since 4.0.0
     * @example
     * ```typescript
     * const maps = scene.getMaps();
     * console.log(maps);
     * // Output: [
     * // { file: 'maps/level1.tmx', id: 'level1', type: 'map' },
     * // { file: 'maps/level2.tmx', id: 'level1', type: 'map' },
     * // { file: 'maps/level3.tmx', id: 'level1', type: 'map' }
     * // ]
     * ```
     * @memberof SceneMap
     */
    getMaps() {
      return Object.values(this.mapsById);
    }
    getMapBydId(id) {
      let mapClass = this.mapsById[id];
      if (!mapClass) {
        return null;
      }
      if (!common.Utils.isClass(mapClass))
        mapClass = common.Utils.createConstructor(mapClass);
      return mapClass;
    }
    async loadMap(id) {
      const mapClass = this.getMapBydId(id);
      if (!mapClass) {
        console.log(`Map ${id} not exists`);
        return;
      }
      let mapInstance;
      if (mapClass["buffer"].has(id)) {
        return mapClass["buffer"].get(id);
      }
      if (common.RpgCommonMap.buffer.has(id)) {
        mapInstance = common.RpgCommonMap.buffer.get(id);
      } else {
        const room = new mapClass(this.server);
        room.$schema.users = [{
          ...RpgPlayer.schemas,
          ...this.server["playerProps"]
        }];
        mapInstance = World.addRoom(id, room);
        await mapInstance.load();
      }
      return mapInstance;
    }
    /**
    * Loads the content of a `.world` file from Tiled Map Editor into the map scene
    * 
    * > Note, that if the map already exists (i.e. you have already defined an RpgMap), the world will retrieve the already existing map. Otherwise it will create a new map
    * 
    * @title Create worlds dynamically
    * @method sceneMap.createDynamicWorldMaps(world)
    * @param {object} world 
    * object is 
    * ```ts
    * {
    *  id?: string
    *  maps: {
    *      id?: string
    *      properties?: object
    *      fileName: string;
           height: number;
           width: number;
           x: number;
           y: number;
    *  }[],
       onlyShowAdjacentMaps: boolean, // only for Tiled Map Editor
       type: 'world' // only for Tiled Map Editor
    * }
    * ```
    * 
    * @since 3.0.0-beta.8
    * @memberof SceneMap
    */
    createDynamicWorldMaps(world) {
      world.id = world.id || common.Utils.generateUID();
      const worldMap = new RpgWorldMaps(world.id).load(world, this);
      this.worldMaps.set(world.id, worldMap);
      return worldMap;
    }
    /**
     * Recover a world
     * 
     * @title Recover a world
     * @method sceneMap.getWorldMaps(id)
     * @param {string} id world id 
     * @return { RpgWorldMaps | undefined }
     * @since 3.0.0-beta.8
     * @memberof SceneMap
     */
    getWorldMaps(id) {
      return this.worldMaps.get(id);
    }
    /**
    * Delete a world
    * 
    * @title Delete a world
    * @method sceneMap.deleteWorldMaps(id)
    * @param {string} id world id 
    * @since 3.0.0-beta.8
    * @memberof SceneMap
    */
    deleteWorldMaps(id) {
      this.worldMaps.delete(id);
    }
    /**
     * Create a dynamic map
     * 
     * Since version 3.0.0-beta.8, you can just pass the path to the file. The identifier will then be the name of the file
     * 
     * @method sceneMap.createDynamicMap(mapData)
     * @title Create a dynamic map
     * @param {object | RpgMap | string} mapData The same property as [@MapData decorator](https://docs.rpgjs.dev/classes/map.html#mapdata-decorator)
     * @returns {RpgMap}
     * @since 3.0.0-beta.4
     * @memberof SceneMap
     * @example
     * ```ts
     * sceneMap.createDynamicMap({
     *      id: 'myid',
     *      file: require('./tmx/mymap.tmx')
     * })
     * ```
     * 
     * And later, on the player:
     * 
     * ```ts
     * player.changeMap('myid')
     * ```
     * 
     * --- 
     * 
     * since beta.8
     * 
     * ```ts
     * sceneMap.createDynamicMap(require('./tmx/mymap.tmx')) // id is "mymap"
     * ```
     */
    createDynamicMap(mapData) {
      if (common.Utils.isString(mapData)) {
        const id = common.Utils.extractId(mapData);
        if (!id) {
          throw new Error("Unable to extract the file identifier. Check that the file has only the following characters: [a-zA-Z0-9-_$!]+");
        }
        mapData = {
          id: id[1],
          file: mapData
        };
      }
      if (isTiledFormat(mapData)) {
        const tiledData = mapData;
        mapData = {
          file: {
            ...tiledData
          }
        };
      }
      if (!mapData.id)
        mapData.id = common.Utils.generateUID();
      if (!common.Utils.isClass(mapData)) {
        let DynamicMap = class extends RpgMap {
        };
        DynamicMap = __decorateClass$1([MapData(mapData)], DynamicMap);
        mapData = DynamicMap;
      }
      const map = mapData;
      this.mapsById[map.id] = map;
      return map;
    }
    async changeMap(mapId, player, positions) {
      const boolArray = await common.RpgPlugin.emit(common.HookServer.PlayerCanChangeMap, [player, this.getMapBydId(mapId)], true);
      if (boolArray.some((el) => el === false)) {
        return null;
      }
      if (player.map === mapId) {
        await player.teleport(positions || "start");
        return null;
      }
      player.emit("preLoadScene", {
        id: mapId
      });
      player.prevMap = player.map;
      if (player.prevMap) {
        await player.execMethod("onLeaveMap", [player.getCurrentMap()]);
        World.leaveRoom(player.prevMap, player.id);
      }
      player.map = mapId;
      player.events = {};
      player.tmpPositions = positions;
      const scalabilityArray = await common.RpgPlugin.emit(common.HookServer.ScalabilityChangeServer, player);
      if (scalabilityArray.some((el) => el === true)) {
        return true;
      }
      player.tmpPositions = null;
      const mapInstance = await this.loadMap(mapId);
      if (!mapInstance)
        return null;
      if (!player.height)
        player.height = mapInstance.tileHeight;
      if (!player.width)
        player.width = mapInstance.tileWidth;
      if (!player.hitbox.h)
        player.hitbox.h = mapInstance.tileHeight;
      if (!player.hitbox.w)
        player.hitbox.w = mapInstance.tileWidth;
      player.emitSceneMap();
      if (!World.getRoom(mapId)) {
        return null;
      }
      player.teleport(positions || "start");
      World.joinRoom(mapId, player.id);
      player = World.getUser(player.id);
      if (player) {
        mapInstance.loadCommonEvents(this.server.inputOptions.events, player);
        player.createDynamicEvent(mapInstance._events, false);
        await player.execMethod("onJoinMap", [mapInstance]);
      }
      return mapInstance;
    }
  }
  SceneMap.id = "map";
  const {
    isString: isString$1
  } = common.Utils;
  class QueryClass {
    /** 
     * Listen to the changes on all the rooms
     * 
     * ```ts
     * import { RpgWorld } from '@rpgjs/server'
     * import { map } from 'rxjs/operators' // install rxjs
     * 
     * RpgWorld.changes
     *  .pipe(
     *      map(rooms => rooms['mymap'])
     *  )
     *  .subscribe((room) => {
     *      const users: any = Object.values(room.users)
     *      console.log(users)
     *  })
     * ``` 
     * 
     * @title Subscribe to the world
     * @prop {Observable} RpgWorld.changes
     * @memberof RpgWorld
     * */
    get changes() {
      return World.changes.asObservable();
    }
    /**
     * Retrieve a player according to his ID
     * 
     * ```ts
     * import { RpgWorld } from '@rpgjs/server'
     * 
     * const player = RpgWorld.getPlayer(player) // player is RpgPlayer (player.id) or string (id)
     * ```
     * 
     * @title Get Player
     * @method RpgWorld.getPlayer(player)
     * @param {RpgPlayer | string} player identifier
     * @returns {RpgPlayer}
     * @memberof RpgWorld
     */
    getPlayer(player) {
      const id = isString$1(player) ? player : "" + player.id;
      const _player = World.getUser(id);
      return _player;
    }
    /**
     * Recover all the players of the game
     * 
     * ```ts
     * import { RpgWorld } from '@rpgjs/server'
     * 
     * const players = RpgWorld.getPlayers()
     * ```
     * 
     * @title Get all Players
     * @method RpgWorld.getPlayers()
     * @returns {Array<RpgPlayer>}
     * @memberof RpgWorld
     */
    getPlayers() {
      const users = World.getUsers();
      const array2 = Object.values(users);
      return array2.map((user) => this.getPlayer(user));
    }
    /**
     * Recover all map objects: players and events. If you specify the `player` parameter, it also retrieves the events in scenario mode of the player in question
     * 
     * ```ts
     * import { RpgWorld } from '@rpgjs/server'
     * 
     * const objects = RpgWorld.getObjectsOfMap('mapname')
     * console.log(objects)
     * ```
     * 
     * Also retrieve events in Scenario mode:
     * 
     * ```ts
     * import { RpgWorld } from '@rpgjs/server'
     * 
     * const objects = RpgWorld.getObjectsOfMap('mapname', 'playerid')
     * ```
     * 
     * @title Get all objects of map
     * @method RpgWorld.getObjectsOfMap(map,playerId?)
     * @param {string} map Map Name
     * @param {RpgPlayer | string} playerId player identifier
     * @returns {Array<RpgPlayer>}
     * @memberof RpgWorld
     */
    getObjectsOfMap(map, playerId) {
      return Object.values(this._getObjectsOfMap(map, playerId));
    }
    _getObjectsOfMap(map, playerId) {
      const room = World.getRoom(map);
      let player = null;
      if (playerId) {
        player = this.getPlayer(playerId);
      }
      return {
        ...room.users,
        ...room.events,
        ...player ? player.events : {}
      };
    }
    /**
     * Find all the shapes of the map
     * 
     * ```ts
     * import { RpgWorld } from '@rpgjs/server'
     * 
     * const shapes = RpgWorld.getShapesOfMap('mapname')
     * console.log(shapes)
     * ```
     * 
     * @title Get all shapes of map
     * @method RpgWorld.getShapesOfMap(map)
     * @param {string} map Map Name
     * @returns {Array<RpgShape>}
     * @memberof RpgWorld
     */
    getShapesOfMap(map) {
      return Object.values(this._getShapesOfMap(map));
    }
    _getShapesOfMap(map) {
      const room = World.getRoom(map);
      return room.shapes;
    }
    // TODO
    getRooms() {
      return World.getRooms();
    }
    getRoom(name) {
      return World.getRoom(name);
    }
    /**
     * Recover all the players of a map
     * 
     * ```ts
     * import { RpgWorld } from '@rpgjs/server'
     * 
     * const players = RpgWorld.getPlayersOfMap('mapname')
     * ```
     * 
     * @title Get all Players a map
     * @method RpgWorld.getPlayersOfMap(map)
     * @param {string} map Map Name
     * @returns {Array<RpgPlayer>}
     * @memberof RpgWorld
     */
    getPlayersOfMap(map) {
      const room = World.getRoom(map);
      return Object.values(room.users);
    }
  }
  const Query = new QueryClass();
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
      if (decorator = decorators[i2])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp(target, key, result);
    return result;
  };
  class RpgServerEngine {
    constructor() {
      this.database = {};
      this.globalConfig = {};
      this.damageFormulas = {};
      this.serverId = {}.SERVER_ID || common.Utils.generateUID();
      this.scenes = /* @__PURE__ */ new Map();
      this.totalConnected = 0;
      this.scheduler = new common.Scheduler();
      this.gameEngine = inject(common.RpgCommonGame);
      this.world = World;
      this.envs = {};
      this.inputOptions = {};
    }
    /**
     * Combat formulas
     * 
     * @prop {Socket Io Server} [io]
     * @memberof RpgServerEngine
     */
    initialize(io, inputOptions) {
      this.io = io;
      this.inputOptions = inputOptions;
      this.envs = inputOptions.envs || {};
      if (this.inputOptions.workers) {
        console.log("workers enabled");
        this.workers = this.gameEngine.createWorkers(this.inputOptions.workers).load();
      }
    }
    async _init() {
      this.damageFormulas = this.inputOptions.damageFormulas || {};
      this.damageFormulas = {
        damageSkill: DAMAGE_SKILL,
        damagePhysic: DAMAGE_PHYSIC,
        damageCritical: DAMAGE_CRITICAL,
        coefficientElements: COEFFICIENT_ELEMENTS,
        ...this.damageFormulas
      };
      this.globalConfig = this.inputOptions.globalConfig;
      if (!this.inputOptions.maps)
        this.inputOptions.maps = [];
      if (!this.inputOptions.events)
        this.inputOptions.events = [];
      if (!this.inputOptions.worldMaps)
        this.inputOptions.worldMaps = [];
      this.playerProps = this.inputOptions.playerProps;
      this.inputOptions.maps = [...common.Utils.arrayFlat(await common.RpgPlugin.emit(common.HookServer.AddMap, this.inputOptions.maps)) || [], ...this.inputOptions.maps];
      this.inputOptions.events = [...common.Utils.arrayFlat(await common.RpgPlugin.emit(common.HookServer.AddEvent, this.inputOptions.events)) || [], ...this.inputOptions.events];
      this.inputOptions.worldMaps = [...common.Utils.arrayFlat(await common.RpgPlugin.emit(common.HookServer.AddWorldMaps, this.inputOptions.worldMaps)) || [], ...this.inputOptions.worldMaps];
      this.globalConfig.inputs = {
        ...common.DefaultInput,
        ...this.globalConfig.inputs || {}
      };
      if (!this.inputOptions.database)
        this.inputOptions.database = {};
      const datas = await common.RpgPlugin.emit(common.HookServer.AddDatabase, this.inputOptions.database) || [];
      for (let element of datas) {
        if (Array.isArray(element)) {
          for (let data of element) {
            this.addInDatabase(data.id, data);
          }
        } else {
          for (let id in element) {
            this.addInDatabase(element[id].id ?? id, element[id]);
          }
        }
      }
      this.loadScenes();
    }
    /**
     * Adds data to the server's database (in RAM) for later use
     * 
     * 
     * @method server.addInDatabase(id,data)
     * @title Add in database
     * @param {number} id resource id
     * @param {class | object} dataClass A class representing the data. You can just add a object if you specify the type
     * @enum {string} [type] The type of data
     * 
     * item
     * weapon
     * armor
     * skill
     * class
     * state
     * actor
     * @since 3.0.0-beta.4
     * @example
     * ```ts
     * @Item({
     *      name: 'Potion',
     *      description: 'Gives 100 HP',
     * })
     * class MyItem() {}
     * 
     * server.addInDatabase('dynamic_item', MyItem)
     * ```
     * 
     * or with an object
     * 
     * ```ts
     * server.addInDatabase('dynamic_item', {
     *      name: 'Potion',
     *      description: 'Gives 100 HP',
     * }, 'item')
     * ```
     * 
     * @returns {void}
     * @memberof RpgServerEngine
     */
    addInDatabase(id, dataClass, type) {
      if (common.Utils.isClass(dataClass)) {
        this.database[id] = dataClass;
        return;
      }
      if (!type) {
        throw new Error(`You must specify a type for the database ${id}`);
      }
      switch (type) {
        case "item":
          let ItemClass = class {
          };
          ItemClass = __decorateClass([database.Item(dataClass)], ItemClass);
          this.database[id] = ItemClass;
          break;
        case "weapon":
          let WeaponClass = class {
          };
          WeaponClass = __decorateClass([database.Weapon(dataClass)], WeaponClass);
          this.database[id] = WeaponClass;
          break;
        case "armor":
          let ArmorClass = class {
          };
          ArmorClass = __decorateClass([database.Armor(dataClass)], ArmorClass);
          this.database[id] = ArmorClass;
          break;
        case "skill":
          let SkillClass = class {
          };
          SkillClass = __decorateClass([database.Skill(dataClass)], SkillClass);
          this.database[id] = SkillClass;
          break;
        case "class":
          let ClassClass = class {
          };
          ClassClass = __decorateClass([database.Class(dataClass)], ClassClass);
          this.database[id] = ClassClass;
          break;
        case "state":
          let StateClass = class {
          };
          StateClass = __decorateClass([database.State(dataClass)], StateClass);
          this.database[id] = StateClass;
          break;
        case "actor":
          let ActorClass = class {
          };
          ActorClass = __decorateClass([database.Actor(dataClass)], ActorClass);
          this.database[id] = ActorClass;
          break;
      }
    }
    /**
    * Start the RPG server
    * 
    * @method server.start()
    * @title Start Server
    * @returns {void}
    * @memberof RpgServerEngine
    */
    async start(inputOptions, scheduler = true) {
      if (inputOptions)
        this.inputOptions = inputOptions;
      await this._init();
      this.tick.subscribe(({
        timestamp,
        deltaTime
      }) => {
        this.step(timestamp, deltaTime);
      });
      if (scheduler)
        this.scheduler.start({
          fps: (inputOptions == null ? void 0 : inputOptions.fps) || 60
        });
      this.gameEngine.start({
        getObject(id) {
          return Query.getPlayer(id);
        },
        getObjectsOfGroup(groupId, player) {
          return Query._getObjectsOfMap(groupId, player);
        },
        getShapesOfGroup(map) {
          return Query._getShapesOfMap(map);
        }
      });
      this.transport(this.io);
      await common.RpgPlugin.emit(common.HookServer.Start, this);
    }
    transport(io) {
      const timeoutDisconnect = this.globalConfig.timeoutDisconnect ?? 0;
      const auth = this.globalConfig.disableAuth ? () => common.Utils.generateUID() : async (socket) => {
        const val = await common.RpgPlugin.emit(common.HookServer.Auth, [this, socket], true);
        if (val.length == 0) {
          return common.Utils.generateUID();
        }
        return val[val.length - 1];
      };
      const transport = new Transport(io, {
        timeoutDisconnect,
        auth
      });
      this.world.timeoutDisconnect = timeoutDisconnect;
      transport.onConnected(this.onPlayerConnected.bind(this));
      transport.onDisconnected(this.onPlayerDisconnected.bind(this));
      return transport;
    }
    get tick() {
      return this.scheduler.tick;
    }
    /**
     * Sends all packages to clients. The sending is done automatically but you can decide to send yourself by calling this method (for example, for unit tests)
     * 
     * @method server.send()
     * @title Send All Packets
     * @returns {void}
     * @memberof RpgServerEngine
     */
    send() {
      return this.world.send();
    }
    async updatePlayersMove(deltaTimeInt) {
      const players = this.world.getUsers();
      const obj = [];
      let p = [];
      for (let playerId in players) {
        const playerInstance = players[playerId]["proxy"];
        if (!playerInstance)
          continue;
        const player = playerInstance.otherPossessedPlayer ?? playerInstance;
        if (player.pendingMove.length > 0) {
          const lastFrame = player.pendingMove[player.pendingMove.length - 1];
          if (this.inputOptions.workers)
            obj.push(player.toObject());
          else {
            p.push(this.gameEngine.processInput(player.playerId, this.globalConfig.inputs).then((val) => {
              player.pendingMove = [];
              player.moving = false;
              player._lastFramePositions = {
                frame: lastFrame.frame,
                position: {
                  ...player.position
                }
              };
              return player;
            }));
          }
        }
      }
      if (this.inputOptions.workers) {
        this.workers.call("movePlayers", obj).then((players2) => {
          for (let playerId in players2) {
            const player = this.world.getUser(playerId);
            const data = players2[playerId];
            if (player) {
              player.position = data.position;
              player.direction = data.direction;
            }
            common.RpgPlugin.emit("Server.onInput", [player, {
              input: data.direction,
              moving: true
            }], true);
          }
        });
      }
      return Promise.all(p);
    }
    nextTick(timestamp) {
      this.scheduler.nextTick(timestamp);
    }
    step(t, dt) {
      this.updatePlayersMove(1);
      if (this.scheduler.frame % 4 === 0) {
        this.send();
      }
      common.RpgPlugin.emit(common.HookServer.Step, this);
    }
    loadScenes() {
      this.scenes.set(SceneMap.id, new SceneMap({
        maps: this.inputOptions.maps,
        events: this.inputOptions.events,
        worldMaps: this.inputOptions.worldMaps
      }));
    }
    getScene(name) {
      return this.scenes.get(name);
    }
    /**
     * Return the scene that manages the maps of the game
     * @prop {SceneMap} [sceneMap]
     * @since 3.0.0-beta.4
     * @memberof RpgServerEngine
     */
    get sceneMap() {
      return this.getScene(SceneMap.id);
    }
    get module() {
      return common.RpgPlugin;
    }
    get assetsPath() {
      var _a;
      return ((_a = this.envs) == null ? void 0 : _a["VITE_ASSETS_PATH"]) || "assets";
    }
    sendToPlayer(currentPlayer, eventName, data) {
      currentPlayer._socket.emit(eventName, data);
    }
    getPlayerBySession(session) {
      const users = this.world.getUsers();
      for (let userId in users) {
        const user = users[userId];
        if (user.session === session) {
          return user;
        }
      }
      return null;
    }
    onPlayerConnected(socket, playerId) {
      const existingUser = this.world.getUser(playerId, false);
      this.world.connectUser(socket, playerId);
      let player;
      if (!existingUser) {
        const {
          token
        } = socket.handshake.auth;
        player = new RpgPlayer(playerId);
        player.session = token;
        this.world.setUser(player, socket);
        player._init();
        if (!token) {
          const newToken = common.Utils.generateUID() + "-" + common.Utils.generateUID() + "-" + common.Utils.generateUID();
          player.session = newToken;
        }
        if (!token) {
          player.execMethod("onConnected");
        } else {
          common.RpgPlugin.emit(common.HookServer.ScalabilityPlayerConnected, player);
        }
      } else {
        player = existingUser;
        if (player.map) {
          player.emit("preLoadScene", {
            reconnect: true,
            id: player.map
          });
          player.emitSceneMap();
          this.world.joinRoom(player.map, playerId);
        }
      }
      socket.emit("playerJoined", {
        playerId,
        session: player.session
      });
      socket.on("move", (data) => {
        if (!(data == null ? void 0 : data.input))
          return;
        if (!Array.isArray(data.input))
          return;
        const controlPlayer = player.otherPossessedPlayer ?? player;
        if (!controlPlayer.canMove) {
          return;
        }
        for (let input of data.input) {
          controlPlayer.pendingMove.push({
            input,
            frame: data.frame
          });
        }
      });
    }
    onPlayerDisconnected(playerId) {
      const player = World.getUser(playerId);
      player.execMethod("onDisconnected");
      this.world.disconnectUser(playerId);
    }
    stop() {
      this.scheduler.stop();
    }
  }
  const global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
  function bind(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }
  const { toString } = Object.prototype;
  const { getPrototypeOf } = Object;
  const kindOf = ((cache) => (thing) => {
    const str2 = toString.call(thing);
    return cache[str2] || (cache[str2] = str2.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  const kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type;
  };
  const typeOfTest = (type) => (thing) => typeof thing === type;
  const { isArray } = Array;
  const isUndefined = typeOfTest("undefined");
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  const isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  const isString = typeOfTest("string");
  const isFunction = typeOfTest("function");
  const isNumber = typeOfTest("number");
  const isObject = (thing) => thing !== null && typeof thing === "object";
  const isBoolean = (thing) => thing === true || thing === false;
  const isPlainObject = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
  };
  const isDate = kindOfTest("Date");
  const isFile = kindOfTest("File");
  const isBlob = kindOfTest("Blob");
  const isFileList = kindOfTest("FileList");
  const isStream = (val) => isObject(val) && isFunction(val.pipe);
  const isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
  };
  const isURLSearchParams = kindOfTest("URLSearchParams");
  const trim = (str2) => str2.trim ? str2.trim() : str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i2;
    let l;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i2 = 0, l = obj.length; i2 < l; i2++) {
        fn.call(null, obj[i2], i2, obj);
      }
    } else {
      const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys2.length;
      let key;
      for (i2 = 0; i2 < len; i2++) {
        key = keys2[i2];
        fn.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey(obj, key) {
    key = key.toLowerCase();
    const keys2 = Object.keys(obj);
    let i2 = keys2.length;
    let _key;
    while (i2-- > 0) {
      _key = keys2[i2];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  const _global = (() => {
    if (typeof globalThis !== "undefined")
      return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global$1;
  })();
  const isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i2 = 0, l = arguments.length; i2 < l; i2++) {
      arguments[i2] && forEach(arguments[i2], assignValue);
    }
    return result;
  }
  const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
    forEach(b, (val, key) => {
      if (thisArg && isFunction(val)) {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    }, { allOwnKeys });
    return a;
  };
  const stripBOM = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  const inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
    let props;
    let i2;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null)
      return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i2 = props.length;
      while (i2-- > 0) {
        prop = props[i2];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  const endsWith = (str2, searchString, position) => {
    str2 = String(str2);
    if (position === void 0 || position > str2.length) {
      position = str2.length;
    }
    position -= searchString.length;
    const lastIndex = str2.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
  const toArray = (thing) => {
    if (!thing)
      return null;
    if (isArray(thing))
      return thing;
    let i2 = thing.length;
    if (!isNumber(i2))
      return null;
    const arr = new Array(i2);
    while (i2-- > 0) {
      arr[i2] = thing[i2];
    }
    return arr;
  };
  const isTypedArray = ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  const forEachEntry = (obj, fn) => {
    const generator = obj && obj[Symbol.iterator];
    const iterator2 = generator.call(obj);
    let result;
    while ((result = iterator2.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };
  const matchAll = (regExp, str2) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str2)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  const isHTMLForm = kindOfTest("HTMLFormElement");
  const toCamelCase = (str2) => {
    return str2.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
  const isRegExp = kindOfTest("RegExp");
  const reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor, name) => {
      if (reducer(descriptor, name, obj) !== false) {
        reducedDescriptors[name] = descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name) => {
      if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj[name];
      if (!isFunction(value))
        return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  const toObjectSet = (arrayOrString, delimiter2) => {
    const obj = {};
    const define2 = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter2));
    return obj;
  };
  const noop = () => {
  };
  const toFiniteNumber = (value, defaultValue) => {
    value = +value;
    return Number.isFinite(value) ? value : defaultValue;
  };
  const ALPHA = "abcdefghijklmnopqrstuvwxyz";
  const DIGIT = "0123456789";
  const ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  };
  const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
    let str2 = "";
    const { length } = alphabet;
    while (size--) {
      str2 += alphabet[Math.random() * length | 0];
    }
    return str2;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
  }
  const toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit = (source, i2) => {
      if (isObject(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (!("toJSON" in source)) {
          stack[i2] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value, key) => {
            const reducedValue = visit(value, i2 + 1);
            !isUndefined(reducedValue) && (target[key] = reducedValue);
          });
          stack[i2] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit(obj, 0);
  };
  const utils = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject
  };
  function AxiosError(message, code, config2, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config2 && (this.config = config2);
    request && (this.request = request);
    response && (this.response = response);
  }
  utils.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils.toJSONObject(this.config),
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }
  });
  const prototype$1 = AxiosError.prototype;
  const descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code) => {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype$1, "isAxiosError", { value: true });
  AxiosError.from = (error, code, config2, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);
    utils.toFlatObject(error, axiosError, function filter2(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code, config2, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  const httpAdapter = null;
  function isVisitable(thing) {
    return utils.isPlainObject(thing) || utils.isArray(thing);
  }
  function removeBrackets(key) {
    return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey(path2, key, dots) {
    if (!path2)
      return key;
    return path2.concat(key).map(function each(token, i2) {
      token = removeBrackets(token);
      return !dots && i2 ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils.isArray(arr) && !arr.some(isVisitable);
  }
  const predicates = utils.toFlatObject(utils, {}, null, function filter2(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData(obj, formData, options2) {
    if (!utils.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new FormData();
    options2 = utils.toFlatObject(options2, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils.isUndefined(source[option]);
    });
    const metaTokens = options2.metaTokens;
    const visitor = options2.visitor || defaultVisitor;
    const dots = options2.dots;
    const indexes = options2.indexes;
    const _Blob = options2.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils.isSpecCompliantForm(formData);
    if (!utils.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null)
        return "";
      if (utils.isDate(value)) {
        return value.toISOString();
      }
      if (!useBlob && utils.isBlob(value)) {
        throw new AxiosError("Blob is not supported. Use a Buffer instead.");
      }
      if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer$2.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key, path2) {
      let arr = value;
      if (value && !path2 && typeof value === "object") {
        if (utils.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, "[]")) && (arr = utils.toArray(value))) {
          key = removeBrackets(key);
          arr.forEach(function each(el, index2) {
            !(utils.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path2, key, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path2) {
      if (utils.isUndefined(value))
        return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path2.join("."));
      }
      stack.push(value);
      utils.forEach(value, function each(el, key) {
        const result = !(utils.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils.isString(key) ? key.trim() : key,
          path2,
          exposedHelpers
        );
        if (result === true) {
          build(el, path2 ? path2.concat(key) : [key]);
        }
      });
      stack.pop();
    }
    if (!utils.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  function encode$1(str2) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str2).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options2) {
    this._pairs = [];
    params && toFormData(params, this, options2);
  }
  const prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append(name, value) {
    this._pairs.push([name, value]);
  };
  prototype.toString = function toString2(encoder2) {
    const _encode = encoder2 ? function(value) {
      return encoder2.call(this, value, encode$1);
    } : encode$1;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url, params, options2) {
    if (!params) {
      return url;
    }
    const _encode = options2 && options2.encode || encode;
    const serializeFn = options2 && options2.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options2);
    } else {
      serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options2).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  }
  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options2) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options2 ? options2.synchronous : false,
        runWhen: options2 ? options2.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    }
  }
  const InterceptorManager$1 = InterceptorManager;
  const transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
  const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
  const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
  const isStandardBrowserEnv = (() => {
    let product;
    if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  })();
  const isStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  const platform = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1
    },
    isStandardBrowserEnv,
    isStandardBrowserWebWorkerEnv,
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };
  function toURLEncodedForm(data, options2) {
    return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
      visitor: function(value, key, path2, helpers) {
        if (platform.isNode && utils.isBuffer(value)) {
          this.append(key, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options2));
  }
  function parsePropPath(name) {
    return utils.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys2 = Object.keys(arr);
    let i2;
    const len = keys2.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys2[i2];
      obj[key] = arr[key];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path2, value, target, index2) {
      let name = path2[index2++];
      const isNumericKey = Number.isFinite(+name);
      const isLast = index2 >= path2.length;
      name = !name && utils.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path2, value, target[name], index2);
      if (result && utils.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
      const obj = {};
      utils.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  const DEFAULT_CONTENT_TYPE = {
    "Content-Type": void 0
  };
  function stringifySafely(rawValue, parser, encoder2) {
    if (utils.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder2 || JSON.stringify)(rawValue);
  }
  const defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils.isObject(data);
      if (isObjectPayload && utils.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils.isFormData(data);
      if (isFormData2) {
        if (!hasJSONContentType) {
          return data;
        }
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }
      if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
        return data;
      }
      if (utils.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    }
  };
  utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method2) {
    defaults.headers[method2] = {};
  });
  utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method2) {
    defaults.headers[method2] = utils.merge(DEFAULT_CONTENT_TYPE);
  });
  const defaults$1 = defaults;
  const ignoreDuplicateOf = utils.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  const parseHeaders = (rawHeaders) => {
    const parsed = {};
    let key;
    let val;
    let i2;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
      i2 = line.indexOf(":");
      key = line.substring(0, i2).trim().toLowerCase();
      val = line.substring(i2 + 1).trim();
      if (!key || parsed[key] && ignoreDuplicateOf[key]) {
        return;
      }
      if (key === "set-cookie") {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    });
    return parsed;
  };
  const $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str2) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str2)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  const isValidHeaderName = (str2) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str2.trim());
  function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
    if (utils.isFunction(filter2)) {
      return filter2.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils.isString(value))
      return;
    if (utils.isString(filter2)) {
      return value.indexOf(filter2) !== -1;
    }
    if (utils.isRegExp(filter2)) {
      return filter2.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str2) => {
      return char.toUpperCase() + str2;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key = utils.findKey(self2, lHeader);
        if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
          self2[key || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders(header), valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils.findKey(this, header);
        if (key) {
          const value = this[key];
          if (!parser) {
            return value;
          }
          if (parser === true) {
            return parseTokens(value);
          }
          if (utils.isFunction(parser)) {
            return parser.call(this, value, key);
          }
          if (utils.isRegExp(parser)) {
            return parser.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils.findKey(this, header);
        return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key = utils.findKey(self2, _header);
          if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
            delete self2[key];
            deleted = true;
          }
        }
      }
      if (utils.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys2 = Object.keys(this);
      let i2 = keys2.length;
      let deleted = false;
      while (i2--) {
        const key = keys2[i2];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format2) {
      const self2 = this;
      const headers = {};
      utils.forEach(this, (value, header) => {
        const key = utils.findKey(headers, header);
        if (key) {
          self2[key] = normalizeValue(value);
          delete self2[header];
          return;
        }
        const normalized = format2 ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  }
  AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils.freezeMethods(AxiosHeaders.prototype);
  utils.freezeMethods(AxiosHeaders);
  const AxiosHeaders$1 = AxiosHeaders;
  function transformData(fns, response) {
    const config2 = this || defaults$1;
    const context = response || config2;
    const headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;
    utils.forEach(fns, function transform(fn) {
      data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }
  function CanceledError(message, config2, request) {
    AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
    this.name = "CanceledError";
  }
  utils.inherits(CanceledError, AxiosError, {
    __CANCEL__: true
  });
  function settle(resolve2, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve2(response);
    } else {
      reject(new AxiosError(
        "Request failed with status code " + response.status,
        [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  const cookies = platform.isStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    function standardBrowserEnv() {
      return {
        write: function write3(name, value, expires, path2, domain2, secure) {
          const cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path2)) {
            cookie.push("path=" + path2);
          }
          if (utils.isString(domain2)) {
            cookie.push("domain=" + domain2);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read2(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return {
        write: function write3() {
        },
        read: function read2() {
          return null;
        },
        remove: function remove() {
        }
      };
    }()
  );
  function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  const isURLSameOrigin = platform.isStandardBrowserEnv ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv() {
      const msie = /(msie|trident)/i.test(navigator.userAgent);
      const urlParsingNode = document.createElement("a");
      let originURL;
      function resolveURL(url) {
        let href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return function isURLSameOrigin2() {
        return true;
      };
    }()
  );
  function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  }
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== void 0 ? min : 1e3;
    return function push2(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i2 = tail;
      let bytesCount = 0;
      while (i2 !== head) {
        bytesCount += bytes[i2++];
        i2 = i2 % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  function progressEventReducer(listener, isDownloadStream) {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return (e) => {
      const loaded = e.loaded;
      const total = e.lengthComputable ? e.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e
      };
      data[isDownloadStream ? "download" : "upload"] = true;
      listener(data);
    };
  }
  const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  const xhrAdapter = isXHRAdapterSupported && function(config2) {
    return new Promise(function dispatchXhrRequest(resolve2, reject) {
      let requestData = config2.data;
      const requestHeaders = AxiosHeaders$1.from(config2.headers).normalize();
      const responseType = config2.responseType;
      let onCanceled;
      function done2() {
        if (config2.cancelToken) {
          config2.cancelToken.unsubscribe(onCanceled);
        }
        if (config2.signal) {
          config2.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils.isFormData(requestData) && (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv)) {
        requestHeaders.setContentType(false);
      }
      let request = new XMLHttpRequest();
      if (config2.auth) {
        const username = config2.auth.username || "";
        const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
        requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
      }
      const fullPath = buildFullPath(config2.baseURL, config2.url);
      request.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
      request.timeout = config2.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders$1.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config2,
          request
        };
        settle(function _resolve(value) {
          resolve2(value);
          done2();
        }, function _reject(err) {
          reject(err);
          done2();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = config2.transitional || transitionalDefaults;
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config2,
          request
        ));
        request = null;
      };
      if (platform.isStandardBrowserEnv) {
        const xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName && cookies.read(config2.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config2.xsrfHeaderName, xsrfValue);
        }
      }
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }
      if (!utils.isUndefined(config2.withCredentials)) {
        request.withCredentials = !!config2.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = config2.responseType;
      }
      if (typeof config2.onDownloadProgress === "function") {
        request.addEventListener("progress", progressEventReducer(config2.onDownloadProgress, true));
      }
      if (typeof config2.onUploadProgress === "function" && request.upload) {
        request.upload.addEventListener("progress", progressEventReducer(config2.onUploadProgress));
      }
      if (config2.cancelToken || config2.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
          request.abort();
          request = null;
        };
        config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
        if (config2.signal) {
          config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(fullPath);
      if (protocol && platform.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
        return;
      }
      request.send(requestData || null);
    });
  };
  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter
  };
  utils.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e) {
      }
      Object.defineProperty(fn, "adapterName", { value });
    }
  });
  const adapters = {
    getAdapter: (adapters2) => {
      adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
      const { length } = adapters2;
      let nameOrAdapter;
      let adapter;
      for (let i2 = 0; i2 < length; i2++) {
        nameOrAdapter = adapters2[i2];
        if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
          break;
        }
      }
      if (!adapter) {
        if (adapter === false) {
          throw new AxiosError(
            `Adapter ${nameOrAdapter} is not supported by the environment`,
            "ERR_NOT_SUPPORT"
          );
        }
        throw new Error(
          utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
        );
      }
      if (!utils.isFunction(adapter)) {
        throw new TypeError("adapter is not a function");
      }
      return adapter;
    },
    adapters: knownAdapters
  };
  function throwIfCancellationRequested(config2) {
    if (config2.cancelToken) {
      config2.cancelToken.throwIfRequested();
    }
    if (config2.signal && config2.signal.aborted) {
      throw new CanceledError(null, config2);
    }
  }
  function dispatchRequest(config2) {
    throwIfCancellationRequested(config2);
    config2.headers = AxiosHeaders$1.from(config2.headers);
    config2.data = transformData.call(
      config2,
      config2.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
      config2.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter);
    return adapter(config2).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config2);
      response.data = transformData.call(
        config2,
        config2.transformResponse,
        response
      );
      response.headers = AxiosHeaders$1.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config2);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config2,
            config2.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
  function mergeConfig(config1, config2) {
    config2 = config2 || {};
    const config3 = {};
    function getMergedValue(target, source, caseless) {
      if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
        return utils.merge.call({ caseless }, target, source);
      } else if (utils.isPlainObject(source)) {
        return utils.merge({}, source);
      } else if (utils.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a, b, caseless) {
      if (!utils.isUndefined(b)) {
        return getMergedValue(a, b, caseless);
      } else if (!utils.isUndefined(a)) {
        return getMergedValue(void 0, a, caseless);
      }
    }
    function valueFromConfig2(a, b) {
      if (!utils.isUndefined(b)) {
        return getMergedValue(void 0, b);
      }
    }
    function defaultToConfig2(a, b) {
      if (!utils.isUndefined(b)) {
        return getMergedValue(void 0, b);
      } else if (!utils.isUndefined(a)) {
        return getMergedValue(void 0, a);
      }
    }
    function mergeDirectKeys(a, b, prop) {
      if (prop in config2) {
        return getMergedValue(a, b);
      } else if (prop in config1) {
        return getMergedValue(void 0, a);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
    };
    utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
    });
    return config3;
  }
  const VERSION = "1.3.6";
  const validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
    validators$1[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
    };
  });
  const deprecatedWarnings = {};
  validators$1.transitional = function transitional(validator2, version2, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator2 === false) {
        throw new AxiosError(
          formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
          AxiosError.ERR_DEPRECATED
        );
      }
      if (version2 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  function assertOptions(options2, schema, allowUnknown) {
    if (typeof options2 !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    const keys2 = Object.keys(options2);
    let i2 = keys2.length;
    while (i2-- > 0) {
      const opt = keys2[i2];
      const validator2 = schema[opt];
      if (validator2) {
        const value = options2[opt];
        const result = value === void 0 || validator2(value, opt, options2);
        if (result !== true) {
          throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  const validator = {
    assertOptions,
    validators: validators$1
  };
  const validators = validator.validators;
  class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager$1(),
        response: new InterceptorManager$1()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    request(configOrUrl, config2) {
      if (typeof configOrUrl === "string") {
        config2 = config2 || {};
        config2.url = configOrUrl;
      } else {
        config2 = configOrUrl || {};
      }
      config2 = mergeConfig(this.defaults, config2);
      const { transitional, paramsSerializer, headers } = config2;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils.isFunction(paramsSerializer)) {
          config2.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }
      config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders;
      contextHeaders = headers && utils.merge(
        headers.common,
        headers[config2.method]
      );
      contextHeaders && utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method2) => {
          delete headers[method2];
        }
      );
      config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i2 = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config2);
        while (i2 < len) {
          promise = promise.then(chain[i2++], chain[i2++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config2;
      i2 = 0;
      while (i2 < len) {
        const onFulfilled = requestInterceptorChain[i2++];
        const onRejected = requestInterceptorChain[i2++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      i2 = 0;
      len = responseInterceptorChain.length;
      while (i2 < len) {
        promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
      }
      return promise;
    }
    getUri(config2) {
      config2 = mergeConfig(this.defaults, config2);
      const fullPath = buildFullPath(config2.baseURL, config2.url);
      return buildURL(fullPath, config2.params, config2.paramsSerializer);
    }
  }
  utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method2) {
    Axios.prototype[method2] = function(url, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method: method2,
        url,
        data: (config2 || {}).data
      }));
    };
  });
  utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method2) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method: method2,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data
        }));
      };
    }
    Axios.prototype[method2] = generateHTTPMethod();
    Axios.prototype[method2 + "Form"] = generateHTTPMethod(true);
  });
  const Axios$1 = Axios;
  class CancelToken {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve2) {
        resolvePromise = resolve2;
      });
      const token = this;
      this.promise.then((cancel) => {
        if (!token._listeners)
          return;
        let i2 = token._listeners.length;
        while (i2-- > 0) {
          token._listeners[i2](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve2) => {
          token.subscribe(resolve2);
          _resolve = resolve2;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config2, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message, config2, request);
        resolvePromise(token.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index2 = this._listeners.indexOf(listener);
      if (index2 !== -1) {
        this._listeners.splice(index2, 1);
      }
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken(function executor(c2) {
        cancel = c2;
      });
      return {
        token,
        cancel
      };
    }
  }
  const CancelToken$1 = CancelToken;
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError(payload) {
    return utils.isObject(payload) && payload.isAxiosError === true;
  }
  const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode).forEach(([key, value]) => {
    HttpStatusCode[value] = key;
  });
  const HttpStatusCode$1 = HttpStatusCode;
  function createInstance(defaultConfig) {
    const context = new Axios$1(defaultConfig);
    const instance = bind(Axios$1.prototype.request, context);
    utils.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
    utils.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
  }
  const axios = createInstance(defaults$1);
  axios.Axios = Axios$1;
  axios.CanceledError = CanceledError;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData;
  axios.AxiosError = AxiosError;
  axios.Cancel = axios.CanceledError;
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;
  axios.isAxiosError = isAxiosError;
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders$1;
  axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.HttpStatusCode = HttpStatusCode$1;
  axios.default = axios;
  const axios$1 = axios;
  class RpgMatchMaker {
    constructor(options2) {
      this.options = options2;
      this.endpoint = options2.endpoint;
      this.headers = options2.headers;
      this.callback = options2.callback;
    }
    async getServer(player) {
      const currentServerId = inject(RpgServerEngine).serverId;
      const payload = {
        playerId: player.id,
        mapName: player.map
      };
      let res = {};
      if (this.callback) {
        res = this.callback(payload);
        if (common.Utils.isPromise(res)) {
          res = await res;
        }
      }
      if (this.endpoint) {
        try {
          res = await axios$1.post(this.endpoint, payload, {
            headers: this.headers
          }).then((res2) => res2.data);
        } catch (err) {
          console.log("There is a problem with the MatchMaker webservice.");
          throw err;
        }
      }
      if (currentServerId == res.serverId) {
        return null;
      }
      return res;
    }
  }
  async function entryPoint(modules, options2) {
    const context = new common.InjectContext();
    setInject(context);
    inject(common.RpgCommonGame, [common.GameSide.Server]);
    if (!options2.globalConfig)
      options2.globalConfig = {};
    const relations = {
      onConnected: common.HookServer.PlayerConnected,
      onInput: common.HookServer.PlayerInput,
      onJoinMap: common.HookServer.PlayerJoinMap,
      onLeaveMap: common.HookServer.PlayerLeaveMap,
      onLevelUp: common.HookServer.PlayerLevelUp,
      onDead: common.HookServer.PlayerDead,
      onDisconnected: common.HookServer.PlayerDisconnected,
      onInShape: common.HookServer.PlayerInShape,
      onOutShape: common.HookServer.PlayerOutShape,
      onMove: common.HookServer.PlayerMove,
      canChangeMap: common.HookServer.PlayerCanChangeMap
    };
    const relationsEngine = {
      onStart: common.HookServer.Start,
      onStep: common.HookServer.Step,
      auth: common.HookServer.Auth
    };
    const {
      playerProps
    } = await common.loadModules(modules, {
      side: "server",
      relations: {
        player: relations,
        engine: relationsEngine,
        scalability: {
          onConnected: common.HookServer.ScalabilityPlayerConnected,
          doChangeServer: common.HookServer.ScalabilityChangeServer
        }
      }
    }, (mod) => {
      const {
        scalability
      } = mod;
      if (scalability) {
        const {
          hooks,
          stateStore,
          matchMaker
        } = scalability;
        const matchMakerInstance = new RpgMatchMaker(matchMaker);
        common.RpgPlugin.on(common.HookServer.Start, () => {
          return stateStore.connect();
        });
        mod.scalability._hooks = {};
        for (let hookName in hooks) {
          let originalHook = mod.scalability.hooks[hookName];
          mod.scalability._hooks[hookName] = function(player) {
            return originalHook(stateStore, matchMakerInstance, player);
          };
        }
      }
      return mod;
    });
    const serverEngine = inject(RpgServerEngine, [options2.io, {
      debug: {},
      updateRate: 10,
      stepRate: 60,
      timeoutInterval: 0,
      countConnections: false,
      playerProps,
      ...options2
    }]);
    return serverEngine;
  }
  class Monitor extends common.EventEmitter {
    constructor() {
      super(...arguments);
      this.monitors = /* @__PURE__ */ new Map();
      this.totalConnected = 0;
    }
    get status() {
      return {
        loop: this.loopMs,
        totalConnected: this.totalConnected
      };
    }
    getStatusOf(id) {
      return this.monitors.get(id);
    }
    update(server) {
      const {
        scheduler,
        options: options2
      } = server;
      if (this.lastTime) {
        const hrtime2 = process.hrtime(this.lastTime);
        this.loopMs = hrtime2[1] / 1e6;
      }
      const period = scheduler.options.period;
      if (this.loopMs > period + 20) {
        const {
          stepRate
        } = options2;
        console.warn("%s - Warning Low FPS. %s players connected. Game Loop: %s FPS", /* @__PURE__ */ new Date(), this.totalConnected, Math.round(stepRate / (this.loopMs / period)));
      }
      this.lastTime = process.hrtime();
    }
    addMonitor(socket) {
      this.totalConnected++;
    }
    removeMonitor(id) {
      this.monitors.delete(id);
      this.totalConnected--;
    }
  }
  const index = new Monitor();
  Object.defineProperty(exports2, "AbstractObject", {
    enumerable: true,
    get: () => common.AbstractObject
  });
  Object.defineProperty(exports2, "Control", {
    enumerable: true,
    get: () => common.Control
  });
  Object.defineProperty(exports2, "Direction", {
    enumerable: true,
    get: () => common.Direction
  });
  Object.defineProperty(exports2, "HookClient", {
    enumerable: true,
    get: () => common.HookClient
  });
  Object.defineProperty(exports2, "HookServer", {
    enumerable: true,
    get: () => common.HookServer
  });
  Object.defineProperty(exports2, "Input", {
    enumerable: true,
    get: () => common.Input
  });
  Object.defineProperty(exports2, "RpgModule", {
    enumerable: true,
    get: () => common.RpgModule
  });
  Object.defineProperty(exports2, "RpgPlugin", {
    enumerable: true,
    get: () => common.RpgPlugin
  });
  Object.defineProperty(exports2, "RpgShape", {
    enumerable: true,
    get: () => common.RpgShape
  });
  Object.defineProperty(exports2, "ShapePositioning", {
    enumerable: true,
    get: () => common.ShapePositioning
  });
  exports2.Components = Components;
  exports2.EventData = EventData;
  exports2.EventMode = EventMode;
  exports2.Frequency = Frequency;
  exports2.Gui = Gui;
  exports2.MapData = MapData;
  exports2.Monitor = index;
  exports2.Move = Move;
  exports2.Presets = index$1;
  exports2.Query = Query;
  exports2.RpgEvent = RpgEvent;
  exports2.RpgMap = RpgMap;
  exports2.RpgMatchMaker = RpgMatchMaker;
  exports2.RpgPlayer = RpgPlayer;
  exports2.RpgSceneMap = SceneMap;
  exports2.RpgServerEngine = RpgServerEngine;
  exports2.RpgWorld = Query;
  exports2.RpgWorldMaps = RpgWorldMaps;
  exports2.Speed = Speed;
  exports2.entryPoint = entryPoint;
  exports2.inject = inject;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
});
