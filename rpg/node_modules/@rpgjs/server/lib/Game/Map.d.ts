import { RpgCommonMap, RpgShape, RpgCommonGame, AbstractObject } from '@rpgjs/common';
import { TiledTileset } from '@rpgjs/tiled';
import { EventOptions } from '../decorators/event';
import { RpgPlayer, RpgEvent } from '../Player/Player';
import { RpgServerEngine } from '../server';
import { Observable } from 'rxjs';
import { HitBox, MovingHitbox } from '@rpgjs/types';
import { EventManager, EventMode } from './EventManager';
export type EventPosOption = {
    x: number;
    y: number;
    z?: number;
    event: EventOptions;
};
export type EventOption = EventPosOption | EventOptions;
export type PlayersList = {
    [eventId: string]: RpgEvent;
};
export type EventsList = {
    [playerId: string]: RpgPlayer;
};
export declare class RpgMap extends RpgCommonMap {
    private _server;
    _events: EventOption[];
    file: any;
    constructor(_server: RpgServerEngine);
    /**
     * @title Players list
     * @prop { { [playerId: string]: RpgPlayer } } [players]
     * @readonly
     * @memberof Map
     */
    get players(): PlayersList;
    /**
     * @title Number of players
     * @prop {number} [nbPlayers]
     * @readonly
     * @memberof Map
     */
    get nbPlayers(): number;
    $additionalEmitProperties(player: RpgPlayer): {
        frame: any;
        pos: any;
    };
    load(): Promise<void>;
    /**
     * Update the map with new data. Data can be a string (TMX content) or an object (parsed TMX content)
     * New Map data will be sent to all players on the map
     *
     * @title Update map
     * @method map.update(data)
     * @since 4.0.0
     * @returns {Promise<void>}
     * @param {object | string} data
     * @memberof Map
     */
    update(data: object | string): Promise<void>;
    /**
     * Update tileset with new data. Data can be a string (TSX content) or an object (TiledTileset)
     * Cache will be removed for this tileset
     * New tileset data will be sent to all players on the map
     * Warning: tileset is not updated for all maps, only for the current map
     *
     * @title Update tileset
     * @method map.updateTileset(data)
     * @since 4.0.0
     * @returns {<void>}
     * @param {TiledTileset | string} data
     * @memberof Map
     */
    updateTileset(data: TiledTileset | string): void;
    /**
     * Remove the map from the server. If there are still players on the map, an error will be thrown
     * Not delete the map file, only in memory
     *
     * @title Remove map
     * @method map.remove()
     * @since 4.0.0
     * @returns {void}
     * @throws {Error} If there are still players on the map
     * @memberof Map
     * */
    remove(ignorePlayers?: boolean): never | void;
    private parseTmx;
    private loadProperties;
    get game(): RpgCommonGame;
    onLeave(player: RpgPlayer): void;
    autoLoadEvent(): void;
    /**
     * Edit a tile on the map. All players on the map will see the modified tile
     *
     *
     * @title Change Tile in map
     * @since 3.0.0-beta.4
     * @method map.setTile(x,y,layer,tileInfo)
     * @param {number} x Position X
     * @param {number} y Position Y
     * @param {string | ((layer: any) => boolean)} layer Name of the layer where you want to put a tile. OYou can also put a function that will act as a filter. The first parameter is the layer and you return a boolean to indicate if you modify the tile of this layer or not
     * @param {object} tileInfo Object with the following properties:
     *  - {number} gid: The tile number in tileset (from 1)
     *  - {object} properties Property of the tile. You own object. To set a collision, set the `collision:true` property
     * @example
     * ```ts
     * map.setTile(15, 18, 'mylayer', { gid: 2 })
     * ```
     * @returns {void}
     * @memberof Map
     */
    setTile(x: number, y: number, layerFilter: string | ((layer: any) => boolean), tileInfo: {
        gid: number;
        properties?: object;
    }): any;
    getEventShape(eventName: string): RpgShape | undefined;
    /**
     * Dynamically create an event in Shared mode
     *
     * ```ts
     * @EventData({
     *  name: 'EV-1'
     * })
     * class MyEvent extends RpgEvent {
     *  onAction() {
     *      console.log('ok')
     *  }
     * }
     *
     * map.createDynamicEvent({
     *      x: 100,
     *      y: 100,
     *      event: MyEvent
     * })
     * ```
     *
     * You can also put an array of objects to create several events at once
     *
     * @title Create Dynamic Event
     * @since 3.0.0-beta.4
     * @method map.createDynamicEvent(eventObj|eventObj[])
     * @param { { x: number, y: number, z?: number, event: eventClass } } eventsList
     * @returns { { [eventId: string]: RpgEvent } }
     * @memberof Map
     */
    createDynamicEvent(eventsList: EventPosOption | EventPosOption[]): {
        [eventId: string]: RpgEvent;
    };
    createEvent(obj: EventPosOption, mode: EventMode, shape?: RpgShape): RpgEvent | null;
    createEvents(eventsList: EventOption[], mode: EventMode): EventsList;
    /**
     * Allows to create a temporary hitbox on the map that can have a movement
For example, you can use it to explode a bomb and find all the affected players, or during a sword strike, you can create a moving hitbox and find the affected players again
     * @title Create a temporary and moving hitbox
     * @since 3.2.0
     * @method map.createMovingHitbox(hitboxes,options)
     * @param {Array<{ width: number, height: number, x: number, y: number }>} hitboxes Create several hitboxes that will give an effect of movement
     * @param {object} [options]
     * @param {speed} [options.speed=1] speed of movement (in frames)
     * @returns {Observable<AbstractObject>} You find the methods of position and movement of an event
     * @memberof Map
     * @example
     *
     * ```ts
     * // Two hitboxes that will be done very quickly
     * map.createMovingHitbox(
     *   [
     *      { x: 0, y: 0, width: 100, height: 100 },
     *      { x: 20, y: 0, width: 100, height: 100 }
     *   ]
     * ).subscribe({
     *      next(hitbox) {
     *          console.log(hitbox.otherPlayersCollision)
     *      },
     *      complete() {
     *          console.log('finish')
     *      }
     * })
     * ```
     */
    createMovingHitbox(hitboxes: Pick<HitBox, 'width' | 'height' | 'x' | 'y'>[], options?: MovingHitbox): Observable<AbstractObject>;
    setSync(schema: any): void;
    getCurrentMap(): this;
}
export interface RpgMap extends EventManager {
    sounds: string[];
    $schema: any;
    $setSchema: (schema: any) => void;
    $patchSchema: (schema: any) => void;
    $snapshotUser: (userId: string) => any;
    onLoad(): any;
    $setCurrentState: (path: string, value: any) => void;
    id: string;
}
