import { Direction, LiteralDirection } from '@rpgjs/common';
import { Utils } from '@rpgjs/common';
import { SocketEvents, SocketMethods } from '@rpgjs/types';
import { Observable, takeUntil, tap, switchMap, of, from } from 'rxjs';
const { arrayFlat, random, isFunction, capitalize } = Utils;
function wait(sec) {
    return new Promise((resolve) => {
        setTimeout(resolve, sec * 1000);
    });
}
export var Frequency;
(function (Frequency) {
    Frequency[Frequency["Lowest"] = 600] = "Lowest";
    Frequency[Frequency["Lower"] = 400] = "Lower";
    Frequency[Frequency["Low"] = 200] = "Low";
    Frequency[Frequency["High"] = 100] = "High";
    Frequency[Frequency["Higher"] = 50] = "Higher";
    Frequency[Frequency["Highest"] = 25] = "Highest";
    Frequency[Frequency["None"] = 0] = "None";
})(Frequency || (Frequency = {}));
export var Speed;
(function (Speed) {
    Speed[Speed["Slowest"] = 0.2] = "Slowest";
    Speed[Speed["Slower"] = 0.5] = "Slower";
    Speed[Speed["Slow"] = 1] = "Slow";
    Speed[Speed["Normal"] = 3] = "Normal";
    Speed[Speed["Fast"] = 5] = "Fast";
    Speed[Speed["Faster"] = 7] = "Faster";
    Speed[Speed["Fastest"] = 10] = "Fastest";
})(Speed || (Speed = {}));
/**
* @title Move
* @enum {Object}
*
* Move.right(repeat=1) | Movement of a number of pixels on the right
* Move.left(repeat=1) | Movement of a number of pixels on the left
* Move.up(repeat=1) | Movement of a number of pixels on the up
* Move.down(repeat=1) | Movement of a number of pixels on the down
* Move.random(repeat=1) | Movement of a number of pixels in a random direction
* Move.towardPlayer(player, repeat=1) | Moves a number of pixels in the direction of the designated player
* Move.awayFromPlayer(player, repeat=1) | Moves a number of pixels in the opposite direction of the designated player
* Move.tileRight(repeat=1) | Movement of a number of tiles on the right
* Move.tileLeft(repeat=1) | Movement of a number of tiles on the left
* Move.tileUp(repeat=1) | Movement of a number of tiles on the up
* Move.tileDown(repeat=1) | Movement of a number of tiles on the down
* Move.tileRandom(repeat=1) | Movement of a number of tiles in a random direction
* Move.tileTowardPlayer(player, repeat=1) | Moves a number of tiles in the direction of the designated player
* Move.tileAwayFromPlayer(player, repeat=1) | Moves a number of tiles in the opposite direction of the designated player
* Move.turnRight() | Turn to the right
* Move.turnLeft() | Turn to the left
* Move.turnUp() | Turn to the up
* Move.turnDown() | Turn to the down
* Move.turnRandom() | Turn to random direction
* Move.turnAwayFromPlayer(player) | Turns in the opposite direction of the designated player
* Move.turnTowardPlayer(player) | Turns in the direction of the designated player
* @memberof Move
* */
class MoveList {
    repeatMove(direction, repeat) {
        return new Array(repeat).fill(direction);
    }
    repeatTileMove(direction, repeat, propMap) {
        return (player, map) => {
            const repeatTile = Math.floor(map[propMap] / player.speed) * repeat;
            return this[direction](repeatTile);
        };
    }
    right(repeat = 1) {
        return this.repeatMove(Direction.Right, repeat);
    }
    left(repeat = 1) {
        return this.repeatMove(Direction.Left, repeat);
    }
    up(repeat = 1) {
        return this.repeatMove(Direction.Up, repeat);
    }
    down(repeat = 1) {
        return this.repeatMove(Direction.Down, repeat);
    }
    wait(sec) {
        return wait(sec);
    }
    random(repeat = 1) {
        return new Array(repeat).fill(null).map(() => [
            Direction.Right,
            Direction.Left,
            Direction.Up,
            Direction.Down
        ][random(0, 3)]);
    }
    tileRight(repeat = 1) {
        return this.repeatTileMove('right', repeat, 'tileWidth');
    }
    tileLeft(repeat = 1) {
        return this.repeatTileMove('left', repeat, 'tileWidth');
    }
    tileUp(repeat = 1) {
        return this.repeatTileMove('up', repeat, 'tileHeight');
    }
    tileDown(repeat = 1) {
        return this.repeatTileMove('down', repeat, 'tileHeight');
    }
    tileRandom(repeat = 1) {
        return (player, map) => {
            let directions = [];
            for (let i = 0; i < repeat; i++) {
                const randFn = [
                    this.tileRight(),
                    this.tileLeft(),
                    this.tileUp(),
                    this.tileDown()
                ][random(0, 3)];
                directions = [
                    ...directions,
                    ...randFn(player, map)
                ];
            }
            return directions;
        };
    }
    _awayFromPlayerDirection(player, otherPlayer) {
        const directionOtherPlayer = otherPlayer.getDirection();
        let newDirection = 0;
        switch (directionOtherPlayer) {
            case Direction.Left:
            case Direction.Right:
                if (otherPlayer.position.x > player.position.x) {
                    newDirection = Direction.Left;
                }
                else {
                    newDirection = Direction.Right;
                }
                break;
            case Direction.Up:
            case Direction.Down:
                if (otherPlayer.position.y > player.position.y) {
                    newDirection = Direction.Up;
                }
                else {
                    newDirection = Direction.Down;
                }
                break;
        }
        return newDirection;
    }
    _towardPlayerDirection(player, otherPlayer) {
        const directionOtherPlayer = otherPlayer.getDirection();
        let newDirection = 0;
        switch (directionOtherPlayer) {
            case Direction.Left:
            case Direction.Right:
                if (otherPlayer.position.x > player.position.x) {
                    newDirection = Direction.Right;
                }
                else {
                    newDirection = Direction.Left;
                }
                break;
            case Direction.Up:
            case Direction.Down:
                if (otherPlayer.position.y > player.position.y) {
                    newDirection = Direction.Down;
                }
                else {
                    newDirection = Direction.Up;
                }
                break;
        }
        return newDirection;
    }
    _awayFromPlayer({ isTile, typeMov }, otherPlayer, repeat = 1) {
        const method = (dir) => {
            const direction = LiteralDirection[dir];
            return this[isTile ? 'tile' + capitalize(direction) : direction](repeat);
        };
        return (player, map) => {
            let newDirection = 0;
            switch (typeMov) {
                case 'away':
                    newDirection = this._awayFromPlayerDirection(player, otherPlayer);
                    break;
                case 'toward':
                    newDirection = this._towardPlayerDirection(player, otherPlayer);
                    break;
            }
            let direction = method(newDirection);
            if (isFunction(direction)) {
                direction = direction(player, map);
            }
            return direction;
        };
    }
    towardPlayer(player, repeat = 1) {
        return this._awayFromPlayer({ isTile: false, typeMov: 'toward' }, player, repeat);
    }
    tileTowardPlayer(player, repeat = 1) {
        return this._awayFromPlayer({ isTile: true, typeMov: 'toward' }, player, repeat);
    }
    awayFromPlayer(player, repeat = 1) {
        return this._awayFromPlayer({ isTile: false, typeMov: 'away' }, player, repeat);
    }
    tileAwayFromPlayer(player, repeat = 1) {
        return this._awayFromPlayer({ isTile: true, typeMov: 'away' }, player, repeat);
    }
    turnLeft() {
        return 'turn-' + Direction.Left;
    }
    turnRight() {
        return 'turn-' + Direction.Right;
    }
    turnUp() {
        return 'turn-' + Direction.Up;
    }
    turnDown() {
        return 'turn-' + Direction.Down;
    }
    turnRandom() {
        return [
            this.turnRight(),
            this.turnLeft(),
            this.turnUp(),
            this.turnDown()
        ][random(0, 3)];
    }
    turnAwayFromPlayer(otherPlayer) {
        return (player) => {
            const direction = this._awayFromPlayerDirection(player, otherPlayer);
            return 'turn-' + direction;
        };
    }
    turnTowardPlayer(otherPlayer) {
        return (player) => {
            const direction = this._towardPlayerDirection(player, otherPlayer);
            return 'turn-' + direction;
        };
    }
}
export const Move = new MoveList();
export class MoveManager {
    /**
     * Gives an itinerary.
     *
     * You can create your own motion function:
     *
     * ```ts
     * import { Direction } from '@rpgjs/server'
     *
     * const customMove = () => {
     *      return [Direction.Left, Direction.Up]
     * }
     *
     * player.moveRoutes([ customMove() ])
     * ```
     *
     * Your function can also return a function:
     *
     *  ```ts
     * import { Direction, RpgPlayer } from '@rpgjs/server'
     *
     * // This function can be found in another file. By returning a function, you have access to the player who is making a move.
     * const customMove = (otherPlayer: RpgPlayer) => {
     *      return (player: RpgPlayer, map) => {
     *          return otherPlayer.position.x > player.position.x ? Direction.Left : Direction.Right
     *      }
     * }
     *
     * player.moveRoutes([ customMove(otherPlayer) ])
     * ```
     *
     * the function contains two parameters:
     *
     * - `player`: the player concerned by the movement
     * - `map`: The information of the current map
     *
     * @title Give an itinerary
     * @method player.moveRoutes(routes)
     * @param {Array<Move>} routes
     * @returns {Promise}
     * @memberof MoveManager
     * @example
     *
     * ```ts
     * import { Move } from '@rpgjs/server'
     *
     * await player.moveRoutes([ Move.tileLeft(), Move.tileDown(2) ])
     * // The path is over when the promise is resolved
     * ```
     */
    moveRoutes(routes) {
        let count = 0;
        let frequence = 0;
        this.breakRoutes(); // break previous route
        return new Promise(async (resolve) => {
            this._finishRoute = resolve;
            routes = routes.map((route) => {
                if (isFunction(route)) {
                    const map = this.getCurrentMap();
                    if (!map) {
                        return undefined;
                    }
                    return route.apply(route, [this, map]);
                }
                return route;
            });
            routes = arrayFlat(routes);
            const move = () => {
                // If movement continues while the player no longer exists or is no longer on the map
                if (!this) {
                    return of(null);
                }
                // if map not exists
                if (!this.getCurrentMap()) {
                    return of(null);
                }
                if (count >= this['nbPixelInTile']) {
                    if (frequence < this.frequency) {
                        frequence++;
                        return of(null);
                    }
                }
                frequence = 0;
                count++;
                const [route] = routes;
                if (route === undefined) {
                    this.breakRoutes();
                    return of(null);
                }
                let ob$ = new Observable();
                switch (route) {
                    case Direction.Left:
                    case Direction.Down:
                    case Direction.Right:
                    case Direction.Up:
                        ob$ = from(this.moveByDirection(route, 1));
                        break;
                    case 'turn-' + Direction.Left:
                        ob$ = of(this.changeDirection(Direction.Left));
                        break;
                    case 'turn-' + Direction.Right:
                        ob$ = of(this.changeDirection(Direction.Right));
                        break;
                    case 'turn-' + Direction.Up:
                        ob$ = of(this.changeDirection(Direction.Up));
                        break;
                    case 'turn-' + Direction.Down:
                        ob$ = of(this.changeDirection(Direction.Down));
                        break;
                }
                return ob$.pipe(tap(() => {
                    routes.shift();
                }));
            };
            this.movingSubscription = this.server.tick
                .pipe(takeUntil(this._destroy$.pipe(tap(() => {
                this.breakRoutes(true);
            }))), switchMap(move))
                .subscribe();
        });
    }
    /**
     * Giving a path that repeats itself in a loop to a character
     *
     * You can stop the movement at any time with `breakRoutes()` and replay it with `replayRoutes()`.
     *
     * @title Infinite Move Routes
     * @method player.infiniteMoveRoute(routes)
     * @param {Array<Move>} routes
     * @returns {void}
     * @memberof MoveManager
     * @example
     *
     * ```ts
     * import { Move } from '@rpgjs/server'
     *
     * player.infiniteMoveRoute([ Move.tileRandom() ])
     * ```
     */
    infiniteMoveRoute(routes) {
        this._infiniteRoutes = routes;
        const move = (isBreaking) => {
            if (isBreaking)
                return;
            this.moveRoutes(routes).then(move);
        };
        move(false);
    }
    /**
     * Works only for infinite movements. You must first use the method `infiniteMoveRoute()`
     *
     * @title Stop an infinite movement
     * @method player.breakRoutes(force=false)
     * @param {boolean} [force] Forces the stop of the infinite movement
     * @returns {void}
     * @memberof MoveManager
     * @example
     *
     * ```ts
     * import { Move } from '@rpgjs/server'
     *
     * player.infiniteMoveRoute([ Move.tileRandom() ])
     * player.breakRoutes(true)
     * ```
     */
    breakRoutes(force = false) {
        if (this._finishRoute) {
            this.movingSubscription?.unsubscribe();
            this._finishRoute(force);
        }
    }
    /**
     * Works only for infinite movements. You must first use the method `infiniteMoveRoute()`
     * If the road was stopped with `breakRoutes()`, you can restart it with this method
     *
     * @title Replay an infinite movement
     * @method player.replayRoutes()
     * @returns {void}
     * @memberof MoveManager
     * @example
     *
     * ```ts
     * import { Move } from '@rpgjs/server'
     *
     * player.infiniteMoveRoute([ Move.tileRandom() ])
     * player.breakRoutes(true)
     * player.replayRoutes()
     * ```
     */
    replayRoutes() {
        if (this._infiniteRoutes)
            this.infiniteMoveRoute(this._infiniteRoutes);
    }
    moveTo(position, options) {
        return this['_moveTo'](this.server.tick, position, options);
    }
    // TODO
    setMoveMode(mode) {
        if (mode.checkCollision)
            this.checkCollision = mode.checkCollision;
        if (mode.clientMode)
            this.clientModeMove = mode.clientMode;
        if (mode.behavior)
            this.behavior = mode.behavior;
        this.emit(SocketEvents.CallMethod, {
            objectId: this.id,
            name: SocketMethods.ModeMove,
            params: [mode]
        });
    }
}
//# sourceMappingURL=MoveManager.js.map