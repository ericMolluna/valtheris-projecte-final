import { RpgCommonPlayer, RpgCommonGame } from '@rpgjs/common';
import { WorldClass } from 'simple-room';
import { RpgMap, EventPosOption } from '../Game/Map';
import { ItemManager } from './ItemManager';
import { GoldManager } from './GoldManager';
import { StateManager } from './StateManager';
import { SkillManager } from './SkillManager';
import { ParameterManager } from './ParameterManager';
import { EffectManager } from './EffectManager';
import { ClassManager } from './ClassManager';
import { ElementManager } from './ElementManager';
import { GuiManager } from './GuiManager';
import { VariableManager } from './VariableManager';
import { MoveManager } from './MoveManager';
import { BattleManager } from './BattleManager';
import { RpgServerEngine } from '../server';
import { CameraOptions, PositionXY_OptionalZ, LayoutObject } from '@rpgjs/types';
import { ComponentManager } from './ComponentManager';
import { EventManager, EventMode } from '../Game/EventManager';
export interface Position {
    x: number;
    y: number;
    z: number;
}
export declare const componentSchema: {
    id: StringConstructor;
    value: StringConstructor;
};
export declare const layoutSchema: {
    width: NumberConstructor;
    height: NumberConstructor;
    marginBottom: NumberConstructor;
    marginTop: NumberConstructor;
    marginLeft: NumberConstructor;
    marginRight: NumberConstructor;
    lines: {
        col: {
            id: StringConstructor;
            value: StringConstructor;
        }[];
    }[];
};
export declare class RpgPlayer extends RpgCommonPlayer {
    playerId: string;
    readonly type: string;
    static schemas: {
        events: {
            position: {
                x: NumberConstructor;
                y: NumberConstructor;
                z: NumberConstructor;
            };
            direction: NumberConstructor;
            teleported: {
                $permanent: boolean;
            };
            deleted: {
                $permanent: boolean;
            };
            moving: {
                $permanent: boolean;
            };
            param: ObjectConstructor;
            hp: NumberConstructor;
            sp: NumberConstructor;
            gold: NumberConstructor;
            level: {
                $effects: string[];
            };
            expForNextlevel: {
                $permanent: boolean;
            };
            exp: NumberConstructor;
            name: StringConstructor;
            items: {
                nb: NumberConstructor;
                item: {
                    name: {
                        $permanent: boolean;
                    };
                    description: {
                        $permanent: boolean;
                    };
                    id: StringConstructor;
                    price: {
                        $permanent: boolean;
                    };
                    consumable: {
                        $permanent: boolean;
                    };
                };
            }[];
            _class: {
                name: {
                    $permanent: boolean;
                };
                description: {
                    $permanent: boolean;
                };
                id: StringConstructor;
            };
            equipments: {
                name: {
                    $permanent: boolean;
                };
                description: {
                    $permanent: boolean;
                };
                id: StringConstructor;
                price: {
                    $permanent: boolean;
                };
                consumable: {
                    $permanent: boolean;
                };
            }[];
            skills: {
                name: {
                    $permanent: boolean;
                };
                description: {
                    $permanent: boolean;
                };
                id: StringConstructor;
                spCost: {
                    $permanent: boolean;
                };
            }[];
            states: {
                name: {
                    $permanent: boolean;
                };
                description: {
                    $permanent: boolean;
                };
                id: StringConstructor;
            }[];
            effects: StringConstructor[];
            layout: {
                top: {
                    width: NumberConstructor;
                    height: NumberConstructor;
                    marginBottom: NumberConstructor;
                    marginTop: NumberConstructor;
                    marginLeft: NumberConstructor;
                    marginRight: NumberConstructor;
                    lines: {
                        col: {
                            id: StringConstructor;
                            value: StringConstructor;
                        }[];
                    }[];
                };
                bottom: {
                    width: NumberConstructor;
                    height: NumberConstructor;
                    marginBottom: NumberConstructor;
                    marginTop: NumberConstructor;
                    marginLeft: NumberConstructor;
                    marginRight: NumberConstructor;
                    lines: {
                        col: {
                            id: StringConstructor;
                            value: StringConstructor;
                        }[];
                    }[];
                };
                left: {
                    width: NumberConstructor;
                    height: NumberConstructor;
                    marginBottom: NumberConstructor;
                    marginTop: NumberConstructor;
                    marginLeft: NumberConstructor;
                    marginRight: NumberConstructor;
                    lines: {
                        col: {
                            id: StringConstructor;
                            value: StringConstructor;
                        }[];
                    }[];
                };
                right: {
                    width: NumberConstructor;
                    height: NumberConstructor;
                    marginBottom: NumberConstructor;
                    marginTop: NumberConstructor;
                    marginLeft: NumberConstructor;
                    marginRight: NumberConstructor;
                    lines: {
                        col: {
                            id: StringConstructor;
                            value: StringConstructor;
                        }[];
                    }[];
                };
                center: {
                    width: NumberConstructor;
                    height: NumberConstructor;
                    marginBottom: NumberConstructor;
                    marginTop: NumberConstructor;
                    marginLeft: NumberConstructor;
                    marginRight: NumberConstructor;
                    lines: {
                        col: {
                            id: StringConstructor;
                            value: StringConstructor;
                        }[];
                    }[];
                };
            };
            action: NumberConstructor;
            map: StringConstructor;
            speed: NumberConstructor;
            frequency: NumberConstructor;
            canMove: BooleanConstructor;
            through: BooleanConstructor;
            throughOtherPlayer: BooleanConstructor;
            width: NumberConstructor;
            height: NumberConstructor;
            wHitbox: NumberConstructor;
            hHitbox: NumberConstructor;
            _statesEfficiency: {
                rate: {
                    $syncWithClient: boolean;
                };
                state: {
                    $syncWithClient: boolean;
                };
            }[];
            tmpPositions: {
                $syncWithClient: boolean;
            };
            initialLevel: {
                $syncWithClient: boolean;
            };
            finalLevel: {
                $syncWithClient: boolean;
            };
        }[];
        position: {
            x: NumberConstructor;
            y: NumberConstructor;
            z: NumberConstructor;
        };
        direction: NumberConstructor;
        teleported: {
            $permanent: boolean;
        };
        deleted: {
            $permanent: boolean;
        };
        moving: {
            $permanent: boolean;
        };
        param: ObjectConstructor;
        hp: NumberConstructor;
        sp: NumberConstructor;
        gold: NumberConstructor;
        level: {
            $effects: string[];
        };
        expForNextlevel: {
            $permanent: boolean;
        };
        exp: NumberConstructor;
        name: StringConstructor;
        items: {
            nb: NumberConstructor;
            item: {
                name: {
                    $permanent: boolean;
                };
                description: {
                    $permanent: boolean;
                };
                id: StringConstructor;
                price: {
                    $permanent: boolean;
                };
                consumable: {
                    $permanent: boolean;
                };
            };
        }[];
        _class: {
            name: {
                $permanent: boolean;
            };
            description: {
                $permanent: boolean;
            };
            id: StringConstructor;
        };
        equipments: {
            name: {
                $permanent: boolean;
            };
            description: {
                $permanent: boolean;
            };
            id: StringConstructor;
            price: {
                $permanent: boolean;
            };
            consumable: {
                $permanent: boolean;
            };
        }[];
        skills: {
            name: {
                $permanent: boolean;
            };
            description: {
                $permanent: boolean;
            };
            id: StringConstructor;
            spCost: {
                $permanent: boolean;
            };
        }[];
        states: {
            name: {
                $permanent: boolean;
            };
            description: {
                $permanent: boolean;
            };
            id: StringConstructor;
        }[];
        effects: StringConstructor[];
        layout: {
            top: {
                width: NumberConstructor;
                height: NumberConstructor;
                marginBottom: NumberConstructor;
                marginTop: NumberConstructor;
                marginLeft: NumberConstructor;
                marginRight: NumberConstructor;
                lines: {
                    col: {
                        id: StringConstructor;
                        value: StringConstructor;
                    }[];
                }[];
            };
            bottom: {
                width: NumberConstructor;
                height: NumberConstructor;
                marginBottom: NumberConstructor;
                marginTop: NumberConstructor;
                marginLeft: NumberConstructor;
                marginRight: NumberConstructor;
                lines: {
                    col: {
                        id: StringConstructor;
                        value: StringConstructor;
                    }[];
                }[];
            };
            left: {
                width: NumberConstructor;
                height: NumberConstructor;
                marginBottom: NumberConstructor;
                marginTop: NumberConstructor;
                marginLeft: NumberConstructor;
                marginRight: NumberConstructor;
                lines: {
                    col: {
                        id: StringConstructor;
                        value: StringConstructor;
                    }[];
                }[];
            };
            right: {
                width: NumberConstructor;
                height: NumberConstructor;
                marginBottom: NumberConstructor;
                marginTop: NumberConstructor;
                marginLeft: NumberConstructor;
                marginRight: NumberConstructor;
                lines: {
                    col: {
                        id: StringConstructor;
                        value: StringConstructor;
                    }[];
                }[];
            };
            center: {
                width: NumberConstructor;
                height: NumberConstructor;
                marginBottom: NumberConstructor;
                marginTop: NumberConstructor;
                marginLeft: NumberConstructor;
                marginRight: NumberConstructor;
                lines: {
                    col: {
                        id: StringConstructor;
                        value: StringConstructor;
                    }[];
                }[];
            };
        };
        action: NumberConstructor;
        map: StringConstructor;
        speed: NumberConstructor;
        frequency: NumberConstructor;
        canMove: BooleanConstructor;
        through: BooleanConstructor;
        throughOtherPlayer: BooleanConstructor;
        width: NumberConstructor;
        height: NumberConstructor;
        wHitbox: NumberConstructor;
        hHitbox: NumberConstructor;
        _statesEfficiency: {
            rate: {
                $syncWithClient: boolean;
            };
            state: {
                $syncWithClient: boolean;
            };
        }[];
        tmpPositions: {
            $syncWithClient: boolean;
        };
        initialLevel: {
            $syncWithClient: boolean;
        };
        finalLevel: {
            $syncWithClient: boolean;
        };
    };
    layout: LayoutObject<any>;
    private _name;
    events: any;
    param: any;
    _rooms: never[];
    session: string | null;
    prevMap: string;
    /**
    * ```ts
    * retreive the server instance
    * ```
    * @title Server Instance
    * @prop {RpgServerEngine} player.server
    * @deprecated Use `inject(RpgServerEngine)` instead. Will be removed in v5
    * @memberof Player
    * */
    server: RpgServerEngine;
    private touchSide;
    otherPossessedPlayer: RpgPlayer | RpgEvent | null;
    followingId: string | null;
    private _dataLoading;
    _lastFramePositions: {
        frame: number;
        position: Position;
    } | undefined;
    /**
     * @deprecated Use `inject(RpgCommonGame)` instead. Will be removed in v5
     */
    gameEngine: RpgCommonGame;
    get otherPlayersCollision(): RpgPlayer[];
    get world(): WorldClass | undefined;
    teleported: number;
    deleted: boolean;
    constructor(playerId: string);
    _init(): void;
    private get schema();
    /**
     * ```ts
     * player.name = 'Link'
     * ```
     * @title Read/Give a name
     * @prop {string} player.name
     * @memberof Player
     * */
    get name(): string;
    set name(val: string);
    /**
     * Change your map. Indicate the positions to put the player at a place on the map
     *
     * > The map must be added to RpgServer beforehand. Guide: [Create Map](/guide/create-map.html)
     *
     * You don't have to give positions but you can put a starting position in the TMX file. Guide: [Start Position](/guide/player-start.html)
     *
     * @title Change Map
     * @method player.changeMap(mapId,positions)
     * @param {string} mapId
     * @param { {x: number, y: number, z?: number} | string } [positions]
     * @returns {Promise<RpgMap | null>} null if map not exists
     * @memberof Player
     */
    changeMap(mapId: string, positions?: {
        x: number;
        y: number;
        z?: number;
    } | string): Promise<RpgMap | null | boolean>;
    autoChangeMap(nextPosition: Position): Promise<boolean>;
    /**
     * Dynamically create an event in Scenario mode on the current map
     *
     * ```ts
     * @EventData({
     *  name: 'EV-1'
     * })
     * class MyEvent extends RpgEvent {
     *  onAction() {
     *      console.log('ok')
     *  }
     * }
     *
     * player.createDynamicEvent({
     *      x: 100,
     *      y: 100,
     *      event: MyEvent
     * })
     * ```
     *
     * You can also put an array of objects to create several events at once
     *
     * @title Create Dynamic Event
     * @since 3.0.0-beta.4
     * @method player.createDynamicEvent(eventObj | eventObj[])
     * @param { { x: number, y: number, z?: number, event: eventClass } } [eventsList]
     * @returns { { [eventId: string]: RpgEvent } }
     * @memberof Player
     */
    createDynamicEvent(eventsList: EventPosOption | EventPosOption[], forceMode?: boolean): {
        [eventId: string]: RpgEvent;
    };
    /**
     * Allows to change the positions of the player on the current map.
     * You can put the X and Y positions or the name of the created shape on Tiled Map Editor.
     * If you have several shapes with the same name, one position will be chosen randomly.
     *
     * ```ts
     * player.teleport({ x: 100, y: 500 })
     * ```
     *
     * or
     *
     * ```ts
     * player.teleport('my-shape-name')
     * ```
     *
     * If no parameter:
     *
     * ```ts
     * player.teleport() // { x: 0, y: 0, z: 0 }
     * ```
     *
     * @title Teleport on the map
     * @method player.teleport(positions)
     * @param { {x: number, y: number, z?: number} | string } [positions]
     * @returns {Promise<{ {x: number, y: number, z: number} }>}
     * @memberof Player
     */
    teleport(positions?: PositionXY_OptionalZ | string): Promise<Position>;
    /**
     * Load the saved data with the method save()
     * If the player was on a map, it repositions the player on the map.
     *
     * ```ts
     * const json = player.save()
     * player.load(json)
     * ```
     *
     * @title Load progress
     * @method player.load(json)
     * @param {string} json The JSON sent by the method save()
     * @returns {Promise<boolean | RpgMap | null>}
     * @memberof Player
     */
    load(json: any): Promise<boolean | RpgMap | null>;
    /**
     * Returns a JSON with all the data to keep in memory. Then use the `load()` method to load the data
     *
     * You can also use the JSON.stringify
     *
     * ```ts
     * const json = player.save() // or JSON.stringify(player)
     * player.load(json)
     * ```
     *
     * @title Save progress
     * @method player.save()
     * @returns {string}
     * @memberof Player
     */
    save(): string;
    toObject(): {
        direction: number;
        id: string;
        canMove: boolean;
        position: {
            x: number;
            y: number;
            z: number;
        };
        hitbox: {
            width: any;
            height: any;
        };
        map: string;
        pendingMove: import("@rpgjs/types").PendingMove;
        speed: number;
    };
    toJSON(): any;
    /**
     * Run the change detection cycle. Normally, as soon as a hook is called in a class, the cycle is started. But you can start it manually
     * The method calls the `onChanges` method on events and synchronizes all map data with the client.

     * @title Run Sync Changes
     * @method player.syncChanges()
     * @returns {void}
     * @memberof Player
     */
    syncChanges(): void;
    databaseById(id: string): any;
    /**
     * Retrieves data from the current map
     *
     * returns null if the player is not assigned to a map
     *
     * @title Get Current Map
     * @method player.getCurrentMap()
     * @returns {RpgMap | null}
     * @memberof Player
     */
    getCurrentMap<T extends RpgMap = RpgMap>(): T | null;
    loadScene(name: string, data: any): void;
    emitSceneMap(): void;
    gameReload(): void;
    changeServer(url: string, port: number): void;
    private _getMap;
    /**
     * Calls the showAnimation() method on the client side to display an animation on the player
     * You must remember to create the spritesheet beforehand
     *
     * For this type of spritesheet:
     *
     * ```ts
     * @Spritesheet({
     *  id: 'fire',
     *  image: require('')
     *  textures: {
     *      default: {
     *          animations: [
     *
     *          ]
     *      }
     *   }
     * })
     * export class FireAnimation {}
     * ```
     *
     * Here is the call of the method:
     *
     * ```ts
     * player.showAnimation('fire', 'default')
     * ```
     *
     * If you don't want to put an animation on top of the event but replace the event graphic with another one, set true as last parameter.
     * This is useful, if for example, you want to make an animated character (sword stroke when pressing a key)
     * When the animation is finished, the original graphic is displayed again
     *
     *
     * ```ts
     * player.showAnimation('sword_stroke', 'default', true)
     * ```
     *
     * Since version 3.0.0-rc, you can define several graphic elements. This allows you to animate them all at once
     *
     * ```ts
     * player.showAnimation(['body', 'sword_stroke'], 'default', true)
     * ```
     *
     * ::: tip
     * For this to work, the animations must have been previously defined in `setGraphic`.
     * :::
     *
     * @title Show Animation
     * @method player.showAnimation(graphic,animationName,replaceGraphic=false)
     * @param {string | string[]} graphic spritesheet identifier
     * @param {string} animationName Name of the animation in the spritesheet
     * @param {boolean} [replaceGraphic] Replace the event graphic with the animation. After the end of the animation, the original graphic is reapplied
     * @returns {void}
     * @memberof Player
     */
    showAnimation(graphic: string | string[], animationName: string, replaceGraphic?: boolean): void;
    /**
     * TODO:
     * 1. It is necessary, on the client side, to make the character move even if controlled by someone else (problem: same playerId so, one will not move because of the client side prediction. Solution: create a new Id ? like session Id ?
     * 2. You would need several sockets per character. If the character changes map or changes server, all players controlling the character must be able to see it
     * 3. If the player regains control, what happens, do we return to the previous map?
     * 4. If it's an event, you must be able to get the event by id in GameEngine
     */
    takePossessionOf(otherPlayer: RpgPlayer | RpgEvent): void;
    /**
     * Sends the client which event or player the camera should follow. You can set options to perform a motion animation
     *
     * @title Camera Follow
     * @method player.cameraFollow(otherPlayer,options)
     * @param {RpgPlayer | RpgEvent} otherPlayer
     * @param {options} options
     * @param {object | boolean} [options.smoothMove] - animate. Set a boolean to use default parameters
     * @param {number} [options.smoothMove.time=1000] - time to animate
     * @param {string} [options.smoothMove.ease=linear] - easing to use. Go to https://easings.net to get function name
     * @returns {void}
     * @since 3.1.0
     * @memberof Player
     */
    cameraFollow(otherPlayer: RpgPlayer | RpgEvent, options?: CameraOptions): void;
    /**
     * Emit data to clients with socket
     *
     * @title Emit to client
     * @method player.emit(key,value)
     * @param {string} key
     * @param {any} value
     * @returns {void}
     * @memberof Player
     */
    emit(key: string, value?: any): void;
    /**
     * Listen to the data (socket) sent by the client
     *
     * @title Listen to data from the client
     * @method player.on(key,cb)
     * @param {string} key
     * @param {function} cb
     * @returns {void}
     * @memberof Player
     */
    on(key: string, cb: Function): void;
    /**
     * Adds a one-time listener function for the event named eventName
     *
     * @title Listen one-time to data from the client
     * @method player.once(key,cb)
     * @since 3.0.0-beta.5
     * @param {string} key
     * @param {function} cb
     * @returns {void}
     * @memberof Player
     */
    once(key: string, cb: Function): void;
    /**
     * Removes all listeners of the specified eventName.
     *
     * @title Removes all listeners of the client
     * @method player.off(key)
     * @since 3.0.0-beta.5
     * @param {string} key
     * @returns {void}
     * @memberof Player
     */
    off(key: string): void;
    disconnect(): void;
    emitToMap(key: string, value: any): void;
    private execMethodSync;
    execMethod(methodName: string, methodData?: never[], target?: any): Promise<any>;
    _triggerHook(name: any, val?: any): void;
    private _eventChanges;
    /**
     * Allows to play a sound, heard only by the player or by the players of the map
     *
     * Here is a sound, client side:
     *
     * ```ts
     * import { Sound } from '@rpgjs/client'
     * @Sound({
     *      id: 'town-music',
     *      sound: require('./sound/town.ogg')
     * })
     * export class TownMusic {}
     * ```
     *
     * Here is the call of the method, server side:
     *
     * ```ts
     * player.playSound('town-music')
     * ```
     *
     * If you want everyone to listen to the sound on the map:
     *
     * ```ts
     * player.playSound('town-music', true)
     * ```
     *
     * @title Play Sound
     * @method player.playSound(soundId,allMap=false)
     * @param {string} soundId Sound identifier, defined on the client side
     * @param {boolean} [forEveryone=false] Indicate if the sound is heard by the players on the map
     * @since 3.0.0-alpha.9
     * @returns {void}
     * @memberof Player
     */
    playSound(soundId: string, forEveryone?: boolean): void;
}
export interface RpgPlayer extends EventManager, ItemManager, GoldManager, StateManager, SkillManager, ParameterManager, EffectManager, ClassManager, ElementManager, GuiManager, VariableManager, MoveManager, BattleManager, ComponentManager {
    _socket: any;
    vision: any;
    attachShape: any;
}
export interface RpgClassEvent<T> {
    _name: string;
    new (): T;
}
export declare class RpgEvent extends RpgPlayer {
    readonly type: string;
    properties: any;
    mode: EventMode;
    playerRelated: RpgPlayer | null;
    constructor(playerId: string);
    execMethod(methodName: string, methodData?: never[]): Promise<any>;
    changeRoomState(path: string): void;
    /**
    * Deletes the event from the map (in shared or scenario mode)
    *
    * @title Remove
    * @since 4.0.0
    * @method event.remove()
    * @returns {boolean} true if the event has been removed. If false, the event is not on the map
    * @memberof RpgEvent
    */
    remove(): boolean;
    emitToMap(key: string, value: any): void;
}
