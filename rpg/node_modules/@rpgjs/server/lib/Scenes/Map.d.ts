import { TiledMap } from '@rpgjs/tiled';
import { MapOptions } from '../decorators/map';
import { RpgMap } from '../Game/Map';
import { RpgWorldMaps, WorldMap } from '../Game/WorldMaps';
import { RpgEvent, RpgPlayer } from '../Player/Player';
export interface RpgClassMap<T> {
    id?: string;
    file?: string;
    new (server: any): T;
}
type SceneMapObject = {
    maps: any[];
    worldMaps: WorldMap[];
    events: RpgEvent[];
};
export declare class SceneMap {
    static readonly id: string;
    private maps;
    private mapsById;
    private worldMaps;
    private server;
    constructor(sceneMapObject: SceneMapObject);
    /**
     * Returns an array of RpgClassMap objects that represent maps with static properties.
     *
     * @title Get maps
     * @method sceneMap.getMaps()
     * @returns {RpgClassMap<RpgMap>[]} Array of RpgClassMap objects.
     * @since 4.0.0
     * @example
     * ```typescript
     * const maps = scene.getMaps();
     * console.log(maps);
     * // Output: [
     * // { file: 'maps/level1.tmx', id: 'level1', type: 'map' },
     * // { file: 'maps/level2.tmx', id: 'level1', type: 'map' },
     * // { file: 'maps/level3.tmx', id: 'level1', type: 'map' }
     * // ]
     * ```
     * @memberof SceneMap
     */
    getMaps(): RpgClassMap<RpgMap>[];
    getMapBydId(id: string): RpgClassMap<RpgMap> | null;
    loadMap(id: string): Promise<RpgMap | undefined>;
    /**
    * Loads the content of a `.world` file from Tiled Map Editor into the map scene
    *
    * > Note, that if the map already exists (i.e. you have already defined an RpgMap), the world will retrieve the already existing map. Otherwise it will create a new map
    *
    * @title Create worlds dynamically
    * @method sceneMap.createDynamicWorldMaps(world)
    * @param {object} world
    * object is
    * ```ts
    * {
    *  id?: string
    *  maps: {
    *      id?: string
    *      properties?: object
    *      fileName: string;
           height: number;
           width: number;
           x: number;
           y: number;
    *  }[],
       onlyShowAdjacentMaps: boolean, // only for Tiled Map Editor
       type: 'world' // only for Tiled Map Editor
    * }
    * ```
    *
    * @since 3.0.0-beta.8
    * @memberof SceneMap
    */
    createDynamicWorldMaps(world: WorldMap): RpgWorldMaps;
    /**
     * Recover a world
     *
     * @title Recover a world
     * @method sceneMap.getWorldMaps(id)
     * @param {string} id world id
     * @return { RpgWorldMaps | undefined }
     * @since 3.0.0-beta.8
     * @memberof SceneMap
     */
    getWorldMaps(id: string): RpgWorldMaps | undefined;
    /**
    * Delete a world
    *
    * @title Delete a world
    * @method sceneMap.deleteWorldMaps(id)
    * @param {string} id world id
    * @since 3.0.0-beta.8
    * @memberof SceneMap
    */
    deleteWorldMaps(id: string): void;
    /**
     * Create a dynamic map
     *
     * Since version 3.0.0-beta.8, you can just pass the path to the file. The identifier will then be the name of the file
     *
     * @method sceneMap.createDynamicMap(mapData)
     * @title Create a dynamic map
     * @param {object | RpgMap | string} mapData The same property as [@MapData decorator](https://docs.rpgjs.dev/classes/map.html#mapdata-decorator)
     * @returns {RpgMap}
     * @since 3.0.0-beta.4
     * @memberof SceneMap
     * @example
     * ```ts
     * sceneMap.createDynamicMap({
     *      id: 'myid',
     *      file: require('./tmx/mymap.tmx')
     * })
     * ```
     *
     * And later, on the player:
     *
     * ```ts
     * player.changeMap('myid')
     * ```
     *
     * ---
     *
     * since beta.8
     *
     * ```ts
     * sceneMap.createDynamicMap(require('./tmx/mymap.tmx')) // id is "mymap"
     * ```
     */
    createDynamicMap(mapData: MapOptions | string | RpgClassMap<RpgMap> | TiledMap): RpgClassMap<RpgMap> | never;
    changeMap(mapId: string, player: RpgPlayer, positions?: {
        x: number;
        y: number;
        z?: number;
    } | string): Promise<RpgMap | null | boolean>;
}
export {};
