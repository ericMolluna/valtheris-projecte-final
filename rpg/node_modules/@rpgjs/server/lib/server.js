var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { SceneMap } from './Scenes/Map.js';
import { RpgPlayer } from './Player/Player.js';
import { Query } from './Query.js';
import { DAMAGE_SKILL, DAMAGE_PHYSIC, DAMAGE_CRITICAL, COEFFICIENT_ELEMENTS } from './presets/index.js';
import { World, Transport } from 'simple-room';
import { Utils, RpgPlugin, Scheduler, HookServer, RpgCommonGame, DefaultInput } from '@rpgjs/common';
import { Actor, Armor, Class, Item, Skill, State, Weapon } from '@rpgjs/database';
import { inject } from './inject.js';
export class RpgServerEngine {
    constructor() {
        /**
         * List of the data
         *
         * @prop {object} [database]
         * @memberof RpgServerEngine
         */
        this.database = {};
        /**
         * retrieve the global configurations assigned at the entry point
         *
         * @prop {object} [globalConfig]
         * @readonly
         * @memberof RpgServerEngine
         * */
        this.globalConfig = {};
        /**
         * Combat formulas
         *
         * @prop {object} [damageFormulas]
         * @memberof RpgServerEngine
         */
        this.damageFormulas = {};
        this.serverId = process.env.SERVER_ID || Utils.generateUID();
        this.scenes = new Map();
        this.totalConnected = 0;
        this.scheduler = new Scheduler();
        this.gameEngine = inject(RpgCommonGame);
        this.world = World;
        this.envs = {};
        this.inputOptions = {};
    }
    /**
     * Combat formulas
     *
     * @prop {Socket Io Server} [io]
     * @memberof RpgServerEngine
     */
    initialize(io, inputOptions) {
        this.io = io;
        this.inputOptions = inputOptions;
        this.envs = inputOptions.envs || {};
        if (this.inputOptions.workers) {
            console.log('workers enabled');
            this.workers = this.gameEngine.createWorkers(this.inputOptions.workers).load();
        }
    }
    async _init() {
        this.damageFormulas = this.inputOptions.damageFormulas || {};
        this.damageFormulas = {
            damageSkill: DAMAGE_SKILL,
            damagePhysic: DAMAGE_PHYSIC,
            damageCritical: DAMAGE_CRITICAL,
            coefficientElements: COEFFICIENT_ELEMENTS,
            ...this.damageFormulas
        };
        this.globalConfig = this.inputOptions.globalConfig;
        if (!this.inputOptions.maps)
            this.inputOptions.maps = [];
        if (!this.inputOptions.events)
            this.inputOptions.events = [];
        if (!this.inputOptions.worldMaps)
            this.inputOptions.worldMaps = [];
        this.playerProps = this.inputOptions.playerProps;
        this.inputOptions.maps = [
            ...Utils.arrayFlat(await RpgPlugin.emit(HookServer.AddMap, this.inputOptions.maps)) || [],
            ...this.inputOptions.maps
        ];
        this.inputOptions.events = [
            ...Utils.arrayFlat(await RpgPlugin.emit(HookServer.AddEvent, this.inputOptions.events)) || [],
            ...this.inputOptions.events
        ];
        this.inputOptions.worldMaps = [
            ...Utils.arrayFlat(await RpgPlugin.emit(HookServer.AddWorldMaps, this.inputOptions.worldMaps)) || [],
            ...this.inputOptions.worldMaps
        ];
        this.globalConfig.inputs = {
            ...DefaultInput,
            ...(this.globalConfig.inputs || {})
        };
        if (!this.inputOptions.database)
            this.inputOptions.database = {};
        /**
         * data is array with object or array
         */
        const datas = await RpgPlugin.emit(HookServer.AddDatabase, this.inputOptions.database) || [];
        for (let element of datas) {
            if (Array.isArray(element)) {
                for (let data of element) {
                    this.addInDatabase(data.id, data);
                }
            }
            else {
                for (let id in element) {
                    this.addInDatabase(element[id].id ?? id, element[id]);
                }
            }
        }
        this.loadScenes();
    }
    /**
     * Adds data to the server's database (in RAM) for later use
     *
     *
     * @method server.addInDatabase(id,data)
     * @title Add in database
     * @param {number} id resource id
     * @param {class | object} dataClass A class representing the data. You can just add a object if you specify the type
     * @enum {string} [type] The type of data
     *
     * item
     * weapon
     * armor
     * skill
     * class
     * state
     * actor
     * @since 3.0.0-beta.4
     * @example
     * ```ts
     * @Item({
     *      name: 'Potion',
     *      description: 'Gives 100 HP',
     * })
     * class MyItem() {}
     *
     * server.addInDatabase('dynamic_item', MyItem)
     * ```
     *
     * or with an object
     *
     * ```ts
     * server.addInDatabase('dynamic_item', {
     *      name: 'Potion',
     *      description: 'Gives 100 HP',
     * }, 'item')
     * ```
     *
     * @returns {void}
     * @memberof RpgServerEngine
     */
    addInDatabase(id, dataClass, type) {
        if (Utils.isClass(dataClass)) {
            this.database[id] = dataClass;
            return;
        }
        if (!type) {
            throw new Error(`You must specify a type for the database ${id}`);
        }
        switch (type) {
            case 'item':
                let ItemClass = class ItemClass {
                };
                ItemClass = __decorate([
                    Item(dataClass)
                ], ItemClass);
                this.database[id] = ItemClass;
                break;
            case 'weapon':
                let WeaponClass = class WeaponClass {
                };
                WeaponClass = __decorate([
                    Weapon(dataClass)
                ], WeaponClass);
                this.database[id] = WeaponClass;
                break;
            case 'armor':
                let ArmorClass = class ArmorClass {
                };
                ArmorClass = __decorate([
                    Armor(dataClass)
                ], ArmorClass);
                this.database[id] = ArmorClass;
                break;
            case 'skill':
                let SkillClass = class SkillClass {
                };
                SkillClass = __decorate([
                    Skill(dataClass)
                ], SkillClass);
                this.database[id] = SkillClass;
                break;
            case 'class':
                let ClassClass = class ClassClass {
                };
                ClassClass = __decorate([
                    Class(dataClass)
                ], ClassClass);
                this.database[id] = ClassClass;
                break;
            case 'state':
                let StateClass = class StateClass {
                };
                StateClass = __decorate([
                    State(dataClass)
                ], StateClass);
                this.database[id] = StateClass;
                break;
            case 'actor':
                let ActorClass = class ActorClass {
                };
                ActorClass = __decorate([
                    Actor(dataClass)
                ], ActorClass);
                this.database[id] = ActorClass;
                break;
        }
    }
    /**
    * Start the RPG server
    *
    * @method server.start()
    * @title Start Server
    * @returns {void}
    * @memberof RpgServerEngine
    */
    async start(inputOptions, scheduler = true) {
        if (inputOptions)
            this.inputOptions = inputOptions;
        await this._init();
        this.tick.subscribe(({ timestamp, deltaTime }) => {
            this.step(timestamp, deltaTime);
        });
        if (scheduler)
            this.scheduler.start({
                fps: inputOptions?.fps || 60
            });
        this.gameEngine.start({
            getObject(id) {
                return Query.getPlayer(id);
            },
            getObjectsOfGroup(groupId, player) {
                return Query._getObjectsOfMap(groupId, player);
            },
            getShapesOfGroup(map) {
                return Query._getShapesOfMap(map);
            }
        });
        //this.io.on('connection', this.onPlayerConnected.bind(this))
        this.transport(this.io);
        await RpgPlugin.emit(HookServer.Start, this);
    }
    transport(io) {
        const timeoutDisconnect = this.globalConfig.timeoutDisconnect ?? 0;
        const auth = this.globalConfig.disableAuth ? () => Utils.generateUID() :
            async (socket) => {
                const val = await RpgPlugin.emit(HookServer.Auth, [this, socket], true);
                if (val.length == 0) {
                    return Utils.generateUID();
                }
                return val[val.length - 1];
            };
        const transport = new Transport(io, {
            timeoutDisconnect,
            auth
        });
        this.world.timeoutDisconnect = timeoutDisconnect;
        transport.onConnected(this.onPlayerConnected.bind(this));
        transport.onDisconnected(this.onPlayerDisconnected.bind(this));
        return transport;
    }
    get tick() {
        return this.scheduler.tick;
    }
    /**
     * Sends all packages to clients. The sending is done automatically but you can decide to send yourself by calling this method (for example, for unit tests)
     *
     * @method server.send()
     * @title Send All Packets
     * @returns {void}
     * @memberof RpgServerEngine
     */
    send() {
        return this.world.send();
    }
    async updatePlayersMove(deltaTimeInt) {
        const players = this.world.getUsers();
        const obj = [];
        let p = [];
        for (let playerId in players) {
            const playerInstance = players[playerId]['proxy'];
            if (!playerInstance)
                continue;
            const player = playerInstance.otherPossessedPlayer ?? playerInstance;
            if (player.pendingMove.length > 0) {
                const lastFrame = player.pendingMove[player.pendingMove.length - 1];
                if (this.inputOptions.workers)
                    obj.push(player.toObject());
                else {
                    p.push(this.gameEngine.processInput(player.playerId, this.globalConfig.inputs).then((val) => {
                        player.pendingMove = [];
                        player.moving = false;
                        player._lastFramePositions = {
                            frame: lastFrame.frame,
                            position: { ...player.position }
                        };
                        return player;
                    }));
                }
            }
        }
        // TODO
        if (this.inputOptions.workers) {
            this.workers.call('movePlayers', obj).then((players) => {
                for (let playerId in players) {
                    const player = this.world.getUser(playerId);
                    const data = players[playerId];
                    if (player) {
                        player.position = data.position;
                        player.direction = data.direction;
                    }
                    RpgPlugin.emit('Server.onInput', [player, {
                            input: data.direction,
                            moving: true
                        }], true);
                }
            });
        }
        return Promise.all(p);
    }
    nextTick(timestamp) {
        this.scheduler.nextTick(timestamp);
    }
    step(t, dt) {
        this.updatePlayersMove(1);
        if (this.scheduler.frame % 4 === 0) {
            this.send();
        }
        RpgPlugin.emit(HookServer.Step, this);
    }
    loadScenes() {
        this.scenes.set(SceneMap.id, new SceneMap({
            maps: this.inputOptions.maps,
            events: this.inputOptions.events,
            worldMaps: this.inputOptions.worldMaps
        }));
    }
    getScene(name) {
        return this.scenes.get(name);
    }
    /**
     * Return the scene that manages the maps of the game
     * @prop {SceneMap} [sceneMap]
     * @since 3.0.0-beta.4
     * @memberof RpgServerEngine
     */
    get sceneMap() {
        return this.getScene(SceneMap.id);
    }
    get module() {
        return RpgPlugin;
    }
    get assetsPath() {
        return this.envs?.['VITE_ASSETS_PATH'] || 'assets';
    }
    sendToPlayer(currentPlayer, eventName, data) {
        currentPlayer._socket.emit(eventName, data);
    }
    getPlayerBySession(session) {
        const users = this.world.getUsers();
        for (let userId in users) {
            const user = users[userId];
            if (user.session === session) {
                return user;
            }
        }
        return null;
    }
    onPlayerConnected(socket, playerId) {
        const existingUser = this.world.getUser(playerId, false);
        this.world.connectUser(socket, playerId);
        let player;
        if (!existingUser) {
            const { token } = socket.handshake.auth;
            player = new RpgPlayer(playerId);
            player.session = token;
            this.world.setUser(player, socket);
            player._init();
            if (!token) {
                const newToken = Utils.generateUID() + '-' + Utils.generateUID() + '-' + Utils.generateUID();
                player.session = newToken;
            }
            if (!token) {
                player.execMethod('onConnected');
            }
            else {
                RpgPlugin.emit(HookServer.ScalabilityPlayerConnected, player);
            }
        }
        else {
            player = existingUser;
            if (player.map) {
                player.emit('preLoadScene', {
                    reconnect: true,
                    id: player.map
                });
                player.emitSceneMap();
                this.world.joinRoom(player.map, playerId);
            }
        }
        socket.emit('playerJoined', { playerId, session: player.session });
        socket.on('move', (data) => {
            if (!data?.input)
                return;
            if (!Array.isArray(data.input))
                return;
            const controlPlayer = player.otherPossessedPlayer ?? player;
            if (!controlPlayer.canMove) {
                return;
            }
            for (let input of data.input) {
                controlPlayer.pendingMove.push({
                    input,
                    frame: data.frame
                });
            }
        });
    }
    onPlayerDisconnected(playerId) {
        const player = World.getUser(playerId);
        player.execMethod('onDisconnected');
        this.world.disconnectUser(playerId);
    }
    stop() {
        this.scheduler.stop();
    }
}
//# sourceMappingURL=server.js.map