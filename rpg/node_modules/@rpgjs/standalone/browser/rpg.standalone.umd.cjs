(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("@rpgjs/common"), require("@rpgjs/server"), require("@rpgjs/client")) : typeof define === "function" && define.amd ? define(["exports", "@rpgjs/common", "@rpgjs/server", "@rpgjs/client"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.RpgStandalone = {}, global2.common, global2.server, global2.client));
})(this, function(exports2, common, server, client) {
  "use strict";
  const GENERIC_KEY_SCHEMA = "@";
  class Utils {
    static isObject(val) {
      return typeof val === "object" && !Array.isArray(val) && val != null;
    }
    static propertiesToArray(obj) {
      const addDelimiter = (a, b) => a ? `${a}.${b}` : b;
      const paths = (obj2 = {}, head = "") => {
        return Object.entries(obj2).reduce((product, array2) => {
          const [key] = array2;
          const value = array2[1];
          const extraProp = Room.hasExtraProp(value);
          let fullPath = addDelimiter(head, key == "0" ? GENERIC_KEY_SCHEMA : key);
          if (extraProp) {
            if (value.$syncWithClient === false) {
              return product;
            }
          }
          if (key[0] != "_" && !extraProp && (Utils.isObject(value) || Array.isArray(value))) {
            if (Object.keys(value).length == 0) {
              return product.concat(fullPath);
            }
            return product.concat(paths(value, fullPath));
          } else {
            return product.concat(fullPath);
          }
        }, []);
      };
      return paths(obj);
    }
    static generateId(n = 5) {
      return Math.random().toString(36).substring(n);
    }
    static async resolveValue(value) {
      if (value instanceof Promise) {
        return await value;
      }
      return value;
    }
    static set(obj, path, value, onlyPlainObject = false) {
      if (Object(obj) !== obj)
        return obj;
      if (typeof path === "string") {
        path = path.split(".");
      }
      let len = path.length;
      if (!len)
        return obj;
      let current = obj;
      for (let i2 = 0; i2 < len - 1; i2++) {
        let segment = path[i2];
        let nextSegment = path[i2 + 1];
        let isNextNumeric = !isNaN(nextSegment) && isFinite(nextSegment);
        if (!current[segment] || typeof current[segment] !== "object") {
          current[segment] = isNextNumeric && !onlyPlainObject ? [] : {};
        }
        current = current[segment];
      }
      current[path[len - 1]] = value;
      return obj;
    }
    static get(obj, path) {
      const keys = path.split(".");
      let current = obj;
      for (let key of keys) {
        if (current[key] === void 0) {
          return void 0;
        }
        current = current[key];
      }
      return current;
    }
    static bufferFrom(input) {
      if (typeof input === "string") {
        let encoder2 = new TextEncoder();
        return encoder2.encode(input);
      } else if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
        return new Uint8Array(input);
      } else {
        throw new Error("Input type not supported");
      }
    }
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var browser = {};
  var encode = {};
  var encodeBuffer = {};
  var writeCore = {};
  var extBuffer = {};
  var bufferish = {};
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var inited = false;
  function init() {
    inited = true;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup[i2] = code[i2];
      revLookup[code.charCodeAt(i2)] = i2;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
  }
  function toByteArray(b64) {
    if (!inited) {
      init();
    }
    var i2, j, l, tmp, placeHolders, arr;
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
    arr = new Arr(len * 3 / 4 - placeHolders);
    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;
    for (i2 = 0, j = 0; i2 < l; i2 += 4, j += 3) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[L++] = tmp >> 16 & 255;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[L++] = tmp & 255;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint82, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint82[i2] << 16) + (uint82[i2 + 1] << 8) + uint82[i2 + 2];
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint82) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint82.length;
    var extraBytes = len % 3;
    var output = "";
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint82, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint82[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[tmp << 4 & 63];
      output += "==";
    } else if (extraBytes === 2) {
      tmp = (uint82[len - 2] << 8) + uint82[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[tmp >> 4 & 63];
      output += lookup[tmp << 2 & 63];
      output += "=";
    }
    parts.push(output);
    return parts.join("");
  }
  function read$2(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i2];
    i2 += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  }
  function write$2(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c2 = Math.pow(2, -e)) < 1) {
        e--;
        c2 *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c2;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c2 >= 2) {
        e++;
        c2 /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c2 - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
    }
    buffer[offset + i2 - d] |= s * 128;
  }
  var toString$2 = {}.toString;
  var isArray = Array.isArray || function(arr) {
    return toString$2.call(arr) == "[object Array]";
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  var INSPECT_MAX_BYTES = 50;
  Buffer$1.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== void 0 ? global.TYPED_ARRAY_SUPPORT : true;
  kMaxLength();
  function kMaxLength() {
    return Buffer$1.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function createBuffer(that, length) {
    if (kMaxLength() < length) {
      throw new RangeError("Invalid typed array length");
    }
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      that = new Uint8Array(length);
      that.__proto__ = Buffer$1.prototype;
    } else {
      if (that === null) {
        that = new Buffer$1(length);
      }
      that.length = length;
    }
    return that;
  }
  function Buffer$1(arg, encodingOrOffset, length) {
    if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
      return new Buffer$1(arg, encodingOrOffset, length);
    }
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new Error(
          "If encoding is specified then the first argument must be a string"
        );
      }
      return allocUnsafe(this, arg);
    }
    return from(this, arg, encodingOrOffset, length);
  }
  Buffer$1.poolSize = 8192;
  Buffer$1._augment = function(arr) {
    arr.__proto__ = Buffer$1.prototype;
    return arr;
  };
  function from(that, value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length);
    }
    if (typeof value === "string") {
      return fromString(that, value, encodingOrOffset);
    }
    return fromObject(that, value);
  }
  Buffer$1.from = function(value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length);
  };
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    Buffer$1.prototype.__proto__ = Uint8Array.prototype;
    Buffer$1.__proto__ = Uint8Array;
  }
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }
  function alloc(that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
    }
    return createBuffer(that, size);
  }
  Buffer$1.alloc = function(size, fill, encoding) {
    return alloc(null, size, fill, encoding);
  };
  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
      for (var i2 = 0; i2 < size; ++i2) {
        that[i2] = 0;
      }
    }
    return that;
  }
  Buffer$1.allocUnsafe = function(size) {
    return allocUnsafe(null, size);
  };
  Buffer$1.allocUnsafeSlow = function(size) {
    return allocUnsafe(null, size);
  };
  function fromString(that, string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer$1.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }
    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);
    var actual = that.write(string, encoding);
    if (actual !== length) {
      that = that.slice(0, actual);
    }
    return that;
  }
  function fromArrayLike(that, array2) {
    var length = array2.length < 0 ? 0 : checked(array2.length) | 0;
    that = createBuffer(that, length);
    for (var i2 = 0; i2 < length; i2 += 1) {
      that[i2] = array2[i2] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array2, byteOffset, length) {
    array2.byteLength;
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError("'offset' is out of bounds");
    }
    if (array2.byteLength < byteOffset + (length || 0)) {
      throw new RangeError("'length' is out of bounds");
    }
    if (byteOffset === void 0 && length === void 0) {
      array2 = new Uint8Array(array2);
    } else if (length === void 0) {
      array2 = new Uint8Array(array2, byteOffset);
    } else {
      array2 = new Uint8Array(array2, byteOffset, length);
    }
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      that = array2;
      that.__proto__ = Buffer$1.prototype;
    } else {
      that = fromArrayLike(that, array2);
    }
    return that;
  }
  function fromObject(that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);
      if (that.length === 0) {
        return that;
      }
      obj.copy(that, 0, 0, len);
      return that;
    }
    if (obj) {
      if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
        if (typeof obj.length !== "number" || isnan(obj.length)) {
          return createBuffer(that, 0);
        }
        return fromArrayLike(that, obj);
      }
      if (obj.type === "Buffer" && isArray(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
    }
    return length | 0;
  }
  Buffer$1.isBuffer = isBuffer;
  function internalIsBuffer(b) {
    return !!(b != null && b._isBuffer);
  }
  Buffer$1.compare = function compare(a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError("Arguments must be Buffers");
    }
    if (a === b)
      return 0;
    var x = a.length;
    var y = b.length;
    for (var i2 = 0, len = Math.min(x, y); i2 < len; ++i2) {
      if (a[i2] !== b[i2]) {
        x = a[i2];
        y = b[i2];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer$1.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer$1.concat = function concat(list, length) {
    if (!isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer$1.alloc(0);
    }
    var i2;
    if (length === void 0) {
      length = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length += list[i2].length;
      }
    }
    var buffer = Buffer$1.allocUnsafe(length);
    var pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      var buf = list[i2];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer;
  };
  function byteLength(string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length;
    }
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      string = "" + string;
    }
    var len = string.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
        case void 0:
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string).length;
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer$1.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer$1.prototype._isBuffer = true;
  function swap(b, n, m) {
    var i2 = b[n];
    b[n] = b[m];
    b[m] = i2;
  }
  Buffer$1.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i2 = 0; i2 < len; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer$1.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i2 = 0; i2 < len; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer$1.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i2 = 0; i2 < len; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer$1.prototype.toString = function toString2() {
    var length = this.length | 0;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer$1.prototype.equals = function equals(b) {
    if (!internalIsBuffer(b))
      throw new TypeError("Argument must be a Buffer");
    if (this === b)
      return true;
    return Buffer$1.compare(this, b) === 0;
  };
  Buffer$1.prototype.inspect = function inspect() {
    var str2 = "";
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str2 = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
      if (this.length > max)
        str2 += " ... ";
    }
    return "<Buffer " + str2 + ">";
  };
  Buffer$1.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError("Argument must be a Buffer");
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i2 = 0; i2 < len; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x = thisCopy[i2];
        y = targetCopy[i2];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    if (buffer.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (isNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer$1.from(val, encoding);
    }
    if (internalIsBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (Buffer$1.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    var i2;
    if (dir) {
      var foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read2(arr, i2 + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer$1.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer$1.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer$1.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new TypeError("Invalid hex string");
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i2 = 0; i2 < length; ++i2) {
      var parsed = parseInt(string.substr(i2 * 2, 2), 16);
      if (isNaN(parsed))
        return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer$1.prototype.write = function write3(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    var remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
          return asciiWrite(this, string, offset, length);
        case "latin1":
        case "binary":
          return latin1Write(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer$1.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf);
    } else {
      return fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i2 = start;
    while (i2 < end) {
      var firstByte = buf[i2];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i2 = 0;
    while (i2 < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = "";
    for (var i2 = start; i2 < end; ++i2) {
      out += toHex(buf[i2]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for (var i2 = 0; i2 < bytes.length; i2 += 2) {
      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    }
    return res;
  }
  Buffer$1.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf;
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer$1.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer$1(sliceLen, void 0);
      for (var i2 = 0; i2 < sliceLen; ++i2) {
        newBuf[i2] = this[i2 + start];
      }
    }
    return newBuf;
  };
  function checkOffset(offset, ext2, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext2 > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer$1.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength2 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    return val;
  };
  Buffer$1.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    var val = this[offset + --byteLength2];
    var mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer$1.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer$1.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer$1.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer$1.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer$1.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer$1.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength2 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer$1.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    var i2 = byteLength2;
    var mul = 1;
    var val = this[offset + --i2];
    while (i2 > 0 && (mul *= 256)) {
      val += this[offset + --i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer$1.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer$1.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer$1.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer$1.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer$1.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer$1.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return read$2(this, offset, true, 23, 4);
  };
  Buffer$1.prototype.readFloatBE = function readFloatBE2(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return read$2(this, offset, false, 23, 4);
  };
  Buffer$1.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return read$2(this, offset, true, 52, 8);
  };
  Buffer$1.prototype.readDoubleBE = function readDoubleBE2(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return read$2(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext2, max, min) {
    if (!internalIsBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext2 > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer$1.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    var mul = 1;
    var i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength2 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer$1.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    var i2 = byteLength2 - 1;
    var mul = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer$1.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    this[offset] = value & 255;
    return offset + 1;
  };
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 65535 + value + 1;
    for (var i2 = 0, j = Math.min(buf.length - offset, 2); i2 < j; ++i2) {
      buf[offset + i2] = (value & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
    }
  }
  Buffer$1.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer$1.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 4294967295 + value + 1;
    for (var i2 = 0, j = Math.min(buf.length - offset, 4); i2 < j; ++i2) {
      buf[offset + i2] = value >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
    }
  }
  Buffer$1.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer$1.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  Buffer$1.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    var i2 = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer$1.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    var i2 = byteLength2 - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer$1.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer$1.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer$1.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  Buffer$1.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer$1.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext2, max, min) {
    if (offset + ext2 > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    write$2(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer$1.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer$1.prototype.writeFloatBE = function writeFloatBE2(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    write$2(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer$1.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer$1.prototype.writeDoubleBE = function writeDoubleBE2(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer$1.prototype.copy = function copy2(target, targetStart, start, end) {
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("sourceStart out of bounds");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    var i2;
    if (this === target && start < targetStart && targetStart < end) {
      for (i2 = len - 1; i2 >= 0; --i2) {
        target[i2 + targetStart] = this[i2 + start];
      }
    } else if (len < 1e3 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
      for (i2 = 0; i2 < len; ++i2) {
        target[i2 + targetStart] = this[i2 + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }
    return len;
  };
  Buffer$1.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer$1.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
    } else if (typeof val === "number") {
      val = val & 255;
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    var i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end; ++i2) {
        this[i2] = val;
      }
    } else {
      var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer$1(val, encoding).toString());
      var len = bytes.length;
      for (i2 = 0; i2 < end - start; ++i2) {
        this[i2 + start] = bytes[i2 % len];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  function base64clean(str2) {
    str2 = stringtrim(str2).replace(INVALID_BASE64_RE, "");
    if (str2.length < 2)
      return "";
    while (str2.length % 4 !== 0) {
      str2 = str2 + "=";
    }
    return str2;
  }
  function stringtrim(str2) {
    if (str2.trim)
      return str2.trim();
    return str2.replace(/^\s+|\s+$/g, "");
  }
  function toHex(n) {
    if (n < 16)
      return "0" + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i2 = 0; i2 < length; ++i2) {
      codePoint = string.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str2) {
    var byteArray = [];
    for (var i2 = 0; i2 < str2.length; ++i2) {
      byteArray.push(str2.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str2, units) {
    var c2, hi, lo;
    var byteArray = [];
    for (var i2 = 0; i2 < str2.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c2 = str2.charCodeAt(i2);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str2) {
    return toByteArray(base64clean(str2));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i2 = 0; i2 < length; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src.length)
        break;
      dst[i2 + offset] = src[i2];
    }
    return i2;
  }
  function isnan(val) {
    return val !== val;
  }
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
  }
  function isFastBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  }
  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
  }
  var bufferGlobal = c("undefined" !== typeof Buffer$1 && Buffer$1) || c(commonjsGlobal.Buffer) || c("undefined" !== typeof window && window.Buffer) || commonjsGlobal.Buffer;
  function c(B) {
    return B && B.isBuffer && B;
  }
  var toString$1 = {}.toString;
  var isarray = Array.isArray || function(arr) {
    return toString$1.call(arr) == "[object Array]";
  };
  var bufferishArrayExports = {};
  var bufferishArray = {
    get exports() {
      return bufferishArrayExports;
    },
    set exports(v) {
      bufferishArrayExports = v;
    }
  };
  var hasRequiredBufferishArray;
  function requireBufferishArray() {
    if (hasRequiredBufferishArray)
      return bufferishArrayExports;
    hasRequiredBufferishArray = 1;
    var Bufferish2 = requireBufferish();
    var exports3 = bufferishArray.exports = alloc2(0);
    exports3.alloc = alloc2;
    exports3.concat = Bufferish2.concat;
    exports3.from = from2;
    function alloc2(size) {
      return new Array(size);
    }
    function from2(value) {
      if (!Bufferish2.isBuffer(value) && Bufferish2.isView(value)) {
        value = Bufferish2.Uint8Array.from(value);
      } else if (Bufferish2.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish2.from.call(exports3, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return Array.prototype.slice.call(value);
    }
    return bufferishArrayExports;
  }
  var bufferishBufferExports = {};
  var bufferishBuffer = {
    get exports() {
      return bufferishBufferExports;
    },
    set exports(v) {
      bufferishBufferExports = v;
    }
  };
  var hasRequiredBufferishBuffer;
  function requireBufferishBuffer() {
    if (hasRequiredBufferishBuffer)
      return bufferishBufferExports;
    hasRequiredBufferishBuffer = 1;
    var Bufferish2 = requireBufferish();
    var Buffer2 = Bufferish2.global;
    var exports3 = bufferishBuffer.exports = Bufferish2.hasBuffer ? alloc2(0) : [];
    exports3.alloc = Bufferish2.hasBuffer && Buffer2.alloc || alloc2;
    exports3.concat = Bufferish2.concat;
    exports3.from = from2;
    function alloc2(size) {
      return new Buffer2(size);
    }
    function from2(value) {
      if (!Bufferish2.isBuffer(value) && Bufferish2.isView(value)) {
        value = Bufferish2.Uint8Array.from(value);
      } else if (Bufferish2.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish2.from.call(exports3, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (Buffer2.from && Buffer2.from.length !== 1) {
        return Buffer2.from(value);
      } else {
        return new Buffer2(value);
      }
    }
    return bufferishBufferExports;
  }
  var bufferishUint8arrayExports = {};
  var bufferishUint8array = {
    get exports() {
      return bufferishUint8arrayExports;
    },
    set exports(v) {
      bufferishUint8arrayExports = v;
    }
  };
  var hasRequiredBufferishUint8array;
  function requireBufferishUint8array() {
    if (hasRequiredBufferishUint8array)
      return bufferishUint8arrayExports;
    hasRequiredBufferishUint8array = 1;
    var Bufferish2 = requireBufferish();
    var exports3 = bufferishUint8array.exports = Bufferish2.hasArrayBuffer ? alloc2(0) : [];
    exports3.alloc = alloc2;
    exports3.concat = Bufferish2.concat;
    exports3.from = from2;
    function alloc2(size) {
      return new Uint8Array(size);
    }
    function from2(value) {
      if (Bufferish2.isView(value)) {
        var byteOffset = value.byteOffset;
        var byteLength2 = value.byteLength;
        value = value.buffer;
        if (value.byteLength !== byteLength2) {
          if (value.slice) {
            value = value.slice(byteOffset, byteOffset + byteLength2);
          } else {
            value = new Uint8Array(value);
            if (value.byteLength !== byteLength2) {
              value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength2);
            }
          }
        }
      } else if (typeof value === "string") {
        return Bufferish2.from.call(exports3, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return new Uint8Array(value);
    }
    return bufferishUint8arrayExports;
  }
  var bufferishProto = {};
  var bufferLite = {};
  bufferLite.copy = copy;
  bufferLite.toString = toString;
  bufferLite.write = write$1;
  function write$1(string, offset) {
    var buffer = this;
    var index = offset || (offset |= 0);
    var length = string.length;
    var chr = 0;
    var i2 = 0;
    while (i2 < length) {
      chr = string.charCodeAt(i2++);
      if (chr < 128) {
        buffer[index++] = chr;
      } else if (chr < 2048) {
        buffer[index++] = 192 | chr >>> 6;
        buffer[index++] = 128 | chr & 63;
      } else if (chr < 55296 || chr > 57343) {
        buffer[index++] = 224 | chr >>> 12;
        buffer[index++] = 128 | chr >>> 6 & 63;
        buffer[index++] = 128 | chr & 63;
      } else {
        chr = (chr - 55296 << 10 | string.charCodeAt(i2++) - 56320) + 65536;
        buffer[index++] = 240 | chr >>> 18;
        buffer[index++] = 128 | chr >>> 12 & 63;
        buffer[index++] = 128 | chr >>> 6 & 63;
        buffer[index++] = 128 | chr & 63;
      }
    }
    return index - offset;
  }
  function toString(encoding, start, end) {
    var buffer = this;
    var index = start | 0;
    if (!end)
      end = buffer.length;
    var string = "";
    var chr = 0;
    while (index < end) {
      chr = buffer[index++];
      if (chr < 128) {
        string += String.fromCharCode(chr);
        continue;
      }
      if ((chr & 224) === 192) {
        chr = (chr & 31) << 6 | buffer[index++] & 63;
      } else if ((chr & 240) === 224) {
        chr = (chr & 15) << 12 | (buffer[index++] & 63) << 6 | buffer[index++] & 63;
      } else if ((chr & 248) === 240) {
        chr = (chr & 7) << 18 | (buffer[index++] & 63) << 12 | (buffer[index++] & 63) << 6 | buffer[index++] & 63;
      }
      if (chr >= 65536) {
        chr -= 65536;
        string += String.fromCharCode((chr >>> 10) + 55296, (chr & 1023) + 56320);
      } else {
        string += String.fromCharCode(chr);
      }
    }
    return string;
  }
  function copy(target, targetStart, start, end) {
    var i2;
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (!targetStart)
      targetStart = 0;
    var len = end - start;
    if (target === this && start < targetStart && targetStart < end) {
      for (i2 = len - 1; i2 >= 0; i2--) {
        target[i2 + targetStart] = this[i2 + start];
      }
    } else {
      for (i2 = 0; i2 < len; i2++) {
        target[i2 + targetStart] = this[i2 + start];
      }
    }
    return len;
  }
  var hasRequiredBufferishProto;
  function requireBufferishProto() {
    if (hasRequiredBufferishProto)
      return bufferishProto;
    hasRequiredBufferishProto = 1;
    var BufferLite = bufferLite;
    bufferishProto.copy = copy2;
    bufferishProto.slice = slice;
    bufferishProto.toString = toString2;
    bufferishProto.write = gen("write");
    var Bufferish2 = requireBufferish();
    var Buffer2 = Bufferish2.global;
    var isBufferShim = Bufferish2.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer2;
    var brokenTypedArray = isBufferShim && !Buffer2.TYPED_ARRAY_SUPPORT;
    function copy2(target, targetStart, start, end) {
      var thisIsBuffer = Bufferish2.isBuffer(this);
      var targetIsBuffer = Bufferish2.isBuffer(target);
      if (thisIsBuffer && targetIsBuffer) {
        return this.copy(target, targetStart, start, end);
      } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer && Bufferish2.isView(this) && Bufferish2.isView(target)) {
        var buffer = start || end != null ? slice.call(this, start, end) : this;
        target.set(buffer, targetStart);
        return buffer.length;
      } else {
        return BufferLite.copy.call(this, target, targetStart, start, end);
      }
    }
    function slice(start, end) {
      var f = this.slice || !brokenTypedArray && this.subarray;
      if (f)
        return f.call(this, start, end);
      var target = Bufferish2.alloc.call(this, end - start);
      copy2.call(this, target, 0, start, end);
      return target;
    }
    function toString2(encoding, start, end) {
      var f = !isBufferShim && Bufferish2.isBuffer(this) ? this.toString : BufferLite.toString;
      return f.apply(this, arguments);
    }
    function gen(method) {
      return wrap;
      function wrap() {
        var f = this[method] || BufferLite[method];
        return f.apply(this, arguments);
      }
    }
    return bufferishProto;
  }
  var hasRequiredBufferish;
  function requireBufferish() {
    if (hasRequiredBufferish)
      return bufferish;
    hasRequiredBufferish = 1;
    (function(exports3) {
      var Buffer2 = exports3.global = bufferGlobal;
      var hasBuffer = exports3.hasBuffer = Buffer2 && !!Buffer2.isBuffer;
      var hasArrayBuffer = exports3.hasArrayBuffer = "undefined" !== typeof ArrayBuffer;
      var isArray2 = exports3.isArray = isarray;
      exports3.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;
      var isBuffer2 = exports3.isBuffer = hasBuffer ? Buffer2.isBuffer : _false;
      var isView = exports3.isView = hasArrayBuffer ? ArrayBuffer.isView || _is("ArrayBuffer", "buffer") : _false;
      exports3.alloc = alloc2;
      exports3.concat = concat;
      exports3.from = from2;
      var BufferArray = exports3.Array = requireBufferishArray();
      var BufferBuffer = exports3.Buffer = requireBufferishBuffer();
      var BufferUint8Array = exports3.Uint8Array = requireBufferishUint8array();
      var BufferProto2 = exports3.prototype = requireBufferishProto();
      function from2(value) {
        if (typeof value === "string") {
          return fromString2.call(this, value);
        } else {
          return auto(this).from(value);
        }
      }
      function alloc2(size) {
        return auto(this).alloc(size);
      }
      function concat(list, length) {
        if (!length) {
          length = 0;
          Array.prototype.forEach.call(list, dryrun);
        }
        var ref = this !== exports3 && this || list[0];
        var result = alloc2.call(ref, length);
        var offset = 0;
        Array.prototype.forEach.call(list, append);
        return result;
        function dryrun(buffer) {
          length += buffer.length;
        }
        function append(buffer) {
          offset += BufferProto2.copy.call(buffer, result, offset);
        }
      }
      var _isArrayBuffer = _is("ArrayBuffer");
      function isArrayBuffer(value) {
        return value instanceof ArrayBuffer || _isArrayBuffer(value);
      }
      function fromString2(value) {
        var expected = value.length * 3;
        var that = alloc2.call(this, expected);
        var actual = BufferProto2.write.call(that, value);
        if (expected !== actual) {
          that = BufferProto2.slice.call(that, 0, actual);
        }
        return that;
      }
      function auto(that) {
        return isBuffer2(that) ? BufferBuffer : isView(that) ? BufferUint8Array : isArray2(that) ? BufferArray : hasBuffer ? BufferBuffer : hasArrayBuffer ? BufferUint8Array : BufferArray;
      }
      function _false() {
        return false;
      }
      function _is(name, key) {
        name = "[object " + name + "]";
        return function(value) {
          return value != null && {}.toString.call(key ? value[key] : value) === name;
        };
      }
    })(bufferish);
    return bufferish;
  }
  extBuffer.ExtBuffer = ExtBuffer$1;
  var Bufferish$5 = requireBufferish();
  function ExtBuffer$1(buffer, type) {
    if (!(this instanceof ExtBuffer$1))
      return new ExtBuffer$1(buffer, type);
    this.buffer = Bufferish$5.from(buffer);
    this.type = type;
  }
  var extPacker = {};
  var hasRequiredExtPacker;
  function requireExtPacker() {
    if (hasRequiredExtPacker)
      return extPacker;
    hasRequiredExtPacker = 1;
    extPacker.setExtPackers = setExtPackers;
    var Bufferish2 = requireBufferish();
    var Buffer2 = Bufferish2.global;
    var packTypedArray = Bufferish2.Uint8Array.from;
    var _encode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtPackers(codec2) {
      codec2.addExtPacker(14, Error, [packError, encode2]);
      codec2.addExtPacker(1, EvalError, [packError, encode2]);
      codec2.addExtPacker(2, RangeError, [packError, encode2]);
      codec2.addExtPacker(3, ReferenceError, [packError, encode2]);
      codec2.addExtPacker(4, SyntaxError, [packError, encode2]);
      codec2.addExtPacker(5, TypeError, [packError, encode2]);
      codec2.addExtPacker(6, URIError, [packError, encode2]);
      codec2.addExtPacker(10, RegExp, [packRegExp, encode2]);
      codec2.addExtPacker(11, Boolean, [packValueOf, encode2]);
      codec2.addExtPacker(12, String, [packValueOf, encode2]);
      codec2.addExtPacker(13, Date, [Number, encode2]);
      codec2.addExtPacker(15, Number, [packValueOf, encode2]);
      if ("undefined" !== typeof Uint8Array) {
        codec2.addExtPacker(17, Int8Array, packTypedArray);
        codec2.addExtPacker(18, Uint8Array, packTypedArray);
        codec2.addExtPacker(19, Int16Array, packTypedArray);
        codec2.addExtPacker(20, Uint16Array, packTypedArray);
        codec2.addExtPacker(21, Int32Array, packTypedArray);
        codec2.addExtPacker(22, Uint32Array, packTypedArray);
        codec2.addExtPacker(23, Float32Array, packTypedArray);
        if ("undefined" !== typeof Float64Array) {
          codec2.addExtPacker(24, Float64Array, packTypedArray);
        }
        if ("undefined" !== typeof Uint8ClampedArray) {
          codec2.addExtPacker(25, Uint8ClampedArray, packTypedArray);
        }
        codec2.addExtPacker(26, ArrayBuffer, packTypedArray);
        codec2.addExtPacker(29, DataView, packTypedArray);
      }
      if (Bufferish2.hasBuffer) {
        codec2.addExtPacker(27, Buffer2, Bufferish2.from);
      }
    }
    function encode2(input) {
      if (!_encode)
        _encode = requireEncode().encode;
      return _encode(input);
    }
    function packValueOf(value) {
      return value.valueOf();
    }
    function packRegExp(value) {
      value = RegExp.prototype.toString.call(value).split("/");
      value.shift();
      var out = [value.pop()];
      out.unshift(value.join("/"));
      return out;
    }
    function packError(value) {
      var out = {};
      for (var key in ERROR_COLUMNS) {
        out[key] = value[key];
      }
      return out;
    }
    return extPacker;
  }
  var writeType = {};
  var int64Buffer = {};
  (function(exports3) {
    !function(exports4) {
      var UNDEFINED = "undefined";
      var BUFFER = UNDEFINED !== typeof Buffer$1 && Buffer$1;
      var UINT8ARRAY = UNDEFINED !== typeof Uint8Array && Uint8Array;
      var ARRAYBUFFER = UNDEFINED !== typeof ArrayBuffer && ArrayBuffer;
      var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
      var isArray2 = Array.isArray || _isArray;
      var BIT32 = 4294967296;
      var BIT24 = 16777216;
      var storage;
      factory("Uint64BE", true, true);
      factory("Int64BE", true, false);
      factory("Uint64LE", false, true);
      factory("Int64LE", false, false);
      function factory(name, bigendian, unsigned) {
        var posH = bigendian ? 0 : 4;
        var posL = bigendian ? 4 : 0;
        var pos0 = bigendian ? 0 : 3;
        var pos1 = bigendian ? 1 : 2;
        var pos2 = bigendian ? 2 : 1;
        var pos3 = bigendian ? 3 : 0;
        var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
        var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
        var proto = Int64.prototype;
        var isName = "is" + name;
        var _isInt64 = "_" + isName;
        proto.buffer = void 0;
        proto.offset = 0;
        proto[_isInt64] = true;
        proto.toNumber = toNumber;
        proto.toString = toString2;
        proto.toJSON = toNumber;
        proto.toArray = toArray;
        if (BUFFER)
          proto.toBuffer = toBuffer;
        if (UINT8ARRAY)
          proto.toArrayBuffer = toArrayBuffer;
        Int64[isName] = isInt64;
        exports4[name] = Int64;
        return Int64;
        function Int64(buffer, offset, value, raddix) {
          if (!(this instanceof Int64))
            return new Int64(buffer, offset, value, raddix);
          return init2(this, buffer, offset, value, raddix);
        }
        function isInt64(b) {
          return !!(b && b[_isInt64]);
        }
        function init2(that, buffer, offset, value, raddix) {
          if (UINT8ARRAY && ARRAYBUFFER) {
            if (buffer instanceof ARRAYBUFFER)
              buffer = new UINT8ARRAY(buffer);
            if (value instanceof ARRAYBUFFER)
              value = new UINT8ARRAY(value);
          }
          if (!buffer && !offset && !value && !storage) {
            that.buffer = newArray(ZERO, 0);
            return;
          }
          if (!isValidBuffer(buffer, offset)) {
            var _storage = storage || Array;
            raddix = offset;
            value = buffer;
            offset = 0;
            buffer = new _storage(8);
          }
          that.buffer = buffer;
          that.offset = offset |= 0;
          if (UNDEFINED === typeof value)
            return;
          if ("string" === typeof value) {
            fromString2(buffer, offset, value, raddix || 10);
          } else if (isValidBuffer(value, raddix)) {
            fromArray(buffer, offset, value, raddix);
          } else if ("number" === typeof raddix) {
            writeInt32(buffer, offset + posH, value);
            writeInt32(buffer, offset + posL, raddix);
          } else if (value > 0) {
            fromPositive(buffer, offset, value);
          } else if (value < 0) {
            fromNegative(buffer, offset, value);
          } else {
            fromArray(buffer, offset, ZERO, 0);
          }
        }
        function fromString2(buffer, offset, str2, raddix) {
          var pos = 0;
          var len = str2.length;
          var high = 0;
          var low = 0;
          if (str2[0] === "-")
            pos++;
          var sign = pos;
          while (pos < len) {
            var chr = parseInt(str2[pos++], raddix);
            if (!(chr >= 0))
              break;
            low = low * raddix + chr;
            high = high * raddix + Math.floor(low / BIT32);
            low %= BIT32;
          }
          if (sign) {
            high = ~high;
            if (low) {
              low = BIT32 - low;
            } else {
              high++;
            }
          }
          writeInt32(buffer, offset + posH, high);
          writeInt32(buffer, offset + posL, low);
        }
        function toNumber() {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          if (!unsigned)
            high |= 0;
          return high ? high * BIT32 + low : low;
        }
        function toString2(radix) {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          var str2 = "";
          var sign = !unsigned && high & 2147483648;
          if (sign) {
            high = ~high;
            low = BIT32 - low;
          }
          radix = radix || 10;
          while (1) {
            var mod = high % radix * BIT32 + low;
            high = Math.floor(high / radix);
            low = Math.floor(mod / radix);
            str2 = (mod % radix).toString(radix) + str2;
            if (!high && !low)
              break;
          }
          if (sign) {
            str2 = "-" + str2;
          }
          return str2;
        }
        function writeInt32(buffer, offset, value) {
          buffer[offset + pos3] = value & 255;
          value = value >> 8;
          buffer[offset + pos2] = value & 255;
          value = value >> 8;
          buffer[offset + pos1] = value & 255;
          value = value >> 8;
          buffer[offset + pos0] = value & 255;
        }
        function readInt32(buffer, offset) {
          return buffer[offset + pos0] * BIT24 + (buffer[offset + pos1] << 16) + (buffer[offset + pos2] << 8) + buffer[offset + pos3];
        }
      }
      function toArray(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = null;
        if (raw !== false && offset === 0 && buffer.length === 8 && isArray2(buffer))
          return buffer;
        return newArray(buffer, offset);
      }
      function toBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = BUFFER;
        if (raw !== false && offset === 0 && buffer.length === 8 && Buffer$1.isBuffer(buffer))
          return buffer;
        var dest = new BUFFER(8);
        fromArray(dest, 0, buffer, offset);
        return dest;
      }
      function toArrayBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        var arrbuf = buffer.buffer;
        storage = UINT8ARRAY;
        if (raw !== false && offset === 0 && arrbuf instanceof ARRAYBUFFER && arrbuf.byteLength === 8)
          return arrbuf;
        var dest = new UINT8ARRAY(8);
        fromArray(dest, 0, buffer, offset);
        return dest.buffer;
      }
      function isValidBuffer(buffer, offset) {
        var len = buffer && buffer.length;
        offset |= 0;
        return len && offset + 8 <= len && "string" !== typeof buffer[offset];
      }
      function fromArray(destbuf, destoff, srcbuf, srcoff) {
        destoff |= 0;
        srcoff |= 0;
        for (var i2 = 0; i2 < 8; i2++) {
          destbuf[destoff++] = srcbuf[srcoff++] & 255;
        }
      }
      function newArray(buffer, offset) {
        return Array.prototype.slice.call(buffer, offset, offset + 8);
      }
      function fromPositiveBE(buffer, offset, value) {
        var pos = offset + 8;
        while (pos > offset) {
          buffer[--pos] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeBE(buffer, offset, value) {
        var pos = offset + 8;
        value++;
        while (pos > offset) {
          buffer[--pos] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function fromPositiveLE(buffer, offset, value) {
        var end = offset + 8;
        while (offset < end) {
          buffer[offset++] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeLE(buffer, offset, value) {
        var end = offset + 8;
        value++;
        while (offset < end) {
          buffer[offset++] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function _isArray(val) {
        return !!val && "[object Array]" == Object.prototype.toString.call(val);
      }
    }(typeof exports3.nodeName !== "string" ? exports3 : commonjsGlobal || {});
  })(int64Buffer);
  var writeToken = {};
  var ieee754$2 = {};
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  ieee754$2.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i2];
    i2 += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  ieee754$2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c2 = Math.pow(2, -e)) < 1) {
        e--;
        c2 *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c2;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c2 >= 2) {
        e++;
        c2 /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c2 - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
    }
    buffer[offset + i2 - d] |= s * 128;
  };
  var writeUint8 = {};
  var constant$1 = writeUint8.uint8 = new Array(256);
  for (var i = 0; i <= 255; i++) {
    constant$1[i] = write0(i);
  }
  function write0(type) {
    return function(encoder2) {
      var offset = encoder2.reserve(1);
      encoder2.buffer[offset] = type;
    };
  }
  var ieee754$1 = ieee754$2;
  var Int64Buffer$2 = int64Buffer;
  var Uint64BE$2 = Int64Buffer$2.Uint64BE;
  var Int64BE$2 = Int64Buffer$2.Int64BE;
  var uint8$2 = writeUint8.uint8;
  var Bufferish$4 = requireBufferish();
  var Buffer = Bufferish$4.global;
  var IS_BUFFER_SHIM = Bufferish$4.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer;
  var NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer.TYPED_ARRAY_SUPPORT;
  var Buffer_prototype = Bufferish$4.hasBuffer && Buffer.prototype || {};
  writeToken.getWriteToken = getWriteToken;
  function getWriteToken(options) {
    if (options && options.uint8array) {
      return init_uint8array();
    } else if (NO_TYPED_ARRAY || Bufferish$4.hasBuffer && options && options.safe) {
      return init_safe();
    } else {
      return init_token$1();
    }
  }
  function init_uint8array() {
    var token = init_token$1();
    token[202] = writeN(202, 4, writeFloatBE);
    token[203] = writeN(203, 8, writeDoubleBE);
    return token;
  }
  function init_token$1() {
    var token = uint8$2.slice();
    token[196] = write1(196);
    token[197] = write2(197);
    token[198] = write4(198);
    token[199] = write1(199);
    token[200] = write2(200);
    token[201] = write4(201);
    token[202] = writeN(202, 4, Buffer_prototype.writeFloatBE || writeFloatBE, true);
    token[203] = writeN(203, 8, Buffer_prototype.writeDoubleBE || writeDoubleBE, true);
    token[204] = write1(204);
    token[205] = write2(205);
    token[206] = write4(206);
    token[207] = writeN(207, 8, writeUInt64BE);
    token[208] = write1(208);
    token[209] = write2(209);
    token[210] = write4(210);
    token[211] = writeN(211, 8, writeInt64BE);
    token[217] = write1(217);
    token[218] = write2(218);
    token[219] = write4(219);
    token[220] = write2(220);
    token[221] = write4(221);
    token[222] = write2(222);
    token[223] = write4(223);
    return token;
  }
  function init_safe() {
    var token = uint8$2.slice();
    token[196] = writeN(196, 1, Buffer.prototype.writeUInt8);
    token[197] = writeN(197, 2, Buffer.prototype.writeUInt16BE);
    token[198] = writeN(198, 4, Buffer.prototype.writeUInt32BE);
    token[199] = writeN(199, 1, Buffer.prototype.writeUInt8);
    token[200] = writeN(200, 2, Buffer.prototype.writeUInt16BE);
    token[201] = writeN(201, 4, Buffer.prototype.writeUInt32BE);
    token[202] = writeN(202, 4, Buffer.prototype.writeFloatBE);
    token[203] = writeN(203, 8, Buffer.prototype.writeDoubleBE);
    token[204] = writeN(204, 1, Buffer.prototype.writeUInt8);
    token[205] = writeN(205, 2, Buffer.prototype.writeUInt16BE);
    token[206] = writeN(206, 4, Buffer.prototype.writeUInt32BE);
    token[207] = writeN(207, 8, writeUInt64BE);
    token[208] = writeN(208, 1, Buffer.prototype.writeInt8);
    token[209] = writeN(209, 2, Buffer.prototype.writeInt16BE);
    token[210] = writeN(210, 4, Buffer.prototype.writeInt32BE);
    token[211] = writeN(211, 8, writeInt64BE);
    token[217] = writeN(217, 1, Buffer.prototype.writeUInt8);
    token[218] = writeN(218, 2, Buffer.prototype.writeUInt16BE);
    token[219] = writeN(219, 4, Buffer.prototype.writeUInt32BE);
    token[220] = writeN(220, 2, Buffer.prototype.writeUInt16BE);
    token[221] = writeN(221, 4, Buffer.prototype.writeUInt32BE);
    token[222] = writeN(222, 2, Buffer.prototype.writeUInt16BE);
    token[223] = writeN(223, 4, Buffer.prototype.writeUInt32BE);
    return token;
  }
  function write1(type) {
    return function(encoder2, value) {
      var offset = encoder2.reserve(2);
      var buffer = encoder2.buffer;
      buffer[offset++] = type;
      buffer[offset] = value;
    };
  }
  function write2(type) {
    return function(encoder2, value) {
      var offset = encoder2.reserve(3);
      var buffer = encoder2.buffer;
      buffer[offset++] = type;
      buffer[offset++] = value >>> 8;
      buffer[offset] = value;
    };
  }
  function write4(type) {
    return function(encoder2, value) {
      var offset = encoder2.reserve(5);
      var buffer = encoder2.buffer;
      buffer[offset++] = type;
      buffer[offset++] = value >>> 24;
      buffer[offset++] = value >>> 16;
      buffer[offset++] = value >>> 8;
      buffer[offset] = value;
    };
  }
  function writeN(type, len, method, noAssert) {
    return function(encoder2, value) {
      var offset = encoder2.reserve(len + 1);
      encoder2.buffer[offset++] = type;
      method.call(encoder2.buffer, value, offset, noAssert);
    };
  }
  function writeUInt64BE(value, offset) {
    new Uint64BE$2(this, offset, value);
  }
  function writeInt64BE(value, offset) {
    new Int64BE$2(this, offset, value);
  }
  function writeFloatBE(value, offset) {
    ieee754$1.write(this, value, offset, false, 23, 4);
  }
  function writeDoubleBE(value, offset) {
    ieee754$1.write(this, value, offset, false, 52, 8);
  }
  var IS_ARRAY$1 = isarray;
  var Int64Buffer$1 = int64Buffer;
  var Uint64BE$1 = Int64Buffer$1.Uint64BE;
  var Int64BE$1 = Int64Buffer$1.Int64BE;
  var Bufferish$3 = requireBufferish();
  var BufferProto$1 = requireBufferishProto();
  var WriteToken = writeToken;
  var uint8$1 = writeUint8.uint8;
  var ExtBuffer = extBuffer.ExtBuffer;
  var HAS_UINT8ARRAY = "undefined" !== typeof Uint8Array;
  var HAS_MAP$1 = "undefined" !== typeof Map;
  var extmap = [];
  extmap[1] = 212;
  extmap[2] = 213;
  extmap[4] = 214;
  extmap[8] = 215;
  extmap[16] = 216;
  writeType.getWriteType = getWriteType;
  function getWriteType(options) {
    var token = WriteToken.getWriteToken(options);
    var useraw = options && options.useraw;
    var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;
    var isBuffer2 = binarraybuffer ? Bufferish$3.isArrayBuffer : Bufferish$3.isBuffer;
    var bin = binarraybuffer ? bin_arraybuffer2 : bin_buffer2;
    var usemap = HAS_MAP$1 && options && options.usemap;
    var map = usemap ? map_to_map2 : obj_to_map;
    var writeType2 = {
      "boolean": bool,
      "function": nil,
      "number": number,
      "object": useraw ? object_raw : object,
      "string": _string(useraw ? raw_head_size : str_head_size),
      "symbol": nil,
      "undefined": nil
    };
    return writeType2;
    function bool(encoder2, value) {
      var type = value ? 195 : 194;
      token[type](encoder2, value);
    }
    function number(encoder2, value) {
      var ivalue = value | 0;
      var type;
      if (value !== ivalue) {
        type = 203;
        token[type](encoder2, value);
        return;
      } else if (-32 <= ivalue && ivalue <= 127) {
        type = ivalue & 255;
      } else if (0 <= ivalue) {
        type = ivalue <= 255 ? 204 : ivalue <= 65535 ? 205 : 206;
      } else {
        type = -128 <= ivalue ? 208 : -32768 <= ivalue ? 209 : 210;
      }
      token[type](encoder2, ivalue);
    }
    function uint64(encoder2, value) {
      var type = 207;
      token[type](encoder2, value.toArray());
    }
    function int64(encoder2, value) {
      var type = 211;
      token[type](encoder2, value.toArray());
    }
    function str_head_size(length) {
      return length < 32 ? 1 : length <= 255 ? 2 : length <= 65535 ? 3 : 5;
    }
    function raw_head_size(length) {
      return length < 32 ? 1 : length <= 65535 ? 3 : 5;
    }
    function _string(head_size) {
      return string;
      function string(encoder2, value) {
        var length = value.length;
        var maxsize = 5 + length * 3;
        encoder2.offset = encoder2.reserve(maxsize);
        var buffer = encoder2.buffer;
        var expected = head_size(length);
        var start = encoder2.offset + expected;
        length = BufferProto$1.write.call(buffer, value, start);
        var actual = head_size(length);
        if (expected !== actual) {
          var targetStart = start + actual - expected;
          var end = start + length;
          BufferProto$1.copy.call(buffer, buffer, targetStart, start, end);
        }
        var type = actual === 1 ? 160 + length : actual <= 3 ? 215 + actual : 219;
        token[type](encoder2, length);
        encoder2.offset += length;
      }
    }
    function object(encoder2, value) {
      if (value === null)
        return nil(encoder2, value);
      if (isBuffer2(value))
        return bin(encoder2, value);
      if (IS_ARRAY$1(value))
        return array2(encoder2, value);
      if (Uint64BE$1.isUint64BE(value))
        return uint64(encoder2, value);
      if (Int64BE$1.isInt64BE(value))
        return int64(encoder2, value);
      var packer = encoder2.codec.getExtPacker(value);
      if (packer)
        value = packer(value);
      if (value instanceof ExtBuffer)
        return ext2(encoder2, value);
      map(encoder2, value);
    }
    function object_raw(encoder2, value) {
      if (isBuffer2(value))
        return raw(encoder2, value);
      object(encoder2, value);
    }
    function nil(encoder2, value) {
      var type = 192;
      token[type](encoder2, value);
    }
    function array2(encoder2, value) {
      var length = value.length;
      var type = length < 16 ? 144 + length : length <= 65535 ? 220 : 221;
      token[type](encoder2, length);
      var encode2 = encoder2.codec.encode;
      for (var i2 = 0; i2 < length; i2++) {
        encode2(encoder2, value[i2]);
      }
    }
    function bin_buffer2(encoder2, value) {
      var length = value.length;
      var type = length < 255 ? 196 : length <= 65535 ? 197 : 198;
      token[type](encoder2, length);
      encoder2.send(value);
    }
    function bin_arraybuffer2(encoder2, value) {
      bin_buffer2(encoder2, new Uint8Array(value));
    }
    function ext2(encoder2, value) {
      var buffer = value.buffer;
      var length = buffer.length;
      var type = extmap[length] || (length < 255 ? 199 : length <= 65535 ? 200 : 201);
      token[type](encoder2, length);
      uint8$1[value.type](encoder2);
      encoder2.send(buffer);
    }
    function obj_to_map(encoder2, value) {
      var keys = Object.keys(value);
      var length = keys.length;
      var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
      token[type](encoder2, length);
      var encode2 = encoder2.codec.encode;
      keys.forEach(function(key) {
        encode2(encoder2, key);
        encode2(encoder2, value[key]);
      });
    }
    function map_to_map2(encoder2, value) {
      if (!(value instanceof Map))
        return obj_to_map(encoder2, value);
      var length = value.size;
      var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
      token[type](encoder2, length);
      var encode2 = encoder2.codec.encode;
      value.forEach(function(val, key, m) {
        encode2(encoder2, key);
        encode2(encoder2, val);
      });
    }
    function raw(encoder2, value) {
      var length = value.length;
      var type = length < 32 ? 160 + length : length <= 65535 ? 218 : 219;
      token[type](encoder2, length);
      encoder2.send(value);
    }
  }
  var codecBase = {};
  var IS_ARRAY = isarray;
  codecBase.createCodec = createCodec;
  codecBase.install = install;
  codecBase.filter = filter;
  var Bufferish$2 = requireBufferish();
  function Codec(options) {
    if (!(this instanceof Codec))
      return new Codec(options);
    this.options = options;
    this.init();
  }
  Codec.prototype.init = function() {
    var options = this.options;
    if (options && options.uint8array) {
      this.bufferish = Bufferish$2.Uint8Array;
    }
    return this;
  };
  function install(props) {
    for (var key in props) {
      Codec.prototype[key] = add(Codec.prototype[key], props[key]);
    }
  }
  function add(a, b) {
    return a && b ? ab : a || b;
    function ab() {
      a.apply(this, arguments);
      return b.apply(this, arguments);
    }
  }
  function join(filters) {
    filters = filters.slice();
    return function(value) {
      return filters.reduce(iterator, value);
    };
    function iterator(value, filter2) {
      return filter2(value);
    }
  }
  function filter(filter2) {
    return IS_ARRAY(filter2) ? join(filter2) : filter2;
  }
  function createCodec(options) {
    return new Codec(options);
  }
  codecBase.preset = createCodec({ preset: true });
  var hasRequiredWriteCore;
  function requireWriteCore() {
    if (hasRequiredWriteCore)
      return writeCore;
    hasRequiredWriteCore = 1;
    var ExtBuffer2 = extBuffer.ExtBuffer;
    var ExtPacker = requireExtPacker();
    var WriteType = writeType;
    var CodecBase = codecBase;
    CodecBase.install({
      addExtPacker,
      getExtPacker,
      init: init2
    });
    writeCore.preset = init2.call(CodecBase.preset);
    function getEncoder(options) {
      var writeType2 = WriteType.getWriteType(options);
      return encode2;
      function encode2(encoder2, value) {
        var func = writeType2[typeof value];
        if (!func)
          throw new Error('Unsupported type "' + typeof value + '": ' + value);
        func(encoder2, value);
      }
    }
    function init2() {
      var options = this.options;
      this.encode = getEncoder(options);
      if (options && options.preset) {
        ExtPacker.setExtPackers(this);
      }
      return this;
    }
    function addExtPacker(etype, Class, packer) {
      packer = CodecBase.filter(packer);
      var name = Class.name;
      if (name && name !== "Object") {
        var packers = this.extPackers || (this.extPackers = {});
        packers[name] = extPacker2;
      } else {
        var list = this.extEncoderList || (this.extEncoderList = []);
        list.unshift([Class, extPacker2]);
      }
      function extPacker2(value) {
        if (packer)
          value = packer(value);
        return new ExtBuffer2(value, etype);
      }
    }
    function getExtPacker(value) {
      var packers = this.extPackers || (this.extPackers = {});
      var c2 = value.constructor;
      var e = c2 && c2.name && packers[c2.name];
      if (e)
        return e;
      var list = this.extEncoderList || (this.extEncoderList = []);
      var len = list.length;
      for (var i2 = 0; i2 < len; i2++) {
        var pair = list[i2];
        if (c2 === pair[0])
          return pair[1];
      }
    }
    return writeCore;
  }
  var flexBuffer = {};
  flexBuffer.FlexDecoder = FlexDecoder;
  flexBuffer.FlexEncoder = FlexEncoder;
  var Bufferish$1 = requireBufferish();
  var MIN_BUFFER_SIZE = 2048;
  var MAX_BUFFER_SIZE = 65536;
  var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";
  function FlexDecoder() {
    if (!(this instanceof FlexDecoder))
      return new FlexDecoder();
  }
  function FlexEncoder() {
    if (!(this instanceof FlexEncoder))
      return new FlexEncoder();
  }
  FlexDecoder.mixin = mixinFactory(getDecoderMethods());
  FlexDecoder.mixin(FlexDecoder.prototype);
  FlexEncoder.mixin = mixinFactory(getEncoderMethods());
  FlexEncoder.mixin(FlexEncoder.prototype);
  function getDecoderMethods() {
    return {
      bufferish: Bufferish$1,
      write: write3,
      fetch,
      flush,
      push,
      pull,
      read: read$1,
      reserve,
      offset: 0
    };
    function write3(chunk) {
      var prev = this.offset ? Bufferish$1.prototype.slice.call(this.buffer, this.offset) : this.buffer;
      this.buffer = prev ? chunk ? this.bufferish.concat([prev, chunk]) : prev : chunk;
      this.offset = 0;
    }
    function flush() {
      while (this.offset < this.buffer.length) {
        var start = this.offset;
        var value;
        try {
          value = this.fetch();
        } catch (e) {
          if (e && e.message != BUFFER_SHORTAGE)
            throw e;
          this.offset = start;
          break;
        }
        this.push(value);
      }
    }
    function reserve(length) {
      var start = this.offset;
      var end = start + length;
      if (end > this.buffer.length)
        throw new Error(BUFFER_SHORTAGE);
      this.offset = end;
      return start;
    }
  }
  function getEncoderMethods() {
    return {
      bufferish: Bufferish$1,
      write,
      fetch: fetch2,
      flush,
      push,
      pull: pull2,
      read: read$1,
      reserve,
      send,
      maxBufferSize: MAX_BUFFER_SIZE,
      minBufferSize: MIN_BUFFER_SIZE,
      offset: 0,
      start: 0
    };
    function fetch2() {
      var start = this.start;
      if (start < this.offset) {
        var end = this.start = this.offset;
        return Bufferish$1.prototype.slice.call(this.buffer, start, end);
      }
    }
    function flush() {
      while (this.start < this.offset) {
        var value = this.fetch();
        if (value)
          this.push(value);
      }
    }
    function pull2() {
      var buffers = this.buffers || (this.buffers = []);
      var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];
      buffers.length = 0;
      return chunk;
    }
    function reserve(length) {
      var req = length | 0;
      if (this.buffer) {
        var size = this.buffer.length;
        var start = this.offset | 0;
        var end = start + req;
        if (end < size) {
          this.offset = end;
          return start;
        }
        this.flush();
        length = Math.max(length, Math.min(size * 2, this.maxBufferSize));
      }
      length = Math.max(length, this.minBufferSize);
      this.buffer = this.bufferish.alloc(length);
      this.start = 0;
      this.offset = req;
      return 0;
    }
    function send(buffer) {
      var length = buffer.length;
      if (length > this.minBufferSize) {
        this.flush();
        this.push(buffer);
      } else {
        var offset = this.reserve(length);
        Bufferish$1.prototype.copy.call(buffer, this.buffer, offset);
      }
    }
  }
  function write() {
    throw new Error("method not implemented: write()");
  }
  function fetch() {
    throw new Error("method not implemented: fetch()");
  }
  function read$1() {
    var length = this.buffers && this.buffers.length;
    if (!length)
      return this.fetch();
    this.flush();
    return this.pull();
  }
  function push(chunk) {
    var buffers = this.buffers || (this.buffers = []);
    buffers.push(chunk);
  }
  function pull() {
    var buffers = this.buffers || (this.buffers = []);
    return buffers.shift();
  }
  function mixinFactory(source) {
    return mixin;
    function mixin(target) {
      for (var key in source) {
        target[key] = source[key];
      }
      return target;
    }
  }
  var hasRequiredEncodeBuffer;
  function requireEncodeBuffer() {
    if (hasRequiredEncodeBuffer)
      return encodeBuffer;
    hasRequiredEncodeBuffer = 1;
    encodeBuffer.EncodeBuffer = EncodeBuffer2;
    var preset = requireWriteCore().preset;
    var FlexEncoder2 = flexBuffer.FlexEncoder;
    FlexEncoder2.mixin(EncodeBuffer2.prototype);
    function EncodeBuffer2(options) {
      if (!(this instanceof EncodeBuffer2))
        return new EncodeBuffer2(options);
      if (options) {
        this.options = options;
        if (options.codec) {
          var codec2 = this.codec = options.codec;
          if (codec2.bufferish)
            this.bufferish = codec2.bufferish;
        }
      }
    }
    EncodeBuffer2.prototype.codec = preset;
    EncodeBuffer2.prototype.write = function(input) {
      this.codec.encode(this, input);
    };
    return encodeBuffer;
  }
  var hasRequiredEncode;
  function requireEncode() {
    if (hasRequiredEncode)
      return encode;
    hasRequiredEncode = 1;
    encode.encode = encode$1;
    var EncodeBuffer2 = requireEncodeBuffer().EncodeBuffer;
    function encode$1(input, options) {
      var encoder2 = new EncodeBuffer2(options);
      encoder2.write(input);
      return encoder2.read();
    }
    return encode;
  }
  var decode = {};
  var decodeBuffer = {};
  var readCore = {};
  var extUnpacker = {};
  var hasRequiredExtUnpacker;
  function requireExtUnpacker() {
    if (hasRequiredExtUnpacker)
      return extUnpacker;
    hasRequiredExtUnpacker = 1;
    extUnpacker.setExtUnpackers = setExtUnpackers;
    var Bufferish2 = requireBufferish();
    var Buffer2 = Bufferish2.global;
    var _decode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtUnpackers(codec2) {
      codec2.addExtUnpacker(14, [decode2, unpackError(Error)]);
      codec2.addExtUnpacker(1, [decode2, unpackError(EvalError)]);
      codec2.addExtUnpacker(2, [decode2, unpackError(RangeError)]);
      codec2.addExtUnpacker(3, [decode2, unpackError(ReferenceError)]);
      codec2.addExtUnpacker(4, [decode2, unpackError(SyntaxError)]);
      codec2.addExtUnpacker(5, [decode2, unpackError(TypeError)]);
      codec2.addExtUnpacker(6, [decode2, unpackError(URIError)]);
      codec2.addExtUnpacker(10, [decode2, unpackRegExp]);
      codec2.addExtUnpacker(11, [decode2, unpackClass(Boolean)]);
      codec2.addExtUnpacker(12, [decode2, unpackClass(String)]);
      codec2.addExtUnpacker(13, [decode2, unpackClass(Date)]);
      codec2.addExtUnpacker(15, [decode2, unpackClass(Number)]);
      if ("undefined" !== typeof Uint8Array) {
        codec2.addExtUnpacker(17, unpackClass(Int8Array));
        codec2.addExtUnpacker(18, unpackClass(Uint8Array));
        codec2.addExtUnpacker(19, [unpackArrayBuffer, unpackClass(Int16Array)]);
        codec2.addExtUnpacker(20, [unpackArrayBuffer, unpackClass(Uint16Array)]);
        codec2.addExtUnpacker(21, [unpackArrayBuffer, unpackClass(Int32Array)]);
        codec2.addExtUnpacker(22, [unpackArrayBuffer, unpackClass(Uint32Array)]);
        codec2.addExtUnpacker(23, [unpackArrayBuffer, unpackClass(Float32Array)]);
        if ("undefined" !== typeof Float64Array) {
          codec2.addExtUnpacker(24, [unpackArrayBuffer, unpackClass(Float64Array)]);
        }
        if ("undefined" !== typeof Uint8ClampedArray) {
          codec2.addExtUnpacker(25, unpackClass(Uint8ClampedArray));
        }
        codec2.addExtUnpacker(26, unpackArrayBuffer);
        codec2.addExtUnpacker(29, [unpackArrayBuffer, unpackClass(DataView)]);
      }
      if (Bufferish2.hasBuffer) {
        codec2.addExtUnpacker(27, unpackClass(Buffer2));
      }
    }
    function decode2(input) {
      if (!_decode)
        _decode = requireDecode().decode;
      return _decode(input);
    }
    function unpackRegExp(value) {
      return RegExp.apply(null, value);
    }
    function unpackError(Class) {
      return function(value) {
        var out = new Class();
        for (var key in ERROR_COLUMNS) {
          out[key] = value[key];
        }
        return out;
      };
    }
    function unpackClass(Class) {
      return function(value) {
        return new Class(value);
      };
    }
    function unpackArrayBuffer(value) {
      return new Uint8Array(value).buffer;
    }
    return extUnpacker;
  }
  var readFormat = {};
  var ieee754 = ieee754$2;
  var Int64Buffer = int64Buffer;
  var Uint64BE = Int64Buffer.Uint64BE;
  var Int64BE = Int64Buffer.Int64BE;
  readFormat.getReadFormat = getReadFormat;
  readFormat.readUint8 = uint8;
  var Bufferish = requireBufferish();
  var BufferProto = requireBufferishProto();
  var HAS_MAP = "undefined" !== typeof Map;
  var NO_ASSERT = true;
  function getReadFormat(options) {
    var binarraybuffer = Bufferish.hasArrayBuffer && options && options.binarraybuffer;
    var int64 = options && options.int64;
    var usemap = HAS_MAP && options && options.usemap;
    var readFormat2 = {
      map: usemap ? map_to_map : map_to_obj,
      array,
      str,
      bin: binarraybuffer ? bin_arraybuffer : bin_buffer,
      ext: ext$1,
      uint8,
      uint16,
      uint32,
      uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),
      int8,
      int16,
      int32,
      int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),
      float32: read(4, readFloatBE),
      float64: read(8, readDoubleBE)
    };
    return readFormat2;
  }
  function map_to_obj(decoder2, len) {
    var value = {};
    var i2;
    var k = new Array(len);
    var v = new Array(len);
    var decode2 = decoder2.codec.decode;
    for (i2 = 0; i2 < len; i2++) {
      k[i2] = decode2(decoder2);
      v[i2] = decode2(decoder2);
    }
    for (i2 = 0; i2 < len; i2++) {
      value[k[i2]] = v[i2];
    }
    return value;
  }
  function map_to_map(decoder2, len) {
    var value = /* @__PURE__ */ new Map();
    var i2;
    var k = new Array(len);
    var v = new Array(len);
    var decode2 = decoder2.codec.decode;
    for (i2 = 0; i2 < len; i2++) {
      k[i2] = decode2(decoder2);
      v[i2] = decode2(decoder2);
    }
    for (i2 = 0; i2 < len; i2++) {
      value.set(k[i2], v[i2]);
    }
    return value;
  }
  function array(decoder2, len) {
    var value = new Array(len);
    var decode2 = decoder2.codec.decode;
    for (var i2 = 0; i2 < len; i2++) {
      value[i2] = decode2(decoder2);
    }
    return value;
  }
  function str(decoder2, len) {
    var start = decoder2.reserve(len);
    var end = start + len;
    return BufferProto.toString.call(decoder2.buffer, "utf-8", start, end);
  }
  function bin_buffer(decoder2, len) {
    var start = decoder2.reserve(len);
    var end = start + len;
    var buf = BufferProto.slice.call(decoder2.buffer, start, end);
    return Bufferish.from(buf);
  }
  function bin_arraybuffer(decoder2, len) {
    var start = decoder2.reserve(len);
    var end = start + len;
    var buf = BufferProto.slice.call(decoder2.buffer, start, end);
    return Bufferish.Uint8Array.from(buf).buffer;
  }
  function ext$1(decoder2, len) {
    var start = decoder2.reserve(len + 1);
    var type = decoder2.buffer[start++];
    var end = start + len;
    var unpack = decoder2.codec.getExtUnpacker(type);
    if (!unpack)
      throw new Error("Invalid ext type: " + (type ? "0x" + type.toString(16) : type));
    var buf = BufferProto.slice.call(decoder2.buffer, start, end);
    return unpack(buf);
  }
  function uint8(decoder2) {
    var start = decoder2.reserve(1);
    return decoder2.buffer[start];
  }
  function int8(decoder2) {
    var start = decoder2.reserve(1);
    var value = decoder2.buffer[start];
    return value & 128 ? value - 256 : value;
  }
  function uint16(decoder2) {
    var start = decoder2.reserve(2);
    var buffer = decoder2.buffer;
    return buffer[start++] << 8 | buffer[start];
  }
  function int16(decoder2) {
    var start = decoder2.reserve(2);
    var buffer = decoder2.buffer;
    var value = buffer[start++] << 8 | buffer[start];
    return value & 32768 ? value - 65536 : value;
  }
  function uint32(decoder2) {
    var start = decoder2.reserve(4);
    var buffer = decoder2.buffer;
    return buffer[start++] * 16777216 + (buffer[start++] << 16) + (buffer[start++] << 8) + buffer[start];
  }
  function int32(decoder2) {
    var start = decoder2.reserve(4);
    var buffer = decoder2.buffer;
    return buffer[start++] << 24 | buffer[start++] << 16 | buffer[start++] << 8 | buffer[start];
  }
  function read(len, method) {
    return function(decoder2) {
      var start = decoder2.reserve(len);
      return method.call(decoder2.buffer, start, NO_ASSERT);
    };
  }
  function readUInt64BE(start) {
    return new Uint64BE(this, start).toNumber();
  }
  function readInt64BE(start) {
    return new Int64BE(this, start).toNumber();
  }
  function readUInt64BE_int64(start) {
    return new Uint64BE(this, start);
  }
  function readInt64BE_int64(start) {
    return new Int64BE(this, start);
  }
  function readFloatBE(start) {
    return ieee754.read(this, start, false, 23, 4);
  }
  function readDoubleBE(start) {
    return ieee754.read(this, start, false, 52, 8);
  }
  var readToken = {};
  var ReadFormat = readFormat;
  readToken.getReadToken = getReadToken;
  function getReadToken(options) {
    var format = ReadFormat.getReadFormat(options);
    if (options && options.useraw) {
      return init_useraw(format);
    } else {
      return init_token(format);
    }
  }
  function init_token(format) {
    var i2;
    var token = new Array(256);
    for (i2 = 0; i2 <= 127; i2++) {
      token[i2] = constant(i2);
    }
    for (i2 = 128; i2 <= 143; i2++) {
      token[i2] = fix(i2 - 128, format.map);
    }
    for (i2 = 144; i2 <= 159; i2++) {
      token[i2] = fix(i2 - 144, format.array);
    }
    for (i2 = 160; i2 <= 191; i2++) {
      token[i2] = fix(i2 - 160, format.str);
    }
    token[192] = constant(null);
    token[193] = null;
    token[194] = constant(false);
    token[195] = constant(true);
    token[196] = flex(format.uint8, format.bin);
    token[197] = flex(format.uint16, format.bin);
    token[198] = flex(format.uint32, format.bin);
    token[199] = flex(format.uint8, format.ext);
    token[200] = flex(format.uint16, format.ext);
    token[201] = flex(format.uint32, format.ext);
    token[202] = format.float32;
    token[203] = format.float64;
    token[204] = format.uint8;
    token[205] = format.uint16;
    token[206] = format.uint32;
    token[207] = format.uint64;
    token[208] = format.int8;
    token[209] = format.int16;
    token[210] = format.int32;
    token[211] = format.int64;
    token[212] = fix(1, format.ext);
    token[213] = fix(2, format.ext);
    token[214] = fix(4, format.ext);
    token[215] = fix(8, format.ext);
    token[216] = fix(16, format.ext);
    token[217] = flex(format.uint8, format.str);
    token[218] = flex(format.uint16, format.str);
    token[219] = flex(format.uint32, format.str);
    token[220] = flex(format.uint16, format.array);
    token[221] = flex(format.uint32, format.array);
    token[222] = flex(format.uint16, format.map);
    token[223] = flex(format.uint32, format.map);
    for (i2 = 224; i2 <= 255; i2++) {
      token[i2] = constant(i2 - 256);
    }
    return token;
  }
  function init_useraw(format) {
    var i2;
    var token = init_token(format).slice();
    token[217] = token[196];
    token[218] = token[197];
    token[219] = token[198];
    for (i2 = 160; i2 <= 191; i2++) {
      token[i2] = fix(i2 - 160, format.bin);
    }
    return token;
  }
  function constant(value) {
    return function() {
      return value;
    };
  }
  function flex(lenFunc, decodeFunc) {
    return function(decoder2) {
      var len = lenFunc(decoder2);
      return decodeFunc(decoder2, len);
    };
  }
  function fix(len, method) {
    return function(decoder2) {
      return method(decoder2, len);
    };
  }
  var hasRequiredReadCore;
  function requireReadCore() {
    if (hasRequiredReadCore)
      return readCore;
    hasRequiredReadCore = 1;
    var ExtBuffer2 = extBuffer.ExtBuffer;
    var ExtUnpacker = requireExtUnpacker();
    var readUint8 = readFormat.readUint8;
    var ReadToken = readToken;
    var CodecBase = codecBase;
    CodecBase.install({
      addExtUnpacker,
      getExtUnpacker,
      init: init2
    });
    readCore.preset = init2.call(CodecBase.preset);
    function getDecoder(options) {
      var readToken2 = ReadToken.getReadToken(options);
      return decode2;
      function decode2(decoder2) {
        var type = readUint8(decoder2);
        var func = readToken2[type];
        if (!func)
          throw new Error("Invalid type: " + (type ? "0x" + type.toString(16) : type));
        return func(decoder2);
      }
    }
    function init2() {
      var options = this.options;
      this.decode = getDecoder(options);
      if (options && options.preset) {
        ExtUnpacker.setExtUnpackers(this);
      }
      return this;
    }
    function addExtUnpacker(etype, unpacker) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      unpackers[etype] = CodecBase.filter(unpacker);
    }
    function getExtUnpacker(type) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      return unpackers[type] || extUnpacker2;
      function extUnpacker2(buffer) {
        return new ExtBuffer2(buffer, type);
      }
    }
    return readCore;
  }
  var hasRequiredDecodeBuffer;
  function requireDecodeBuffer() {
    if (hasRequiredDecodeBuffer)
      return decodeBuffer;
    hasRequiredDecodeBuffer = 1;
    decodeBuffer.DecodeBuffer = DecodeBuffer2;
    var preset = requireReadCore().preset;
    var FlexDecoder2 = flexBuffer.FlexDecoder;
    FlexDecoder2.mixin(DecodeBuffer2.prototype);
    function DecodeBuffer2(options) {
      if (!(this instanceof DecodeBuffer2))
        return new DecodeBuffer2(options);
      if (options) {
        this.options = options;
        if (options.codec) {
          var codec2 = this.codec = options.codec;
          if (codec2.bufferish)
            this.bufferish = codec2.bufferish;
        }
      }
    }
    DecodeBuffer2.prototype.codec = preset;
    DecodeBuffer2.prototype.fetch = function() {
      return this.codec.decode(this);
    };
    return decodeBuffer;
  }
  var hasRequiredDecode;
  function requireDecode() {
    if (hasRequiredDecode)
      return decode;
    hasRequiredDecode = 1;
    decode.decode = decode$1;
    var DecodeBuffer2 = requireDecodeBuffer().DecodeBuffer;
    function decode$1(input, options) {
      var decoder2 = new DecodeBuffer2(options);
      decoder2.write(input);
      return decoder2.read();
    }
    return decode;
  }
  var encoder = {};
  var eventLiteExports = {};
  var eventLite = {
    get exports() {
      return eventLiteExports;
    },
    set exports(v) {
      eventLiteExports = v;
    }
  };
  /**
   * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
   *
   * @copyright Yusuke Kawasaki
   * @license MIT
   * @constructor
   * @see https://github.com/kawanet/event-lite
   * @see http://kawanet.github.io/event-lite/EventLite.html
   * @example
   * var EventLite = require("event-lite");
   *
   * function MyClass() {...}             // your class
   *
   * EventLite.mixin(MyClass.prototype);  // import event methods
   *
   * var obj = new MyClass();
   * obj.on("foo", function() {...});     // add event listener
   * obj.once("bar", function() {...});   // add one-time event listener
   * obj.emit("foo");                     // dispatch event
   * obj.emit("bar");                     // dispatch another event
   * obj.off("foo");                      // remove event listener
   */
  (function(module2) {
    function EventLite2() {
      if (!(this instanceof EventLite2))
        return new EventLite2();
    }
    (function(EventLite3) {
      module2.exports = EventLite3;
      var LISTENERS = "listeners";
      var methods = {
        on,
        once,
        off,
        emit
      };
      mixin(EventLite3.prototype);
      EventLite3.mixin = mixin;
      function mixin(target) {
        for (var key in methods) {
          target[key] = methods[key];
        }
        return target;
      }
      function on(type, func) {
        getListeners(this, type).push(func);
        return this;
      }
      function once(type, func) {
        var that = this;
        wrap.originalListener = func;
        getListeners(that, type).push(wrap);
        return that;
        function wrap() {
          off.call(that, type, wrap);
          func.apply(this, arguments);
        }
      }
      function off(type, func) {
        var that = this;
        var listners;
        if (!arguments.length) {
          delete that[LISTENERS];
        } else if (!func) {
          listners = that[LISTENERS];
          if (listners) {
            delete listners[type];
            if (!Object.keys(listners).length)
              return off.call(that);
          }
        } else {
          listners = getListeners(that, type, true);
          if (listners) {
            listners = listners.filter(ne);
            if (!listners.length)
              return off.call(that, type);
            that[LISTENERS][type] = listners;
          }
        }
        return that;
        function ne(test) {
          return test !== func && test.originalListener !== func;
        }
      }
      function emit(type, value) {
        var that = this;
        var listeners = getListeners(that, type, true);
        if (!listeners)
          return false;
        var arglen = arguments.length;
        if (arglen === 1) {
          listeners.forEach(zeroarg);
        } else if (arglen === 2) {
          listeners.forEach(onearg);
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          listeners.forEach(moreargs);
        }
        return !!listeners.length;
        function zeroarg(func) {
          func.call(that);
        }
        function onearg(func) {
          func.call(that, value);
        }
        function moreargs(func) {
          func.apply(that, args);
        }
      }
      function getListeners(that, type, readonly) {
        if (readonly && !that[LISTENERS])
          return;
        var listeners = that[LISTENERS] || (that[LISTENERS] = {});
        return listeners[type] || (listeners[type] = []);
      }
    })(EventLite2);
  })(eventLite);
  encoder.Encoder = Encoder;
  var EventLite$1 = eventLiteExports;
  var EncodeBuffer = requireEncodeBuffer().EncodeBuffer;
  function Encoder(options) {
    if (!(this instanceof Encoder))
      return new Encoder(options);
    EncodeBuffer.call(this, options);
  }
  Encoder.prototype = new EncodeBuffer();
  EventLite$1.mixin(Encoder.prototype);
  Encoder.prototype.encode = function(chunk) {
    this.write(chunk);
    this.emit("data", this.read());
  };
  Encoder.prototype.end = function(chunk) {
    if (arguments.length)
      this.encode(chunk);
    this.flush();
    this.emit("end");
  };
  var decoder = {};
  decoder.Decoder = Decoder;
  var EventLite = eventLiteExports;
  var DecodeBuffer = requireDecodeBuffer().DecodeBuffer;
  function Decoder(options) {
    if (!(this instanceof Decoder))
      return new Decoder(options);
    DecodeBuffer.call(this, options);
  }
  Decoder.prototype = new DecodeBuffer();
  EventLite.mixin(Decoder.prototype);
  Decoder.prototype.decode = function(chunk) {
    if (arguments.length)
      this.write(chunk);
    this.flush();
  };
  Decoder.prototype.push = function(chunk) {
    this.emit("data", chunk);
  };
  Decoder.prototype.end = function(chunk) {
    this.decode(chunk);
    this.emit("end");
  };
  var ext = {};
  requireReadCore();
  requireWriteCore();
  ext.createCodec = codecBase.createCodec;
  var codec = {};
  requireReadCore();
  requireWriteCore();
  codec.codec = {
    preset: codecBase.preset
  };
  browser.encode = requireEncode().encode;
  browser.decode = requireDecode().decode;
  browser.Encoder = encoder.Encoder;
  browser.Decoder = decoder.Decoder;
  browser.createCodec = ext.createCodec;
  browser.codec = codec.codec;
  class Packet {
    constructor(data, roomId) {
      this.data = data;
      this.roomId = roomId;
    }
    get body() {
      return this.data;
    }
    message(otherData) {
      return [this.roomId, Date.now(), otherData ?? this.data];
    }
    clone(data) {
      return new Packet(data, this.roomId);
    }
    encode(otherData) {
      return browser.encode(this.message(otherData));
    }
  }
  const { get: get$1, set: set$1 } = Utils;
  class TransmitterClass {
    constructor() {
      this.encode = true;
      this.packets = {};
    }
    addPacket(room, obj) {
      const { id } = room;
      if (!id)
        return;
      if (!this.packets[id])
        this.packets[id] = [];
      this.packets[id].push(new Packet(obj, id));
    }
    forEach(cb) {
      for (let roomId in this.packets) {
        cb(this.packets[roomId], roomId);
      }
    }
    getPackets(room) {
      if (!room.id)
        return;
      return this.packets[room.id];
    }
    clear(room) {
      if (room && room.id) {
        this.packets[room.id] = [];
      } else {
        this.packets = {};
      }
    }
    error(user, error) {
      const err = error instanceof Error ? error.toObject ? error.toObject() : error.message : error;
      user._socket.emit("error", err);
    }
    async emit(user, packet, room) {
      let data = packet.body;
      if (room.$additionalEmitProperties) {
        let additionalData = await Utils.resolveValue(room.$additionalEmitProperties(user, packet.body));
        if (additionalData !== void 0) {
          if (typeof additionalData === "string") {
            additionalData = [additionalData];
          }
          if (Array.isArray(additionalData)) {
            const newData = structuredClone(data);
            for (let path of additionalData) {
              set$1(newData, path, get$1(room, path));
            }
            data = newData;
          } else {
            data = { ...data, ...additionalData };
          }
        }
      }
      user._socket.emit("w", this.encode ? packet.encode(data) : packet.message(data));
    }
  }
  const Transmitter = new TransmitterClass();
  var UserState;
  (function(UserState2) {
    UserState2["Connected"] = "C";
    UserState2["Disconnected"] = "D";
  })(UserState || (UserState = {}));
  class User {
    constructor() {
      this.$state = UserState.Connected;
      this._secretSessionId = "";
      this._rooms = [];
    }
  }
  User.schema = {
    $state: String
  };
  class CustomError extends Error {
    constructor(customMessage) {
      super(customMessage);
      this.customMessage = customMessage;
      this.status = 500;
      this.code = "INTERNAL_SERVER_ERROR";
      this.message = "Internal Server error";
    }
    toObject() {
      return {
        message: this.customMessage || this.message,
        status: this.status,
        code: this.code
      };
    }
  }
  class NotAuthorized extends CustomError {
    constructor(customMessage) {
      super(customMessage);
      this.status = 401;
      this.code = "NOT_AUTHORIZED";
      this.message = "Not authorized";
    }
  }
  const { set, get } = Utils;
  class Room {
    constructor() {
      this.memoryTotalObject = {};
      this.memoryObject = {};
      this.permanentObject = [];
    }
    static hasExtraProp(obj) {
      return obj.$default !== void 0 || obj.$syncWithClient !== void 0 || obj.$permanent !== void 0 || obj.$validate !== void 0 || obj.$effects !== void 0 || obj.$type !== void 0;
    }
    static compileSchema(schema, room) {
      const dict = {};
      const masks = {};
      const permanentObject = [];
      function specialObject(val, p) {
        if (Room.hasExtraProp(val)) {
          if (val.$permanent ?? true)
            permanentObject.push(p);
          if (room && val.$default !== void 0)
            ;
          if (val.$syncWithClient === false) {
            return;
          }
          dict[p] = {
            ...val
          };
        } else {
          dict[p] = val;
          masks[p] = Utils.propertiesToArray(val);
          compile(val, p);
        }
      }
      function compile(schema2, path = "") {
        for (let prop in schema2) {
          const val = schema2[prop];
          let p = (path ? path + "." : "") + prop;
          if (Array.isArray(val)) {
            dict[p] = GENERIC_KEY_SCHEMA;
            p += "." + GENERIC_KEY_SCHEMA;
            if (val[0] === void 0)
              val[0] = {};
            if (Utils.isObject(val[0])) {
              specialObject(val[0], p);
            } else {
              dict[p] = val[0];
              compile(val[0], p);
            }
          } else if (Utils.isObject(val)) {
            specialObject(val, p);
          } else {
            permanentObject.push(p);
            dict[p] = val;
          }
        }
      }
      compile(schema);
      return {
        masks,
        dict,
        permanentObject
      };
    }
    async join(user, room) {
      if (room["canJoin"]) {
        const authBool = await Utils.resolveValue(room["canJoin"](user, user._socket));
        if (authBool === false || typeof authBool == "string") {
          Transmitter.error(user, new NotAuthorized(authBool));
          return false;
        }
      }
      if (World.agonesSDK) {
        await World.agonesSDK.allocate();
      }
      let firstJoin = !room.users[user.id];
      room.users[user.id] = user;
      const userProxy = World.users[user.id]["proxy"];
      userProxy.$state = UserState.Connected;
      if (firstJoin) {
        if (!userProxy._rooms)
          userProxy._rooms = [];
        userProxy._rooms.push(room.id);
        if (!userProxy.id)
          userProxy.id = Utils.generateId();
        if (room["onJoin"])
          room["onJoin"](userProxy);
      }
      if (this.getUsersLength(room) == 1) {
        this.memoryTotalObject = Room.extractObjectOfRoom(room, room.$schema);
      }
      const packet = new Packet({
        ...this.memoryTotalObject,
        join: firstJoin
      }, room.id);
      await Transmitter.emit(userProxy, packet, room);
      return true;
    }
    async leave(user, room) {
      if (room["onLeave"])
        room["onLeave"](user);
      const index = user._rooms.findIndex((id) => room.id == id);
      user._rooms.splice(index, 1);
      delete room.users[user.id];
      delete World.users[user.id]["proxy"];
      if (World.nbUsers == 0 && World.agonesSDK) {
        const { onBeforeShutdown, shutdownIfNotPlayers } = World.agonesOptions;
        if (shutdownIfNotPlayers) {
          if (onBeforeShutdown)
            await onBeforeShutdown();
          await World.agonesSDK.shutdown();
        }
      }
    }
    getUsersLength(room) {
      return Object.keys(room.users).length;
    }
    addInputs(room, obj) {
      room.$schema = {
        ...obj,
        ...room.$schema
      };
    }
    snapshotUser(room, userId) {
      const userSchema = this.permanentObject.filter((path) => path.startsWith("users.@")).map((path) => path.replace("users.@.", ""));
      const userObject = room.users[userId];
      if (!userObject)
        return null;
      return Room.extractObjectOfRoom(userObject, userSchema);
    }
    snapshot(room) {
      return Room.extractObjectOfRoom(room, this.permanentObject);
    }
    setProxy(room) {
      const self2 = this;
      const { dict, permanentObject, masks } = Room.compileSchema(room.$schema, room);
      const proxifiedObjects = /* @__PURE__ */ new WeakSet();
      this.permanentObject = permanentObject;
      room.$dict = dict;
      const getInfoDict = (path, key, dictPath) => {
        const basePath = dict[dictPath];
        const p = (path ? path + "." : "") + key;
        const genericPath = (dictPath ? dictPath + "." : "") + (basePath == GENERIC_KEY_SCHEMA ? GENERIC_KEY_SCHEMA : key);
        return {
          fullPath: p,
          genericPath,
          infoDict: dict[genericPath],
          mask: masks[genericPath]
        };
      };
      function deepProxy(object, path = "", dictPath = "") {
        if (proxifiedObjects.has(object)) {
          return object;
        }
        return new Proxy(object, {
          set(target, key, val, receiver) {
            const { fullPath: p, infoDict, genericPath, mask } = getInfoDict(path, key, dictPath);
            if (typeof val == "object" && infoDict && val != null) {
              const valProxy = deepProxy(val, p, genericPath);
              proxifiedObjects.add(valProxy);
              if (path == "users") {
                World.users[key]["proxy"] = valProxy;
              }
              Reflect.set(target, key, val, receiver);
              val = target[key];
            } else {
              if (infoDict == null ? void 0 : infoDict.$validate) {
                const { error } = infoDict.$validate.validate(val);
                if (error)
                  return true;
              }
              Reflect.set(target, key, val, receiver);
              val = target[key];
            }
            if (key == "length" && dict[dictPath] == GENERIC_KEY_SCHEMA) {
              return true;
            }
            if (infoDict) {
              if (infoDict.$effects) {
                for (let propEffect of infoDict.$effects) {
                  let pathEffect = "";
                  if (propEffect.startsWith("$this")) {
                    if (p) {
                      const pSplit = p.split(".");
                      pSplit[pSplit.length - 1] = propEffect.replace("$this.", "");
                      pathEffect = pSplit.join(".");
                    } else {
                      pathEffect = propEffect.replace("$this.", "");
                    }
                  } else {
                    pathEffect = propEffect;
                  }
                  self2.editMemoryObject(pathEffect, room);
                }
              }
              let newObj;
              if (Utils.isObject(infoDict) && val != null && !Room.hasExtraProp(infoDict)) {
                newObj = Room.extractObjectOfRoom(val, mask);
              } else if (infoDict == GENERIC_KEY_SCHEMA) {
                newObj = {};
                if (Object.keys(val).length == 0) {
                  newObj["$reset"] = true;
                }
                for (let key2 in val) {
                  const item = val[key2];
                  if (typeof item == "string" || typeof item == "number" || typeof item == "boolean") {
                    newObj[key2] = item;
                    continue;
                  }
                  newObj[key2] = Room.extractObjectOfRoom(item, dict[genericPath + "." + GENERIC_KEY_SCHEMA]);
                }
              } else {
                newObj = val;
              }
              self2.detectChanges(room, newObj, p);
            }
            return true;
          },
          get(target, key, receiver) {
            const toProxy = (val2, path2) => {
              if (typeof key != "string") {
                return val2;
              }
              if (key[0] == "_" || val2 == null) {
                return val2;
              }
              const { fullPath: p, infoDict, genericPath } = getInfoDict(path2, key, dictPath);
              if (typeof val2 == "object" && infoDict) {
                val2 = deepProxy(val2, p, genericPath);
                proxifiedObjects.add(val2);
              }
              return val2;
            };
            let val = Reflect.get(target, key, receiver);
            val = toProxy(val, path);
            return val;
          },
          deleteProperty(target, key) {
            const { fullPath: p, infoDict } = getInfoDict(path, key, dictPath);
            Reflect.deleteProperty(target, key);
            if (infoDict)
              self2.detectChanges(room, null, p);
            return true;
          }
        });
      }
      return deepProxy(room);
    }
    add(id, room) {
      room.id = id;
      room.$dict = {};
      if (!room.$schema)
        room.$schema = {};
      if (!room.$schema.users)
        room.$schema.users = [User.schema];
      if (!room.$inputs)
        room.$inputs = {};
      if (!room.users)
        room.users = {};
      if (room.$inputs)
        this.addInputs(room, room.$inputs);
      room.$detectChanges = () => {
      };
      room.$setSchema = (schema) => {
        room.$schema = schema;
        return this.setProxy(room);
      };
      room.$patchSchema = (schema) => {
        room.$schema = {
          ...room.$schema,
          ...schema
        };
        return this.setProxy(room);
      };
      room.$snapshot = () => {
        return this.snapshot(room);
      };
      room.$snapshotUser = (userId) => {
        return this.snapshotUser(room, userId);
      };
      room.$join = async (user) => {
        if (typeof user == "string") {
          user = World.users[user];
        }
        if (user) {
          return this.join(user, room);
        }
        return false;
      };
      room.$leave = async (user) => {
        if (typeof user == "string") {
          user = World.users[user]["proxy"];
        }
        await this.leave(user, room);
      };
      room.$currentState = () => this.memoryObject;
      room.$setCurrentState = (path, value) => {
        this.editMemoryObject(path, value === void 0 ? room : value);
      };
      room.$clearCurrentState = () => {
        this.memoryObject = {};
      };
      this.proxyRoom = room = this.setProxy(room);
      if (this.proxyRoom["onInit"])
        this.proxyRoom["onInit"]();
      return this.proxyRoom;
    }
    static extractObjectOfRoom(room, schema) {
      const newObj = {};
      const _schema = Array.isArray(schema) ? schema : Utils.propertiesToArray(schema);
      const regex = new RegExp("^(.*?)\\.\\" + GENERIC_KEY_SCHEMA);
      function extractAndSet(obj, path) {
        if (path.endsWith("@")) {
          return;
        }
        const match = regex.exec(path);
        if (match) {
          const generic = get(room, match[1]);
          if (generic && typeof generic === "object") {
            for (let key in generic) {
              if (generic.hasOwnProperty(key)) {
                extractAndSet(obj, path.replace(GENERIC_KEY_SCHEMA, key));
              }
            }
          }
        } else {
          set(obj, path, get(room, path));
        }
      }
      for (let path of _schema) {
        extractAndSet(newObj, path);
      }
      return newObj;
    }
    detectChanges(room, obj, path) {
      if (obj != null) {
        const [prop, userId] = path.split(".");
        if (prop == "users") {
          if (!room.users[userId]) {
            return;
          }
        }
      }
      this.editMemoryObject(path, obj);
      set(this.memoryTotalObject, path, obj);
      if (this.proxyRoom["onChanges"])
        this.proxyRoom["onChanges"](this.memoryObject);
      const id = room.id;
      World.changes.next({
        ...World.changes.value,
        [id]: room
      });
    }
    editMemoryObject(path, roomOrValue) {
      if (roomOrValue && typeof roomOrValue == "object" && "$currentState" in roomOrValue) {
        set(this.memoryObject, path, get(roomOrValue, path), true);
      } else {
        set(this.memoryObject, path, roomOrValue, true);
      }
    }
  }
  Room.propNameUsers = "users";
  class TransportCommon {
    onConnected(cb) {
      this.onConnectedCb = cb;
    }
    onJoin(cb) {
      this.onJoinCb = cb;
    }
    onInput(cb) {
      this.onInputCb = cb;
    }
    onAction(cb) {
      this.onActionCb = cb;
    }
    onDisconnected(cb) {
      this.onDisconnectedCb = cb;
    }
  }
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = void 0;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from2, pack) {
    if (pack || arguments.length === 2)
      for (var i2 = 0, l = from2.length, ar; i2 < l; i2++) {
        if (ar || !(i2 in from2)) {
          if (!ar)
            ar = Array.prototype.slice.call(from2, 0, i2);
          ar[i2] = from2[i2];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from2));
  }
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  function isFunction(value) {
    return typeof value === "function";
  }
  function createErrorClass(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }
  var UnsubscriptionError = createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors) {
      _super(this);
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
        return i2 + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
    };
  });
  function arrRemove(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }
  var Subscription = function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a, e_2, _b;
      var errors;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                  _a.call(_parentage_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors = e instanceof UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors = errors !== null && errors !== void 0 ? errors : [];
                if (err instanceof UnsubscriptionError) {
                  errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                _b.call(_finalizers_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError(errors);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function() {
      var empty = new Subscription2();
      empty.closed = true;
      return empty;
    }();
    return Subscription2;
  }();
  var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
  }
  function execFinalizer(finalizer) {
    if (isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }
  var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };
  var timeoutProvider = {
    setTimeout: function(handler, timeout) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = timeoutProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
    },
    clearTimeout: function(handle) {
      var delegate = timeoutProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: void 0
  };
  function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function() {
      {
        throw err;
      }
    });
  }
  function noop() {
  }
  function errorContext(cb) {
    {
      cb();
    }
  }
  var Subscriber = function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber2.create = function(next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };
    Subscriber2.prototype.next = function(value) {
      if (this.isStopped)
        ;
      else {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (this.isStopped)
        ;
      else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped)
        ;
      else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  }(Subscription);
  var _bind = Function.prototype.bind;
  function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
  }
  var ConsumerObserver = function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError(error);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber = function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
          error: error !== null && error !== void 0 ? error : void 0,
          complete: complete !== null && complete !== void 0 ? complete : void 0
        };
      } else {
        var context_1;
        if (_this && config.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind(observerOrNext.next, context_1),
            error: observerOrNext.error && bind(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber);
  function handleUnhandledError(error) {
    {
      reportUnhandledError(error);
    }
  }
  function defaultErrorHandler(err) {
    throw err;
  }
  var EMPTY_OBSERVER = {
    closed: true,
    next: noop,
    error: defaultErrorHandler,
    complete: noop
  };
  var observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
  function identity(x) {
    return x;
  }
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }
  var Observable = function() {
    function Observable2(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable2 = new Observable2();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
      errorContext(function() {
        var _a = _this, operator = _a.operator, source = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscriber = new SafeSubscriber({
          next: function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var _a;
      return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable2.prototype[observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value;
        _this.subscribe(function(x) {
          return value = x;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve(value);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver(value) {
    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
  }
  var ObjectUnsubscribedError = createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });
  var Subject = function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
    };
    Subject2.prototype.next = function(value) {
      var _this = this;
      errorContext(function() {
        var e_1, _a;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
              var observer = _c.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err) {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function() {
        var _a;
        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
      if (hasError || isStopped) {
        return EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription(function() {
        _this.currentObservers = null;
        arrRemove(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable2 = new Observable();
      observable2.source = this;
      return observable2;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable);
  var AnonymousSubject = function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject2.prototype.error = function(err) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a, _b;
      return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject);
  var BehaviorSubject = function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  }(Subject);
  class Transport extends TransportCommon {
    constructor(io, options = {}) {
      super();
      this.io = io;
      this.options = options;
      this.bandwidthData = {};
      this.WINDOW_SECONDS = 10;
      io.on("connection", (socket) => {
        const id = socket.playerId;
        this.bandwidthData[id] = new BehaviorSubject({
          incoming: [],
          outgoing: []
        });
        this.handleConnection(socket, id);
        socket.on(":input", ({ prop, value }) => this.onInputCb(id, prop, value));
        socket.on(":action", ({ name, value }) => this.onActionCb(id, name, value));
        if (options.clientCanJoinRoom)
          socket.on(":join", (roomId) => this.onJoinCb(roomId, id));
        socket.on("disconnect", () => {
          var _a;
          (_a = this.bandwidthData[id]) == null ? void 0 : _a.unsubscribe();
          delete this.bandwidthData[id];
          this.onDisconnectedCb(id);
        });
      });
      this.use();
    }
    handleConnection(socket, id) {
      this.onConnectedCb(socket, id);
    }
    use() {
      var _a, _b;
      const { maxKbpsIncoming, maxKbpsOutgoing, auth } = this.options;
      (_b = (_a = this.io).use) == null ? void 0 : _b.call(_a, async (socket, next) => {
        let playerId;
        if (auth) {
          try {
            playerId = await Utils.resolveValue(auth(socket));
          } catch (err) {
            socket.disconnect();
            next(new NotAuthorized(err).toObject());
            return;
          }
        }
        if (!playerId)
          playerId = Utils.generateId(5);
        socket.playerId = playerId;
        socket.use((packet, nextMiddleware) => {
          var _a2, _b2;
          if (packet && packet[1]) {
            const packetSize = Utils.bufferFrom(JSON.stringify(packet)).length - 2;
            const data = { size: packetSize, timestamp: Date.now() };
            this.updateBandwidthData(playerId, { incoming: data });
            const kbps = this.calculateKbps(((_a2 = this.bandwidthData[playerId]) == null ? void 0 : _a2.value.incoming) || []);
            if (maxKbpsIncoming && kbps > maxKbpsIncoming) {
              socket.disconnect();
              return;
            }
            this.cleanOldData(((_b2 = this.bandwidthData[playerId]) == null ? void 0 : _b2.value.incoming) || []);
          }
          nextMiddleware();
        });
        const originalEmit = socket.emit;
        socket.emit = (...args) => {
          var _a2, _b2;
          const packetSize = Utils.bufferFrom(JSON.stringify(args)).length - 2;
          const data = { size: packetSize, timestamp: Date.now() };
          this.updateBandwidthData(playerId, { outgoing: data });
          const kbps = this.calculateKbps(((_a2 = this.bandwidthData[playerId]) == null ? void 0 : _a2.value.outgoing) || []);
          if (maxKbpsOutgoing && kbps > maxKbpsOutgoing) {
            socket.disconnect();
            return;
          }
          this.cleanOldData(((_b2 = this.bandwidthData[playerId]) == null ? void 0 : _b2.value.outgoing) || []);
          originalEmit.apply(socket, args);
        };
        next();
      });
    }
    updateBandwidthData(socketId, data) {
      var _a, _b;
      const currentData = ((_a = this.bandwidthData[socketId]) == null ? void 0 : _a.value) || { incoming: [], outgoing: [] };
      if (data.incoming) {
        currentData.incoming.push(data.incoming);
      }
      if (data.outgoing) {
        currentData.outgoing.push(data.outgoing);
      }
      (_b = this.bandwidthData[socketId]) == null ? void 0 : _b.next(currentData);
    }
    cleanOldData(dataArray) {
      const cutOff = Date.now() - this.WINDOW_SECONDS * 1e3;
      while (dataArray.length > 0 && dataArray[0].timestamp < cutOff) {
        dataArray.shift();
      }
    }
    calculateKbps(dataArray) {
      const totalBytes = dataArray.reduce((acc, entry) => acc + entry.size, 0);
      return totalBytes * 8 / (this.WINDOW_SECONDS * 1e3);
    }
    getTelemetry() {
      const socketsData = {};
      let totalKbps = 0;
      for (const [socketId, bandwidth] of Object.entries(this.bandwidthData)) {
        const socketData = bandwidth.value;
        const incomingKbps = this.calculateKbps(socketData.incoming);
        const outgoingKbps = this.calculateKbps(socketData.outgoing);
        socketsData[socketId] = { incomingKbps, outgoingKbps };
        totalKbps += incomingKbps + outgoingKbps;
      }
      return {
        sockets: socketsData,
        totalKbps
      };
    }
  }
  class WorldClass {
    constructor() {
      this.rooms = /* @__PURE__ */ new Map();
      this.users = {};
      this.userClass = User;
      this.timeoutDisconnect = 0;
      this.changes = new BehaviorSubject({});
      this._transport = null;
      this.agonesSDK = null;
      this.agonesOptions = {};
    }
    /**
     * Define user class
     *
     * @method setUserClass()
     * @returns {void}
     */
    setUserClass(userClass) {
      this.userClass = userClass;
    }
    setAgones(agones, options = {}) {
      this.agonesSDK = agones;
      this.agonesOptions = options;
    }
    /**
     * Define transportation. You can set socket.io as default
     *
     * @method transport()
     * @param {object} io
     * @returns {Transport}
     */
    transport(io, options = {}) {
      if (options.timeoutDisconnect) {
        this.timeoutDisconnect = options.timeoutDisconnect;
      }
      const transport = new Transport(io, options);
      transport.onConnected(this.connectUser.bind(this));
      transport.onDisconnected(this.disconnectUser.bind(this));
      transport.onJoin(this.joinRoom.bind(this));
      transport.onInput((id, prop, value) => {
        this.forEachUserRooms(id, (room, user) => {
          try {
            if (room.$inputs && room.$inputs[prop]) {
              room[prop] = value;
            }
          } catch (err) {
            Transmitter.error(user, err);
          }
        });
      });
      transport.onAction((id, name, value) => {
        this.forEachUserRooms(id, async (room, user) => {
          if (room.$actions && room.$actions[name]) {
            try {
              room[name](user, value);
            } catch (err) {
              Transmitter.error(user, err);
            }
          }
        });
      });
      return this._transport = transport;
    }
    /**
     * Loop over all rooms of a user
     *
     * Example
     *
     * ```js
     * World.forEachUserRooms('userid', (room, user) => {
     *      console.log(room.id)
     * })
     * ```
     *
     * @method forEachUserRooms()
     * @param {string} userId
     * @param {(room: RoomClass, user: User)} cb
     * @returns {void}
     */
    forEachUserRooms(userId, cb) {
      const user = this.getUser(userId, true);
      if (!user)
        return;
      for (let roomId of user._rooms) {
        const room = this.getRoom(roomId);
        cb(room, user);
      }
    }
    /**
    * Retrieves all users in the world
    *
    * @method getUsers()
    * @returns { {[id: string]: User} }
    */
    getUsers() {
      return this.users;
    }
    /**
     * Get a user in the world
     *
     * @param {string} id User Id
     * @param {boolean} [getProxy] Retrieves the proxied user. (true by default)
     * @returns {User | null}
     */
    getUser(id, getProxy = true) {
      if (!this.users[id])
        return null;
      if (getProxy && this.users[id]["proxy"]) {
        return this.users[id]["proxy"];
      }
      return this.users[id];
    }
    setUser(user, socket) {
      if (socket)
        user._socket = socket;
      user._rooms = [];
      this.users[user.id] = user;
      return this.users[user.id];
    }
    get nbUsers() {
      return Object.keys(this.users).length;
    }
    /**
     * Send the packages to the rooms.
     *
     * @method send()
     */
    async send() {
      for (let [_, room] of this.rooms) {
        const obj = room.$currentState();
        if (Object.keys(obj).length == 0) {
          return;
        }
        Transmitter.addPacket(room, obj);
        for (let id in room.users) {
          const user = room.users[id];
          const packets = Transmitter.getPackets(room);
          if (packets) {
            for (let packet of packets) {
              await Transmitter.emit(user, packet, room);
            }
          }
        }
        room.$clearCurrentState();
      }
      Transmitter.clear();
    }
    /**
     * Connect a user
     *
     * @method connectUser()
     * @param {object} socket
     * @param {id} userId
     * @param {object} options
     *  - getUserInstance: function that returns a new instance of the user
     * @returns {User}
     */
    connectUser(socket, id, options = {}) {
      var _a;
      const existingUser = this.getUser(id, false);
      if (existingUser) {
        if (existingUser._timeoutDisconnect) {
          clearTimeout(existingUser._timeoutDisconnect);
          delete existingUser._timeoutDisconnect;
        }
        existingUser._socket = socket;
        existingUser.$state = UserState.Connected;
        return existingUser;
      }
      const user = ((_a = options.getUserInstance) == null ? void 0 : _a.call(options, socket)) ?? new this.userClass();
      user.id = id;
      socket.emit("uid", id);
      this.setUser(user, socket);
      return user;
    }
    /**
     * Removes the user from all rooms and removes him from the world
     *
     * @method disconnectUser()
     * @param {string} userId
     * @returns {void}
     */
    disconnectUser(userId) {
      return new Promise((resolve, reject) => {
        const user = this.getUser(userId);
        if (!user)
          return resolve();
        user.$state = UserState.Disconnected;
        const leave = () => {
          const leaveAllPromises = [];
          this.forEachUserRooms(userId, async (room, user2) => {
            if (room.$leave)
              leaveAllPromises.push(room.$leave(user2));
          });
          delete this.users[userId];
          Promise.all(leaveAllPromises).then(resolve).catch((err) => {
            Transmitter.error(user, err);
            reject(err);
          });
        };
        if (this.timeoutDisconnect == 0) {
          leave();
          return;
        }
        user._timeoutDisconnect = setTimeout(leave, this.timeoutDisconnect);
      });
    }
    httpUpgrade(httpServer, io) {
      httpServer.removeAllListeners("upgrade");
      httpServer.on("upgrade", (req, socket, head) => {
        if (req.url.startsWith("/socket.io/")) {
          io.engine.handleUpgrade(req, socket, head);
        } else {
          socket.destroy();
        }
      });
    }
    async joinOrLeaveRoom(type, roomId, userId) {
      const room = this.getRoom(roomId);
      if (!room)
        return;
      if (room[type]) {
        try {
          await room[type](this.getUser(userId, false));
        } catch (err) {
          Transmitter.error(this.getUser(userId, false), err);
          throw err;
        }
      }
      return room;
    }
    /**
     * Leave an existing room
     *
     * @param {string} roomId
     * @param {string} userId
     * @returns {RoomClass | undefined}
     */
    async leaveRoom(roomId, userId) {
      return this.joinOrLeaveRoom("$leave", roomId, userId);
    }
    /**
     * Join an existing room
     *
     * @param {string} roomId
     * @param {string} userId
     * @returns {RoomClass | undefined}
     */
    async joinRoom(roomId, userId) {
      return this.joinOrLeaveRoom("$join", roomId, userId);
    }
    /**
     * Add Room
     *
     * Example 1:
     *
     * ```js
     * class ChessRoom {
     *
     * }
     *
     * World.addRoom('myroom', ChessRoom)
     * ```
     *
     * Example 2:
     *
     * ```js
     * class ChessRoom {
     *  constructor(name) { }
     * }
     *
     * World.addRoom('myroom', new ChessRoom('test'))
     * ```
     *
     * @param {string} id room id
     * @param {Class or instance of Class} roomClass
     * @returns instance of Class
     */
    addRoom(id, roomClass) {
      if (roomClass.constructor.name == "Function") {
        roomClass = new roomClass();
      }
      const room = new Room().add(id, roomClass);
      this.rooms.set(id, room);
      if (this.agonesSDK) {
        this.agonesSDK.setLabel("room.id", id);
      }
      return room;
    }
    /**
     * Get an existing room
     *
     * @param {string} roomId
     * @returns {RoomClass}
     */
    getRoom(id) {
      return this.rooms.get(id);
    }
    /**
     * Recover the rooms of the world
     *
     * @param {string} roomId
     * @returns {Map<string, RoomClass>}
     */
    getRooms() {
      return this.rooms;
    }
    /**
     * Delete the room
     *
     * @param {string} roomId
     * @returns {void}
     */
    removeRoom(id) {
      this.rooms.delete(id);
    }
    /**
     * Remove all rooms and users
     */
    clear() {
      var _a, _b;
      this.rooms.clear();
      this.users = {};
      if (this._transport) {
        (_b = (_a = this._transport.io) == null ? void 0 : _a.clear) == null ? void 0 : _b.call(_a);
      }
    }
  }
  const World = new WorldClass();
  class MiddlewareHandler {
    constructor() {
      this.middlewares = [];
    }
    use(middleware) {
      this.middlewares.push(middleware);
    }
    run(socket, finalCallback = (err) => {
    }) {
      let index = 0;
      const next = (err) => {
        if (err) {
          finalCallback(err);
          return;
        }
        if (index >= this.middlewares.length) {
          finalCallback();
          return;
        }
        const middleware = this.middlewares[index];
        index += 1;
        middleware(socket, next);
      };
      next();
    }
    clear() {
      this.middlewares = [];
    }
  }
  class MockIo {
    constructor() {
      this.events = /* @__PURE__ */ new Map();
      this.eventsOnce = /* @__PURE__ */ new Map();
    }
    on(name, value) {
      this.events.set(name, [...this.events.get(name) || [], value]);
    }
    off(name) {
      if (this.eventsOnce.has(name)) {
        this.eventsOnce.delete(name);
        return;
      }
      this.events.delete(name);
    }
    once(name, value) {
      this.eventsOnce.set(name, value);
    }
    _trigger(name, data, client2) {
      const events = this.events.get(name) || [];
      for (const event of events) {
        event(data, client2);
      }
      const eventOnce = this.eventsOnce.get(name);
      if (eventOnce) {
        eventOnce(data, client2);
        this.eventsOnce.delete(name);
      }
    }
  }
  class MockSocket extends MockIo {
    constructor(handshake, client2) {
      super();
      this.handshake = handshake;
      this.client = client2;
      this.middlewares = new MiddlewareHandler();
      this.id = client2.fakeId ?? "" + Math.random();
      this.client.id = this.id;
    }
    emit(name, data) {
      this.client._trigger(name, data);
    }
    removeAllListeners(name) {
      return this.off(name);
    }
    use(cb) {
      this.middlewares.use(cb);
    }
    disconnect() {
    }
  }
  class MockClientIo extends MockIo {
    constructor(fakeId) {
      super();
      this.fakeId = fakeId;
      this.id = "";
      this._socket = null;
    }
    async connection(handshake) {
      this._socket = await serverIo$1.connection(this, handshake);
      this._trigger("connect", void 0);
      return this;
    }
    emit(name, data) {
      if (!this._socket)
        throw new Error("Client not connected");
      this._socket.middlewares.run([name, data], (err) => {
        if (err) {
          this._trigger("error", err);
          return;
        }
        serverIo$1.emit(name, data, this.id);
      });
      return this;
    }
    disconnect() {
      this.emit("disconnect", void 0);
    }
  }
  class MockServerIo extends MockIo {
    constructor() {
      super(...arguments);
      this.clients = /* @__PURE__ */ new Map();
      this.middlewares = new MiddlewareHandler();
    }
    connection(client2, handshake) {
      return new Promise((resolve, reject) => {
        const socket = new MockSocket(handshake, client2);
        this.clients.set(socket.id, socket);
        client2.id = socket.id;
        this.middlewares.run(socket, (err) => {
          if (err) {
            client2._trigger("error", err);
            return;
          }
          this._trigger("connection", socket);
          resolve(socket);
        });
      });
    }
    emit(name, data, id) {
      var _a;
      (_a = this.clients.get(id)) == null ? void 0 : _a._trigger(name, data);
    }
    use(cb) {
      this.middlewares.use(cb);
    }
    clear() {
      this.events.clear();
      this.eventsOnce.clear();
      this.clients.clear();
      this.middlewares.clear();
    }
  }
  const serverIo$1 = new MockServerIo();
  const ClientIo$1 = MockClientIo;
  const MockSocketIo = {
    serverIo: serverIo$1,
    ClientIo: ClientIo$1
  };
  const {
    serverIo,
    ClientIo
  } = MockSocketIo;
  function entryPoint(modules, options = {}) {
    const io = new ClientIo();
    class StandaloneGame {
      async start() {
        this.client = client.entryPoint(modules, {
          standalone: true,
          io,
          globalConfig: options.globalConfigClient,
          ...options
        });
        this.server = await server.entryPoint(modules, {
          io: serverIo,
          standalone: true,
          basePath: "",
          globalConfig: options.globalConfigServer,
          ...options
        });
        await this.server.start();
        await this.client.start();
        return this;
      }
      setHooks(hooks, side) {
        if (!common.Utils.isArray(hooks))
          modules.push({
            [side]: hooks
          });
        else
          modules.concat(hooks.map((hook) => {
            return {
              [side]: hook
            };
          }));
      }
      logicHooks(serverHooks) {
        this.setHooks(serverHooks, "server");
      }
      renderHooks(clientHooks) {
        this.setHooks(clientHooks, "client");
      }
    }
    return new StandaloneGame();
  }
  exports2.entryPoint = entryPoint;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
});
