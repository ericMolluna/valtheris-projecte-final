class MiddlewareHandler {
    constructor() {
        this.middlewares = [];
    }
    use(middleware) {
        this.middlewares.push(middleware);
    }
    run(socket, finalCallback = (err) => { }) {
        let index = 0;
        const next = (err) => {
            if (err) {
                finalCallback(err);
                return;
            }
            if (index >= this.middlewares.length) {
                finalCallback();
                return;
            }
            const middleware = this.middlewares[index];
            index += 1;
            middleware(socket, next);
        };
        next();
    }
    clear() {
        this.middlewares = [];
    }
}
class MockIo {
    constructor() {
        this.events = new Map();
        this.eventsOnce = new Map();
    }
    on(name, value) {
        this.events.set(name, [...(this.events.get(name) || []), value]);
    }
    off(name) {
        if (this.eventsOnce.has(name)) {
            this.eventsOnce.delete(name);
            return;
        }
        this.events.delete(name);
    }
    once(name, value) {
        this.eventsOnce.set(name, value);
    }
    _trigger(name, data, client) {
        const events = this.events.get(name) || [];
        for (const event of events) {
            event(data, client);
        }
        const eventOnce = this.eventsOnce.get(name);
        if (eventOnce) {
            eventOnce(data, client);
            this.eventsOnce.delete(name);
        }
    }
}
class MockSocket extends MockIo {
    constructor(handshake, client) {
        super();
        this.handshake = handshake;
        this.client = client;
        this.middlewares = new MiddlewareHandler();
        this.id = client.fakeId ?? '' + Math.random();
        this.client.id = this.id;
    }
    emit(name, data) {
        this.client._trigger(name, data);
    }
    removeAllListeners(name) {
        return this.off(name);
    }
    use(cb) {
        this.middlewares.use(cb);
    }
    disconnect() { }
}
class MockClientIo extends MockIo {
    constructor(fakeId) {
        super();
        this.fakeId = fakeId;
        this.id = '';
        this._socket = null;
    }
    async connection(handshake) {
        this._socket = await serverIo.connection(this, handshake);
        this._trigger('connect', undefined);
        return this;
    }
    emit(name, data) {
        if (!this._socket)
            throw new Error('Client not connected');
        this._socket.middlewares.run([name, data], (err) => {
            if (err) {
                this._trigger('error', err);
                return;
            }
            serverIo.emit(name, data, this.id);
        });
        return this;
    }
    disconnect() {
        this.emit('disconnect', undefined);
    }
}
class MockServerIo extends MockIo {
    constructor() {
        super(...arguments);
        this.clients = new Map();
        this.middlewares = new MiddlewareHandler();
    }
    connection(client, handshake) {
        return new Promise((resolve, reject) => {
            const socket = new MockSocket(handshake, client);
            this.clients.set(socket.id, socket);
            client.id = socket.id;
            this.middlewares.run(socket, (err) => {
                if (err) {
                    client._trigger('error', err);
                    return;
                }
                this._trigger('connection', socket);
                resolve(socket);
            });
        });
    }
    emit(name, data, id) {
        this.clients.get(id)?._trigger(name, data);
    }
    use(cb) {
        this.middlewares.use(cb);
    }
    clear() {
        this.events.clear();
        this.eventsOnce.clear();
        this.clients.clear();
        this.middlewares.clear();
    }
}
const serverIo = new MockServerIo();
const ClientIo = MockClientIo;
export default {
    serverIo,
    ClientIo
};
//# sourceMappingURL=mock-socket.js.map