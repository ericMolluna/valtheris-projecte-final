import { Packet } from './packet.js';
import { Utils } from './utils.js';
const { get, set } = Utils;
class TransmitterClass {
    constructor() {
        this.encode = true;
        this.packets = {};
    }
    addPacket(room, obj) {
        const { id } = room;
        if (!id)
            return;
        if (!this.packets[id])
            this.packets[id] = [];
        this.packets[id].push(new Packet(obj, id));
    }
    forEach(cb) {
        for (let roomId in this.packets) {
            cb(this.packets[roomId], roomId);
        }
    }
    getPackets(room) {
        if (!room.id)
            return;
        return this.packets[room.id];
    }
    clear(room) {
        if (room && room.id) {
            this.packets[room.id] = [];
        }
        else {
            this.packets = {};
        }
    }
    error(user, error) {
        const err = error instanceof Error ? error.toObject ? error.toObject() : error.message : error;
        user._socket.emit('error', err);
    }
    async emit(user, packet, room) {
        let data = packet.body;
        if (room.$additionalEmitProperties) {
            let additionalData = await Utils.resolveValue(room.$additionalEmitProperties(user, packet.body));
            if (additionalData !== undefined) {
                if (typeof additionalData === 'string') {
                    additionalData = [additionalData];
                }
                if (Array.isArray(additionalData)) {
                    const newData = structuredClone(data);
                    for (let path of additionalData) {
                        set(newData, path, get(room, path));
                    }
                    data = newData;
                }
                else {
                    data = { ...data, ...additionalData };
                }
            }
        }
        user._socket.emit('w', this.encode ? packet.encode(data) : packet.message(data));
    }
}
export const Transmitter = new TransmitterClass();
//# sourceMappingURL=transmitter.js.map