import { TransportCommon } from './common.js';
import { BehaviorSubject } from 'rxjs';
import { Utils } from '../utils.js';
import { NotAuthorized } from '../errors/not-authorized.js';
export class Transport extends TransportCommon {
    constructor(io, options = {}) {
        super();
        this.io = io;
        this.options = options;
        this.bandwidthData = {};
        this.WINDOW_SECONDS = 10; // Store data for the last 10 seconds
        io.on('connection', (socket) => {
            const id = socket.playerId;
            this.bandwidthData[id] = new BehaviorSubject({
                incoming: [],
                outgoing: []
            });
            this.handleConnection(socket, id);
            socket.on(':input', ({ prop, value }) => this.onInputCb(id, prop, value));
            socket.on(':action', ({ name, value }) => this.onActionCb(id, name, value));
            if (options.clientCanJoinRoom)
                socket.on(':join', (roomId) => this.onJoinCb(roomId, id));
            socket.on('disconnect', () => {
                this.bandwidthData[id]?.unsubscribe();
                delete this.bandwidthData[id];
                this.onDisconnectedCb(id);
            });
        });
        this.use();
    }
    handleConnection(socket, id) {
        this.onConnectedCb(socket, id);
    }
    use() {
        const { maxKbpsIncoming, maxKbpsOutgoing, auth } = this.options;
        this.io.use?.(async (socket, next) => {
            let playerId;
            if (auth) {
                try {
                    playerId = await Utils.resolveValue(auth(socket));
                }
                catch (err) {
                    socket.disconnect();
                    next(new NotAuthorized(err).toObject());
                    return;
                }
            }
            if (!playerId)
                playerId = Utils.generateId(5);
            socket.playerId = playerId;
            // Intercept incoming messages
            socket.use((packet, nextMiddleware) => {
                if (packet && packet[1]) {
                    const packetSize = Utils.bufferFrom(JSON.stringify(packet)).length - 2;
                    const data = { size: packetSize, timestamp: Date.now() };
                    this.updateBandwidthData(playerId, { incoming: data });
                    const kbps = this.calculateKbps(this.bandwidthData[playerId]?.value.incoming || []);
                    if (maxKbpsIncoming && kbps > maxKbpsIncoming) {
                        socket.disconnect();
                        return;
                    }
                    this.cleanOldData(this.bandwidthData[playerId]?.value.incoming || []);
                }
                nextMiddleware();
            });
            // Intercept outgoing messages
            const originalEmit = socket.emit;
            socket.emit = (...args) => {
                const packetSize = Utils.bufferFrom(JSON.stringify(args)).length - 2;
                const data = { size: packetSize, timestamp: Date.now() };
                this.updateBandwidthData(playerId, { outgoing: data });
                const kbps = this.calculateKbps(this.bandwidthData[playerId]?.value.outgoing || []);
                if (maxKbpsOutgoing && kbps > maxKbpsOutgoing) {
                    socket.disconnect();
                    return;
                }
                this.cleanOldData(this.bandwidthData[playerId]?.value.outgoing || []);
                originalEmit.apply(socket, args);
            };
            next();
        });
    }
    updateBandwidthData(socketId, data) {
        const currentData = this.bandwidthData[socketId]?.value || { incoming: [], outgoing: [] };
        if (data.incoming) {
            currentData.incoming.push(data.incoming);
        }
        if (data.outgoing) {
            currentData.outgoing.push(data.outgoing);
        }
        this.bandwidthData[socketId]?.next(currentData);
    }
    cleanOldData(dataArray) {
        const cutOff = Date.now() - (this.WINDOW_SECONDS * 1000);
        while (dataArray.length > 0 && dataArray[0].timestamp < cutOff) {
            dataArray.shift();
        }
    }
    calculateKbps(dataArray) {
        const totalBytes = dataArray.reduce((acc, entry) => acc + entry.size, 0);
        return (totalBytes * 8) / (this.WINDOW_SECONDS * 1000); // Convert bytes to kilobits and divide by seconds
    }
    getTelemetry() {
        const socketsData = {};
        let totalKbps = 0;
        for (const [socketId, bandwidth] of Object.entries(this.bandwidthData)) {
            const socketData = bandwidth.value;
            const incomingKbps = this.calculateKbps(socketData.incoming);
            const outgoingKbps = this.calculateKbps(socketData.outgoing);
            socketsData[socketId] = { incomingKbps, outgoingKbps };
            totalKbps += incomingKbps + outgoingKbps;
        }
        return {
            sockets: socketsData,
            totalKbps
        };
    }
}
//# sourceMappingURL=socket.js.map