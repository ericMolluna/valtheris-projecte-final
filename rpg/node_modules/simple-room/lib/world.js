import { Room } from './room.js';
import { Transmitter } from './transmitter.js';
import { Transport } from './transports/socket.js';
import { User, UserState } from './rooms/default.js';
import { BehaviorSubject } from 'rxjs';
export class WorldClass {
    constructor() {
        this.rooms = new Map();
        this.users = {};
        this.userClass = User;
        this.timeoutDisconnect = 0;
        this.changes = new BehaviorSubject({});
        this._transport = null;
        this.agonesSDK = null;
        this.agonesOptions = {};
    }
    /**
     * Define user class
     *
     * @method setUserClass()
     * @returns {void}
     */
    setUserClass(userClass) {
        this.userClass = userClass;
    }
    setAgones(agones, options = {}) {
        this.agonesSDK = agones;
        this.agonesOptions = options;
    }
    /**
     * Define transportation. You can set socket.io as default
     *
     * @method transport()
     * @param {object} io
     * @returns {Transport}
     */
    transport(io, options = {}) {
        if (options.timeoutDisconnect) {
            this.timeoutDisconnect = options.timeoutDisconnect;
        }
        const transport = new Transport(io, options);
        transport.onConnected(this.connectUser.bind(this));
        transport.onDisconnected(this.disconnectUser.bind(this));
        transport.onJoin(this.joinRoom.bind(this));
        transport.onInput((id, prop, value) => {
            this.forEachUserRooms(id, (room, user) => {
                try {
                    if (room.$inputs && room.$inputs[prop]) {
                        room[prop] = value;
                    }
                }
                catch (err) {
                    Transmitter.error(user, err);
                }
            });
        });
        transport.onAction((id, name, value) => {
            this.forEachUserRooms(id, async (room, user) => {
                if (room.$actions && room.$actions[name]) {
                    try {
                        room[name](user, value);
                    }
                    catch (err) {
                        Transmitter.error(user, err);
                    }
                }
            });
        });
        return this._transport = transport;
    }
    /**
     * Loop over all rooms of a user
     *
     * Example
     *
     * ```js
     * World.forEachUserRooms('userid', (room, user) => {
     *      console.log(room.id)
     * })
     * ```
     *
     * @method forEachUserRooms()
     * @param {string} userId
     * @param {(room: RoomClass, user: User)} cb
     * @returns {void}
     */
    forEachUserRooms(userId, cb) {
        const user = this.getUser(userId, true);
        if (!user)
            return;
        for (let roomId of user._rooms) {
            const room = this.getRoom(roomId);
            cb(room, user);
        }
    }
    /**
    * Retrieves all users in the world
    *
    * @method getUsers()
    * @returns { {[id: string]: User} }
    */
    getUsers() {
        return this.users;
    }
    /**
     * Get a user in the world
     *
     * @param {string} id User Id
     * @param {boolean} [getProxy] Retrieves the proxied user. (true by default)
     * @returns {User | null}
     */
    getUser(id, getProxy = true) {
        if (!this.users[id])
            return null;
        if (getProxy && this.users[id]['proxy']) {
            return this.users[id]['proxy'];
        }
        return this.users[id];
    }
    setUser(user, socket) {
        if (socket)
            user._socket = socket;
        user._rooms = [];
        this.users[user.id] = user;
        return this.users[user.id];
    }
    get nbUsers() {
        return Object.keys(this.users).length;
    }
    /**
     * Send the packages to the rooms.
     *
     * @method send()
     */
    async send() {
        for (let [_, room] of this.rooms) {
            const obj = room.$currentState();
            if (Object.keys(obj).length == 0) {
                continue;
            }
            Transmitter.addPacket(room, obj);
            for (let id in room.users) {
                const user = room.users[id];
                const packets = Transmitter.getPackets(room);
                if (packets) {
                    for (let packet of packets) {
                        await Transmitter.emit(user, packet, room);
                    }
                }
            }
            room.$clearCurrentState();
        }
        Transmitter.clear();
    }
    /**
     * Connect a user
     *
     * @method connectUser()
     * @param {object} socket
     * @param {id} userId
     * @param {object} options
     *  - getUserInstance: function that returns a new instance of the user
     * @returns {User}
     */
    connectUser(socket, id, options = {}) {
        const existingUser = this.getUser(id, false);
        if (existingUser) {
            if (existingUser._timeoutDisconnect) {
                clearTimeout(existingUser._timeoutDisconnect);
                delete existingUser._timeoutDisconnect;
            }
            existingUser._socket = socket;
            existingUser.$state = UserState.Connected;
            return existingUser;
        }
        const user = options.getUserInstance?.(socket) ?? new this.userClass();
        user.id = id;
        socket.emit('uid', id);
        this.setUser(user, socket);
        return user;
    }
    /**
     * Removes the user from all rooms and removes him from the world
     *
     * @method disconnectUser()
     * @param {string} userId
     * @returns {void}
     */
    disconnectUser(userId) {
        return new Promise((resolve, reject) => {
            const user = this.getUser(userId);
            if (!user)
                return resolve();
            user.$state = UserState.Disconnected;
            const leave = () => {
                const leaveAllPromises = [];
                this.forEachUserRooms(userId, async (room, user) => {
                    if (room.$leave)
                        leaveAllPromises.push(room.$leave(user));
                });
                delete this.users[userId];
                Promise.all(leaveAllPromises)
                    .then(resolve)
                    .catch(err => {
                    Transmitter.error(user, err);
                    reject(err);
                });
            };
            if (!this.timeoutDisconnect) {
                leave();
                return;
            }
            user._timeoutDisconnect = setTimeout(leave, this.timeoutDisconnect);
        });
    }
    httpUpgrade(httpServer, io) {
        httpServer.removeAllListeners("upgrade");
        httpServer.on("upgrade", (req, socket, head) => {
            if (req.url.startsWith("/socket.io/")) {
                io.engine.handleUpgrade(req, socket, head);
            }
            else {
                socket.destroy();
            }
        });
    }
    async joinOrLeaveRoom(type, roomId, userId) {
        const room = this.getRoom(roomId);
        if (!room)
            return;
        if (room[type]) {
            try {
                await room[type](this.getUser(userId, false));
            }
            catch (err) {
                Transmitter.error(this.getUser(userId, false), err);
                throw err;
            }
        }
        return room;
    }
    /**
     * Leave an existing room
     *
     * @param {string} roomId
     * @param {string} userId
     * @returns {RoomClass | undefined}
     */
    async leaveRoom(roomId, userId) {
        return this.joinOrLeaveRoom('$leave', roomId, userId);
    }
    /**
     * Join an existing room
     *
     * @param {string} roomId
     * @param {string} userId
     * @returns {RoomClass | undefined}
     */
    async joinRoom(roomId, userId) {
        return this.joinOrLeaveRoom('$join', roomId, userId);
    }
    /**
     * Add Room
     *
     * Example 1:
     *
     * ```js
     * class ChessRoom {
     *
     * }
     *
     * World.addRoom('myroom', ChessRoom)
     * ```
     *
     * Example 2:
     *
     * ```js
     * class ChessRoom {
     *  constructor(name) { }
     * }
     *
     * World.addRoom('myroom', new ChessRoom('test'))
     * ```
     *
     * @param {string} id room id
     * @param {Class or instance of Class} roomClass
     * @returns instance of Class
     */
    addRoom(id, roomClass, options = {}) {
        if (roomClass.constructor.name == 'Function') {
            roomClass = new roomClass();
        }
        const room = new Room(options).add(id, roomClass);
        this.rooms.set(id, room);
        if (this.agonesSDK) {
            this.agonesSDK.setLabel('room.id', id);
        }
        return room;
    }
    /**
     * Get an existing room
     *
     * @param {string} roomId
     * @returns {RoomClass}
     */
    getRoom(id) {
        return this.rooms.get(id);
    }
    /**
     * Recover the rooms of the world
     *
     * @param {string} roomId
     * @returns {Map<string, RoomClass>}
     */
    getRooms() {
        return this.rooms;
    }
    /**
     * Delete the room
     *
     * @param {string} roomId
     * @returns {void}
     */
    removeRoom(id) {
        this.rooms.delete(id);
    }
    /**
     * Remove all rooms and users
     */
    clear() {
        this.rooms.clear();
        this.changes.next({});
        this.users = {};
        if (this._transport) {
            this._transport.io?.clear?.();
        }
    }
}
export const World = new WorldClass();
//# sourceMappingURL=world.js.map